// Copyright 2023 Bloomberg Finance L.P.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// bmqp_ctrlmsg_messages.h          *DO NOT EDIT*          @generated -*-C++-*-
#ifndef INCLUDED_BMQP_CTRLMSG_MESSAGES
#define INCLUDED_BMQP_CTRLMSG_MESSAGES

//@PURPOSE: Provide value-semantic attribute classes

#include <bslalg_typetraits.h>

#include <bdlat_attributeinfo.h>

#include <bdlat_enumeratorinfo.h>

#include <bdlat_selectioninfo.h>

#include <bdlat_typetraits.h>

#include <bslh_hash.h>
#include <bsls_objectbuffer.h>

#include <bslma_default.h>

#include <bsls_assert.h>

#include <bdlb_nullablevalue.h>

#include <bsl_string.h>

#include <bsl_vector.h>

#include <bsls_types.h>

#include <bsl_iosfwd.h>
#include <bsl_limits.h>

#include <bsl_ostream.h>
#include <bsl_string.h>

namespace BloombergLP {

namespace bslma {
class Allocator;
}

namespace bmqp_ctrlmsg {
class AdminCommand;
}
namespace bmqp_ctrlmsg {
class AdminCommandResponse;
}
namespace bmqp_ctrlmsg {
class AppIdInfo;
}
namespace bmqp_ctrlmsg {
class CloseQueueResponse;
}
namespace bmqp_ctrlmsg {
class ClusterSyncRequest;
}
namespace bmqp_ctrlmsg {
class ClusterSyncResponse;
}
namespace bmqp_ctrlmsg {
class ConsumerInfo;
}
namespace bmqp_ctrlmsg {
class Disconnect;
}
namespace bmqp_ctrlmsg {
class DisconnectResponse;
}
namespace bmqp_ctrlmsg {
class ElectionProposal;
}
namespace bmqp_ctrlmsg {
class ElectionResponse;
}
namespace bmqp_ctrlmsg {
class ElectorNodeStatus;
}
namespace bmqp_ctrlmsg {
class FollowerClusterStateRequest;
}
namespace bmqp_ctrlmsg {
class FollowerLSNRequest;
}
namespace bmqp_ctrlmsg {
class GuidInfo;
}
namespace bmqp_ctrlmsg {
class HeartbeatResponse;
}
namespace bmqp_ctrlmsg {
class LeaderHeartbeat;
}
namespace bmqp_ctrlmsg {
class LeaderMessageSequence;
}
namespace bmqp_ctrlmsg {
class LeaderPassive;
}
namespace bmqp_ctrlmsg {
class LeaderSyncDataQuery;
}
namespace bmqp_ctrlmsg {
class LeaderSyncStateQuery;
}
namespace bmqp_ctrlmsg {
class LeadershipCessionNotification;
}
namespace bmqp_ctrlmsg {
class PartitionPrimaryInfo;
}
namespace bmqp_ctrlmsg {
class PartitionSequenceNumber;
}
namespace bmqp_ctrlmsg {
class PartitionSyncDataQueryResponse;
}
namespace bmqp_ctrlmsg {
class PartitionSyncStateQuery;
}
namespace bmqp_ctrlmsg {
class QueueAssignmentRequest;
}
namespace bmqp_ctrlmsg {
class QueueUnassignmentRequest;
}
namespace bmqp_ctrlmsg {
class RegistrationResponse;
}
namespace bmqp_ctrlmsg {
class ReverseConnectionRequest;
}
namespace bmqp_ctrlmsg {
class RoutingConfiguration;
}
namespace bmqp_ctrlmsg {
class ScoutingRequest;
}
namespace bmqp_ctrlmsg {
class ScoutingResponse;
}
namespace bmqp_ctrlmsg {
class StopRequest;
}
namespace bmqp_ctrlmsg {
class StopResponse;
}
namespace bmqp_ctrlmsg {
class SubQueueIdInfo;
}
namespace bmqp_ctrlmsg {
class SyncPoint;
}
namespace bmqp_ctrlmsg {
class ClientIdentity;
}
namespace bmqp_ctrlmsg {
class DumpMessages;
}
namespace bmqp_ctrlmsg {
class ElectorMessageChoice;
}
namespace bmqp_ctrlmsg {
class Expression;
}
namespace bmqp_ctrlmsg {
class FollowerLSNResponse;
}
namespace bmqp_ctrlmsg {
class LeaderAdvisoryAck;
}
namespace bmqp_ctrlmsg {
class LeaderAdvisoryCommit;
}
namespace bmqp_ctrlmsg {
class LeaderSyncStateQueryResponse;
}
namespace bmqp_ctrlmsg {
class NodeStatusAdvisory;
}
namespace bmqp_ctrlmsg {
class PartitionPrimaryAdvisory;
}
namespace bmqp_ctrlmsg {
class PrimaryStateRequest;
}
namespace bmqp_ctrlmsg {
class PrimaryStateResponse;
}
namespace bmqp_ctrlmsg {
class PrimaryStatusAdvisory;
}
namespace bmqp_ctrlmsg {
class QueueHandleParameters;
}
namespace bmqp_ctrlmsg {
class QueueInfo;
}
namespace bmqp_ctrlmsg {
class QueueInfoUpdate;
}
namespace bmqp_ctrlmsg {
class QueueStreamParameters;
}
namespace bmqp_ctrlmsg {
class RegistrationRequest;
}
namespace bmqp_ctrlmsg {
class ReplicaDataRequest;
}
namespace bmqp_ctrlmsg {
class ReplicaDataResponse;
}
namespace bmqp_ctrlmsg {
class ReplicaStateRequest;
}
namespace bmqp_ctrlmsg {
class ReplicaStateResponse;
}
namespace bmqp_ctrlmsg {
class StateNotificationChoice;
}
namespace bmqp_ctrlmsg {
class Status;
}
namespace bmqp_ctrlmsg {
class StorageSyncResponse;
}
namespace bmqp_ctrlmsg {
class SyncPointOffsetPair;
}
namespace bmqp_ctrlmsg {
class BrokerResponse;
}
namespace bmqp_ctrlmsg {
class CloseQueue;
}
namespace bmqp_ctrlmsg {
class ConfigureQueueStream;
}
namespace bmqp_ctrlmsg {
class ElectorMessage;
}
namespace bmqp_ctrlmsg {
class LeaderAdvisory;
}
namespace bmqp_ctrlmsg {
class OpenQueue;
}
namespace bmqp_ctrlmsg {
class PartitionMessageChoice;
}
namespace bmqp_ctrlmsg {
class PartitionSyncDataQuery;
}
namespace bmqp_ctrlmsg {
class PartitionSyncDataQueryStatus;
}
namespace bmqp_ctrlmsg {
class PartitionSyncStateQueryResponse;
}
namespace bmqp_ctrlmsg {
class QueueAssignmentAdvisory;
}
namespace bmqp_ctrlmsg {
class QueueUnAssignmentAdvisory;
}
namespace bmqp_ctrlmsg {
class QueueUnassignedAdvisory;
}
namespace bmqp_ctrlmsg {
class QueueUpdateAdvisory;
}
namespace bmqp_ctrlmsg {
class StateNotification;
}
namespace bmqp_ctrlmsg {
class StorageSyncRequest;
}
namespace bmqp_ctrlmsg {
class Subscription;
}
namespace bmqp_ctrlmsg {
class ConfigureQueueStreamResponse;
}
namespace bmqp_ctrlmsg {
class FollowerClusterStateResponse;
}
namespace bmqp_ctrlmsg {
class LeaderSyncDataQueryResponse;
}
namespace bmqp_ctrlmsg {
class NegotiationMessage;
}
namespace bmqp_ctrlmsg {
class OpenQueueResponse;
}
namespace bmqp_ctrlmsg {
class PartitionMessage;
}
namespace bmqp_ctrlmsg {
class StreamParameters;
}
namespace bmqp_ctrlmsg {
class ClusterStateFSMMessageChoice;
}
namespace bmqp_ctrlmsg {
class ConfigureStream;
}
namespace bmqp_ctrlmsg {
class ClusterStateFSMMessage;
}
namespace bmqp_ctrlmsg {
class ConfigureStreamResponse;
}
namespace bmqp_ctrlmsg {
class ClusterMessageChoice;
}
namespace bmqp_ctrlmsg {
class ClusterMessage;
}
namespace bmqp_ctrlmsg {
class ControlMessageChoice;
}
namespace bmqp_ctrlmsg {
class ControlMessage;
}
namespace bmqp_ctrlmsg {

// ==================
// class AdminCommand
// ==================

class AdminCommand {
    // This request is sent by the admin client to execute the specified
    // command on the broker.  Command is expected in a human-friendly text
    // format, to get a list of available commands 'help' command can be sent.

    // INSTANCE DATA
    bsl::string d_command;
    bool        d_rerouted;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_COMMAND = 0, ATTRIBUTE_ID_REROUTED = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_COMMAND = 0, ATTRIBUTE_INDEX_REROUTED = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit AdminCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'AdminCommand' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    AdminCommand(const AdminCommand& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'AdminCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AdminCommand(AdminCommand&& original) noexcept;
    // Create an object of type 'AdminCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    AdminCommand(AdminCommand&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'AdminCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~AdminCommand();
    // Destroy this object.

    // MANIPULATORS
    AdminCommand& operator=(const AdminCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AdminCommand& operator=(AdminCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& command();
    // Return a reference to the modifiable "Command" attribute of this
    // object.

    bool& rerouted();
    // Return a reference to the modifiable "Rerouted" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& command() const;
    // Return a reference offering non-modifiable access to the "Command"
    // attribute of this object.

    bool rerouted() const;
    // Return the value of the "Rerouted" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const AdminCommand& lhs, const AdminCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.command() == rhs.command() &&
               lhs.rerouted() == rhs.rerouted();
    }

    friend bool operator!=(const AdminCommand& lhs, const AdminCommand& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const AdminCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const AdminCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'AdminCommand'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.command());
        hashAppend(hashAlg, object.rerouted());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::AdminCommand)

namespace bmqp_ctrlmsg {

// ==========================
// class AdminCommandResponse
// ==========================

class AdminCommandResponse {
    // This response is sent by the broker to the admin client in response to
    // an 'AdminCommand' request with the command execution results.  The
    // resulting text can be both non-structured text or represent a valid
    // json, depending on specific command.  Also it can contain error message
    // if some problem occured.

    // INSTANCE DATA
    bsl::string d_text;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_TEXT = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_TEXT = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit AdminCommandResponse(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'AdminCommandResponse' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    AdminCommandResponse(const AdminCommandResponse& original,
                         bslma::Allocator*           basicAllocator = 0);
    // Create an object of type 'AdminCommandResponse' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AdminCommandResponse(AdminCommandResponse&& original) noexcept;
    // Create an object of type 'AdminCommandResponse' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    AdminCommandResponse(AdminCommandResponse&& original,
                         bslma::Allocator*      basicAllocator);
    // Create an object of type 'AdminCommandResponse' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~AdminCommandResponse();
    // Destroy this object.

    // MANIPULATORS
    AdminCommandResponse& operator=(const AdminCommandResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AdminCommandResponse& operator=(AdminCommandResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& text();
    // Return a reference to the modifiable "Text" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& text() const;
    // Return a reference offering non-modifiable access to the "Text"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const AdminCommandResponse& lhs,
                           const AdminCommandResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.text() == rhs.text();
    }

    friend bool operator!=(const AdminCommandResponse& lhs,
                           const AdminCommandResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const AdminCommandResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const AdminCommandResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'AdminCommandResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.text());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::AdminCommandResponse)

namespace bmqp_ctrlmsg {

// ===============
// class AppIdInfo
// ===============

class AppIdInfo {
    // This type represents the details of an application id, that is the app
    // id string and app key bytes for a queue.

    // INSTANCE DATA
    bsl::vector<char> d_appKey;
    bsl::string       d_appId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_APP_ID = 0, ATTRIBUTE_ID_APP_KEY = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_APP_ID = 0, ATTRIBUTE_INDEX_APP_KEY = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit AppIdInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'AppIdInfo' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    AppIdInfo(const AppIdInfo& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'AppIdInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AppIdInfo(AppIdInfo&& original) noexcept;
    // Create an object of type 'AppIdInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    AppIdInfo(AppIdInfo&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'AppIdInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~AppIdInfo();
    // Destroy this object.

    // MANIPULATORS
    AppIdInfo& operator=(const AppIdInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AppIdInfo& operator=(AppIdInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    bsl::vector<char>& appKey();
    // Return a reference to the modifiable "AppKey" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    const bsl::vector<char>& appKey() const;
    // Return a reference offering non-modifiable access to the "AppKey"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const AppIdInfo& lhs, const AppIdInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.appId() == rhs.appId() && lhs.appKey() == rhs.appKey();
    }

    friend bool operator!=(const AppIdInfo& lhs, const AppIdInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const AppIdInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const AppIdInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'AppIdInfo'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.appId());
        hashAppend(hashAlg, object.appKey());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::AppIdInfo)

namespace bmqp_ctrlmsg {

// ====================
// class ClientLanguage
// ====================

struct ClientLanguage {
    // Enumeration of the various types of language which can be used by a
    // client.

  public:
    // TYPES
    enum Value { E_UNKNOWN = 0, E_CPP = 1, E_JAVA = 2 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return ClientLanguage::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::ClientLanguage)

namespace bmqp_ctrlmsg {

// ================
// class ClientType
// ================

struct ClientType {
    // Enumeration of the various types of client which can connect to the
    // bmqbrkr.

  public:
    // TYPES
    enum Value {
        E_UNKNOWN   = 0,
        E_TCPCLIENT = 1,
        E_TCPBROKER = 2,
        E_TCPADMIN  = 3
    };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return ClientType::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::ClientType)

namespace bmqp_ctrlmsg {

// ========================
// class CloseQueueResponse
// ========================

class CloseQueueResponse {
    // Response of a 'CloseQueue' request, indicating success of the operation.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const CloseQueueResponse&,
                           const CloseQueueResponse&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const CloseQueueResponse& lhs,
                           const CloseQueueResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const CloseQueueResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const CloseQueueResponse&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'CloseQueueResponse'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::CloseQueueResponse)

namespace bmqp_ctrlmsg {

// ========================
// class ClusterSyncRequest
// ========================

class ClusterSyncRequest {
    // This type represents a message sent by a cluster member node to all
    // peers, in order to ensure sync (think of it as a distributed latch
    // between all nodes in the cluster).  Each peer, upon reception of this
    // request, is expected to reply with a 'ClusterSyncResponse' message.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterSyncRequest&,
                           const ClusterSyncRequest&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const ClusterSyncRequest& lhs,
                           const ClusterSyncRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const ClusterSyncRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const ClusterSyncRequest&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterSyncRequest'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterSyncRequest)

namespace bmqp_ctrlmsg {

// =========================
// class ClusterSyncResponse
// =========================

class ClusterSyncResponse {
    // This type represents a message sent by a cluster member node, in
    // response to a 'ClusterSyncRequest'.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterSyncResponse&,
                           const ClusterSyncResponse&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const ClusterSyncResponse& lhs,
                           const ClusterSyncResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const ClusterSyncResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const ClusterSyncResponse&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterSyncResponse'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterSyncResponse)

namespace bmqp_ctrlmsg {

// ==================
// class ConsumerInfo
// ==================

class ConsumerInfo {
    // This complex type contains various parameters required by an upstream
    // node to configure subscription for a queue handle that has already been
    // created.
    // maxUnconfirmedMessages.: maximum number of outstanding delivered but
    // pending confirmation from the client maxUnconfirmedBytes....: maximum
    // cumulated bytes of all outstanding delivered but pending confirmation
    // messages from the client consumerPriority.......: priority as advertised
    // by the downstream node for this subscription consumerPriorityCount..:
    // weight of the subscription as advertised by the downstream node, having
    // above-mentioned consumer priority

    // INSTANCE DATA
    bsls::Types::Int64 d_maxUnconfirmedMessages;
    bsls::Types::Int64 d_maxUnconfirmedBytes;
    int                d_consumerPriority;
    int                d_consumerPriorityCount;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ConsumerInfo& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES = 0,
        ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES    = 1,
        ATTRIBUTE_ID_CONSUMER_PRIORITY        = 2,
        ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT  = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES = 0,
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES    = 1,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY        = 2,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT  = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bsls::Types::Int64
        DEFAULT_INITIALIZER_MAX_UNCONFIRMED_MESSAGES;

    static const bsls::Types::Int64 DEFAULT_INITIALIZER_MAX_UNCONFIRMED_BYTES;

    static const int DEFAULT_INITIALIZER_CONSUMER_PRIORITY;

    static const int DEFAULT_INITIALIZER_CONSUMER_PRIORITY_COUNT;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ConsumerInfo();
    // Create an object of type 'ConsumerInfo' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Int64& maxUnconfirmedMessages();
    // Return a reference to the modifiable "MaxUnconfirmedMessages"
    // attribute of this object.

    bsls::Types::Int64& maxUnconfirmedBytes();
    // Return a reference to the modifiable "MaxUnconfirmedBytes" attribute
    // of this object.

    int& consumerPriority();
    // Return a reference to the modifiable "ConsumerPriority" attribute of
    // this object.

    int& consumerPriorityCount();
    // Return a reference to the modifiable "ConsumerPriorityCount"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Int64 maxUnconfirmedMessages() const;
    // Return the value of the "MaxUnconfirmedMessages" attribute of this
    // object.

    bsls::Types::Int64 maxUnconfirmedBytes() const;
    // Return the value of the "MaxUnconfirmedBytes" attribute of this
    // object.

    int consumerPriority() const;
    // Return the value of the "ConsumerPriority" attribute of this object.

    int consumerPriorityCount() const;
    // Return the value of the "ConsumerPriorityCount" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const ConsumerInfo& lhs, const ConsumerInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ConsumerInfo& lhs, const ConsumerInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const ConsumerInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const ConsumerInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ConsumerInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ConsumerInfo)

namespace bmqp_ctrlmsg {

// ================
// class Disconnect
// ================

class Disconnect {
    // This request is sent by the SDK to the broker to perform a gracefull
    // clean shutdown.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const Disconnect&, const Disconnect&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const Disconnect& lhs, const Disconnect& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const Disconnect& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const Disconnect&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Disconnect'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::Disconnect)

namespace bmqp_ctrlmsg {

// ========================
// class DisconnectResponse
// ========================

class DisconnectResponse {
    // This response is sent by the broker to the SDK in response to a
    // 'Disconnect' request, to acknowledge reception of the request and
    // indicate to the client it's good to close the channel.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const DisconnectResponse&,
                           const DisconnectResponse&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const DisconnectResponse& lhs,
                           const DisconnectResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const DisconnectResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const DisconnectResponse&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DisconnectResponse'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::DisconnectResponse)

namespace bmqp_ctrlmsg {

// ====================
// class DumpActionType
// ====================

struct DumpActionType {
  public:
    // TYPES
    enum Value {
        E_ON              = 0,
        E_OFF             = 1,
        E_MESSAGE_COUNT   = 2,
        E_TIME_IN_SECONDS = 3
    };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return DumpActionType::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::DumpActionType)

namespace bmqp_ctrlmsg {

// =================
// class DumpMsgType
// =================

struct DumpMsgType {
  public:
    // TYPES
    enum Value {
        E_INCOMING = 0,
        E_OUTGOING = 1,
        E_PUSH     = 2,
        E_ACK      = 3,
        E_PUT      = 4,
        E_CONFIRM  = 5
    };

    enum { NUM_ENUMERATORS = 6 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return DumpMsgType::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::DumpMsgType)

namespace bmqp_ctrlmsg {

// ======================
// class ElectionProposal
// ======================

class ElectionProposal {
    // This type represents an election proposal from a given node in the BMQ
    // leader election algorithm.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const ElectionProposal&, const ElectionProposal&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const ElectionProposal& lhs,
                           const ElectionProposal& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const ElectionProposal& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const ElectionProposal&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ElectionProposal'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ElectionProposal)

namespace bmqp_ctrlmsg {

// ======================
// class ElectionResponse
// ======================

class ElectionResponse {
    // This type represents an election response from a given node in the BMQ
    // leader election algorithm.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const ElectionResponse&, const ElectionResponse&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const ElectionResponse& lhs,
                           const ElectionResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const ElectionResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const ElectionResponse&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ElectionResponse'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ElectionResponse)

namespace bmqp_ctrlmsg {

// =======================
// class ElectorNodeStatus
// =======================

class ElectorNodeStatus {
    // This type represents a notification from a node about its status.
    // isAvailable..: flag indicated whether an elector node is available or
    // not.

    // INSTANCE DATA
    bool d_isAvailable;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_IS_AVAILABLE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_IS_AVAILABLE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ElectorNodeStatus();
    // Create an object of type 'ElectorNodeStatus' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bool& isAvailable();
    // Return a reference to the modifiable "IsAvailable" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bool isAvailable() const;
    // Return the value of the "IsAvailable" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ElectorNodeStatus& lhs,
                           const ElectorNodeStatus& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isAvailable() == rhs.isAvailable();
    }

    friend bool operator!=(const ElectorNodeStatus& lhs,
                           const ElectorNodeStatus& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const ElectorNodeStatus& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const ElectorNodeStatus& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ElectorNodeStatus'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.isAvailable());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ElectorNodeStatus)

namespace bmqp_ctrlmsg {

// =======================
// class ExpressionVersion
// =======================

struct ExpressionVersion {
    // Enumeration of the various expression versions.

  public:
    // TYPES
    enum Value { E_UNDEFINED = 0, E_VERSION_1 = 1 };

    enum { NUM_ENUMERATORS = 2 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return ExpressionVersion::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::ExpressionVersion)

namespace bmqp_ctrlmsg {

// =================================
// class FollowerClusterStateRequest
// =================================

class FollowerClusterStateRequest {
    // This type represents a request sent by the leader to the highest LSN
    // follower to obtain its cluster state snapshot.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const FollowerClusterStateRequest&,
                           const FollowerClusterStateRequest&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const FollowerClusterStateRequest& lhs,
                           const FollowerClusterStateRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                      stream,
                                    const FollowerClusterStateRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&,
                           const FollowerClusterStateRequest&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'FollowerClusterStateRequest'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::FollowerClusterStateRequest)

namespace bmqp_ctrlmsg {

// ========================
// class FollowerLSNRequest
// ========================

class FollowerLSNRequest {
    // This type represents a request sent by the leader to a follower to query
    // its leader-sequence number.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const FollowerLSNRequest&,
                           const FollowerLSNRequest&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const FollowerLSNRequest& lhs,
                           const FollowerLSNRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const FollowerLSNRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const FollowerLSNRequest&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'FollowerLSNRequest'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::FollowerLSNRequest)

namespace bmqp_ctrlmsg {

// ==============
// class GuidInfo
// ==============

class GuidInfo {
    // This represents the 'clientId' and 'nanoSecondsFromEpoch' provided by
    // bmqp::MessageGUIDGenerator.  Sending them to the broker will allow to
    // retrieve the source and compute the absolute time of a GUID.
    // clientId..............: SDK client ID nanoSecondsFromEpoch..: number of
    // nano seconds from epoch

    // INSTANCE DATA
    bsls::Types::Int64 d_nanoSecondsFromEpoch;
    bsl::string        d_clientId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CLIENT_ID               = 0,
        ATTRIBUTE_ID_NANO_SECONDS_FROM_EPOCH = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_CLIENT_ID               = 0,
        ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const char DEFAULT_INITIALIZER_CLIENT_ID[];

    static const bsls::Types::Int64
        DEFAULT_INITIALIZER_NANO_SECONDS_FROM_EPOCH;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit GuidInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'GuidInfo' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    GuidInfo(const GuidInfo& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'GuidInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    GuidInfo(GuidInfo&& original) noexcept;
    // Create an object of type 'GuidInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    GuidInfo(GuidInfo&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'GuidInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~GuidInfo();
    // Destroy this object.

    // MANIPULATORS
    GuidInfo& operator=(const GuidInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    GuidInfo& operator=(GuidInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clientId();
    // Return a reference to the modifiable "ClientId" attribute of this
    // object.

    bsls::Types::Int64& nanoSecondsFromEpoch();
    // Return a reference to the modifiable "NanoSecondsFromEpoch"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clientId() const;
    // Return a reference offering non-modifiable access to the "ClientId"
    // attribute of this object.

    bsls::Types::Int64 nanoSecondsFromEpoch() const;
    // Return the value of the "NanoSecondsFromEpoch" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const GuidInfo& lhs, const GuidInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clientId() == rhs.clientId() &&
               lhs.nanoSecondsFromEpoch() == rhs.nanoSecondsFromEpoch();
    }

    friend bool operator!=(const GuidInfo& lhs, const GuidInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const GuidInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const GuidInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'GuidInfo'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.clientId());
        hashAppend(hashAlg, object.nanoSecondsFromEpoch());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::GuidInfo)

namespace bmqp_ctrlmsg {

// =======================
// class HeartbeatResponse
// =======================

class HeartbeatResponse {
    // This type represents a response sent by a peer node to the node which
    // sent it a leader heartbeat message.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const HeartbeatResponse&, const HeartbeatResponse&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const HeartbeatResponse& lhs,
                           const HeartbeatResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const HeartbeatResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const HeartbeatResponse&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'HeartbeatResponse'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::HeartbeatResponse)

namespace bmqp_ctrlmsg {

// =====================
// class LeaderHeartbeat
// =====================

class LeaderHeartbeat {
    // This type represents a heartbeat from the leader node in the BlazingMQ
    // leader election algorithm.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderHeartbeat&, const LeaderHeartbeat&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const LeaderHeartbeat& lhs,
                           const LeaderHeartbeat& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&          stream,
                                    const LeaderHeartbeat& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const LeaderHeartbeat&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderHeartbeat'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::LeaderHeartbeat)

namespace bmqp_ctrlmsg {

// ===========================
// class LeaderMessageSequence
// ===========================

class LeaderMessageSequence {
    // This type represents the sequence number of a message/advisory/response
    // sent by the leader.

    // INSTANCE DATA
    bsls::Types::Uint64 d_electorTerm;
    bsls::Types::Uint64 d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_ELECTOR_TERM = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_ELECTOR_TERM    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    LeaderMessageSequence();
    // Create an object of type 'LeaderMessageSequence' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Uint64& electorTerm();
    // Return a reference to the modifiable "ElectorTerm" attribute of this
    // object.

    bsls::Types::Uint64& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Uint64 electorTerm() const;
    // Return the value of the "ElectorTerm" attribute of this object.

    bsls::Types::Uint64 sequenceNumber() const;
    // Return the value of the "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderMessageSequence& lhs,
                           const LeaderMessageSequence& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.electorTerm() == rhs.electorTerm() &&
               lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const LeaderMessageSequence& lhs,
                           const LeaderMessageSequence& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                stream,
                                    const LeaderMessageSequence& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&            hashAlg,
                           const LeaderMessageSequence& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderMessageSequence'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.electorTerm());
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderMessageSequence)

namespace bmqp_ctrlmsg {

// ===================
// class LeaderPassive
// ===================

class LeaderPassive {
    // This type represents a particular type of cluster issue whereby the
    // leader is seen as passive by a follower node, resulting in invalid
    // cluster state.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderPassive&, const LeaderPassive&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const LeaderPassive& lhs, const LeaderPassive& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const LeaderPassive& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const LeaderPassive&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderPassive'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::LeaderPassive)

namespace bmqp_ctrlmsg {

// =========================
// class LeaderSyncDataQuery
// =========================

class LeaderSyncDataQuery {
    // This type represents a request sent by current leader to a follower to
    // ask follower to send the leader its partition/primary mapping and queue
    // information.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderSyncDataQuery&,
                           const LeaderSyncDataQuery&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const LeaderSyncDataQuery& lhs,
                           const LeaderSyncDataQuery& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const LeaderSyncDataQuery& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const LeaderSyncDataQuery&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderSyncDataQuery'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderSyncDataQuery)

namespace bmqp_ctrlmsg {

// ==========================
// class LeaderSyncStateQuery
// ==========================

class LeaderSyncStateQuery {
    // This type represents a request sent by current leader to a follower to
    // query follower's view of the cluster state maintained by the leader.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderSyncStateQuery&,
                           const LeaderSyncStateQuery&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const LeaderSyncStateQuery& lhs,
                           const LeaderSyncStateQuery& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const LeaderSyncStateQuery& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const LeaderSyncStateQuery&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderSyncStateQuery'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderSyncStateQuery)

namespace bmqp_ctrlmsg {

// ===================================
// class LeadershipCessionNotification
// ===================================

class LeadershipCessionNotification {
    // This type represents a notification signalling cession of leadership
    // from the leader node in the BlazingMQ leader election algorithm.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const LeadershipCessionNotification&,
                           const LeadershipCessionNotification&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const LeadershipCessionNotification& lhs,
                           const LeadershipCessionNotification& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream,
                                    const LeadershipCessionNotification& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&,
                           const LeadershipCessionNotification&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeadershipCessionNotification'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeadershipCessionNotification)

namespace bmqp_ctrlmsg {

// ================
// class NodeStatus
// ================

struct NodeStatus {
    // Enumeration of the various node states.

  public:
    // TYPES
    enum Value {
        E_UNKNOWN     = 0,
        E_STARTING    = 10,
        E_AVAILABLE   = 20,
        E_STOPPING    = 30,
        E_UNAVAILABLE = 40
    };

    enum { NUM_ENUMERATORS = 5 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return NodeStatus::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::NodeStatus)

namespace bmqp_ctrlmsg {

// ==========================
// class PartitionPrimaryInfo
// ==========================

class PartitionPrimaryInfo {
    // This type represents the details of parition->primary node mapping.

    // INSTANCE DATA
    unsigned int d_primaryLeaseId;
    int          d_partitionId;
    int          d_primaryNodeId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID     = 0,
        ATTRIBUTE_ID_PRIMARY_NODE_ID  = 1,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID     = 0,
        ATTRIBUTE_INDEX_PRIMARY_NODE_ID  = 1,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PartitionPrimaryInfo();
    // Create an object of type 'PartitionPrimaryInfo' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    int& primaryNodeId();
    // Return a reference to the modifiable "PrimaryNodeId" attribute of
    // this object.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    int primaryNodeId() const;
    // Return the value of the "PrimaryNodeId" attribute of this object.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionPrimaryInfo& lhs,
                           const PartitionPrimaryInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.primaryNodeId() == rhs.primaryNodeId() &&
               lhs.primaryLeaseId() == rhs.primaryLeaseId();
    }

    friend bool operator!=(const PartitionPrimaryInfo& lhs,
                           const PartitionPrimaryInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const PartitionPrimaryInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const PartitionPrimaryInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionPrimaryInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionPrimaryInfo)

namespace bmqp_ctrlmsg {

// =============================
// class PartitionSequenceNumber
// =============================

class PartitionSequenceNumber {
    // This type represents the logical sequence number in a partition.

    // INSTANCE DATA
    bsls::Types::Uint64 d_sequenceNumber;
    unsigned int        d_primaryLeaseId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 0,
        ATTRIBUTE_ID_SEQUENCE_NUMBER  = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER  = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PartitionSequenceNumber();
    // Create an object of type 'PartitionSequenceNumber' having the
    // default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    bsls::Types::Uint64& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    bsls::Types::Uint64 sequenceNumber() const;
    // Return the value of the "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionSequenceNumber& lhs,
                           const PartitionSequenceNumber& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.primaryLeaseId() == rhs.primaryLeaseId() &&
               lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const PartitionSequenceNumber& lhs,
                           const PartitionSequenceNumber& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                  stream,
                                    const PartitionSequenceNumber& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&              hashAlg,
                           const PartitionSequenceNumber& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionSequenceNumber'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.primaryLeaseId());
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSequenceNumber)

namespace bmqp_ctrlmsg {

// ====================================
// class PartitionSyncDataQueryResponse
// ====================================

class PartitionSyncDataQueryResponse {
    // This type represents a message sent by a peer node to the new primary in
    // response to PartitionSyncDataQuery.
    // partitionId....: The corresponding partitionId

    // INSTANCE DATA
    bsls::Types::Uint64 d_endSequenceNum;
    unsigned int        d_endPrimaryLeaseId;
    int                 d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID         = 0,
        ATTRIBUTE_ID_END_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_ID_END_SEQUENCE_NUM     = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID         = 0,
        ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_INDEX_END_SEQUENCE_NUM     = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PartitionSyncDataQueryResponse();
    // Create an object of type 'PartitionSyncDataQueryResponse' having the
    // default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    unsigned int& endPrimaryLeaseId();
    // Return a reference to the modifiable "EndPrimaryLeaseId" attribute
    // of this object.

    bsls::Types::Uint64& endSequenceNum();
    // Return a reference to the modifiable "EndSequenceNum" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    unsigned int endPrimaryLeaseId() const;
    // Return the value of the "EndPrimaryLeaseId" attribute of this
    // object.

    bsls::Types::Uint64 endSequenceNum() const;
    // Return the value of the "EndSequenceNum" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionSyncDataQueryResponse& lhs,
                           const PartitionSyncDataQueryResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.endPrimaryLeaseId() == rhs.endPrimaryLeaseId() &&
               lhs.endSequenceNum() == rhs.endSequenceNum();
    }

    friend bool operator!=(const PartitionSyncDataQueryResponse& lhs,
                           const PartitionSyncDataQueryResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream,
                                    const PartitionSyncDataQueryResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                     hashAlg,
                           const PartitionSyncDataQueryResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionSyncDataQueryResponse'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncDataQueryResponse)

namespace bmqp_ctrlmsg {

// =============================
// class PartitionSyncStateQuery
// =============================

class PartitionSyncStateQuery {
    // This type represents a request sent by a new primary node to all its
    // AVAILABLE peers to query their current state for a given partition.
    // partitionId: The corresponding partitionId

    // INSTANCE DATA
    int d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_PARTITION_ID = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_PARTITION_ID;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PartitionSyncStateQuery();
    // Create an object of type 'PartitionSyncStateQuery' having the
    // default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionSyncStateQuery& lhs,
                           const PartitionSyncStateQuery& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId();
    }

    friend bool operator!=(const PartitionSyncStateQuery& lhs,
                           const PartitionSyncStateQuery& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                  stream,
                                    const PartitionSyncStateQuery& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&              hashAlg,
                           const PartitionSyncStateQuery& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionSyncStateQuery'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.partitionId());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncStateQuery)

namespace bmqp_ctrlmsg {

// ===================
// class PrimaryStatus
// ===================

struct PrimaryStatus {
    // Enumeration of the various primary status.

  public:
    // TYPES
    enum Value { E_UNDEFINED = 0, E_PASSIVE = 1, E_ACTIVE = 5 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return PrimaryStatus::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::PrimaryStatus)

namespace bmqp_ctrlmsg {

// ============================
// class QueueAssignmentRequest
// ============================

class QueueAssignmentRequest {
    // This type represents a request, sent to the leader, to assign the queue
    // with the specified 'queueUri'.

    // INSTANCE DATA
    bsl::string d_queueUri;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_QUEUE_URI = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_QUEUE_URI = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueAssignmentRequest(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueAssignmentRequest' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    QueueAssignmentRequest(const QueueAssignmentRequest& original,
                           bslma::Allocator*             basicAllocator = 0);
    // Create an object of type 'QueueAssignmentRequest' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueAssignmentRequest(QueueAssignmentRequest&& original) noexcept;
    // Create an object of type 'QueueAssignmentRequest' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    QueueAssignmentRequest(QueueAssignmentRequest&& original,
                           bslma::Allocator*        basicAllocator);
    // Create an object of type 'QueueAssignmentRequest' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~QueueAssignmentRequest();
    // Destroy this object.

    // MANIPULATORS
    QueueAssignmentRequest& operator=(const QueueAssignmentRequest& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueAssignmentRequest& operator=(QueueAssignmentRequest&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& queueUri();
    // Return a reference to the modifiable "QueueUri" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& queueUri() const;
    // Return a reference offering non-modifiable access to the "QueueUri"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueAssignmentRequest& lhs,
                           const QueueAssignmentRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.queueUri() == rhs.queueUri();
    }

    friend bool operator!=(const QueueAssignmentRequest& lhs,
                           const QueueAssignmentRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                 stream,
                                    const QueueAssignmentRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&             hashAlg,
                           const QueueAssignmentRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueAssignmentRequest'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.queueUri());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueAssignmentRequest)

namespace bmqp_ctrlmsg {

// ==============================
// class QueueUnassignmentRequest
// ==============================

class QueueUnassignmentRequest {
    // This type represents a request, sent to the leader, to unassign the
    // queue with the specified 'queueUri'.

    // INSTANCE DATA
    bsl::vector<char> d_queueKey;
    bsl::string       d_queueUri;
    int               d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_QUEUE_URI    = 0,
        ATTRIBUTE_ID_PARTITION_ID = 1,
        ATTRIBUTE_ID_QUEUE_KEY    = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_QUEUE_URI    = 0,
        ATTRIBUTE_INDEX_PARTITION_ID = 1,
        ATTRIBUTE_INDEX_QUEUE_KEY    = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueUnassignmentRequest(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueUnassignmentRequest' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    QueueUnassignmentRequest(const QueueUnassignmentRequest& original,
                             bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueUnassignmentRequest' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnassignmentRequest(QueueUnassignmentRequest&& original) noexcept;
    // Create an object of type 'QueueUnassignmentRequest' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    QueueUnassignmentRequest(QueueUnassignmentRequest&& original,
                             bslma::Allocator*          basicAllocator);
    // Create an object of type 'QueueUnassignmentRequest' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~QueueUnassignmentRequest();
    // Destroy this object.

    // MANIPULATORS
    QueueUnassignmentRequest& operator=(const QueueUnassignmentRequest& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnassignmentRequest& operator=(QueueUnassignmentRequest&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& queueUri();
    // Return a reference to the modifiable "QueueUri" attribute of this
    // object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    bsl::vector<char>& queueKey();
    // Return a reference to the modifiable "QueueKey" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& queueUri() const;
    // Return a reference offering non-modifiable access to the "QueueUri"
    // attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const bsl::vector<char>& queueKey() const;
    // Return a reference offering non-modifiable access to the "QueueKey"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueUnassignmentRequest& lhs,
                           const QueueUnassignmentRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.queueUri() == rhs.queueUri() &&
               lhs.partitionId() == rhs.partitionId() &&
               lhs.queueKey() == rhs.queueKey();
    }

    friend bool operator!=(const QueueUnassignmentRequest& lhs,
                           const QueueUnassignmentRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                   stream,
                                    const QueueUnassignmentRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&               hashAlg,
                           const QueueUnassignmentRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueUnassignmentRequest'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueUnassignmentRequest)

namespace bmqp_ctrlmsg {

// ==========================
// class RegistrationResponse
// ==========================

class RegistrationResponse {
    // This type represents a response to the 'RegistrationRequest' sent by the
    // leader to a follower.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const RegistrationResponse&,
                           const RegistrationResponse&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const RegistrationResponse& lhs,
                           const RegistrationResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const RegistrationResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const RegistrationResponse&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RegistrationResponse'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::RegistrationResponse)

namespace bmqp_ctrlmsg {

// =====================
// class ReplicaDataType
// =====================

struct ReplicaDataType {
    // Enumeration of the various replica data request/response types.

  public:
    // TYPES
    enum Value { E_UNKNOWN = 0, E_PULL = 10, E_PUSH = 20, E_DROP = 30 };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return ReplicaDataType::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::ReplicaDataType)

namespace bmqp_ctrlmsg {

// ==============================
// class ReverseConnectionRequest
// ==============================

class ReverseConnectionRequest {
    // This negotiation message is used as the first message exchanged in the
    // case of reverse connection: the 'connecting' out peer sends that message
    // once the connection is established, indicating to the remote peer that
    // it should use this connection as the communication channel for the
    // 'clusterNodeId' of the 'clusterName'.
    // protocolVersion...: protocol version used by this broker
    // clusterName.......: the name of the cluster this connection is about
    // clusterNodeId.....: the nodeId of the node in that cluster (note that
    // the -1 default corresponds to 'mqbnet::Cluster::k_INVALID_NODE_ID').

    // INSTANCE DATA
    bsl::string d_clusterName;
    int         d_protocolVersion;
    int         d_clusterNodeId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PROTOCOL_VERSION = 0,
        ATTRIBUTE_ID_CLUSTER_NAME     = 1,
        ATTRIBUTE_ID_CLUSTER_NODE_ID  = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PROTOCOL_VERSION = 0,
        ATTRIBUTE_INDEX_CLUSTER_NAME     = 1,
        ATTRIBUTE_INDEX_CLUSTER_NODE_ID  = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const char DEFAULT_INITIALIZER_CLUSTER_NAME[];

    static const int DEFAULT_INITIALIZER_CLUSTER_NODE_ID;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ReverseConnectionRequest(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ReverseConnectionRequest' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    ReverseConnectionRequest(const ReverseConnectionRequest& original,
                             bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ReverseConnectionRequest' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReverseConnectionRequest(ReverseConnectionRequest&& original) noexcept;
    // Create an object of type 'ReverseConnectionRequest' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    ReverseConnectionRequest(ReverseConnectionRequest&& original,
                             bslma::Allocator*          basicAllocator);
    // Create an object of type 'ReverseConnectionRequest' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~ReverseConnectionRequest();
    // Destroy this object.

    // MANIPULATORS
    ReverseConnectionRequest& operator=(const ReverseConnectionRequest& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReverseConnectionRequest& operator=(ReverseConnectionRequest&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& protocolVersion();
    // Return a reference to the modifiable "ProtocolVersion" attribute of
    // this object.

    bsl::string& clusterName();
    // Return a reference to the modifiable "ClusterName" attribute of this
    // object.

    int& clusterNodeId();
    // Return a reference to the modifiable "ClusterNodeId" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int protocolVersion() const;
    // Return the value of the "ProtocolVersion" attribute of this object.

    const bsl::string& clusterName() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterName" attribute of this object.

    int clusterNodeId() const;
    // Return the value of the "ClusterNodeId" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ReverseConnectionRequest& lhs,
                           const ReverseConnectionRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.protocolVersion() == rhs.protocolVersion() &&
               lhs.clusterName() == rhs.clusterName() &&
               lhs.clusterNodeId() == rhs.clusterNodeId();
    }

    friend bool operator!=(const ReverseConnectionRequest& lhs,
                           const ReverseConnectionRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                   stream,
                                    const ReverseConnectionRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&               hashAlg,
                           const ReverseConnectionRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ReverseConnectionRequest'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReverseConnectionRequest)

namespace bmqp_ctrlmsg {

// ==========================
// class RoutingConfiguration
// ==========================

class RoutingConfiguration {
    // This complex type contains various attributes required by the downstream
    // node to route messages to the consumers attached to it.
    // flags.: Flags representing the routing configuration

    // INSTANCE DATA
    bsls::Types::Uint64 d_flags;
    // This is an unsigned representation with flag bits specified on the
    // 'RoutingConfigurationFlags' type.

  public:
    // TYPES
    enum { ATTRIBUTE_ID_FLAGS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_FLAGS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    RoutingConfiguration();
    // Create an object of type 'RoutingConfiguration' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Uint64& flags();
    // Return a reference to the modifiable "Flags" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Uint64 flags() const;
    // Return the value of the "Flags" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RoutingConfiguration& lhs,
                           const RoutingConfiguration& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.flags() == rhs.flags();
    }

    friend bool operator!=(const RoutingConfiguration& lhs,
                           const RoutingConfiguration& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const RoutingConfiguration& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const RoutingConfiguration& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RoutingConfiguration'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.flags());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::RoutingConfiguration)

namespace bmqp_ctrlmsg {

// ===============================
// class RoutingConfigurationFlags
// ===============================

struct RoutingConfigurationFlags {
    // This flag encodes configuration on how messages should be routed to
    // downstream consumers.
    // E_AT_MOST_ONCE..............: This indicates that this domain is
    // configured with at-most-once semantics.  This in turn means that
    // confirms are optional and acknowledgments (if required) will always be
    // send, even if there's message loss.  E_DELIVER_CONSUMER_PRIORITY.: This
    // flag indicates that only downstream consumers having the highest
    // consumer should be considered as available destination for a message.
    // E_DELIVER_ALL...............: This flag indicates that messages should
    // be delivered to all available downstream consumers (after some added
    // filtering based on other flags, such as 'E_DELIVER_CONSUMER_PRIORITY').
    // E_HAS_MULTIPLE_SUB_STREAMS..: This flag indicates that multiple
    // downstream consumers should be considered as available destination for a
    // message.

  public:
    // TYPES
    enum Value {
        E_AT_MOST_ONCE              = 0,
        E_DELIVER_CONSUMER_PRIORITY = 1,
        E_DELIVER_ALL               = 2,
        E_HAS_MULTIPLE_SUB_STREAMS  = 3
    };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return RoutingConfigurationFlags::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::RoutingConfigurationFlags)

namespace bmqp_ctrlmsg {

// =====================
// class ScoutingRequest
// =====================

class ScoutingRequest {
    // This type represents a request sent by a peer node to gauge the interest
    // peer nodes in supporting it, with the term specified in the top level
    // type.

    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const ScoutingRequest&, const ScoutingRequest&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const ScoutingRequest& lhs,
                           const ScoutingRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&          stream,
                                    const ScoutingRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const ScoutingRequest&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ScoutingRequest'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ScoutingRequest)

namespace bmqp_ctrlmsg {

// ======================
// class ScoutingResponse
// ======================

class ScoutingResponse {
    // This type represents a message sent by a peer node as a response to the
    // scouting request from another peer.
    // willVote..: boolean indicating if this peer will support an election
    // proposal from the requester node with the term specified in the top
    // level type.

    // INSTANCE DATA
    bool d_willVote;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_WILL_VOTE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_WILL_VOTE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ScoutingResponse();
    // Create an object of type 'ScoutingResponse' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bool& willVote();
    // Return a reference to the modifiable "WillVote" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bool willVote() const;
    // Return the value of the "WillVote" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ScoutingResponse& lhs,
                           const ScoutingResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.willVote() == rhs.willVote();
    }

    friend bool operator!=(const ScoutingResponse& lhs,
                           const ScoutingResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const ScoutingResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const ScoutingResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ScoutingResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.willVote());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ScoutingResponse)

namespace bmqp_ctrlmsg {

// ====================
// class StatusCategory
// ====================

struct StatusCategory {
    // Enumeration of the various status categories.  Some categories (TIMEOUT,
    // CANCELED) should not be sent by the broker, but adding them in that enum
    // will make it possible from the SDK (which could fire those errors in
    // response of a request) to simulate such response from the broker and
    // hence allow to use a single code path for the response handling.  ##
    // This enum must remain in sync with 'bmqt_resultcode::GenericResult'

  public:
    // TYPES
    enum Value {
        E_SUCCESS          = 0,
        E_UNKNOWN          = -1,
        E_TIMEOUT          = -2,
        E_NOT_CONNECTED    = -3,
        E_CANCELED         = -4,
        E_NOT_SUPPORTED    = -5,
        E_REFUSED          = -6,
        E_INVALID_ARGUMENT = -7,
        E_NOT_READY        = -8
    };

    enum { NUM_ENUMERATORS = 9 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return StatusCategory::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::StatusCategory)

namespace bmqp_ctrlmsg {

// =================
// class StopRequest
// =================

class StopRequest {
    // This type represents a request sent by a cluster member node upon
    // graceful shutdown / going into maintenance mode.

    // INSTANCE DATA
    bsl::string d_clusterName;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CLUSTER_NAME = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CLUSTER_NAME = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit StopRequest(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StopRequest' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StopRequest(const StopRequest& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'StopRequest' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StopRequest(StopRequest&& original) noexcept;
    // Create an object of type 'StopRequest' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StopRequest(StopRequest&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'StopRequest' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StopRequest();
    // Destroy this object.

    // MANIPULATORS
    StopRequest& operator=(const StopRequest& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StopRequest& operator=(StopRequest&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clusterName();
    // Return a reference to the modifiable "ClusterName" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clusterName() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterName" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StopRequest& lhs, const StopRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clusterName() == rhs.clusterName();
    }

    friend bool operator!=(const StopRequest& lhs, const StopRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const StopRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const StopRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'StopRequest'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.clusterName());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StopRequest)

namespace bmqp_ctrlmsg {

// ==================
// class StopResponse
// ==================

class StopResponse {
    // This type represents a response sent by a cluster member node or proxy
    // after completing processing stopRequest.
    // clusterName: Must match the one in corresponding stopRequest

    // INSTANCE DATA
    bsl::string d_clusterName;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CLUSTER_NAME = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CLUSTER_NAME = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit StopResponse(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StopResponse' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StopResponse(const StopResponse& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'StopResponse' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StopResponse(StopResponse&& original) noexcept;
    // Create an object of type 'StopResponse' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StopResponse(StopResponse&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'StopResponse' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StopResponse();
    // Destroy this object.

    // MANIPULATORS
    StopResponse& operator=(const StopResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StopResponse& operator=(StopResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clusterName();
    // Return a reference to the modifiable "ClusterName" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clusterName() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterName" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StopResponse& lhs, const StopResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clusterName() == rhs.clusterName();
    }

    friend bool operator!=(const StopResponse& lhs, const StopResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const StopResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const StopResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StopResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.clusterName());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StopResponse)

namespace bmqp_ctrlmsg {

// =============================
// class StorageSyncResponseType
// =============================

struct StorageSyncResponseType {
    // Enumeration of the various categories for storage sync response.

  public:
    // TYPES
    enum Value {
        E_UNDEFINED = 0,
        E_PATCH     = 1,
        E_FILE      = 2,
        E_IN_SYNC   = 3,
        E_EMPTY     = 4
    };

    enum { NUM_ENUMERATORS = 5 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return StorageSyncResponseType::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::StorageSyncResponseType)

namespace bmqp_ctrlmsg {

// ====================
// class SubQueueIdInfo
// ====================

class SubQueueIdInfo {
    // This complex type contains various attributes which uniquely identify a
    // subQueueId (which typically would represent a fanout consumer).
    // subId.: Id of the subQueue appId.: Application-provided unique string
    // identifier for a given fanout consumer

    // INSTANCE DATA
    bsl::string  d_appId;
    unsigned int d_subId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SUB_ID = 0, ATTRIBUTE_ID_APP_ID = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SUB_ID = 0, ATTRIBUTE_INDEX_APP_ID = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const unsigned int DEFAULT_INITIALIZER_SUB_ID;

    static const char DEFAULT_INITIALIZER_APP_ID[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit SubQueueIdInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'SubQueueIdInfo' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    SubQueueIdInfo(const SubQueueIdInfo& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'SubQueueIdInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SubQueueIdInfo(SubQueueIdInfo&& original) noexcept;
    // Create an object of type 'SubQueueIdInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    SubQueueIdInfo(SubQueueIdInfo&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'SubQueueIdInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~SubQueueIdInfo();
    // Destroy this object.

    // MANIPULATORS
    SubQueueIdInfo& operator=(const SubQueueIdInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SubQueueIdInfo& operator=(SubQueueIdInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& subId();
    // Return a reference to the modifiable "SubId" attribute of this
    // object.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int subId() const;
    // Return the value of the "SubId" attribute of this object.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const SubQueueIdInfo& lhs,
                           const SubQueueIdInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.subId() == rhs.subId() && lhs.appId() == rhs.appId();
    }

    friend bool operator!=(const SubQueueIdInfo& lhs,
                           const SubQueueIdInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const SubQueueIdInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const SubQueueIdInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'SubQueueIdInfo'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.subId());
        hashAppend(hashAlg, object.appId());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::SubQueueIdInfo)

namespace bmqp_ctrlmsg {

// ===============
// class SyncPoint
// ===============

class SyncPoint {
    // This type represents a 'sync point' for a given partition (file store)
    // in the BlazingMQ replicated state machine.  Note that sync point is sent
    // as a binary message, not a schema message.  This type exists in this
    // schema solely as a convenience for using a generated type instead of
    // writing one by hand.
    // partitionId.............: Id of the applicable partition (file store)
    // primaryLeaseId..........: LeaseId of the sender node (primary for the
    // partition) primaryNodeId...........: NodeId of the sender (primary for
    // the partition) sequenceNum.............: Sequence number of the last
    // message dataFilePositionDwords..: Position of data file when this sync
    // point was issued.

    // INSTANCE DATA
    bsls::Types::Uint64 d_sequenceNum;
    unsigned int        d_primaryLeaseId;
    unsigned int        d_dataFileOffsetDwords;
    unsigned int        d_qlistFileOffsetWords;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const SyncPoint& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PRIMARY_LEASE_ID        = 0,
        ATTRIBUTE_ID_SEQUENCE_NUM            = 1,
        ATTRIBUTE_ID_DATA_FILE_OFFSET_DWORDS = 2,
        ATTRIBUTE_ID_QLIST_FILE_OFFSET_WORDS = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID        = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUM            = 1,
        ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS = 2,
        ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    SyncPoint();
    // Create an object of type 'SyncPoint' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    bsls::Types::Uint64& sequenceNum();
    // Return a reference to the modifiable "SequenceNum" attribute of this
    // object.

    unsigned int& dataFileOffsetDwords();
    // Return a reference to the modifiable "DataFileOffsetDwords"
    // attribute of this object.

    unsigned int& qlistFileOffsetWords();
    // Return a reference to the modifiable "QlistFileOffsetWords"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    bsls::Types::Uint64 sequenceNum() const;
    // Return the value of the "SequenceNum" attribute of this object.

    unsigned int dataFileOffsetDwords() const;
    // Return the value of the "DataFileOffsetDwords" attribute of this
    // object.

    unsigned int qlistFileOffsetWords() const;
    // Return the value of the "QlistFileOffsetWords" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const SyncPoint& lhs, const SyncPoint& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const SyncPoint& lhs, const SyncPoint& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const SyncPoint& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const SyncPoint& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'SyncPoint'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::SyncPoint)

namespace bmqp_ctrlmsg {

// ====================
// class ClientIdentity
// ====================

class ClientIdentity {
    // This represents the 'identification' sent by a client to the broker
    // during connection negotiation.
    // protocolVersion...: protocol version used by this client
    // sdkVersion........: version of the SDK used by this client
    // clientType........: type of client trying to connect to the bmqbrkr
    // processName.......: name of the process pid...............: PID of the
    // process sessionId.........: instance count of the session in the task
    // hostName..........: name of the host where the client is running
    // features..........: a space separated list of supported features by the
    // client clusterName.......: used only when 'clientType' is 'E_TCPBROKER'
    // and contains the name of the Cluster responsible for establishing this
    // inter-broker connectivity; whether this is about a Cluster proxy or a
    // Cluster member.  clusterNodeId.....: used only when 'clientType' is
    // 'E_TCPBROKER' and contains the node id of the broker in that cluster, or
    // -1 if the broker  is not part of the cluster (i.e., a -1 value for
    // 'clusterNodeId' indicates this connection is about a Cluster proxy; note
    // that this -1 must be equal to 'mqbnet::Cluster::k_INVALID_NODE_ID').
    // sdkLanguage.......: language of the SDK used by this client.
    // guidInfo..........: data provided by bmqp::MessageGUIDGenerator.
    // Contains clientId, current timer tick and number of seconds from epoch.

    // INSTANCE DATA
    bsl::string           d_processName;
    bsl::string           d_hostName;
    bsl::string           d_features;
    bsl::string           d_clusterName;
    GuidInfo              d_guidInfo;
    int                   d_protocolVersion;
    int                   d_sdkVersion;
    int                   d_pid;
    int                   d_sessionId;
    int                   d_clusterNodeId;
    ClientType::Value     d_clientType;
    ClientLanguage::Value d_sdkLanguage;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClientIdentity& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PROTOCOL_VERSION = 0,
        ATTRIBUTE_ID_SDK_VERSION      = 1,
        ATTRIBUTE_ID_CLIENT_TYPE      = 2,
        ATTRIBUTE_ID_PROCESS_NAME     = 3,
        ATTRIBUTE_ID_PID              = 4,
        ATTRIBUTE_ID_SESSION_ID       = 5,
        ATTRIBUTE_ID_HOST_NAME        = 6,
        ATTRIBUTE_ID_FEATURES         = 7,
        ATTRIBUTE_ID_CLUSTER_NAME     = 8,
        ATTRIBUTE_ID_CLUSTER_NODE_ID  = 9,
        ATTRIBUTE_ID_SDK_LANGUAGE     = 10,
        ATTRIBUTE_ID_GUID_INFO        = 11
    };

    enum { NUM_ATTRIBUTES = 12 };

    enum {
        ATTRIBUTE_INDEX_PROTOCOL_VERSION = 0,
        ATTRIBUTE_INDEX_SDK_VERSION      = 1,
        ATTRIBUTE_INDEX_CLIENT_TYPE      = 2,
        ATTRIBUTE_INDEX_PROCESS_NAME     = 3,
        ATTRIBUTE_INDEX_PID              = 4,
        ATTRIBUTE_INDEX_SESSION_ID       = 5,
        ATTRIBUTE_INDEX_HOST_NAME        = 6,
        ATTRIBUTE_INDEX_FEATURES         = 7,
        ATTRIBUTE_INDEX_CLUSTER_NAME     = 8,
        ATTRIBUTE_INDEX_CLUSTER_NODE_ID  = 9,
        ATTRIBUTE_INDEX_SDK_LANGUAGE     = 10,
        ATTRIBUTE_INDEX_GUID_INFO        = 11
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_SDK_VERSION;

    static const char DEFAULT_INITIALIZER_PROCESS_NAME[];

    static const int DEFAULT_INITIALIZER_PID;

    static const int DEFAULT_INITIALIZER_SESSION_ID;

    static const char DEFAULT_INITIALIZER_HOST_NAME[];

    static const char DEFAULT_INITIALIZER_FEATURES[];

    static const char DEFAULT_INITIALIZER_CLUSTER_NAME[];

    static const int DEFAULT_INITIALIZER_CLUSTER_NODE_ID;

    static const ClientLanguage::Value DEFAULT_INITIALIZER_SDK_LANGUAGE;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClientIdentity(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClientIdentity' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClientIdentity(const ClientIdentity& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'ClientIdentity' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClientIdentity(ClientIdentity&& original) noexcept;
    // Create an object of type 'ClientIdentity' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClientIdentity(ClientIdentity&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'ClientIdentity' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClientIdentity();
    // Destroy this object.

    // MANIPULATORS
    ClientIdentity& operator=(const ClientIdentity& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClientIdentity& operator=(ClientIdentity&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& protocolVersion();
    // Return a reference to the modifiable "ProtocolVersion" attribute of
    // this object.

    int& sdkVersion();
    // Return a reference to the modifiable "SdkVersion" attribute of this
    // object.

    ClientType::Value& clientType();
    // Return a reference to the modifiable "ClientType" attribute of this
    // object.

    bsl::string& processName();
    // Return a reference to the modifiable "ProcessName" attribute of this
    // object.

    int& pid();
    // Return a reference to the modifiable "Pid" attribute of this object.

    int& sessionId();
    // Return a reference to the modifiable "SessionId" attribute of this
    // object.

    bsl::string& hostName();
    // Return a reference to the modifiable "HostName" attribute of this
    // object.

    bsl::string& features();
    // Return a reference to the modifiable "Features" attribute of this
    // object.

    bsl::string& clusterName();
    // Return a reference to the modifiable "ClusterName" attribute of this
    // object.

    int& clusterNodeId();
    // Return a reference to the modifiable "ClusterNodeId" attribute of
    // this object.

    ClientLanguage::Value& sdkLanguage();
    // Return a reference to the modifiable "SdkLanguage" attribute of this
    // object.

    GuidInfo& guidInfo();
    // Return a reference to the modifiable "GuidInfo" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int protocolVersion() const;
    // Return the value of the "ProtocolVersion" attribute of this object.

    int sdkVersion() const;
    // Return the value of the "SdkVersion" attribute of this object.

    ClientType::Value clientType() const;
    // Return the value of the "ClientType" attribute of this object.

    const bsl::string& processName() const;
    // Return a reference offering non-modifiable access to the
    // "ProcessName" attribute of this object.

    int pid() const;
    // Return the value of the "Pid" attribute of this object.

    int sessionId() const;
    // Return the value of the "SessionId" attribute of this object.

    const bsl::string& hostName() const;
    // Return a reference offering non-modifiable access to the "HostName"
    // attribute of this object.

    const bsl::string& features() const;
    // Return a reference offering non-modifiable access to the "Features"
    // attribute of this object.

    const bsl::string& clusterName() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterName" attribute of this object.

    int clusterNodeId() const;
    // Return the value of the "ClusterNodeId" attribute of this object.

    ClientLanguage::Value sdkLanguage() const;
    // Return the value of the "SdkLanguage" attribute of this object.

    const GuidInfo& guidInfo() const;
    // Return a reference offering non-modifiable access to the "GuidInfo"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClientIdentity& lhs,
                           const ClientIdentity& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClientIdentity& lhs,
                           const ClientIdentity& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const ClientIdentity& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const ClientIdentity& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClientIdentity'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClientIdentity)

namespace bmqp_ctrlmsg {

// ==================
// class DumpMessages
// ==================

class DumpMessages {
    // INSTANCE DATA
    int                   d_dumpActionValue;
    DumpMsgType::Value    d_msgTypeToDump;
    DumpActionType::Value d_dumpActionType;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_MSG_TYPE_TO_DUMP  = 0,
        ATTRIBUTE_ID_DUMP_ACTION_TYPE  = 1,
        ATTRIBUTE_ID_DUMP_ACTION_VALUE = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP  = 0,
        ATTRIBUTE_INDEX_DUMP_ACTION_TYPE  = 1,
        ATTRIBUTE_INDEX_DUMP_ACTION_VALUE = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_DUMP_ACTION_VALUE;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    DumpMessages();
    // Create an object of type 'DumpMessages' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    DumpMsgType::Value& msgTypeToDump();
    // Return a reference to the modifiable "MsgTypeToDump" attribute of
    // this object.

    DumpActionType::Value& dumpActionType();
    // Return a reference to the modifiable "DumpActionType" attribute of
    // this object.

    int& dumpActionValue();
    // Return a reference to the modifiable "DumpActionValue" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    DumpMsgType::Value msgTypeToDump() const;
    // Return the value of the "MsgTypeToDump" attribute of this object.

    DumpActionType::Value dumpActionType() const;
    // Return the value of the "DumpActionType" attribute of this object.

    int dumpActionValue() const;
    // Return the value of the "DumpActionValue" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DumpMessages& lhs, const DumpMessages& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.msgTypeToDump() == rhs.msgTypeToDump() &&
               lhs.dumpActionType() == rhs.dumpActionType() &&
               lhs.dumpActionValue() == rhs.dumpActionValue();
    }

    friend bool operator!=(const DumpMessages& lhs, const DumpMessages& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const DumpMessages& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const DumpMessages& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DumpMessages'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::DumpMessages)

namespace bmqp_ctrlmsg {

// ==========================
// class ElectorMessageChoice
// ==========================

class ElectorMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ElectionProposal>  d_electionProposal;
        bsls::ObjectBuffer<ElectionResponse>  d_electionResponse;
        bsls::ObjectBuffer<LeaderHeartbeat>   d_leaderHeartbeat;
        bsls::ObjectBuffer<ElectorNodeStatus> d_electorNodeStatus;
        bsls::ObjectBuffer<HeartbeatResponse> d_heartbeatResponse;
        bsls::ObjectBuffer<ScoutingRequest>   d_scoutingRequest;
        bsls::ObjectBuffer<ScoutingResponse>  d_scoutingResponse;
        bsls::ObjectBuffer<LeadershipCessionNotification>
            d_leadershipCessionNotification;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ElectorMessageChoice& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                       = -1,
        SELECTION_ID_ELECTION_PROPOSAL               = 0,
        SELECTION_ID_ELECTION_RESPONSE               = 1,
        SELECTION_ID_LEADER_HEARTBEAT                = 2,
        SELECTION_ID_ELECTOR_NODE_STATUS             = 3,
        SELECTION_ID_HEARTBEAT_RESPONSE              = 4,
        SELECTION_ID_SCOUTING_REQUEST                = 5,
        SELECTION_ID_SCOUTING_RESPONSE               = 6,
        SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION = 7
    };

    enum { NUM_SELECTIONS = 8 };

    enum {
        SELECTION_INDEX_ELECTION_PROPOSAL               = 0,
        SELECTION_INDEX_ELECTION_RESPONSE               = 1,
        SELECTION_INDEX_LEADER_HEARTBEAT                = 2,
        SELECTION_INDEX_ELECTOR_NODE_STATUS             = 3,
        SELECTION_INDEX_HEARTBEAT_RESPONSE              = 4,
        SELECTION_INDEX_SCOUTING_REQUEST                = 5,
        SELECTION_INDEX_SCOUTING_RESPONSE               = 6,
        SELECTION_INDEX_LEADERSHIP_CESSION_NOTIFICATION = 7
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    ElectorMessageChoice();
    // Create an object of type 'ElectorMessageChoice' having the default
    // value.

    ElectorMessageChoice(const ElectorMessageChoice& original);
    // Create an object of type 'ElectorMessageChoice' having the value of
    // the specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorMessageChoice(ElectorMessageChoice&& original) noexcept;
    // Create an object of type 'ElectorMessageChoice' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
#endif

    ~ElectorMessageChoice();
    // Destroy this object.

    // MANIPULATORS
    ElectorMessageChoice& operator=(const ElectorMessageChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorMessageChoice& operator=(ElectorMessageChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    ElectionProposal& makeElectionProposal();
    ElectionProposal& makeElectionProposal(const ElectionProposal& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectionProposal& makeElectionProposal(ElectionProposal&& value);
#endif
    // Set the value of this object to be a "ElectionProposal" value.
    // Optionally specify the 'value' of the "ElectionProposal".  If
    // 'value' is not specified, the default "ElectionProposal" value is
    // used.

    ElectionResponse& makeElectionResponse();
    ElectionResponse& makeElectionResponse(const ElectionResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectionResponse& makeElectionResponse(ElectionResponse&& value);
#endif
    // Set the value of this object to be a "ElectionResponse" value.
    // Optionally specify the 'value' of the "ElectionResponse".  If
    // 'value' is not specified, the default "ElectionResponse" value is
    // used.

    LeaderHeartbeat& makeLeaderHeartbeat();
    LeaderHeartbeat& makeLeaderHeartbeat(const LeaderHeartbeat& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderHeartbeat& makeLeaderHeartbeat(LeaderHeartbeat&& value);
#endif
    // Set the value of this object to be a "LeaderHeartbeat" value.
    // Optionally specify the 'value' of the "LeaderHeartbeat".  If 'value'
    // is not specified, the default "LeaderHeartbeat" value is used.

    ElectorNodeStatus& makeElectorNodeStatus();
    ElectorNodeStatus& makeElectorNodeStatus(const ElectorNodeStatus& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorNodeStatus& makeElectorNodeStatus(ElectorNodeStatus&& value);
#endif
    // Set the value of this object to be a "ElectorNodeStatus" value.
    // Optionally specify the 'value' of the "ElectorNodeStatus".  If
    // 'value' is not specified, the default "ElectorNodeStatus" value is
    // used.

    HeartbeatResponse& makeHeartbeatResponse();
    HeartbeatResponse& makeHeartbeatResponse(const HeartbeatResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    HeartbeatResponse& makeHeartbeatResponse(HeartbeatResponse&& value);
#endif
    // Set the value of this object to be a "HeartbeatResponse" value.
    // Optionally specify the 'value' of the "HeartbeatResponse".  If
    // 'value' is not specified, the default "HeartbeatResponse" value is
    // used.

    ScoutingRequest& makeScoutingRequest();
    ScoutingRequest& makeScoutingRequest(const ScoutingRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ScoutingRequest& makeScoutingRequest(ScoutingRequest&& value);
#endif
    // Set the value of this object to be a "ScoutingRequest" value.
    // Optionally specify the 'value' of the "ScoutingRequest".  If 'value'
    // is not specified, the default "ScoutingRequest" value is used.

    ScoutingResponse& makeScoutingResponse();
    ScoutingResponse& makeScoutingResponse(const ScoutingResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ScoutingResponse& makeScoutingResponse(ScoutingResponse&& value);
#endif
    // Set the value of this object to be a "ScoutingResponse" value.
    // Optionally specify the 'value' of the "ScoutingResponse".  If
    // 'value' is not specified, the default "ScoutingResponse" value is
    // used.

    LeadershipCessionNotification& makeLeadershipCessionNotification();
    LeadershipCessionNotification& makeLeadershipCessionNotification(
        const LeadershipCessionNotification& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeadershipCessionNotification&
    makeLeadershipCessionNotification(LeadershipCessionNotification&& value);
#endif
    // Set the value of this object to be a "LeadershipCessionNotification"
    // value.  Optionally specify the 'value' of the
    // "LeadershipCessionNotification".  If 'value' is not specified, the
    // default "LeadershipCessionNotification" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    ElectionProposal& electionProposal();
    // Return a reference to the modifiable "ElectionProposal" selection of
    // this object if "ElectionProposal" is the current selection.  The
    // behavior is undefined unless "ElectionProposal" is the selection of
    // this object.

    ElectionResponse& electionResponse();
    // Return a reference to the modifiable "ElectionResponse" selection of
    // this object if "ElectionResponse" is the current selection.  The
    // behavior is undefined unless "ElectionResponse" is the selection of
    // this object.

    LeaderHeartbeat& leaderHeartbeat();
    // Return a reference to the modifiable "LeaderHeartbeat" selection of
    // this object if "LeaderHeartbeat" is the current selection.  The
    // behavior is undefined unless "LeaderHeartbeat" is the selection of
    // this object.

    ElectorNodeStatus& electorNodeStatus();
    // Return a reference to the modifiable "ElectorNodeStatus" selection
    // of this object if "ElectorNodeStatus" is the current selection.  The
    // behavior is undefined unless "ElectorNodeStatus" is the selection of
    // this object.

    HeartbeatResponse& heartbeatResponse();
    // Return a reference to the modifiable "HeartbeatResponse" selection
    // of this object if "HeartbeatResponse" is the current selection.  The
    // behavior is undefined unless "HeartbeatResponse" is the selection of
    // this object.

    ScoutingRequest& scoutingRequest();
    // Return a reference to the modifiable "ScoutingRequest" selection of
    // this object if "ScoutingRequest" is the current selection.  The
    // behavior is undefined unless "ScoutingRequest" is the selection of
    // this object.

    ScoutingResponse& scoutingResponse();
    // Return a reference to the modifiable "ScoutingResponse" selection of
    // this object if "ScoutingResponse" is the current selection.  The
    // behavior is undefined unless "ScoutingResponse" is the selection of
    // this object.

    LeadershipCessionNotification& leadershipCessionNotification();
    // Return a reference to the modifiable "LeadershipCessionNotification"
    // selection of this object if "LeadershipCessionNotification" is the
    // current selection.  The behavior is undefined unless
    // "LeadershipCessionNotification" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const ElectionProposal& electionProposal() const;
    // Return a reference to the non-modifiable "ElectionProposal"
    // selection of this object if "ElectionProposal" is the current
    // selection.  The behavior is undefined unless "ElectionProposal" is
    // the selection of this object.

    const ElectionResponse& electionResponse() const;
    // Return a reference to the non-modifiable "ElectionResponse"
    // selection of this object if "ElectionResponse" is the current
    // selection.  The behavior is undefined unless "ElectionResponse" is
    // the selection of this object.

    const LeaderHeartbeat& leaderHeartbeat() const;
    // Return a reference to the non-modifiable "LeaderHeartbeat" selection
    // of this object if "LeaderHeartbeat" is the current selection.  The
    // behavior is undefined unless "LeaderHeartbeat" is the selection of
    // this object.

    const ElectorNodeStatus& electorNodeStatus() const;
    // Return a reference to the non-modifiable "ElectorNodeStatus"
    // selection of this object if "ElectorNodeStatus" is the current
    // selection.  The behavior is undefined unless "ElectorNodeStatus" is
    // the selection of this object.

    const HeartbeatResponse& heartbeatResponse() const;
    // Return a reference to the non-modifiable "HeartbeatResponse"
    // selection of this object if "HeartbeatResponse" is the current
    // selection.  The behavior is undefined unless "HeartbeatResponse" is
    // the selection of this object.

    const ScoutingRequest& scoutingRequest() const;
    // Return a reference to the non-modifiable "ScoutingRequest" selection
    // of this object if "ScoutingRequest" is the current selection.  The
    // behavior is undefined unless "ScoutingRequest" is the selection of
    // this object.

    const ScoutingResponse& scoutingResponse() const;
    // Return a reference to the non-modifiable "ScoutingResponse"
    // selection of this object if "ScoutingResponse" is the current
    // selection.  The behavior is undefined unless "ScoutingResponse" is
    // the selection of this object.

    const LeadershipCessionNotification& leadershipCessionNotification() const;
    // Return a reference to the non-modifiable
    // "LeadershipCessionNotification" selection of this object if
    // "LeadershipCessionNotification" is the current selection.  The
    // behavior is undefined unless "LeadershipCessionNotification" is the
    // selection of this object.

    bool isElectionProposalValue() const;
    // Return 'true' if the value of this object is a "ElectionProposal"
    // value, and return 'false' otherwise.

    bool isElectionResponseValue() const;
    // Return 'true' if the value of this object is a "ElectionResponse"
    // value, and return 'false' otherwise.

    bool isLeaderHeartbeatValue() const;
    // Return 'true' if the value of this object is a "LeaderHeartbeat"
    // value, and return 'false' otherwise.

    bool isElectorNodeStatusValue() const;
    // Return 'true' if the value of this object is a "ElectorNodeStatus"
    // value, and return 'false' otherwise.

    bool isHeartbeatResponseValue() const;
    // Return 'true' if the value of this object is a "HeartbeatResponse"
    // value, and return 'false' otherwise.

    bool isScoutingRequestValue() const;
    // Return 'true' if the value of this object is a "ScoutingRequest"
    // value, and return 'false' otherwise.

    bool isScoutingResponseValue() const;
    // Return 'true' if the value of this object is a "ScoutingResponse"
    // value, and return 'false' otherwise.

    bool isLeadershipCessionNotificationValue() const;
    // Return 'true' if the value of this object is a
    // "LeadershipCessionNotification" value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ElectorMessageChoice& lhs,
                           const ElectorMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ElectorMessageChoice' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ElectorMessageChoice& lhs,
                           const ElectorMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const ElectorMessageChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const ElectorMessageChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ElectorMessageChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ElectorMessageChoice)

namespace bmqp_ctrlmsg {

// ================
// class Expression
// ================

class Expression {
    // This complex type contains expression to evaluate when selecting
    // Subscription for delivery.
    // version................: expression version (default is HSL)
    // text...................: textual representation of the expression

    // INSTANCE DATA
    bsl::string              d_text;
    ExpressionVersion::Value d_version;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_VERSION = 0, ATTRIBUTE_ID_TEXT = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_VERSION = 0, ATTRIBUTE_INDEX_TEXT = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const ExpressionVersion::Value DEFAULT_INITIALIZER_VERSION;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Expression(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Expression' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Expression(const Expression& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Expression' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Expression(Expression&& original) noexcept;
    // Create an object of type 'Expression' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    Expression(Expression&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Expression' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Expression();
    // Destroy this object.

    // MANIPULATORS
    Expression& operator=(const Expression& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Expression& operator=(Expression&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ExpressionVersion::Value& version();
    // Return a reference to the modifiable "Version" attribute of this
    // object.

    bsl::string& text();
    // Return a reference to the modifiable "Text" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    ExpressionVersion::Value version() const;
    // Return the value of the "Version" attribute of this object.

    const bsl::string& text() const;
    // Return a reference offering non-modifiable access to the "Text"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Expression& lhs, const Expression& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.version() == rhs.version() && lhs.text() == rhs.text();
    }

    friend bool operator!=(const Expression& lhs, const Expression& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const Expression& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Expression& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Expression'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.version());
        hashAppend(hashAlg, object.text());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::Expression)

namespace bmqp_ctrlmsg {

// =========================
// class FollowerLSNResponse
// =========================

class FollowerLSNResponse {
    // This type represents a response to the 'FollowerLSNRequest' sent by a
    // follower to the leader.
    // sequenceNumber..: Follower's leader-sequence number

    // INSTANCE DATA
    LeaderMessageSequence d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    FollowerLSNResponse();
    // Create an object of type 'FollowerLSNResponse' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const FollowerLSNResponse& lhs,
                           const FollowerLSNResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const FollowerLSNResponse& lhs,
                           const FollowerLSNResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const FollowerLSNResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const FollowerLSNResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'FollowerLSNResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::FollowerLSNResponse)

namespace bmqp_ctrlmsg {

// =======================
// class LeaderAdvisoryAck
// =======================

class LeaderAdvisoryAck {
    // This type represents a one way message indicating receipt of a specific
    // leader advisory.

    // INSTANCE DATA
    LeaderMessageSequence d_sequenceNumberAcked;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER_ACKED = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    LeaderAdvisoryAck();
    // Create an object of type 'LeaderAdvisoryAck' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumberAcked();
    // Return a reference to the modifiable "SequenceNumberAcked" attribute
    // of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumberAcked() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumberAcked" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderAdvisoryAck& lhs,
                           const LeaderAdvisoryAck& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sequenceNumberAcked() == rhs.sequenceNumberAcked();
    }

    friend bool operator!=(const LeaderAdvisoryAck& lhs,
                           const LeaderAdvisoryAck& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const LeaderAdvisoryAck& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const LeaderAdvisoryAck& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderAdvisoryAck'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.sequenceNumberAcked());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderAdvisoryAck)

namespace bmqp_ctrlmsg {

// ==========================
// class LeaderAdvisoryCommit
// ==========================

class LeaderAdvisoryCommit {
    // This type represents a one way message indicating commit of a specific
    // leader advisory.

    // INSTANCE DATA
    LeaderMessageSequence d_sequenceNumber;
    LeaderMessageSequence d_sequenceNumberCommitted;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SEQUENCE_NUMBER           = 0,
        ATTRIBUTE_ID_SEQUENCE_NUMBER_COMMITTED = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER           = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    LeaderAdvisoryCommit();
    // Create an object of type 'LeaderAdvisoryCommit' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    LeaderMessageSequence& sequenceNumberCommitted();
    // Return a reference to the modifiable "SequenceNumberCommitted"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    const LeaderMessageSequence& sequenceNumberCommitted() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumberCommitted" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderAdvisoryCommit& lhs,
                           const LeaderAdvisoryCommit& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sequenceNumber() == rhs.sequenceNumber() &&
               lhs.sequenceNumberCommitted() == rhs.sequenceNumberCommitted();
    }

    friend bool operator!=(const LeaderAdvisoryCommit& lhs,
                           const LeaderAdvisoryCommit& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const LeaderAdvisoryCommit& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const LeaderAdvisoryCommit& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderAdvisoryCommit'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.sequenceNumber());
        hashAppend(hashAlg, object.sequenceNumberCommitted());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderAdvisoryCommit)

namespace bmqp_ctrlmsg {

// ==================================
// class LeaderSyncStateQueryResponse
// ==================================

class LeaderSyncStateQueryResponse {
    // This type represents a response to the 'LeaderSyncStateQuery' sent by
    // the follower to the leader.

    // INSTANCE DATA
    LeaderMessageSequence d_leaderMessageSequence;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    LeaderSyncStateQueryResponse();
    // Create an object of type 'LeaderSyncStateQueryResponse' having the
    // default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& leaderMessageSequence();
    // Return a reference to the modifiable "LeaderMessageSequence"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& leaderMessageSequence() const;
    // Return a reference offering non-modifiable access to the
    // "LeaderMessageSequence" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderSyncStateQueryResponse& lhs,
                           const LeaderSyncStateQueryResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.leaderMessageSequence() == rhs.leaderMessageSequence();
    }

    friend bool operator!=(const LeaderSyncStateQueryResponse& lhs,
                           const LeaderSyncStateQueryResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                       stream,
                                    const LeaderSyncStateQueryResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                   hashAlg,
                           const LeaderSyncStateQueryResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderSyncStateQueryResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.leaderMessageSequence());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderSyncStateQueryResponse)

namespace bmqp_ctrlmsg {

// ========================
// class NodeStatusAdvisory
// ========================

class NodeStatusAdvisory {
    // This type represents a one way message sent by a node to its peers
    // whenever its status changes, as it deemed by the node itself.

    // INSTANCE DATA
    NodeStatus::Value d_status;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_STATUS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_STATUS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    NodeStatusAdvisory();
    // Create an object of type 'NodeStatusAdvisory' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    NodeStatus::Value& status();
    // Return a reference to the modifiable "Status" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    NodeStatus::Value status() const;
    // Return the value of the "Status" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const NodeStatusAdvisory& lhs,
                           const NodeStatusAdvisory& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.status() == rhs.status();
    }

    friend bool operator!=(const NodeStatusAdvisory& lhs,
                           const NodeStatusAdvisory& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const NodeStatusAdvisory& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&         hashAlg,
                           const NodeStatusAdvisory& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'NodeStatusAdvisory'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.status());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::NodeStatusAdvisory)

namespace bmqp_ctrlmsg {

// ==============================
// class PartitionPrimaryAdvisory
// ==============================

class PartitionPrimaryAdvisory {
    // This type represents a one way message sent by the leader to all
    // followers with a mapping of partition -> primary node, and other
    // relevant infomration.

    // INSTANCE DATA
    bsl::vector<PartitionPrimaryInfo> d_partitions;
    LeaderMessageSequence             d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0, ATTRIBUTE_ID_PARTITIONS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0,
        ATTRIBUTE_INDEX_PARTITIONS      = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit PartitionPrimaryAdvisory(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PartitionPrimaryAdvisory' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    PartitionPrimaryAdvisory(const PartitionPrimaryAdvisory& original,
                             bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PartitionPrimaryAdvisory' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionPrimaryAdvisory(PartitionPrimaryAdvisory&& original) noexcept;
    // Create an object of type 'PartitionPrimaryAdvisory' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    PartitionPrimaryAdvisory(PartitionPrimaryAdvisory&& original,
                             bslma::Allocator*          basicAllocator);
    // Create an object of type 'PartitionPrimaryAdvisory' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~PartitionPrimaryAdvisory();
    // Destroy this object.

    // MANIPULATORS
    PartitionPrimaryAdvisory& operator=(const PartitionPrimaryAdvisory& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionPrimaryAdvisory& operator=(PartitionPrimaryAdvisory&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    bsl::vector<PartitionPrimaryInfo>& partitions();
    // Return a reference to the modifiable "Partitions" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    const bsl::vector<PartitionPrimaryInfo>& partitions() const;
    // Return a reference offering non-modifiable access to the
    // "Partitions" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionPrimaryAdvisory& lhs,
                           const PartitionPrimaryAdvisory& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sequenceNumber() == rhs.sequenceNumber() &&
               lhs.partitions() == rhs.partitions();
    }

    friend bool operator!=(const PartitionPrimaryAdvisory& lhs,
                           const PartitionPrimaryAdvisory& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                   stream,
                                    const PartitionPrimaryAdvisory& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&               hashAlg,
                           const PartitionPrimaryAdvisory& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionPrimaryAdvisory'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.sequenceNumber());
        hashAppend(hashAlg, object.partitions());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionPrimaryAdvisory)

namespace bmqp_ctrlmsg {

// =========================
// class PrimaryStateRequest
// =========================

class PrimaryStateRequest {
    // This type represents a request sent to the primary by a replica to ask
    // for primary's sequence number.  The replica also sends it own sequence
    // number as part of this request.
    // partitionId:    partition id for corresponding partition.
    // sequenceNumber: Replica's sequence number for corresponding partition.

    // INSTANCE DATA
    PartitionSequenceNumber d_sequenceNumber;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PrimaryStateRequest();
    // Create an object of type 'PrimaryStateRequest' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    PartitionSequenceNumber& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const PartitionSequenceNumber& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PrimaryStateRequest& lhs,
                           const PrimaryStateRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const PrimaryStateRequest& lhs,
                           const PrimaryStateRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const PrimaryStateRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const PrimaryStateRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PrimaryStateRequest'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.partitionId());
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PrimaryStateRequest)

namespace bmqp_ctrlmsg {

// ==========================
// class PrimaryStateResponse
// ==========================

class PrimaryStateResponse {
    // This type represents a response sent by a primary to the replica along
    // with its sequence number.
    // partitionId:    partition id for corresponding partition.
    // sequenceNumber: Primary's sequence number for corresponding partition.

    // INSTANCE DATA
    PartitionSequenceNumber d_sequenceNumber;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PrimaryStateResponse();
    // Create an object of type 'PrimaryStateResponse' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    PartitionSequenceNumber& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const PartitionSequenceNumber& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PrimaryStateResponse& lhs,
                           const PrimaryStateResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const PrimaryStateResponse& lhs,
                           const PrimaryStateResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const PrimaryStateResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const PrimaryStateResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PrimaryStateResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.partitionId());
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PrimaryStateResponse)

namespace bmqp_ctrlmsg {

// ===========================
// class PrimaryStatusAdvisory
// ===========================

class PrimaryStatusAdvisory {
    // This type represents a message sent by a primary node to the replicas
    // whenever primary's status changes.
    // partitionId..: The corresponding partitionId status.......: Status of
    // the query

    // INSTANCE DATA
    unsigned int         d_primaryLeaseId;
    int                  d_partitionId;
    PrimaryStatus::Value d_status;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID     = 0,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_ID_STATUS           = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID     = 0,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_INDEX_STATUS           = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const PrimaryStatus::Value DEFAULT_INITIALIZER_STATUS;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PrimaryStatusAdvisory();
    // Create an object of type 'PrimaryStatusAdvisory' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    PrimaryStatus::Value& status();
    // Return a reference to the modifiable "Status" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    PrimaryStatus::Value status() const;
    // Return the value of the "Status" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PrimaryStatusAdvisory& lhs,
                           const PrimaryStatusAdvisory& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.primaryLeaseId() == rhs.primaryLeaseId() &&
               lhs.status() == rhs.status();
    }

    friend bool operator!=(const PrimaryStatusAdvisory& lhs,
                           const PrimaryStatusAdvisory& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                stream,
                                    const PrimaryStatusAdvisory& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&            hashAlg,
                           const PrimaryStatusAdvisory& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PrimaryStatusAdvisory'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PrimaryStatusAdvisory)

namespace bmqp_ctrlmsg {

// ===========================
// class QueueHandleParameters
// ===========================

class QueueHandleParameters {
    // This complex type contains various parameters required by an upstream
    // node to create a queue handle for the requester.
    // uri........: URI of the queue to open qId........: id that will be used
    // to reference this queue subIdInfo..: Optional SubQueueId info,
    // applicable if requester is a fanout consumer flags......: flags to use
    // when opening the queue readCount..: the number of 'downstream' reader
    // clients aggregated in this open queue request writeCount.: the number of
    // 'downstream' writer clients aggregated in this open queue request
    // adminCount.: the number of 'downstream' admin clients aggregated in this
    // open queue request

    // INSTANCE DATA
    bsls::Types::Uint64                 d_flags;
    bsl::string                         d_uri;
    bdlb::NullableValue<SubQueueIdInfo> d_subIdInfo;
    unsigned int                        d_qId;
    int                                 d_readCount;
    int                                 d_writeCount;
    int                                 d_adminCount;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueHandleParameters& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_URI         = 0,
        ATTRIBUTE_ID_Q_ID        = 1,
        ATTRIBUTE_ID_SUB_ID_INFO = 2,
        ATTRIBUTE_ID_FLAGS       = 3,
        ATTRIBUTE_ID_READ_COUNT  = 4,
        ATTRIBUTE_ID_WRITE_COUNT = 5,
        ATTRIBUTE_ID_ADMIN_COUNT = 6
    };

    enum { NUM_ATTRIBUTES = 7 };

    enum {
        ATTRIBUTE_INDEX_URI         = 0,
        ATTRIBUTE_INDEX_Q_ID        = 1,
        ATTRIBUTE_INDEX_SUB_ID_INFO = 2,
        ATTRIBUTE_INDEX_FLAGS       = 3,
        ATTRIBUTE_INDEX_READ_COUNT  = 4,
        ATTRIBUTE_INDEX_WRITE_COUNT = 5,
        ATTRIBUTE_INDEX_ADMIN_COUNT = 6
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_READ_COUNT;

    static const int DEFAULT_INITIALIZER_WRITE_COUNT;

    static const int DEFAULT_INITIALIZER_ADMIN_COUNT;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueHandleParameters(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueHandleParameters' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    QueueHandleParameters(const QueueHandleParameters& original,
                          bslma::Allocator*            basicAllocator = 0);
    // Create an object of type 'QueueHandleParameters' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueHandleParameters(QueueHandleParameters&& original) noexcept;
    // Create an object of type 'QueueHandleParameters' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueHandleParameters(QueueHandleParameters&& original,
                          bslma::Allocator*       basicAllocator);
    // Create an object of type 'QueueHandleParameters' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueHandleParameters();
    // Destroy this object.

    // MANIPULATORS
    QueueHandleParameters& operator=(const QueueHandleParameters& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueHandleParameters& operator=(QueueHandleParameters&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& uri();
    // Return a reference to the modifiable "Uri" attribute of this object.

    unsigned int& qId();
    // Return a reference to the modifiable "QId" attribute of this object.

    bdlb::NullableValue<SubQueueIdInfo>& subIdInfo();
    // Return a reference to the modifiable "SubIdInfo" attribute of this
    // object.

    bsls::Types::Uint64& flags();
    // Return a reference to the modifiable "Flags" attribute of this
    // object.

    int& readCount();
    // Return a reference to the modifiable "ReadCount" attribute of this
    // object.

    int& writeCount();
    // Return a reference to the modifiable "WriteCount" attribute of this
    // object.

    int& adminCount();
    // Return a reference to the modifiable "AdminCount" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& uri() const;
    // Return a reference offering non-modifiable access to the "Uri"
    // attribute of this object.

    unsigned int qId() const;
    // Return the value of the "QId" attribute of this object.

    const bdlb::NullableValue<SubQueueIdInfo>& subIdInfo() const;
    // Return a reference offering non-modifiable access to the "SubIdInfo"
    // attribute of this object.

    bsls::Types::Uint64 flags() const;
    // Return the value of the "Flags" attribute of this object.

    int readCount() const;
    // Return the value of the "ReadCount" attribute of this object.

    int writeCount() const;
    // Return the value of the "WriteCount" attribute of this object.

    int adminCount() const;
    // Return the value of the "AdminCount" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueHandleParameters& lhs,
                           const QueueHandleParameters& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueHandleParameters& lhs,
                           const QueueHandleParameters& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                stream,
                                    const QueueHandleParameters& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&            hashAlg,
                           const QueueHandleParameters& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueHandleParameters'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueHandleParameters)

namespace bmqp_ctrlmsg {

// ===============
// class QueueInfo
// ===============

class QueueInfo {
    // This type represents a queue assignment, that is the key and partitionId
    // assigned to a given URI.

    // INSTANCE DATA
    bsl::vector<char>      d_key;
    bsl::vector<AppIdInfo> d_appIds;
    bsl::string            d_uri;
    int                    d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueInfo& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_URI          = 0,
        ATTRIBUTE_ID_KEY          = 1,
        ATTRIBUTE_ID_PARTITION_ID = 2,
        ATTRIBUTE_ID_APP_IDS      = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_URI          = 0,
        ATTRIBUTE_INDEX_KEY          = 1,
        ATTRIBUTE_INDEX_PARTITION_ID = 2,
        ATTRIBUTE_INDEX_APP_IDS      = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueInfo' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueInfo(const QueueInfo& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInfo(QueueInfo&& original) noexcept;
    // Create an object of type 'QueueInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueInfo(QueueInfo&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueInfo();
    // Destroy this object.

    // MANIPULATORS
    QueueInfo& operator=(const QueueInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInfo& operator=(QueueInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& uri();
    // Return a reference to the modifiable "Uri" attribute of this object.

    bsl::vector<char>& key();
    // Return a reference to the modifiable "Key" attribute of this object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    bsl::vector<AppIdInfo>& appIds();
    // Return a reference to the modifiable "AppIds" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& uri() const;
    // Return a reference offering non-modifiable access to the "Uri"
    // attribute of this object.

    const bsl::vector<char>& key() const;
    // Return a reference offering non-modifiable access to the "Key"
    // attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const bsl::vector<AppIdInfo>& appIds() const;
    // Return a reference offering non-modifiable access to the "AppIds"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueInfo& lhs, const QueueInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueInfo& lhs, const QueueInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const QueueInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const QueueInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'QueueInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueInfo)

namespace bmqp_ctrlmsg {

// =====================
// class QueueInfoUpdate
// =====================

class QueueInfoUpdate {
    // This type represents a queue update, that is the added or removed appIds
    // for a given URI.  In the case of (un)registering appIds for a domain
    // without any queues present, the 'domain' field will be populated whereas
    // the 'uri', 'key' and 'partitionId' will all be set to null/invalid.

    // INSTANCE DATA
    bsl::vector<char>      d_key;
    bsl::vector<AppIdInfo> d_addedAppIds;
    bsl::vector<AppIdInfo> d_removedAppIds;
    bsl::string            d_uri;
    bsl::string            d_domain;
    int                    d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueInfoUpdate& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_URI             = 0,
        ATTRIBUTE_ID_KEY             = 1,
        ATTRIBUTE_ID_PARTITION_ID    = 2,
        ATTRIBUTE_ID_ADDED_APP_IDS   = 3,
        ATTRIBUTE_ID_REMOVED_APP_IDS = 4,
        ATTRIBUTE_ID_DOMAIN          = 5
    };

    enum { NUM_ATTRIBUTES = 6 };

    enum {
        ATTRIBUTE_INDEX_URI             = 0,
        ATTRIBUTE_INDEX_KEY             = 1,
        ATTRIBUTE_INDEX_PARTITION_ID    = 2,
        ATTRIBUTE_INDEX_ADDED_APP_IDS   = 3,
        ATTRIBUTE_INDEX_REMOVED_APP_IDS = 4,
        ATTRIBUTE_INDEX_DOMAIN          = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueInfoUpdate(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueInfoUpdate' having the default value.
    //  Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueInfoUpdate(const QueueInfoUpdate& original,
                    bslma::Allocator*      basicAllocator = 0);
    // Create an object of type 'QueueInfoUpdate' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInfoUpdate(QueueInfoUpdate&& original) noexcept;
    // Create an object of type 'QueueInfoUpdate' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueInfoUpdate(QueueInfoUpdate&& original,
                    bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueInfoUpdate' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueInfoUpdate();
    // Destroy this object.

    // MANIPULATORS
    QueueInfoUpdate& operator=(const QueueInfoUpdate& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInfoUpdate& operator=(QueueInfoUpdate&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& uri();
    // Return a reference to the modifiable "Uri" attribute of this object.

    bsl::vector<char>& key();
    // Return a reference to the modifiable "Key" attribute of this object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    bsl::vector<AppIdInfo>& addedAppIds();
    // Return a reference to the modifiable "AddedAppIds" attribute of this
    // object.

    bsl::vector<AppIdInfo>& removedAppIds();
    // Return a reference to the modifiable "RemovedAppIds" attribute of
    // this object.

    bsl::string& domain();
    // Return a reference to the modifiable "Domain" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& uri() const;
    // Return a reference offering non-modifiable access to the "Uri"
    // attribute of this object.

    const bsl::vector<char>& key() const;
    // Return a reference offering non-modifiable access to the "Key"
    // attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const bsl::vector<AppIdInfo>& addedAppIds() const;
    // Return a reference offering non-modifiable access to the
    // "AddedAppIds" attribute of this object.

    const bsl::vector<AppIdInfo>& removedAppIds() const;
    // Return a reference offering non-modifiable access to the
    // "RemovedAppIds" attribute of this object.

    const bsl::string& domain() const;
    // Return a reference offering non-modifiable access to the "Domain"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueInfoUpdate& lhs,
                           const QueueInfoUpdate& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueInfoUpdate& lhs,
                           const QueueInfoUpdate& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&          stream,
                                    const QueueInfoUpdate& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&      hashAlg,
                           const QueueInfoUpdate& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueInfoUpdate'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueInfoUpdate)

namespace bmqp_ctrlmsg {

// ===========================
// class QueueStreamParameters
// ===========================

class QueueStreamParameters {
    // This complex type contains various parameters required by an upstream
    // node to configure a queue handle (i.e., a "stream") that has already
    // been created.
    // subIdInfo..............: Optional subQueueId identifying the stream in
    // case downstream node represents a fanout consumer
    // maxUnconfirmedMessages.: maximum number of outstanding delivered but
    // pending confirmation from the client maxUnconfirmedBytes....: maximum
    // cumulated bytes of all outstanding delivered but pending confirmation
    // messages from the client consumerPriority.......: priority as advertised
    // by the downstream node for this stream consumerPriorityCount..: weight
    // of the stream as advertised by the downstream node, having
    // above-mentioned consumer priority

    // INSTANCE DATA
    bsls::Types::Int64                  d_maxUnconfirmedMessages;
    bsls::Types::Int64                  d_maxUnconfirmedBytes;
    bdlb::NullableValue<SubQueueIdInfo> d_subIdInfo;
    int                                 d_consumerPriority;
    int                                 d_consumerPriorityCount;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueStreamParameters& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SUB_ID_INFO              = 0,
        ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES = 1,
        ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES    = 2,
        ATTRIBUTE_ID_CONSUMER_PRIORITY        = 3,
        ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT  = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_SUB_ID_INFO              = 0,
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES = 1,
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES    = 2,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY        = 3,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT  = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bsls::Types::Int64
        DEFAULT_INITIALIZER_MAX_UNCONFIRMED_MESSAGES;

    static const bsls::Types::Int64 DEFAULT_INITIALIZER_MAX_UNCONFIRMED_BYTES;

    static const int DEFAULT_INITIALIZER_CONSUMER_PRIORITY;

    static const int DEFAULT_INITIALIZER_CONSUMER_PRIORITY_COUNT;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueStreamParameters(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueStreamParameters' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    QueueStreamParameters(const QueueStreamParameters& original,
                          bslma::Allocator*            basicAllocator = 0);
    // Create an object of type 'QueueStreamParameters' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueStreamParameters(QueueStreamParameters&& original) noexcept;
    // Create an object of type 'QueueStreamParameters' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueStreamParameters(QueueStreamParameters&& original,
                          bslma::Allocator*       basicAllocator);
    // Create an object of type 'QueueStreamParameters' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueStreamParameters();
    // Destroy this object.

    // MANIPULATORS
    QueueStreamParameters& operator=(const QueueStreamParameters& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueStreamParameters& operator=(QueueStreamParameters&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bdlb::NullableValue<SubQueueIdInfo>& subIdInfo();
    // Return a reference to the modifiable "SubIdInfo" attribute of this
    // object.

    bsls::Types::Int64& maxUnconfirmedMessages();
    // Return a reference to the modifiable "MaxUnconfirmedMessages"
    // attribute of this object.

    bsls::Types::Int64& maxUnconfirmedBytes();
    // Return a reference to the modifiable "MaxUnconfirmedBytes" attribute
    // of this object.

    int& consumerPriority();
    // Return a reference to the modifiable "ConsumerPriority" attribute of
    // this object.

    int& consumerPriorityCount();
    // Return a reference to the modifiable "ConsumerPriorityCount"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bdlb::NullableValue<SubQueueIdInfo>& subIdInfo() const;
    // Return a reference offering non-modifiable access to the "SubIdInfo"
    // attribute of this object.

    bsls::Types::Int64 maxUnconfirmedMessages() const;
    // Return the value of the "MaxUnconfirmedMessages" attribute of this
    // object.

    bsls::Types::Int64 maxUnconfirmedBytes() const;
    // Return the value of the "MaxUnconfirmedBytes" attribute of this
    // object.

    int consumerPriority() const;
    // Return the value of the "ConsumerPriority" attribute of this object.

    int consumerPriorityCount() const;
    // Return the value of the "ConsumerPriorityCount" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueStreamParameters& lhs,
                           const QueueStreamParameters& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueStreamParameters& lhs,
                           const QueueStreamParameters& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                stream,
                                    const QueueStreamParameters& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&            hashAlg,
                           const QueueStreamParameters& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueStreamParameters'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueStreamParameters)

namespace bmqp_ctrlmsg {

// =========================
// class RegistrationRequest
// =========================

class RegistrationRequest {
    // This type represents a request sent by a follower to the leader to
    // register its leader-sequence number.
    // sequenceNumber..: Follower's leader-sequence number

    // INSTANCE DATA
    LeaderMessageSequence d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    RegistrationRequest();
    // Create an object of type 'RegistrationRequest' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RegistrationRequest& lhs,
                           const RegistrationRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const RegistrationRequest& lhs,
                           const RegistrationRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const RegistrationRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const RegistrationRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RegistrationRequest'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::RegistrationRequest)

namespace bmqp_ctrlmsg {

// ========================
// class ReplicaDataRequest
// ========================

class ReplicaDataRequest {
    // This type represents a request sent to the replica by the primary to
    // start the synchronization of data.
    // replicaDataType:     type of request i.e.  PULL, PUSH or DROP for
    // corresponding partition.  partitionId:         partition id for
    // corresponding partition.  beginSequenceNumber: Primary's begin sequence
    // number for corresponding partition for corresponding data chunks.
    // endSequenceNumber:   Primary's end sequence number for corresponding
    // partition for corresponding data chunks.

    // INSTANCE DATA
    PartitionSequenceNumber d_beginSequenceNumber;
    PartitionSequenceNumber d_endSequenceNumber;
    int                     d_partitionId;
    ReplicaDataType::Value  d_replicaDataType;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ReplicaDataRequest& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_REPLICA_DATA_TYPE     = 0,
        ATTRIBUTE_ID_PARTITION_ID          = 1,
        ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER = 2,
        ATTRIBUTE_ID_END_SEQUENCE_NUMBER   = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_REPLICA_DATA_TYPE     = 0,
        ATTRIBUTE_INDEX_PARTITION_ID          = 1,
        ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER = 2,
        ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER   = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ReplicaDataRequest();
    // Create an object of type 'ReplicaDataRequest' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ReplicaDataType::Value& replicaDataType();
    // Return a reference to the modifiable "ReplicaDataType" attribute of
    // this object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    PartitionSequenceNumber& beginSequenceNumber();
    // Return a reference to the modifiable "BeginSequenceNumber" attribute
    // of this object.

    PartitionSequenceNumber& endSequenceNumber();
    // Return a reference to the modifiable "EndSequenceNumber" attribute
    // of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    ReplicaDataType::Value replicaDataType() const;
    // Return the value of the "ReplicaDataType" attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const PartitionSequenceNumber& beginSequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "BeginSequenceNumber" attribute of this object.

    const PartitionSequenceNumber& endSequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "EndSequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ReplicaDataRequest& lhs,
                           const ReplicaDataRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ReplicaDataRequest& lhs,
                           const ReplicaDataRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const ReplicaDataRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&         hashAlg,
                           const ReplicaDataRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ReplicaDataRequest'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReplicaDataRequest)

namespace bmqp_ctrlmsg {

// =========================
// class ReplicaDataResponse
// =========================

class ReplicaDataResponse {
    // This type represents a response sent by a replica to the primary for the
    // data synchronization request received by it.
    // replicaDataType:     type of request received i.e.  PULL, PUSH or DROP
    // for corresponding partition.  Note, this field will be set as per the
    // request received and the primary purpose of sending this field back in
    // response is for debugging and sanity checking.  partitionId:
    // partition id for corresponding partition.  beginSequenceNumber:
    // Replica's begin sequence number for corresponding partition for
    // corresponding data chunks.  endSequenceNumber:   Replica's end sequence
    // number for corresponding partition for corresponding data chunks.

    // INSTANCE DATA
    PartitionSequenceNumber d_beginSequenceNumber;
    PartitionSequenceNumber d_endSequenceNumber;
    int                     d_partitionId;
    ReplicaDataType::Value  d_replicaDataType;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ReplicaDataResponse& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_REPLICA_DATA_TYPE     = 0,
        ATTRIBUTE_ID_PARTITION_ID          = 1,
        ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER = 2,
        ATTRIBUTE_ID_END_SEQUENCE_NUMBER   = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_REPLICA_DATA_TYPE     = 0,
        ATTRIBUTE_INDEX_PARTITION_ID          = 1,
        ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER = 2,
        ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER   = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ReplicaDataResponse();
    // Create an object of type 'ReplicaDataResponse' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ReplicaDataType::Value& replicaDataType();
    // Return a reference to the modifiable "ReplicaDataType" attribute of
    // this object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    PartitionSequenceNumber& beginSequenceNumber();
    // Return a reference to the modifiable "BeginSequenceNumber" attribute
    // of this object.

    PartitionSequenceNumber& endSequenceNumber();
    // Return a reference to the modifiable "EndSequenceNumber" attribute
    // of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    ReplicaDataType::Value replicaDataType() const;
    // Return the value of the "ReplicaDataType" attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const PartitionSequenceNumber& beginSequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "BeginSequenceNumber" attribute of this object.

    const PartitionSequenceNumber& endSequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "EndSequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ReplicaDataResponse& lhs,
                           const ReplicaDataResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ReplicaDataResponse& lhs,
                           const ReplicaDataResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const ReplicaDataResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const ReplicaDataResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ReplicaDataResponse'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReplicaDataResponse)

namespace bmqp_ctrlmsg {

// =========================
// class ReplicaStateRequest
// =========================

class ReplicaStateRequest {
    // This type represents a request sent to the replica by the primary to ask
    // for replica's sequence number.  The primary also sends its own sequence
    // number as part of this request.
    // partitionId:    partition id for corresponding partition.
    // sequenceNumber: Primary's sequence number for corresponding partition.

    // INSTANCE DATA
    PartitionSequenceNumber d_sequenceNumber;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ReplicaStateRequest();
    // Create an object of type 'ReplicaStateRequest' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    PartitionSequenceNumber& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const PartitionSequenceNumber& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ReplicaStateRequest& lhs,
                           const ReplicaStateRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const ReplicaStateRequest& lhs,
                           const ReplicaStateRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const ReplicaStateRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const ReplicaStateRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ReplicaStateRequest'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.partitionId());
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReplicaStateRequest)

namespace bmqp_ctrlmsg {

// ==========================
// class ReplicaStateResponse
// ==========================

class ReplicaStateResponse {
    // This type represents a response sent by a replica to the primary along
    // with its sequence number.
    // partitionId:    partition id for corresponding partition.
    // sequenceNumber: Replica's sequence number for corresponding partition.

    // INSTANCE DATA
    PartitionSequenceNumber d_sequenceNumber;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ReplicaStateResponse();
    // Create an object of type 'ReplicaStateResponse' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    PartitionSequenceNumber& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const PartitionSequenceNumber& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ReplicaStateResponse& lhs,
                           const ReplicaStateResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const ReplicaStateResponse& lhs,
                           const ReplicaStateResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const ReplicaStateResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const ReplicaStateResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ReplicaStateResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.partitionId());
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReplicaStateResponse)

namespace bmqp_ctrlmsg {

// =============================
// class StateNotificationChoice
// =============================

class StateNotificationChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<LeaderPassive> d_leaderPassive;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StateNotificationChoice& rhs) const;

  public:
    // TYPES

    enum { SELECTION_ID_UNDEFINED = -1, SELECTION_ID_LEADER_PASSIVE = 0 };

    enum { NUM_SELECTIONS = 1 };

    enum { SELECTION_INDEX_LEADER_PASSIVE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    StateNotificationChoice();
    // Create an object of type 'StateNotificationChoice' having the
    // default value.

    StateNotificationChoice(const StateNotificationChoice& original);
    // Create an object of type 'StateNotificationChoice' having the value
    // of the specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StateNotificationChoice(StateNotificationChoice&& original) noexcept;
    // Create an object of type 'StateNotificationChoice' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.
#endif

    ~StateNotificationChoice();
    // Destroy this object.

    // MANIPULATORS
    StateNotificationChoice& operator=(const StateNotificationChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StateNotificationChoice& operator=(StateNotificationChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    LeaderPassive& makeLeaderPassive();
    LeaderPassive& makeLeaderPassive(const LeaderPassive& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderPassive& makeLeaderPassive(LeaderPassive&& value);
#endif
    // Set the value of this object to be a "LeaderPassive" value.
    // Optionally specify the 'value' of the "LeaderPassive".  If 'value'
    // is not specified, the default "LeaderPassive" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    LeaderPassive& leaderPassive();
    // Return a reference to the modifiable "LeaderPassive" selection of
    // this object if "LeaderPassive" is the current selection.  The
    // behavior is undefined unless "LeaderPassive" is the selection of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const LeaderPassive& leaderPassive() const;
    // Return a reference to the non-modifiable "LeaderPassive" selection
    // of this object if "LeaderPassive" is the current selection.  The
    // behavior is undefined unless "LeaderPassive" is the selection of
    // this object.

    bool isLeaderPassiveValue() const;
    // Return 'true' if the value of this object is a "LeaderPassive"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StateNotificationChoice& lhs,
                           const StateNotificationChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'StateNotificationChoice' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StateNotificationChoice& lhs,
                           const StateNotificationChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                  stream,
                                    const StateNotificationChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&              hashAlg,
                           const StateNotificationChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StateNotificationChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StateNotificationChoice)

namespace bmqp_ctrlmsg {

// ============
// class Status
// ============

class Status {
    // Generic type to represent a status.
    // category.: the category of the status code.....: an integer value
    // representing the error message..: an optional string describing the
    // error

    // INSTANCE DATA
    bsl::string           d_message;
    int                   d_code;
    StatusCategory::Value d_category;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CATEGORY = 0,
        ATTRIBUTE_ID_CODE     = 1,
        ATTRIBUTE_ID_MESSAGE  = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_CATEGORY = 0,
        ATTRIBUTE_INDEX_CODE     = 1,
        ATTRIBUTE_INDEX_MESSAGE  = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const char DEFAULT_INITIALIZER_MESSAGE[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Status(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Status' having the default value.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Status(const Status& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Status' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Status(Status&& original) noexcept;
    // Create an object of type 'Status' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Status(Status&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Status' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Status();
    // Destroy this object.

    // MANIPULATORS
    Status& operator=(const Status& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Status& operator=(Status&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    StatusCategory::Value& category();
    // Return a reference to the modifiable "Category" attribute of this
    // object.

    int& code();
    // Return a reference to the modifiable "Code" attribute of this
    // object.

    bsl::string& message();
    // Return a reference to the modifiable "Message" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    StatusCategory::Value category() const;
    // Return the value of the "Category" attribute of this object.

    int code() const;
    // Return the value of the "Code" attribute of this object.

    const bsl::string& message() const;
    // Return a reference offering non-modifiable access to the "Message"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Status& lhs, const Status& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.category() == rhs.category() && lhs.code() == rhs.code() &&
               lhs.message() == rhs.message();
    }

    friend bool operator!=(const Status& lhs, const Status& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Status& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Status& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Status'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::Status)

namespace bmqp_ctrlmsg {

// =========================
// class StorageSyncResponse
// =========================

class StorageSyncResponse {
    // This type represents the message sent by the peer node in response to a
    // storage sync request.
    // partitionId..............: The corresponding partitionId
    // storageSyncResponseType..: Type of storage sync response (enumeration)
    // beginSyncPoint...........: Starting sync point of the sent storage
    // endSyncPoint.............: Ending sync point of the sent storage

    // INSTANCE DATA
    SyncPoint                      d_beginSyncPoint;
    SyncPoint                      d_endSyncPoint;
    int                            d_partitionId;
    StorageSyncResponseType::Value d_storageSyncResponseType;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StorageSyncResponse& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID               = 0,
        ATTRIBUTE_ID_STORAGE_SYNC_RESPONSE_TYPE = 1,
        ATTRIBUTE_ID_BEGIN_SYNC_POINT           = 2,
        ATTRIBUTE_ID_END_SYNC_POINT             = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID               = 0,
        ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE = 1,
        ATTRIBUTE_INDEX_BEGIN_SYNC_POINT           = 2,
        ATTRIBUTE_INDEX_END_SYNC_POINT             = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    StorageSyncResponse();
    // Create an object of type 'StorageSyncResponse' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    StorageSyncResponseType::Value& storageSyncResponseType();
    // Return a reference to the modifiable "StorageSyncResponseType"
    // attribute of this object.

    SyncPoint& beginSyncPoint();
    // Return a reference to the modifiable "BeginSyncPoint" attribute of
    // this object.

    SyncPoint& endSyncPoint();
    // Return a reference to the modifiable "EndSyncPoint" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    StorageSyncResponseType::Value storageSyncResponseType() const;
    // Return the value of the "StorageSyncResponseType" attribute of this
    // object.

    const SyncPoint& beginSyncPoint() const;
    // Return a reference offering non-modifiable access to the
    // "BeginSyncPoint" attribute of this object.

    const SyncPoint& endSyncPoint() const;
    // Return a reference offering non-modifiable access to the
    // "EndSyncPoint" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageSyncResponse& lhs,
                           const StorageSyncResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StorageSyncResponse& lhs,
                           const StorageSyncResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const StorageSyncResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const StorageSyncResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageSyncResponse'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StorageSyncResponse)

namespace bmqp_ctrlmsg {

// =========================
// class SyncPointOffsetPair
// =========================

class SyncPointOffsetPair {
    // A pair of SyncPt and the offset in the journal where that SyncPt
    // appears.  Note that in future, we may introduce a journal-offset field
    // in the SyncPt itself, but that could be different from the offset of
    // SyncPt itself.

    // INSTANCE DATA
    bsls::Types::Uint64 d_offset;
    SyncPoint           d_syncPoint;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SYNC_POINT = 0, ATTRIBUTE_ID_OFFSET = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SYNC_POINT = 0, ATTRIBUTE_INDEX_OFFSET = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    SyncPointOffsetPair();
    // Create an object of type 'SyncPointOffsetPair' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    SyncPoint& syncPoint();
    // Return a reference to the modifiable "SyncPoint" attribute of this
    // object.

    bsls::Types::Uint64& offset();
    // Return a reference to the modifiable "Offset" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const SyncPoint& syncPoint() const;
    // Return a reference offering non-modifiable access to the "SyncPoint"
    // attribute of this object.

    bsls::Types::Uint64 offset() const;
    // Return the value of the "Offset" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const SyncPointOffsetPair& lhs,
                           const SyncPointOffsetPair& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.syncPoint() == rhs.syncPoint() &&
               lhs.offset() == rhs.offset();
    }

    friend bool operator!=(const SyncPointOffsetPair& lhs,
                           const SyncPointOffsetPair& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const SyncPointOffsetPair& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const SyncPointOffsetPair& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'SyncPointOffsetPair'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.syncPoint());
        hashAppend(hashAlg, object.offset());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::SyncPointOffsetPair)

namespace bmqp_ctrlmsg {

// ====================
// class BrokerResponse
// ====================

class BrokerResponse {
    // This represents the response from the broker to a 'ClientIdentity'
    // message during connection negotiation.
    // result..........: the result of the negotiation protocolVersion.:
    // protocol version used by the bmqbrkr brokerVersion...: version of the
    // broker isDeprecatedSdk.: is the version of the client's SDK version
    // deprecated

    // INSTANCE DATA
    Status         d_result;
    ClientIdentity d_brokerIdentity;
    int            d_protocolVersion;
    int            d_brokerVersion;
    bool           d_isDeprecatedSdk;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const BrokerResponse& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_RESULT            = 0,
        ATTRIBUTE_ID_PROTOCOL_VERSION  = 1,
        ATTRIBUTE_ID_BROKER_VERSION    = 2,
        ATTRIBUTE_ID_IS_DEPRECATED_SDK = 3,
        ATTRIBUTE_ID_BROKER_IDENTITY   = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_RESULT            = 0,
        ATTRIBUTE_INDEX_PROTOCOL_VERSION  = 1,
        ATTRIBUTE_INDEX_BROKER_VERSION    = 2,
        ATTRIBUTE_INDEX_IS_DEPRECATED_SDK = 3,
        ATTRIBUTE_INDEX_BROKER_IDENTITY   = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bool DEFAULT_INITIALIZER_IS_DEPRECATED_SDK;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit BrokerResponse(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'BrokerResponse' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    BrokerResponse(const BrokerResponse& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'BrokerResponse' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerResponse(BrokerResponse&& original) noexcept;
    // Create an object of type 'BrokerResponse' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    BrokerResponse(BrokerResponse&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'BrokerResponse' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~BrokerResponse();
    // Destroy this object.

    // MANIPULATORS
    BrokerResponse& operator=(const BrokerResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerResponse& operator=(BrokerResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    Status& result();
    // Return a reference to the modifiable "Result" attribute of this
    // object.

    int& protocolVersion();
    // Return a reference to the modifiable "ProtocolVersion" attribute of
    // this object.

    int& brokerVersion();
    // Return a reference to the modifiable "BrokerVersion" attribute of
    // this object.

    bool& isDeprecatedSdk();
    // Return a reference to the modifiable "IsDeprecatedSdk" attribute of
    // this object.

    ClientIdentity& brokerIdentity();
    // Return a reference to the modifiable "BrokerIdentity" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const Status& result() const;
    // Return a reference offering non-modifiable access to the "Result"
    // attribute of this object.

    int protocolVersion() const;
    // Return the value of the "ProtocolVersion" attribute of this object.

    int brokerVersion() const;
    // Return the value of the "BrokerVersion" attribute of this object.

    bool isDeprecatedSdk() const;
    // Return the value of the "IsDeprecatedSdk" attribute of this object.

    const ClientIdentity& brokerIdentity() const;
    // Return a reference offering non-modifiable access to the
    // "BrokerIdentity" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const BrokerResponse& lhs,
                           const BrokerResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const BrokerResponse& lhs,
                           const BrokerResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const BrokerResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const BrokerResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'BrokerResponse'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::BrokerResponse)

namespace bmqp_ctrlmsg {

// ================
// class CloseQueue
// ================

class CloseQueue {
    // This request contains parameters advertised by the downstream node when
    // it wants to close a queue on an upstream node.
    // handleParameters.: Queue handle parameters as advertised by the
    // downstream node isFinal..........: Flag advertising if downstream node
    // has no more clients for this queue, and upstream node is free to delete
    // the queue handle representing the downstream node

    // INSTANCE DATA
    QueueHandleParameters d_handleParameters;
    bool                  d_isFinal;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_HANDLE_PARAMETERS = 0, ATTRIBUTE_ID_IS_FINAL = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_HANDLE_PARAMETERS = 0,
        ATTRIBUTE_INDEX_IS_FINAL          = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bool DEFAULT_INITIALIZER_IS_FINAL;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit CloseQueue(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'CloseQueue' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    CloseQueue(const CloseQueue& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'CloseQueue' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CloseQueue(CloseQueue&& original) noexcept;
    // Create an object of type 'CloseQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    CloseQueue(CloseQueue&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'CloseQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~CloseQueue();
    // Destroy this object.

    // MANIPULATORS
    CloseQueue& operator=(const CloseQueue& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CloseQueue& operator=(CloseQueue&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    QueueHandleParameters& handleParameters();
    // Return a reference to the modifiable "HandleParameters" attribute of
    // this object.

    bool& isFinal();
    // Return a reference to the modifiable "IsFinal" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const QueueHandleParameters& handleParameters() const;
    // Return a reference offering non-modifiable access to the
    // "HandleParameters" attribute of this object.

    bool isFinal() const;
    // Return the value of the "IsFinal" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const CloseQueue& lhs, const CloseQueue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.handleParameters() == rhs.handleParameters() &&
               lhs.isFinal() == rhs.isFinal();
    }

    friend bool operator!=(const CloseQueue& lhs, const CloseQueue& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const CloseQueue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const CloseQueue& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'CloseQueue'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.handleParameters());
        hashAppend(hashAlg, object.isFinal());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::CloseQueue)

namespace bmqp_ctrlmsg {

// ==========================
// class ConfigureQueueStream
// ==========================

class ConfigureQueueStream {
    // This request contains parameters advertised by the downstream node so
    // that upstream node can configure the stream associated with the
    // downstream node.
    // qId..............: Id identifying the queue streamParameters.:
    // Parameters for configuring the stream

    // INSTANCE DATA
    QueueStreamParameters d_streamParameters;
    unsigned int          d_qId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_Q_ID = 0, ATTRIBUTE_ID_STREAM_PARAMETERS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_Q_ID = 0, ATTRIBUTE_INDEX_STREAM_PARAMETERS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ConfigureQueueStream(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ConfigureQueueStream' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ConfigureQueueStream(const ConfigureQueueStream& original,
                         bslma::Allocator*           basicAllocator = 0);
    // Create an object of type 'ConfigureQueueStream' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureQueueStream(ConfigureQueueStream&& original) noexcept;
    // Create an object of type 'ConfigureQueueStream' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ConfigureQueueStream(ConfigureQueueStream&& original,
                         bslma::Allocator*      basicAllocator);
    // Create an object of type 'ConfigureQueueStream' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ConfigureQueueStream();
    // Destroy this object.

    // MANIPULATORS
    ConfigureQueueStream& operator=(const ConfigureQueueStream& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureQueueStream& operator=(ConfigureQueueStream&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& qId();
    // Return a reference to the modifiable "QId" attribute of this object.

    QueueStreamParameters& streamParameters();
    // Return a reference to the modifiable "StreamParameters" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int qId() const;
    // Return the value of the "QId" attribute of this object.

    const QueueStreamParameters& streamParameters() const;
    // Return a reference offering non-modifiable access to the
    // "StreamParameters" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ConfigureQueueStream& lhs,
                           const ConfigureQueueStream& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.qId() == rhs.qId() &&
               lhs.streamParameters() == rhs.streamParameters();
    }

    friend bool operator!=(const ConfigureQueueStream& lhs,
                           const ConfigureQueueStream& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const ConfigureQueueStream& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const ConfigureQueueStream& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ConfigureQueueStream'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.qId());
        hashAppend(hashAlg, object.streamParameters());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ConfigureQueueStream)

namespace bmqp_ctrlmsg {

// ====================
// class ElectorMessage
// ====================

class ElectorMessage {
    // This type is the top level type for any message being sent by elector
    // component in the cluster.
    // term....: Term being proposed in the election choice..: Enumerates all
    // the different types of elector messages

    // INSTANCE DATA
    bsls::Types::Uint64  d_term;
    ElectorMessageChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_TERM = 0, ATTRIBUTE_ID_CHOICE = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_TERM = 0, ATTRIBUTE_INDEX_CHOICE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ElectorMessage();
    // Create an object of type 'ElectorMessage' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Uint64& term();
    // Return a reference to the modifiable "Term" attribute of this
    // object.

    ElectorMessageChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Uint64 term() const;
    // Return the value of the "Term" attribute of this object.

    const ElectorMessageChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ElectorMessage& lhs,
                           const ElectorMessage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.term() == rhs.term() && lhs.choice() == rhs.choice();
    }

    friend bool operator!=(const ElectorMessage& lhs,
                           const ElectorMessage& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const ElectorMessage& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const ElectorMessage& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ElectorMessage'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.term());
        hashAppend(hashAlg, object.choice());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ElectorMessage)

namespace bmqp_ctrlmsg {

// ====================
// class LeaderAdvisory
// ====================

class LeaderAdvisory {
    // This type represents a one way message sent by the leader to all
    // followers about partition/primary and queue info mappings.

    // INSTANCE DATA
    bsl::vector<QueueInfo>            d_queues;
    bsl::vector<PartitionPrimaryInfo> d_partitions;
    LeaderMessageSequence             d_sequenceNumber;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SEQUENCE_NUMBER = 0,
        ATTRIBUTE_ID_PARTITIONS      = 1,
        ATTRIBUTE_ID_QUEUES          = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0,
        ATTRIBUTE_INDEX_PARTITIONS      = 1,
        ATTRIBUTE_INDEX_QUEUES          = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit LeaderAdvisory(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'LeaderAdvisory' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    LeaderAdvisory(const LeaderAdvisory& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'LeaderAdvisory' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderAdvisory(LeaderAdvisory&& original) noexcept;
    // Create an object of type 'LeaderAdvisory' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    LeaderAdvisory(LeaderAdvisory&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'LeaderAdvisory' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~LeaderAdvisory();
    // Destroy this object.

    // MANIPULATORS
    LeaderAdvisory& operator=(const LeaderAdvisory& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderAdvisory& operator=(LeaderAdvisory&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    bsl::vector<PartitionPrimaryInfo>& partitions();
    // Return a reference to the modifiable "Partitions" attribute of this
    // object.

    bsl::vector<QueueInfo>& queues();
    // Return a reference to the modifiable "Queues" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    const bsl::vector<PartitionPrimaryInfo>& partitions() const;
    // Return a reference offering non-modifiable access to the
    // "Partitions" attribute of this object.

    const bsl::vector<QueueInfo>& queues() const;
    // Return a reference offering non-modifiable access to the "Queues"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderAdvisory& lhs,
                           const LeaderAdvisory& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sequenceNumber() == rhs.sequenceNumber() &&
               lhs.partitions() == rhs.partitions() &&
               lhs.queues() == rhs.queues();
    }

    friend bool operator!=(const LeaderAdvisory& lhs,
                           const LeaderAdvisory& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const LeaderAdvisory& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const LeaderAdvisory& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderAdvisory'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderAdvisory)

namespace bmqp_ctrlmsg {

// ===============
// class OpenQueue
// ===============

class OpenQueue {
    // This request is an indication that the client wants to open a queue, and
    // the upstream node should create a queue handle for the requester.
    // handleParameters.: Parameters for the queue handle to be created

    // INSTANCE DATA
    QueueHandleParameters d_handleParameters;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_HANDLE_PARAMETERS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_HANDLE_PARAMETERS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit OpenQueue(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'OpenQueue' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    OpenQueue(const OpenQueue& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'OpenQueue' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    OpenQueue(OpenQueue&& original) noexcept;
    // Create an object of type 'OpenQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    OpenQueue(OpenQueue&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'OpenQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~OpenQueue();
    // Destroy this object.

    // MANIPULATORS
    OpenQueue& operator=(const OpenQueue& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    OpenQueue& operator=(OpenQueue&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    QueueHandleParameters& handleParameters();
    // Return a reference to the modifiable "HandleParameters" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const QueueHandleParameters& handleParameters() const;
    // Return a reference offering non-modifiable access to the
    // "HandleParameters" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const OpenQueue& lhs, const OpenQueue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.handleParameters() == rhs.handleParameters();
    }

    friend bool operator!=(const OpenQueue& lhs, const OpenQueue& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const OpenQueue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const OpenQueue& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'OpenQueue'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.handleParameters());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::OpenQueue)

namespace bmqp_ctrlmsg {

// ============================
// class PartitionMessageChoice
// ============================

class PartitionMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ReplicaStateRequest>  d_replicaStateRequest;
        bsls::ObjectBuffer<ReplicaStateResponse> d_replicaStateResponse;
        bsls::ObjectBuffer<PrimaryStateRequest>  d_primaryStateRequest;
        bsls::ObjectBuffer<PrimaryStateResponse> d_primaryStateResponse;
        bsls::ObjectBuffer<ReplicaDataRequest>   d_replicaDataRequest;
        bsls::ObjectBuffer<ReplicaDataResponse>  d_replicaDataResponse;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const PartitionMessageChoice& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED              = -1,
        SELECTION_ID_REPLICA_STATE_REQUEST  = 0,
        SELECTION_ID_REPLICA_STATE_RESPONSE = 1,
        SELECTION_ID_PRIMARY_STATE_REQUEST  = 2,
        SELECTION_ID_PRIMARY_STATE_RESPONSE = 3,
        SELECTION_ID_REPLICA_DATA_REQUEST   = 4,
        SELECTION_ID_REPLICA_DATA_RESPONSE  = 5
    };

    enum { NUM_SELECTIONS = 6 };

    enum {
        SELECTION_INDEX_REPLICA_STATE_REQUEST  = 0,
        SELECTION_INDEX_REPLICA_STATE_RESPONSE = 1,
        SELECTION_INDEX_PRIMARY_STATE_REQUEST  = 2,
        SELECTION_INDEX_PRIMARY_STATE_RESPONSE = 3,
        SELECTION_INDEX_REPLICA_DATA_REQUEST   = 4,
        SELECTION_INDEX_REPLICA_DATA_RESPONSE  = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    PartitionMessageChoice();
    // Create an object of type 'PartitionMessageChoice' having the default
    // value.

    PartitionMessageChoice(const PartitionMessageChoice& original);
    // Create an object of type 'PartitionMessageChoice' having the value
    // of the specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionMessageChoice(PartitionMessageChoice&& original) noexcept;
    // Create an object of type 'PartitionMessageChoice' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.
#endif

    ~PartitionMessageChoice();
    // Destroy this object.

    // MANIPULATORS
    PartitionMessageChoice& operator=(const PartitionMessageChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionMessageChoice& operator=(PartitionMessageChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    ReplicaStateRequest& makeReplicaStateRequest();
    ReplicaStateRequest&
    makeReplicaStateRequest(const ReplicaStateRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicaStateRequest& makeReplicaStateRequest(ReplicaStateRequest&& value);
#endif
    // Set the value of this object to be a "ReplicaStateRequest" value.
    // Optionally specify the 'value' of the "ReplicaStateRequest".  If
    // 'value' is not specified, the default "ReplicaStateRequest" value is
    // used.

    ReplicaStateResponse& makeReplicaStateResponse();
    ReplicaStateResponse&
    makeReplicaStateResponse(const ReplicaStateResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicaStateResponse&
    makeReplicaStateResponse(ReplicaStateResponse&& value);
#endif
    // Set the value of this object to be a "ReplicaStateResponse" value.
    // Optionally specify the 'value' of the "ReplicaStateResponse".  If
    // 'value' is not specified, the default "ReplicaStateResponse" value
    // is used.

    PrimaryStateRequest& makePrimaryStateRequest();
    PrimaryStateRequest&
    makePrimaryStateRequest(const PrimaryStateRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PrimaryStateRequest& makePrimaryStateRequest(PrimaryStateRequest&& value);
#endif
    // Set the value of this object to be a "PrimaryStateRequest" value.
    // Optionally specify the 'value' of the "PrimaryStateRequest".  If
    // 'value' is not specified, the default "PrimaryStateRequest" value is
    // used.

    PrimaryStateResponse& makePrimaryStateResponse();
    PrimaryStateResponse&
    makePrimaryStateResponse(const PrimaryStateResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PrimaryStateResponse&
    makePrimaryStateResponse(PrimaryStateResponse&& value);
#endif
    // Set the value of this object to be a "PrimaryStateResponse" value.
    // Optionally specify the 'value' of the "PrimaryStateResponse".  If
    // 'value' is not specified, the default "PrimaryStateResponse" value
    // is used.

    ReplicaDataRequest& makeReplicaDataRequest();
    ReplicaDataRequest&
    makeReplicaDataRequest(const ReplicaDataRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicaDataRequest& makeReplicaDataRequest(ReplicaDataRequest&& value);
#endif
    // Set the value of this object to be a "ReplicaDataRequest" value.
    // Optionally specify the 'value' of the "ReplicaDataRequest".  If
    // 'value' is not specified, the default "ReplicaDataRequest" value is
    // used.

    ReplicaDataResponse& makeReplicaDataResponse();
    ReplicaDataResponse&
    makeReplicaDataResponse(const ReplicaDataResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicaDataResponse& makeReplicaDataResponse(ReplicaDataResponse&& value);
#endif
    // Set the value of this object to be a "ReplicaDataResponse" value.
    // Optionally specify the 'value' of the "ReplicaDataResponse".  If
    // 'value' is not specified, the default "ReplicaDataResponse" value is
    // used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    ReplicaStateRequest& replicaStateRequest();
    // Return a reference to the modifiable "ReplicaStateRequest" selection
    // of this object if "ReplicaStateRequest" is the current selection.
    // The behavior is undefined unless "ReplicaStateRequest" is the
    // selection of this object.

    ReplicaStateResponse& replicaStateResponse();
    // Return a reference to the modifiable "ReplicaStateResponse"
    // selection of this object if "ReplicaStateResponse" is the current
    // selection.  The behavior is undefined unless "ReplicaStateResponse"
    // is the selection of this object.

    PrimaryStateRequest& primaryStateRequest();
    // Return a reference to the modifiable "PrimaryStateRequest" selection
    // of this object if "PrimaryStateRequest" is the current selection.
    // The behavior is undefined unless "PrimaryStateRequest" is the
    // selection of this object.

    PrimaryStateResponse& primaryStateResponse();
    // Return a reference to the modifiable "PrimaryStateResponse"
    // selection of this object if "PrimaryStateResponse" is the current
    // selection.  The behavior is undefined unless "PrimaryStateResponse"
    // is the selection of this object.

    ReplicaDataRequest& replicaDataRequest();
    // Return a reference to the modifiable "ReplicaDataRequest" selection
    // of this object if "ReplicaDataRequest" is the current selection.
    // The behavior is undefined unless "ReplicaDataRequest" is the
    // selection of this object.

    ReplicaDataResponse& replicaDataResponse();
    // Return a reference to the modifiable "ReplicaDataResponse" selection
    // of this object if "ReplicaDataResponse" is the current selection.
    // The behavior is undefined unless "ReplicaDataResponse" is the
    // selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const ReplicaStateRequest& replicaStateRequest() const;
    // Return a reference to the non-modifiable "ReplicaStateRequest"
    // selection of this object if "ReplicaStateRequest" is the current
    // selection.  The behavior is undefined unless "ReplicaStateRequest"
    // is the selection of this object.

    const ReplicaStateResponse& replicaStateResponse() const;
    // Return a reference to the non-modifiable "ReplicaStateResponse"
    // selection of this object if "ReplicaStateResponse" is the current
    // selection.  The behavior is undefined unless "ReplicaStateResponse"
    // is the selection of this object.

    const PrimaryStateRequest& primaryStateRequest() const;
    // Return a reference to the non-modifiable "PrimaryStateRequest"
    // selection of this object if "PrimaryStateRequest" is the current
    // selection.  The behavior is undefined unless "PrimaryStateRequest"
    // is the selection of this object.

    const PrimaryStateResponse& primaryStateResponse() const;
    // Return a reference to the non-modifiable "PrimaryStateResponse"
    // selection of this object if "PrimaryStateResponse" is the current
    // selection.  The behavior is undefined unless "PrimaryStateResponse"
    // is the selection of this object.

    const ReplicaDataRequest& replicaDataRequest() const;
    // Return a reference to the non-modifiable "ReplicaDataRequest"
    // selection of this object if "ReplicaDataRequest" is the current
    // selection.  The behavior is undefined unless "ReplicaDataRequest" is
    // the selection of this object.

    const ReplicaDataResponse& replicaDataResponse() const;
    // Return a reference to the non-modifiable "ReplicaDataResponse"
    // selection of this object if "ReplicaDataResponse" is the current
    // selection.  The behavior is undefined unless "ReplicaDataResponse"
    // is the selection of this object.

    bool isReplicaStateRequestValue() const;
    // Return 'true' if the value of this object is a "ReplicaStateRequest"
    // value, and return 'false' otherwise.

    bool isReplicaStateResponseValue() const;
    // Return 'true' if the value of this object is a
    // "ReplicaStateResponse" value, and return 'false' otherwise.

    bool isPrimaryStateRequestValue() const;
    // Return 'true' if the value of this object is a "PrimaryStateRequest"
    // value, and return 'false' otherwise.

    bool isPrimaryStateResponseValue() const;
    // Return 'true' if the value of this object is a
    // "PrimaryStateResponse" value, and return 'false' otherwise.

    bool isReplicaDataRequestValue() const;
    // Return 'true' if the value of this object is a "ReplicaDataRequest"
    // value, and return 'false' otherwise.

    bool isReplicaDataResponseValue() const;
    // Return 'true' if the value of this object is a "ReplicaDataResponse"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionMessageChoice& lhs,
                           const PartitionMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'PartitionMessageChoice' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const PartitionMessageChoice& lhs,
                           const PartitionMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                 stream,
                                    const PartitionMessageChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&             hashAlg,
                           const PartitionMessageChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionMessageChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionMessageChoice)

namespace bmqp_ctrlmsg {

// ============================
// class PartitionSyncDataQuery
// ============================

class PartitionSyncDataQuery {
    // This type represents a request sent by a new primary node to one of the
    // AVAILABLE peers to asking for syncing the partition.
    // partitionId....: The corresponding partitionId lastSyncPoint..: Last
    // sync point of the requester for this partition.

    // INSTANCE DATA
    bsls::Types::Uint64 d_lastSequenceNum;
    bsls::Types::Uint64 d_uptoSequenceNum;
    SyncPointOffsetPair d_lastSyncPointOffsetPair;
    unsigned int        d_lastPrimaryLeaseId;
    unsigned int        d_uptoPrimaryLeaseId;
    int                 d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const PartitionSyncDataQuery& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID                = 0,
        ATTRIBUTE_ID_LAST_PRIMARY_LEASE_ID       = 1,
        ATTRIBUTE_ID_LAST_SEQUENCE_NUM           = 2,
        ATTRIBUTE_ID_UPTO_PRIMARY_LEASE_ID       = 3,
        ATTRIBUTE_ID_UPTO_SEQUENCE_NUM           = 4,
        ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR = 5
    };

    enum { NUM_ATTRIBUTES = 6 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID                = 0,
        ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID       = 1,
        ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM           = 2,
        ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID       = 3,
        ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM           = 4,
        ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PartitionSyncDataQuery();
    // Create an object of type 'PartitionSyncDataQuery' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    unsigned int& lastPrimaryLeaseId();
    // Return a reference to the modifiable "LastPrimaryLeaseId" attribute
    // of this object.

    bsls::Types::Uint64& lastSequenceNum();
    // Return a reference to the modifiable "LastSequenceNum" attribute of
    // this object.

    unsigned int& uptoPrimaryLeaseId();
    // Return a reference to the modifiable "UptoPrimaryLeaseId" attribute
    // of this object.

    bsls::Types::Uint64& uptoSequenceNum();
    // Return a reference to the modifiable "UptoSequenceNum" attribute of
    // this object.

    SyncPointOffsetPair& lastSyncPointOffsetPair();
    // Return a reference to the modifiable "LastSyncPointOffsetPair"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    unsigned int lastPrimaryLeaseId() const;
    // Return the value of the "LastPrimaryLeaseId" attribute of this
    // object.

    bsls::Types::Uint64 lastSequenceNum() const;
    // Return the value of the "LastSequenceNum" attribute of this object.

    unsigned int uptoPrimaryLeaseId() const;
    // Return the value of the "UptoPrimaryLeaseId" attribute of this
    // object.

    bsls::Types::Uint64 uptoSequenceNum() const;
    // Return the value of the "UptoSequenceNum" attribute of this object.

    const SyncPointOffsetPair& lastSyncPointOffsetPair() const;
    // Return a reference offering non-modifiable access to the
    // "LastSyncPointOffsetPair" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionSyncDataQuery& lhs,
                           const PartitionSyncDataQuery& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const PartitionSyncDataQuery& lhs,
                           const PartitionSyncDataQuery& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                 stream,
                                    const PartitionSyncDataQuery& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&             hashAlg,
                           const PartitionSyncDataQuery& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionSyncDataQuery'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncDataQuery)

namespace bmqp_ctrlmsg {

// ==================================
// class PartitionSyncDataQueryStatus
// ==================================

class PartitionSyncDataQueryStatus {
    // This type represents a message sent by a peer node to the new primary
    // after it is finished sending partition sync data.  This message
    // indicates to the new primary node that partition sync from peer is
    // complete (with appropriate success/failure status indicated in this
    // message).
    // partitionId..: The corresponding partitionId status.......: Status of
    // the query

    // INSTANCE DATA
    Status d_status;
    int    d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_STATUS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_PARTITION_ID = 0, ATTRIBUTE_INDEX_STATUS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit PartitionSyncDataQueryStatus(
        bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PartitionSyncDataQueryStatus' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    PartitionSyncDataQueryStatus(const PartitionSyncDataQueryStatus& original,
                                 bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PartitionSyncDataQueryStatus' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncDataQueryStatus(
        PartitionSyncDataQueryStatus&& original) noexcept;
    // Create an object of type 'PartitionSyncDataQueryStatus' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    PartitionSyncDataQueryStatus(PartitionSyncDataQueryStatus&& original,
                                 bslma::Allocator* basicAllocator);
    // Create an object of type 'PartitionSyncDataQueryStatus' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~PartitionSyncDataQueryStatus();
    // Destroy this object.

    // MANIPULATORS
    PartitionSyncDataQueryStatus&
    operator=(const PartitionSyncDataQueryStatus& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncDataQueryStatus&
    operator=(PartitionSyncDataQueryStatus&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    Status& status();
    // Return a reference to the modifiable "Status" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const Status& status() const;
    // Return a reference offering non-modifiable access to the "Status"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionSyncDataQueryStatus& lhs,
                           const PartitionSyncDataQueryStatus& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.status() == rhs.status();
    }

    friend bool operator!=(const PartitionSyncDataQueryStatus& lhs,
                           const PartitionSyncDataQueryStatus& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                       stream,
                                    const PartitionSyncDataQueryStatus& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                   hashAlg,
                           const PartitionSyncDataQueryStatus& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionSyncDataQueryStatus'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.partitionId());
        hashAppend(hashAlg, object.status());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncDataQueryStatus)

namespace bmqp_ctrlmsg {

// =====================================
// class PartitionSyncStateQueryResponse
// =====================================

class PartitionSyncStateQueryResponse {
    // This type represents a message sent by a peer node in response to
    // PartitionSyncStateQueryQuery.
    // partitionId....: The corresponding partitionId primaryLeaseId.: Peer's
    // partition's primary leaseId sequenceNum....: Peer's partition's sequence
    // number lastSyncPoint..: Last sync point for this partition

    // INSTANCE DATA
    bsls::Types::Uint64 d_sequenceNum;
    SyncPointOffsetPair d_lastSyncPointOffsetPair;
    unsigned int        d_primaryLeaseId;
    int                 d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const PartitionSyncStateQueryResponse& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID                = 0,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID            = 1,
        ATTRIBUTE_ID_SEQUENCE_NUM                = 2,
        ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID                = 0,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID            = 1,
        ATTRIBUTE_INDEX_SEQUENCE_NUM                = 2,
        ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PartitionSyncStateQueryResponse();
    // Create an object of type 'PartitionSyncStateQueryResponse' having
    // the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    bsls::Types::Uint64& sequenceNum();
    // Return a reference to the modifiable "SequenceNum" attribute of this
    // object.

    SyncPointOffsetPair& lastSyncPointOffsetPair();
    // Return a reference to the modifiable "LastSyncPointOffsetPair"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    bsls::Types::Uint64 sequenceNum() const;
    // Return the value of the "SequenceNum" attribute of this object.

    const SyncPointOffsetPair& lastSyncPointOffsetPair() const;
    // Return a reference offering non-modifiable access to the
    // "LastSyncPointOffsetPair" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionSyncStateQueryResponse& lhs,
                           const PartitionSyncStateQueryResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const PartitionSyncStateQueryResponse& lhs,
                           const PartitionSyncStateQueryResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream,
                                    const PartitionSyncStateQueryResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                      hashAlg,
                           const PartitionSyncStateQueryResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionSyncStateQueryResponse'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncStateQueryResponse)

namespace bmqp_ctrlmsg {

// =============================
// class QueueAssignmentAdvisory
// =============================

class QueueAssignmentAdvisory {
    // This type represents a one way message sent by the leader to all
    // followers when a queue is assigned a partition.

    // INSTANCE DATA
    bsl::vector<QueueInfo> d_queues;
    LeaderMessageSequence  d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0, ATTRIBUTE_ID_QUEUES = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0, ATTRIBUTE_INDEX_QUEUES = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueAssignmentAdvisory(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueAssignmentAdvisory' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    QueueAssignmentAdvisory(const QueueAssignmentAdvisory& original,
                            bslma::Allocator*              basicAllocator = 0);
    // Create an object of type 'QueueAssignmentAdvisory' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueAssignmentAdvisory(QueueAssignmentAdvisory&& original) noexcept;
    // Create an object of type 'QueueAssignmentAdvisory' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    QueueAssignmentAdvisory(QueueAssignmentAdvisory&& original,
                            bslma::Allocator*         basicAllocator);
    // Create an object of type 'QueueAssignmentAdvisory' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~QueueAssignmentAdvisory();
    // Destroy this object.

    // MANIPULATORS
    QueueAssignmentAdvisory& operator=(const QueueAssignmentAdvisory& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueAssignmentAdvisory& operator=(QueueAssignmentAdvisory&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    bsl::vector<QueueInfo>& queues();
    // Return a reference to the modifiable "Queues" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    const bsl::vector<QueueInfo>& queues() const;
    // Return a reference offering non-modifiable access to the "Queues"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueAssignmentAdvisory& lhs,
                           const QueueAssignmentAdvisory& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sequenceNumber() == rhs.sequenceNumber() &&
               lhs.queues() == rhs.queues();
    }

    friend bool operator!=(const QueueAssignmentAdvisory& lhs,
                           const QueueAssignmentAdvisory& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                  stream,
                                    const QueueAssignmentAdvisory& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&              hashAlg,
                           const QueueAssignmentAdvisory& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueAssignmentAdvisory'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.sequenceNumber());
        hashAppend(hashAlg, object.queues());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueAssignmentAdvisory)

namespace bmqp_ctrlmsg {

// ===============================
// class QueueUnAssignmentAdvisory
// ===============================

class QueueUnAssignmentAdvisory {
    // This type represents a one way message sent by the primary of a
    // partition to all peers when queues are unmapped from that partition.
    // NOTE: The 'partitionId' member of 'QueueInfo' is unused (superseeded by
    // the 'partitionId' at this level of the data structure).

    // INSTANCE DATA
    bsl::vector<QueueInfo> d_queues;
    unsigned int           d_primaryLeaseId;
    int                    d_primaryNodeId;
    int                    d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueUnAssignmentAdvisory& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PRIMARY_NODE_ID  = 0,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_ID_PARTITION_ID     = 2,
        ATTRIBUTE_ID_QUEUES           = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PRIMARY_NODE_ID  = 0,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_INDEX_PARTITION_ID     = 2,
        ATTRIBUTE_INDEX_QUEUES           = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueUnAssignmentAdvisory(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueUnAssignmentAdvisory' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    QueueUnAssignmentAdvisory(const QueueUnAssignmentAdvisory& original,
                              bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueUnAssignmentAdvisory' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnAssignmentAdvisory(QueueUnAssignmentAdvisory&& original) noexcept;
    // Create an object of type 'QueueUnAssignmentAdvisory' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    QueueUnAssignmentAdvisory(QueueUnAssignmentAdvisory&& original,
                              bslma::Allocator*           basicAllocator);
    // Create an object of type 'QueueUnAssignmentAdvisory' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~QueueUnAssignmentAdvisory();
    // Destroy this object.

    // MANIPULATORS
    QueueUnAssignmentAdvisory& operator=(const QueueUnAssignmentAdvisory& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnAssignmentAdvisory& operator=(QueueUnAssignmentAdvisory&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& primaryNodeId();
    // Return a reference to the modifiable "PrimaryNodeId" attribute of
    // this object.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    bsl::vector<QueueInfo>& queues();
    // Return a reference to the modifiable "Queues" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int primaryNodeId() const;
    // Return the value of the "PrimaryNodeId" attribute of this object.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const bsl::vector<QueueInfo>& queues() const;
    // Return a reference offering non-modifiable access to the "Queues"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueUnAssignmentAdvisory& lhs,
                           const QueueUnAssignmentAdvisory& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueUnAssignmentAdvisory& lhs,
                           const QueueUnAssignmentAdvisory& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                    stream,
                                    const QueueUnAssignmentAdvisory& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                hashAlg,
                           const QueueUnAssignmentAdvisory& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueUnAssignmentAdvisory'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueUnAssignmentAdvisory)

namespace bmqp_ctrlmsg {

// =============================
// class QueueUnassignedAdvisory
// =============================

class QueueUnassignedAdvisory {
    // This type represents a one way message sent by the leader to all peers
    // when queues are unmapped from that partition.  Once the logic is updated
    // such that leader broadcasts queue unassigned advisories, primary node
    // will no longer broadcastthem, and the other similar type
    // 'QueueUnAssignmentAdvisory' will be removed.

    // INSTANCE DATA
    bsl::vector<QueueInfo> d_queues;
    LeaderMessageSequence  d_sequenceNumber;
    unsigned int           d_primaryLeaseId;
    int                    d_partitionId;
    int                    d_primaryNodeId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueUnassignedAdvisory& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SEQUENCE_NUMBER  = 0,
        ATTRIBUTE_ID_PARTITION_ID     = 1,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 2,
        ATTRIBUTE_ID_PRIMARY_NODE_ID  = 3,
        ATTRIBUTE_ID_QUEUES           = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER  = 0,
        ATTRIBUTE_INDEX_PARTITION_ID     = 1,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 2,
        ATTRIBUTE_INDEX_PRIMARY_NODE_ID  = 3,
        ATTRIBUTE_INDEX_QUEUES           = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueUnassignedAdvisory(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueUnassignedAdvisory' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    QueueUnassignedAdvisory(const QueueUnassignedAdvisory& original,
                            bslma::Allocator*              basicAllocator = 0);
    // Create an object of type 'QueueUnassignedAdvisory' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnassignedAdvisory(QueueUnassignedAdvisory&& original) noexcept;
    // Create an object of type 'QueueUnassignedAdvisory' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    QueueUnassignedAdvisory(QueueUnassignedAdvisory&& original,
                            bslma::Allocator*         basicAllocator);
    // Create an object of type 'QueueUnassignedAdvisory' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~QueueUnassignedAdvisory();
    // Destroy this object.

    // MANIPULATORS
    QueueUnassignedAdvisory& operator=(const QueueUnassignedAdvisory& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnassignedAdvisory& operator=(QueueUnassignedAdvisory&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    int& primaryNodeId();
    // Return a reference to the modifiable "PrimaryNodeId" attribute of
    // this object.

    bsl::vector<QueueInfo>& queues();
    // Return a reference to the modifiable "Queues" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    int primaryNodeId() const;
    // Return the value of the "PrimaryNodeId" attribute of this object.

    const bsl::vector<QueueInfo>& queues() const;
    // Return a reference offering non-modifiable access to the "Queues"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueUnassignedAdvisory& lhs,
                           const QueueUnassignedAdvisory& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueUnassignedAdvisory& lhs,
                           const QueueUnassignedAdvisory& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                  stream,
                                    const QueueUnassignedAdvisory& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&              hashAlg,
                           const QueueUnassignedAdvisory& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueUnassignedAdvisory'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueUnassignedAdvisory)

namespace bmqp_ctrlmsg {

// =========================
// class QueueUpdateAdvisory
// =========================

class QueueUpdateAdvisory {
    // This type represents a one way message sent by the leader to all
    // followers when appIds are added to, or removed from, a queue.

    // INSTANCE DATA
    bsl::vector<QueueInfoUpdate> d_queueUpdates;
    LeaderMessageSequence        d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0, ATTRIBUTE_ID_QUEUE_UPDATES = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0,
        ATTRIBUTE_INDEX_QUEUE_UPDATES   = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueUpdateAdvisory(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueUpdateAdvisory' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    QueueUpdateAdvisory(const QueueUpdateAdvisory& original,
                        bslma::Allocator*          basicAllocator = 0);
    // Create an object of type 'QueueUpdateAdvisory' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUpdateAdvisory(QueueUpdateAdvisory&& original) noexcept;
    // Create an object of type 'QueueUpdateAdvisory' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueUpdateAdvisory(QueueUpdateAdvisory&& original,
                        bslma::Allocator*     basicAllocator);
    // Create an object of type 'QueueUpdateAdvisory' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueUpdateAdvisory();
    // Destroy this object.

    // MANIPULATORS
    QueueUpdateAdvisory& operator=(const QueueUpdateAdvisory& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUpdateAdvisory& operator=(QueueUpdateAdvisory&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderMessageSequence& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    bsl::vector<QueueInfoUpdate>& queueUpdates();
    // Return a reference to the modifiable "QueueUpdates" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderMessageSequence& sequenceNumber() const;
    // Return a reference offering non-modifiable access to the
    // "SequenceNumber" attribute of this object.

    const bsl::vector<QueueInfoUpdate>& queueUpdates() const;
    // Return a reference offering non-modifiable access to the
    // "QueueUpdates" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueUpdateAdvisory& lhs,
                           const QueueUpdateAdvisory& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sequenceNumber() == rhs.sequenceNumber() &&
               lhs.queueUpdates() == rhs.queueUpdates();
    }

    friend bool operator!=(const QueueUpdateAdvisory& lhs,
                           const QueueUpdateAdvisory& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const QueueUpdateAdvisory& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const QueueUpdateAdvisory& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueUpdateAdvisory'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.sequenceNumber());
        hashAppend(hashAlg, object.queueUpdates());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueUpdateAdvisory)

namespace bmqp_ctrlmsg {

// =======================
// class StateNotification
// =======================

class StateNotification {
    // Choice of all the various cluster state notifications sent from a node
    // in the cluster to a peer node with the capacity to take action upon the
    // notification.
    // leaderPassive..: Leader is passive

    // INSTANCE DATA
    StateNotificationChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    StateNotification();
    // Create an object of type 'StateNotification' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    StateNotificationChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const StateNotificationChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StateNotification& lhs,
                           const StateNotification& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.choice() == rhs.choice();
    }

    friend bool operator!=(const StateNotification& lhs,
                           const StateNotification& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const StateNotification& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const StateNotification& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StateNotification'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.choice());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StateNotification)

namespace bmqp_ctrlmsg {

// ========================
// class StorageSyncRequest
// ========================

class StorageSyncRequest {
    // This type represents a request sent by a cluster node to a peer node in
    // the cluster requesting to initiate storage sync.
    // partitionId.....: The corresponding partitionId beginSyncPoint..:
    // Optional starting sync point of the missing storage endSyncPoint....:
    // Optional ending sync point of the missing storage

    // INSTANCE DATA
    bdlb::NullableValue<SyncPointOffsetPair> d_beginSyncPointOffsetPair;
    bdlb::NullableValue<SyncPointOffsetPair> d_endSyncPointOffsetPair;
    int                                      d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID                 = 0,
        ATTRIBUTE_ID_BEGIN_SYNC_POINT_OFFSET_PAIR = 1,
        ATTRIBUTE_ID_END_SYNC_POINT_OFFSET_PAIR   = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID                 = 0,
        ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR = 1,
        ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR   = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    StorageSyncRequest();
    // Create an object of type 'StorageSyncRequest' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    bdlb::NullableValue<SyncPointOffsetPair>& beginSyncPointOffsetPair();
    // Return a reference to the modifiable "BeginSyncPointOffsetPair"
    // attribute of this object.

    bdlb::NullableValue<SyncPointOffsetPair>& endSyncPointOffsetPair();
    // Return a reference to the modifiable "EndSyncPointOffsetPair"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const bdlb::NullableValue<SyncPointOffsetPair>&
    beginSyncPointOffsetPair() const;
    // Return a reference offering non-modifiable access to the
    // "BeginSyncPointOffsetPair" attribute of this object.

    const bdlb::NullableValue<SyncPointOffsetPair>&
    endSyncPointOffsetPair() const;
    // Return a reference offering non-modifiable access to the
    // "EndSyncPointOffsetPair" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageSyncRequest& lhs,
                           const StorageSyncRequest& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.beginSyncPointOffsetPair() ==
                   rhs.beginSyncPointOffsetPair() &&
               lhs.endSyncPointOffsetPair() == rhs.endSyncPointOffsetPair();
    }

    friend bool operator!=(const StorageSyncRequest& lhs,
                           const StorageSyncRequest& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const StorageSyncRequest& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&         hashAlg,
                           const StorageSyncRequest& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageSyncRequest'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StorageSyncRequest)

namespace bmqp_ctrlmsg {

// ==================
// class Subscription
// ==================

class Subscription {
    // This complex type contains various parameters required by an upstream
    // node to configure subscription for a queue handle that has already been
    // created.
    // sId....................: subscription identifier
    // consumers..............: consumer parameters

    // INSTANCE DATA
    bsl::vector<ConsumerInfo> d_consumers;
    Expression                d_expression;
    unsigned int              d_sId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_S_ID       = 0,
        ATTRIBUTE_ID_EXPRESSION = 1,
        ATTRIBUTE_ID_CONSUMERS  = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_S_ID       = 0,
        ATTRIBUTE_INDEX_EXPRESSION = 1,
        ATTRIBUTE_INDEX_CONSUMERS  = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Subscription(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Subscription' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Subscription(const Subscription& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'Subscription' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Subscription(Subscription&& original) noexcept;
    // Create an object of type 'Subscription' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    Subscription(Subscription&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Subscription' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Subscription();
    // Destroy this object.

    // MANIPULATORS
    Subscription& operator=(const Subscription& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Subscription& operator=(Subscription&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& sId();
    // Return a reference to the modifiable "SId" attribute of this object.

    Expression& expression();
    // Return a reference to the modifiable "Expression" attribute of this
    // object.

    bsl::vector<ConsumerInfo>& consumers();
    // Return a reference to the modifiable "Consumers" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int sId() const;
    // Return the value of the "SId" attribute of this object.

    const Expression& expression() const;
    // Return a reference offering non-modifiable access to the
    // "Expression" attribute of this object.

    const bsl::vector<ConsumerInfo>& consumers() const;
    // Return a reference offering non-modifiable access to the "Consumers"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Subscription& lhs, const Subscription& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.sId() == rhs.sId() &&
               lhs.expression() == rhs.expression() &&
               lhs.consumers() == rhs.consumers();
    }

    friend bool operator!=(const Subscription& lhs, const Subscription& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const Subscription& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const Subscription& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'Subscription'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::Subscription)

namespace bmqp_ctrlmsg {

// ==================================
// class ConfigureQueueStreamResponse
// ==================================

class ConfigureQueueStreamResponse {
    // Response of a 'ConfigureQueueStream' request, indicating success of the
    // operation.

    // INSTANCE DATA
    ConfigureQueueStream d_request;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_REQUEST = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_REQUEST = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ConfigureQueueStreamResponse(
        bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ConfigureQueueStreamResponse' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    ConfigureQueueStreamResponse(const ConfigureQueueStreamResponse& original,
                                 bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ConfigureQueueStreamResponse' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureQueueStreamResponse(
        ConfigureQueueStreamResponse&& original) noexcept;
    // Create an object of type 'ConfigureQueueStreamResponse' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    ConfigureQueueStreamResponse(ConfigureQueueStreamResponse&& original,
                                 bslma::Allocator* basicAllocator);
    // Create an object of type 'ConfigureQueueStreamResponse' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~ConfigureQueueStreamResponse();
    // Destroy this object.

    // MANIPULATORS
    ConfigureQueueStreamResponse&
    operator=(const ConfigureQueueStreamResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureQueueStreamResponse&
    operator=(ConfigureQueueStreamResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ConfigureQueueStream& request();
    // Return a reference to the modifiable "Request" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const ConfigureQueueStream& request() const;
    // Return a reference offering non-modifiable access to the "Request"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ConfigureQueueStreamResponse& lhs,
                           const ConfigureQueueStreamResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.request() == rhs.request();
    }

    friend bool operator!=(const ConfigureQueueStreamResponse& lhs,
                           const ConfigureQueueStreamResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                       stream,
                                    const ConfigureQueueStreamResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                   hashAlg,
                           const ConfigureQueueStreamResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ConfigureQueueStreamResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.request());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ConfigureQueueStreamResponse)

namespace bmqp_ctrlmsg {

// ==================================
// class FollowerClusterStateResponse
// ==================================

class FollowerClusterStateResponse {
    // This type represents a response to the 'FollowerClusterStateRequest'
    // sent by the highest LSN follower to the leader, containing its cluster
    // state snapshot.
    // clusterStateSnapshot..: Encoded cluster state snapshot, in the form of a
    // leader advisory.

    // INSTANCE DATA
    LeaderAdvisory d_clusterStateSnapshot;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CLUSTER_STATE_SNAPSHOT = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit FollowerClusterStateResponse(
        bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'FollowerClusterStateResponse' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    FollowerClusterStateResponse(const FollowerClusterStateResponse& original,
                                 bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'FollowerClusterStateResponse' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerClusterStateResponse(
        FollowerClusterStateResponse&& original) noexcept;
    // Create an object of type 'FollowerClusterStateResponse' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    FollowerClusterStateResponse(FollowerClusterStateResponse&& original,
                                 bslma::Allocator* basicAllocator);
    // Create an object of type 'FollowerClusterStateResponse' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~FollowerClusterStateResponse();
    // Destroy this object.

    // MANIPULATORS
    FollowerClusterStateResponse&
    operator=(const FollowerClusterStateResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerClusterStateResponse&
    operator=(FollowerClusterStateResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderAdvisory& clusterStateSnapshot();
    // Return a reference to the modifiable "ClusterStateSnapshot"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderAdvisory& clusterStateSnapshot() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterStateSnapshot" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const FollowerClusterStateResponse& lhs,
                           const FollowerClusterStateResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clusterStateSnapshot() == rhs.clusterStateSnapshot();
    }

    friend bool operator!=(const FollowerClusterStateResponse& lhs,
                           const FollowerClusterStateResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                       stream,
                                    const FollowerClusterStateResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                   hashAlg,
                           const FollowerClusterStateResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'FollowerClusterStateResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.clusterStateSnapshot());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::FollowerClusterStateResponse)

namespace bmqp_ctrlmsg {

// =================================
// class LeaderSyncDataQueryResponse
// =================================

class LeaderSyncDataQueryResponse {
    // This type represents a response to the 'LeaderSyncDataQuery' sent by the
    // follower to the leader.

    // INSTANCE DATA
    LeaderAdvisory d_leaderSyncData;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_LEADER_SYNC_DATA = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_LEADER_SYNC_DATA = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit LeaderSyncDataQueryResponse(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'LeaderSyncDataQueryResponse' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    LeaderSyncDataQueryResponse(const LeaderSyncDataQueryResponse& original,
                                bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'LeaderSyncDataQueryResponse' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncDataQueryResponse(
        LeaderSyncDataQueryResponse&& original) noexcept;
    // Create an object of type 'LeaderSyncDataQueryResponse' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    LeaderSyncDataQueryResponse(LeaderSyncDataQueryResponse&& original,
                                bslma::Allocator*             basicAllocator);
    // Create an object of type 'LeaderSyncDataQueryResponse' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~LeaderSyncDataQueryResponse();
    // Destroy this object.

    // MANIPULATORS
    LeaderSyncDataQueryResponse&
    operator=(const LeaderSyncDataQueryResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncDataQueryResponse& operator=(LeaderSyncDataQueryResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    LeaderAdvisory& leaderSyncData();
    // Return a reference to the modifiable "LeaderSyncData" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const LeaderAdvisory& leaderSyncData() const;
    // Return a reference offering non-modifiable access to the
    // "LeaderSyncData" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderSyncDataQueryResponse& lhs,
                           const LeaderSyncDataQueryResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.leaderSyncData() == rhs.leaderSyncData();
    }

    friend bool operator!=(const LeaderSyncDataQueryResponse& lhs,
                           const LeaderSyncDataQueryResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                      stream,
                                    const LeaderSyncDataQueryResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                  hashAlg,
                           const LeaderSyncDataQueryResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderSyncDataQueryResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.leaderSyncData());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderSyncDataQueryResponse)

namespace bmqp_ctrlmsg {

// ========================
// class NegotiationMessage
// ========================

class NegotiationMessage {
    // This type is the top level type for any message being exchanged during
    // negotiation of a connection with the broker, whether by a BlazingMQ
    // client or another broker.
    // choice.: enumerates all the different type of negotiation packets
    // During negotiation, the process (whether a client using the libbmq SDK,
    // or a bmqbrkr) sends a 'clientIdentity' message; to which the remote peer
    // will reply with a 'brokerResponse' message, embedding a 'clientIdentity'
    // representing its own identity.  In order to support reverse connection,
    // the negotiation will be 3 steps: first, a 'reverseConnectionRequest'
    // will be sent, which will trigger the 'normal' 2-steps negotiation to be
    // initiated by the remote peer.

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ClientIdentity> d_clientIdentity;
        bsls::ObjectBuffer<BrokerResponse> d_brokerResponse;
        bsls::ObjectBuffer<ReverseConnectionRequest>
            d_reverseConnectionRequest;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const NegotiationMessage& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                  = -1,
        SELECTION_ID_CLIENT_IDENTITY            = 0,
        SELECTION_ID_BROKER_RESPONSE            = 1,
        SELECTION_ID_REVERSE_CONNECTION_REQUEST = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_CLIENT_IDENTITY            = 0,
        SELECTION_INDEX_BROKER_RESPONSE            = 1,
        SELECTION_INDEX_REVERSE_CONNECTION_REQUEST = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit NegotiationMessage(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'NegotiationMessage' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    NegotiationMessage(const NegotiationMessage& original,
                       bslma::Allocator*         basicAllocator = 0);
    // Create an object of type 'NegotiationMessage' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    NegotiationMessage(NegotiationMessage&& original) noexcept;
    // Create an object of type 'NegotiationMessage' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    NegotiationMessage(NegotiationMessage&& original,
                       bslma::Allocator*    basicAllocator);
    // Create an object of type 'NegotiationMessage' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~NegotiationMessage();
    // Destroy this object.

    // MANIPULATORS
    NegotiationMessage& operator=(const NegotiationMessage& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    NegotiationMessage& operator=(NegotiationMessage&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    ClientIdentity& makeClientIdentity();
    ClientIdentity& makeClientIdentity(const ClientIdentity& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClientIdentity& makeClientIdentity(ClientIdentity&& value);
#endif
    // Set the value of this object to be a "ClientIdentity" value.
    // Optionally specify the 'value' of the "ClientIdentity".  If 'value'
    // is not specified, the default "ClientIdentity" value is used.

    BrokerResponse& makeBrokerResponse();
    BrokerResponse& makeBrokerResponse(const BrokerResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerResponse& makeBrokerResponse(BrokerResponse&& value);
#endif
    // Set the value of this object to be a "BrokerResponse" value.
    // Optionally specify the 'value' of the "BrokerResponse".  If 'value'
    // is not specified, the default "BrokerResponse" value is used.

    ReverseConnectionRequest& makeReverseConnectionRequest();
    ReverseConnectionRequest&
    makeReverseConnectionRequest(const ReverseConnectionRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReverseConnectionRequest&
    makeReverseConnectionRequest(ReverseConnectionRequest&& value);
#endif
    // Set the value of this object to be a "ReverseConnectionRequest"
    // value.  Optionally specify the 'value' of the
    // "ReverseConnectionRequest".  If 'value' is not specified, the
    // default "ReverseConnectionRequest" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    ClientIdentity& clientIdentity();
    // Return a reference to the modifiable "ClientIdentity" selection of
    // this object if "ClientIdentity" is the current selection.  The
    // behavior is undefined unless "ClientIdentity" is the selection of
    // this object.

    BrokerResponse& brokerResponse();
    // Return a reference to the modifiable "BrokerResponse" selection of
    // this object if "BrokerResponse" is the current selection.  The
    // behavior is undefined unless "BrokerResponse" is the selection of
    // this object.

    ReverseConnectionRequest& reverseConnectionRequest();
    // Return a reference to the modifiable "ReverseConnectionRequest"
    // selection of this object if "ReverseConnectionRequest" is the
    // current selection.  The behavior is undefined unless
    // "ReverseConnectionRequest" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const ClientIdentity& clientIdentity() const;
    // Return a reference to the non-modifiable "ClientIdentity" selection
    // of this object if "ClientIdentity" is the current selection.  The
    // behavior is undefined unless "ClientIdentity" is the selection of
    // this object.

    const BrokerResponse& brokerResponse() const;
    // Return a reference to the non-modifiable "BrokerResponse" selection
    // of this object if "BrokerResponse" is the current selection.  The
    // behavior is undefined unless "BrokerResponse" is the selection of
    // this object.

    const ReverseConnectionRequest& reverseConnectionRequest() const;
    // Return a reference to the non-modifiable "ReverseConnectionRequest"
    // selection of this object if "ReverseConnectionRequest" is the
    // current selection.  The behavior is undefined unless
    // "ReverseConnectionRequest" is the selection of this object.

    bool isClientIdentityValue() const;
    // Return 'true' if the value of this object is a "ClientIdentity"
    // value, and return 'false' otherwise.

    bool isBrokerResponseValue() const;
    // Return 'true' if the value of this object is a "BrokerResponse"
    // value, and return 'false' otherwise.

    bool isReverseConnectionRequestValue() const;
    // Return 'true' if the value of this object is a
    // "ReverseConnectionRequest" value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const NegotiationMessage& lhs,
                           const NegotiationMessage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'NegotiationMessage' objects have
    // the same value if either the selections in both objects have the
    // same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const NegotiationMessage& lhs,
                           const NegotiationMessage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const NegotiationMessage& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&         hashAlg,
                           const NegotiationMessage& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'NegotiationMessage'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::NegotiationMessage)

namespace bmqp_ctrlmsg {

// =======================
// class OpenQueueResponse
// =======================

class OpenQueueResponse {
    // Response of an 'OpenQueue' request indicating success of the operation.
    //
    // originalRequest......: original request this 'OpenQueueResponse' is the
    // response of routingConfiguration.: routing info to be used by the
    // downstream node to distribute messages to consumers attached to it
    // deduplicationTimeMs........: timeout, in milliseconds, to keep GUID of
    // PUT message for the purpose of detecting duplicate PUTs.

    // INSTANCE DATA
    RoutingConfiguration d_routingConfiguration;
    OpenQueue            d_originalRequest;
    int                  d_deduplicationTimeMs;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_ORIGINAL_REQUEST      = 0,
        ATTRIBUTE_ID_ROUTING_CONFIGURATION = 1,
        ATTRIBUTE_ID_DEDUPLICATION_TIME_MS = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_ORIGINAL_REQUEST      = 0,
        ATTRIBUTE_INDEX_ROUTING_CONFIGURATION = 1,
        ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_DEDUPLICATION_TIME_MS;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit OpenQueueResponse(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'OpenQueueResponse' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    OpenQueueResponse(const OpenQueueResponse& original,
                      bslma::Allocator*        basicAllocator = 0);
    // Create an object of type 'OpenQueueResponse' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    OpenQueueResponse(OpenQueueResponse&& original) noexcept;
    // Create an object of type 'OpenQueueResponse' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    OpenQueueResponse(OpenQueueResponse&& original,
                      bslma::Allocator*   basicAllocator);
    // Create an object of type 'OpenQueueResponse' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~OpenQueueResponse();
    // Destroy this object.

    // MANIPULATORS
    OpenQueueResponse& operator=(const OpenQueueResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    OpenQueueResponse& operator=(OpenQueueResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    OpenQueue& originalRequest();
    // Return a reference to the modifiable "OriginalRequest" attribute of
    // this object.

    RoutingConfiguration& routingConfiguration();
    // Return a reference to the modifiable "RoutingConfiguration"
    // attribute of this object.

    int& deduplicationTimeMs();
    // Return a reference to the modifiable "DeduplicationTimeMs" attribute
    // of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const OpenQueue& originalRequest() const;
    // Return a reference offering non-modifiable access to the
    // "OriginalRequest" attribute of this object.

    const RoutingConfiguration& routingConfiguration() const;
    // Return a reference offering non-modifiable access to the
    // "RoutingConfiguration" attribute of this object.

    int deduplicationTimeMs() const;
    // Return the value of the "DeduplicationTimeMs" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const OpenQueueResponse& lhs,
                           const OpenQueueResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.originalRequest() == rhs.originalRequest() &&
               lhs.routingConfiguration() == rhs.routingConfiguration() &&
               lhs.deduplicationTimeMs() == rhs.deduplicationTimeMs();
    }

    friend bool operator!=(const OpenQueueResponse& lhs,
                           const OpenQueueResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const OpenQueueResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const OpenQueueResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'OpenQueueResponse'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::OpenQueueResponse)

namespace bmqp_ctrlmsg {

// ======================
// class PartitionMessage
// ======================

class PartitionMessage {
    // This type is the top level type for any message being sent by a node
    // inside the cluster to one or more peer nodes to exchange partition
    // state.  Note that this type of message is not sent outside the cluster.
    //
    // choice.: enumerates all the different types of partition messages

    // INSTANCE DATA
    PartitionMessageChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    PartitionMessage();
    // Create an object of type 'PartitionMessage' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    PartitionMessageChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const PartitionMessageChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionMessage& lhs,
                           const PartitionMessage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.choice() == rhs.choice();
    }

    friend bool operator!=(const PartitionMessage& lhs,
                           const PartitionMessage& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const PartitionMessage& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const PartitionMessage& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionMessage'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.choice());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::PartitionMessage)

namespace bmqp_ctrlmsg {

// ======================
// class StreamParameters
// ======================

class StreamParameters {
    // This request contains parameters advertised by the downstream node so
    // that upstream node can configure subscriptions associated with the given
    // queue on the downstream node.
    // appId..................: Application-provided unique string identifier
    // for a given fanout consumer subscriptions..........: Parameters for
    // configuring subscriptions

    // INSTANCE DATA
    bsl::vector<Subscription> d_subscriptions;
    bsl::string               d_appId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_APP_ID = 0, ATTRIBUTE_ID_SUBSCRIPTIONS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_APP_ID = 0, ATTRIBUTE_INDEX_SUBSCRIPTIONS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const char DEFAULT_INITIALIZER_APP_ID[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit StreamParameters(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StreamParameters' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    StreamParameters(const StreamParameters& original,
                     bslma::Allocator*       basicAllocator = 0);
    // Create an object of type 'StreamParameters' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StreamParameters(StreamParameters&& original) noexcept;
    // Create an object of type 'StreamParameters' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StreamParameters(StreamParameters&& original,
                     bslma::Allocator*  basicAllocator);
    // Create an object of type 'StreamParameters' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StreamParameters();
    // Destroy this object.

    // MANIPULATORS
    StreamParameters& operator=(const StreamParameters& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StreamParameters& operator=(StreamParameters&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    bsl::vector<Subscription>& subscriptions();
    // Return a reference to the modifiable "Subscriptions" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    const bsl::vector<Subscription>& subscriptions() const;
    // Return a reference offering non-modifiable access to the
    // "Subscriptions" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StreamParameters& lhs,
                           const StreamParameters& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.appId() == rhs.appId() &&
               lhs.subscriptions() == rhs.subscriptions();
    }

    friend bool operator!=(const StreamParameters& lhs,
                           const StreamParameters& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const StreamParameters& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const StreamParameters& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StreamParameters'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.appId());
        hashAppend(hashAlg, object.subscriptions());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StreamParameters)

namespace bmqp_ctrlmsg {

// ==================================
// class ClusterStateFSMMessageChoice
// ==================================

class ClusterStateFSMMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<FollowerLSNRequest>   d_followerLSNRequest;
        bsls::ObjectBuffer<FollowerLSNResponse>  d_followerLSNResponse;
        bsls::ObjectBuffer<RegistrationRequest>  d_registrationRequest;
        bsls::ObjectBuffer<RegistrationResponse> d_registrationResponse;
        bsls::ObjectBuffer<FollowerClusterStateRequest>
            d_followerClusterStateRequest;
        bsls::ObjectBuffer<FollowerClusterStateResponse>
            d_followerClusterStateResponse;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterStateFSMMessageChoice& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                       = -1,
        SELECTION_ID_FOLLOWER_L_S_N_REQUEST          = 0,
        SELECTION_ID_FOLLOWER_L_S_N_RESPONSE         = 1,
        SELECTION_ID_REGISTRATION_REQUEST            = 2,
        SELECTION_ID_REGISTRATION_RESPONSE           = 3,
        SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST  = 4,
        SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE = 5
    };

    enum { NUM_SELECTIONS = 6 };

    enum {
        SELECTION_INDEX_FOLLOWER_L_S_N_REQUEST          = 0,
        SELECTION_INDEX_FOLLOWER_L_S_N_RESPONSE         = 1,
        SELECTION_INDEX_REGISTRATION_REQUEST            = 2,
        SELECTION_INDEX_REGISTRATION_RESPONSE           = 3,
        SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_REQUEST  = 4,
        SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_RESPONSE = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterStateFSMMessageChoice(
        bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterStateFSMMessageChoice' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    ClusterStateFSMMessageChoice(const ClusterStateFSMMessageChoice& original,
                                 bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterStateFSMMessageChoice' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateFSMMessageChoice(
        ClusterStateFSMMessageChoice&& original) noexcept;
    // Create an object of type 'ClusterStateFSMMessageChoice' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    ClusterStateFSMMessageChoice(ClusterStateFSMMessageChoice&& original,
                                 bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterStateFSMMessageChoice' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~ClusterStateFSMMessageChoice();
    // Destroy this object.

    // MANIPULATORS
    ClusterStateFSMMessageChoice&
    operator=(const ClusterStateFSMMessageChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateFSMMessageChoice&
    operator=(ClusterStateFSMMessageChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    FollowerLSNRequest& makeFollowerLSNRequest();
    FollowerLSNRequest&
    makeFollowerLSNRequest(const FollowerLSNRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerLSNRequest& makeFollowerLSNRequest(FollowerLSNRequest&& value);
#endif
    // Set the value of this object to be a "FollowerLSNRequest" value.
    // Optionally specify the 'value' of the "FollowerLSNRequest".  If
    // 'value' is not specified, the default "FollowerLSNRequest" value is
    // used.

    FollowerLSNResponse& makeFollowerLSNResponse();
    FollowerLSNResponse&
    makeFollowerLSNResponse(const FollowerLSNResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerLSNResponse& makeFollowerLSNResponse(FollowerLSNResponse&& value);
#endif
    // Set the value of this object to be a "FollowerLSNResponse" value.
    // Optionally specify the 'value' of the "FollowerLSNResponse".  If
    // 'value' is not specified, the default "FollowerLSNResponse" value is
    // used.

    RegistrationRequest& makeRegistrationRequest();
    RegistrationRequest&
    makeRegistrationRequest(const RegistrationRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RegistrationRequest& makeRegistrationRequest(RegistrationRequest&& value);
#endif
    // Set the value of this object to be a "RegistrationRequest" value.
    // Optionally specify the 'value' of the "RegistrationRequest".  If
    // 'value' is not specified, the default "RegistrationRequest" value is
    // used.

    RegistrationResponse& makeRegistrationResponse();
    RegistrationResponse&
    makeRegistrationResponse(const RegistrationResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RegistrationResponse&
    makeRegistrationResponse(RegistrationResponse&& value);
#endif
    // Set the value of this object to be a "RegistrationResponse" value.
    // Optionally specify the 'value' of the "RegistrationResponse".  If
    // 'value' is not specified, the default "RegistrationResponse" value
    // is used.

    FollowerClusterStateRequest& makeFollowerClusterStateRequest();
    FollowerClusterStateRequest&
    makeFollowerClusterStateRequest(const FollowerClusterStateRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerClusterStateRequest&
    makeFollowerClusterStateRequest(FollowerClusterStateRequest&& value);
#endif
    // Set the value of this object to be a "FollowerClusterStateRequest"
    // value.  Optionally specify the 'value' of the
    // "FollowerClusterStateRequest".  If 'value' is not specified, the
    // default "FollowerClusterStateRequest" value is used.

    FollowerClusterStateResponse& makeFollowerClusterStateResponse();
    FollowerClusterStateResponse& makeFollowerClusterStateResponse(
        const FollowerClusterStateResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerClusterStateResponse&
    makeFollowerClusterStateResponse(FollowerClusterStateResponse&& value);
#endif
    // Set the value of this object to be a "FollowerClusterStateResponse"
    // value.  Optionally specify the 'value' of the
    // "FollowerClusterStateResponse".  If 'value' is not specified, the
    // default "FollowerClusterStateResponse" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    FollowerLSNRequest& followerLSNRequest();
    // Return a reference to the modifiable "FollowerLSNRequest" selection
    // of this object if "FollowerLSNRequest" is the current selection.
    // The behavior is undefined unless "FollowerLSNRequest" is the
    // selection of this object.

    FollowerLSNResponse& followerLSNResponse();
    // Return a reference to the modifiable "FollowerLSNResponse" selection
    // of this object if "FollowerLSNResponse" is the current selection.
    // The behavior is undefined unless "FollowerLSNResponse" is the
    // selection of this object.

    RegistrationRequest& registrationRequest();
    // Return a reference to the modifiable "RegistrationRequest" selection
    // of this object if "RegistrationRequest" is the current selection.
    // The behavior is undefined unless "RegistrationRequest" is the
    // selection of this object.

    RegistrationResponse& registrationResponse();
    // Return a reference to the modifiable "RegistrationResponse"
    // selection of this object if "RegistrationResponse" is the current
    // selection.  The behavior is undefined unless "RegistrationResponse"
    // is the selection of this object.

    FollowerClusterStateRequest& followerClusterStateRequest();
    // Return a reference to the modifiable "FollowerClusterStateRequest"
    // selection of this object if "FollowerClusterStateRequest" is the
    // current selection.  The behavior is undefined unless
    // "FollowerClusterStateRequest" is the selection of this object.

    FollowerClusterStateResponse& followerClusterStateResponse();
    // Return a reference to the modifiable "FollowerClusterStateResponse"
    // selection of this object if "FollowerClusterStateResponse" is the
    // current selection.  The behavior is undefined unless
    // "FollowerClusterStateResponse" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const FollowerLSNRequest& followerLSNRequest() const;
    // Return a reference to the non-modifiable "FollowerLSNRequest"
    // selection of this object if "FollowerLSNRequest" is the current
    // selection.  The behavior is undefined unless "FollowerLSNRequest" is
    // the selection of this object.

    const FollowerLSNResponse& followerLSNResponse() const;
    // Return a reference to the non-modifiable "FollowerLSNResponse"
    // selection of this object if "FollowerLSNResponse" is the current
    // selection.  The behavior is undefined unless "FollowerLSNResponse"
    // is the selection of this object.

    const RegistrationRequest& registrationRequest() const;
    // Return a reference to the non-modifiable "RegistrationRequest"
    // selection of this object if "RegistrationRequest" is the current
    // selection.  The behavior is undefined unless "RegistrationRequest"
    // is the selection of this object.

    const RegistrationResponse& registrationResponse() const;
    // Return a reference to the non-modifiable "RegistrationResponse"
    // selection of this object if "RegistrationResponse" is the current
    // selection.  The behavior is undefined unless "RegistrationResponse"
    // is the selection of this object.

    const FollowerClusterStateRequest& followerClusterStateRequest() const;
    // Return a reference to the non-modifiable
    // "FollowerClusterStateRequest" selection of this object if
    // "FollowerClusterStateRequest" is the current selection.  The
    // behavior is undefined unless "FollowerClusterStateRequest" is the
    // selection of this object.

    const FollowerClusterStateResponse& followerClusterStateResponse() const;
    // Return a reference to the non-modifiable
    // "FollowerClusterStateResponse" selection of this object if
    // "FollowerClusterStateResponse" is the current selection.  The
    // behavior is undefined unless "FollowerClusterStateResponse" is the
    // selection of this object.

    bool isFollowerLSNRequestValue() const;
    // Return 'true' if the value of this object is a "FollowerLSNRequest"
    // value, and return 'false' otherwise.

    bool isFollowerLSNResponseValue() const;
    // Return 'true' if the value of this object is a "FollowerLSNResponse"
    // value, and return 'false' otherwise.

    bool isRegistrationRequestValue() const;
    // Return 'true' if the value of this object is a "RegistrationRequest"
    // value, and return 'false' otherwise.

    bool isRegistrationResponseValue() const;
    // Return 'true' if the value of this object is a
    // "RegistrationResponse" value, and return 'false' otherwise.

    bool isFollowerClusterStateRequestValue() const;
    // Return 'true' if the value of this object is a
    // "FollowerClusterStateRequest" value, and return 'false' otherwise.

    bool isFollowerClusterStateResponseValue() const;
    // Return 'true' if the value of this object is a
    // "FollowerClusterStateResponse" value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterStateFSMMessageChoice& lhs,
                           const ClusterStateFSMMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ClusterStateFSMMessageChoice'
    // objects have the same value if either the selections in both objects
    // have the same ids and the same values, or both selections are
    // undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterStateFSMMessageChoice& lhs,
                           const ClusterStateFSMMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                       stream,
                                    const ClusterStateFSMMessageChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                   hashAlg,
                           const ClusterStateFSMMessageChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterStateFSMMessageChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterStateFSMMessageChoice)

namespace bmqp_ctrlmsg {

// =====================
// class ConfigureStream
// =====================

class ConfigureStream {
    // This request contains parameters advertised by the downstream node so
    // that upstream node can configure subscriptions associated with the given
    // queue on the downstream node.
    // qId....................: Id identifying the queue
    // subscriptionParameters.: Parameters for configuring subscriptions

    // INSTANCE DATA
    StreamParameters d_streamParameters;
    unsigned int     d_qId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_Q_ID = 0, ATTRIBUTE_ID_STREAM_PARAMETERS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_Q_ID = 0, ATTRIBUTE_INDEX_STREAM_PARAMETERS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ConfigureStream(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ConfigureStream' having the default value.
    //  Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ConfigureStream(const ConfigureStream& original,
                    bslma::Allocator*      basicAllocator = 0);
    // Create an object of type 'ConfigureStream' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureStream(ConfigureStream&& original) noexcept;
    // Create an object of type 'ConfigureStream' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ConfigureStream(ConfigureStream&& original,
                    bslma::Allocator* basicAllocator);
    // Create an object of type 'ConfigureStream' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ConfigureStream();
    // Destroy this object.

    // MANIPULATORS
    ConfigureStream& operator=(const ConfigureStream& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureStream& operator=(ConfigureStream&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& qId();
    // Return a reference to the modifiable "QId" attribute of this object.

    StreamParameters& streamParameters();
    // Return a reference to the modifiable "StreamParameters" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int qId() const;
    // Return the value of the "QId" attribute of this object.

    const StreamParameters& streamParameters() const;
    // Return a reference offering non-modifiable access to the
    // "StreamParameters" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ConfigureStream& lhs,
                           const ConfigureStream& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.qId() == rhs.qId() &&
               lhs.streamParameters() == rhs.streamParameters();
    }

    friend bool operator!=(const ConfigureStream& lhs,
                           const ConfigureStream& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&          stream,
                                    const ConfigureStream& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&      hashAlg,
                           const ConfigureStream& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ConfigureStream'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.qId());
        hashAppend(hashAlg, object.streamParameters());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ConfigureStream)

namespace bmqp_ctrlmsg {

// ============================
// class ClusterStateFSMMessage
// ============================

class ClusterStateFSMMessage {
    // This type is the top level type for any message being sent by a node
    // inside the cluster to one or more peer nodes that triggers an event in
    // the Cluster State FSM.  Note that this type of message is not sent
    // outside the cluster.
    // choice.: enumerates all the different types of cluster state messages

    // INSTANCE DATA
    ClusterStateFSMMessageChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterStateFSMMessage(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterStateFSMMessage' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ClusterStateFSMMessage(const ClusterStateFSMMessage& original,
                           bslma::Allocator*             basicAllocator = 0);
    // Create an object of type 'ClusterStateFSMMessage' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateFSMMessage(ClusterStateFSMMessage&& original) noexcept;
    // Create an object of type 'ClusterStateFSMMessage' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    ClusterStateFSMMessage(ClusterStateFSMMessage&& original,
                           bslma::Allocator*        basicAllocator);
    // Create an object of type 'ClusterStateFSMMessage' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~ClusterStateFSMMessage();
    // Destroy this object.

    // MANIPULATORS
    ClusterStateFSMMessage& operator=(const ClusterStateFSMMessage& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateFSMMessage& operator=(ClusterStateFSMMessage&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ClusterStateFSMMessageChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const ClusterStateFSMMessageChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterStateFSMMessage& lhs,
                           const ClusterStateFSMMessage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.choice() == rhs.choice();
    }

    friend bool operator!=(const ClusterStateFSMMessage& lhs,
                           const ClusterStateFSMMessage& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                 stream,
                                    const ClusterStateFSMMessage& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&             hashAlg,
                           const ClusterStateFSMMessage& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterStateFSMMessage'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.choice());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterStateFSMMessage)

namespace bmqp_ctrlmsg {

// =============================
// class ConfigureStreamResponse
// =============================

class ConfigureStreamResponse {
    // Response of a 'ConfigureStream' request, indicating success of the
    // operation.

    // INSTANCE DATA
    ConfigureStream d_request;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_REQUEST = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_REQUEST = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ConfigureStreamResponse(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ConfigureStreamResponse' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    ConfigureStreamResponse(const ConfigureStreamResponse& original,
                            bslma::Allocator*              basicAllocator = 0);
    // Create an object of type 'ConfigureStreamResponse' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureStreamResponse(ConfigureStreamResponse&& original) noexcept;
    // Create an object of type 'ConfigureStreamResponse' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    ConfigureStreamResponse(ConfigureStreamResponse&& original,
                            bslma::Allocator*         basicAllocator);
    // Create an object of type 'ConfigureStreamResponse' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~ConfigureStreamResponse();
    // Destroy this object.

    // MANIPULATORS
    ConfigureStreamResponse& operator=(const ConfigureStreamResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureStreamResponse& operator=(ConfigureStreamResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ConfigureStream& request();
    // Return a reference to the modifiable "Request" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const ConfigureStream& request() const;
    // Return a reference offering non-modifiable access to the "Request"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ConfigureStreamResponse& lhs,
                           const ConfigureStreamResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.request() == rhs.request();
    }

    friend bool operator!=(const ConfigureStreamResponse& lhs,
                           const ConfigureStreamResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                  stream,
                                    const ConfigureStreamResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&              hashAlg,
                           const ConfigureStreamResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ConfigureStreamResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.request());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ConfigureStreamResponse)

namespace bmqp_ctrlmsg {

// ==========================
// class ClusterMessageChoice
// ==========================

class ClusterMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<PartitionPrimaryAdvisory>
                                                    d_partitionPrimaryAdvisory;
        bsls::ObjectBuffer<LeaderAdvisory>          d_leaderAdvisory;
        bsls::ObjectBuffer<QueueAssignmentAdvisory> d_queueAssignmentAdvisory;
        bsls::ObjectBuffer<NodeStatusAdvisory>      d_nodeStatusAdvisory;
        bsls::ObjectBuffer<LeaderSyncStateQuery>    d_leaderSyncStateQuery;
        bsls::ObjectBuffer<LeaderSyncStateQueryResponse>
                                                d_leaderSyncStateQueryResponse;
        bsls::ObjectBuffer<LeaderSyncDataQuery> d_leaderSyncDataQuery;
        bsls::ObjectBuffer<LeaderSyncDataQueryResponse>
            d_leaderSyncDataQueryResponse;
        bsls::ObjectBuffer<QueueAssignmentRequest>  d_queueAssignmentRequest;
        bsls::ObjectBuffer<StorageSyncRequest>      d_storageSyncRequest;
        bsls::ObjectBuffer<StorageSyncResponse>     d_storageSyncResponse;
        bsls::ObjectBuffer<PartitionSyncStateQuery> d_partitionSyncStateQuery;
        bsls::ObjectBuffer<PartitionSyncStateQueryResponse>
            d_partitionSyncStateQueryResponse;
        bsls::ObjectBuffer<PartitionSyncDataQuery> d_partitionSyncDataQuery;
        bsls::ObjectBuffer<PartitionSyncDataQueryResponse>
            d_partitionSyncDataQueryResponse;
        bsls::ObjectBuffer<PartitionSyncDataQueryStatus>
            d_partitionSyncDataQueryStatus;
        bsls::ObjectBuffer<PrimaryStatusAdvisory> d_primaryStatusAdvisory;
        bsls::ObjectBuffer<ClusterSyncRequest>    d_clusterSyncRequest;
        bsls::ObjectBuffer<ClusterSyncResponse>   d_clusterSyncResponse;
        bsls::ObjectBuffer<QueueUnAssignmentAdvisory>
            d_queueUnAssignmentAdvisory;
        bsls::ObjectBuffer<QueueUnassignedAdvisory> d_queueUnassignedAdvisory;
        bsls::ObjectBuffer<LeaderAdvisoryAck>       d_leaderAdvisoryAck;
        bsls::ObjectBuffer<LeaderAdvisoryCommit>    d_leaderAdvisoryCommit;
        bsls::ObjectBuffer<StateNotification>       d_stateNotification;
        bsls::ObjectBuffer<StopRequest>             d_stopRequest;
        bsls::ObjectBuffer<StopResponse>            d_stopResponse;
        bsls::ObjectBuffer<QueueUnassignmentRequest>
                                                   d_queueUnassignmentRequest;
        bsls::ObjectBuffer<QueueUpdateAdvisory>    d_queueUpdateAdvisory;
        bsls::ObjectBuffer<ClusterStateFSMMessage> d_clusterStateFSMMessage;
        bsls::ObjectBuffer<PartitionMessage>       d_partitionMessage;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterMessageChoice& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                           = -1,
        SELECTION_ID_PARTITION_PRIMARY_ADVISORY          = 0,
        SELECTION_ID_LEADER_ADVISORY                     = 1,
        SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY           = 2,
        SELECTION_ID_NODE_STATUS_ADVISORY                = 3,
        SELECTION_ID_LEADER_SYNC_STATE_QUERY             = 4,
        SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE    = 5,
        SELECTION_ID_LEADER_SYNC_DATA_QUERY              = 6,
        SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE     = 7,
        SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST            = 8,
        SELECTION_ID_STORAGE_SYNC_REQUEST                = 9,
        SELECTION_ID_STORAGE_SYNC_RESPONSE               = 10,
        SELECTION_ID_PARTITION_SYNC_STATE_QUERY          = 11,
        SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE = 12,
        SELECTION_ID_PARTITION_SYNC_DATA_QUERY           = 13,
        SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE  = 14,
        SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS    = 15,
        SELECTION_ID_PRIMARY_STATUS_ADVISORY             = 16,
        SELECTION_ID_CLUSTER_SYNC_REQUEST                = 17,
        SELECTION_ID_CLUSTER_SYNC_RESPONSE               = 18,
        SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY        = 19,
        SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY           = 20,
        SELECTION_ID_LEADER_ADVISORY_ACK                 = 21,
        SELECTION_ID_LEADER_ADVISORY_COMMIT              = 22,
        SELECTION_ID_STATE_NOTIFICATION                  = 23,
        SELECTION_ID_STOP_REQUEST                        = 24,
        SELECTION_ID_STOP_RESPONSE                       = 25,
        SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST          = 26,
        SELECTION_ID_QUEUE_UPDATE_ADVISORY               = 27,
        SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE         = 28,
        SELECTION_ID_PARTITION_MESSAGE                   = 29
    };

    enum { NUM_SELECTIONS = 30 };

    enum {
        SELECTION_INDEX_PARTITION_PRIMARY_ADVISORY          = 0,
        SELECTION_INDEX_LEADER_ADVISORY                     = 1,
        SELECTION_INDEX_QUEUE_ASSIGNMENT_ADVISORY           = 2,
        SELECTION_INDEX_NODE_STATUS_ADVISORY                = 3,
        SELECTION_INDEX_LEADER_SYNC_STATE_QUERY             = 4,
        SELECTION_INDEX_LEADER_SYNC_STATE_QUERY_RESPONSE    = 5,
        SELECTION_INDEX_LEADER_SYNC_DATA_QUERY              = 6,
        SELECTION_INDEX_LEADER_SYNC_DATA_QUERY_RESPONSE     = 7,
        SELECTION_INDEX_QUEUE_ASSIGNMENT_REQUEST            = 8,
        SELECTION_INDEX_STORAGE_SYNC_REQUEST                = 9,
        SELECTION_INDEX_STORAGE_SYNC_RESPONSE               = 10,
        SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY          = 11,
        SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY_RESPONSE = 12,
        SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY           = 13,
        SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_RESPONSE  = 14,
        SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_STATUS    = 15,
        SELECTION_INDEX_PRIMARY_STATUS_ADVISORY             = 16,
        SELECTION_INDEX_CLUSTER_SYNC_REQUEST                = 17,
        SELECTION_INDEX_CLUSTER_SYNC_RESPONSE               = 18,
        SELECTION_INDEX_QUEUE_UN_ASSIGNMENT_ADVISORY        = 19,
        SELECTION_INDEX_QUEUE_UNASSIGNED_ADVISORY           = 20,
        SELECTION_INDEX_LEADER_ADVISORY_ACK                 = 21,
        SELECTION_INDEX_LEADER_ADVISORY_COMMIT              = 22,
        SELECTION_INDEX_STATE_NOTIFICATION                  = 23,
        SELECTION_INDEX_STOP_REQUEST                        = 24,
        SELECTION_INDEX_STOP_RESPONSE                       = 25,
        SELECTION_INDEX_QUEUE_UNASSIGNMENT_REQUEST          = 26,
        SELECTION_INDEX_QUEUE_UPDATE_ADVISORY               = 27,
        SELECTION_INDEX_CLUSTER_STATE_F_S_M_MESSAGE         = 28,
        SELECTION_INDEX_PARTITION_MESSAGE                   = 29
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterMessageChoice(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterMessageChoice' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ClusterMessageChoice(const ClusterMessageChoice& original,
                         bslma::Allocator*           basicAllocator = 0);
    // Create an object of type 'ClusterMessageChoice' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterMessageChoice(ClusterMessageChoice&& original) noexcept;
    // Create an object of type 'ClusterMessageChoice' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterMessageChoice(ClusterMessageChoice&& original,
                         bslma::Allocator*      basicAllocator);
    // Create an object of type 'ClusterMessageChoice' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterMessageChoice();
    // Destroy this object.

    // MANIPULATORS
    ClusterMessageChoice& operator=(const ClusterMessageChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterMessageChoice& operator=(ClusterMessageChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    PartitionPrimaryAdvisory& makePartitionPrimaryAdvisory();
    PartitionPrimaryAdvisory&
    makePartitionPrimaryAdvisory(const PartitionPrimaryAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionPrimaryAdvisory&
    makePartitionPrimaryAdvisory(PartitionPrimaryAdvisory&& value);
#endif
    // Set the value of this object to be a "PartitionPrimaryAdvisory"
    // value.  Optionally specify the 'value' of the
    // "PartitionPrimaryAdvisory".  If 'value' is not specified, the
    // default "PartitionPrimaryAdvisory" value is used.

    LeaderAdvisory& makeLeaderAdvisory();
    LeaderAdvisory& makeLeaderAdvisory(const LeaderAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderAdvisory& makeLeaderAdvisory(LeaderAdvisory&& value);
#endif
    // Set the value of this object to be a "LeaderAdvisory" value.
    // Optionally specify the 'value' of the "LeaderAdvisory".  If 'value'
    // is not specified, the default "LeaderAdvisory" value is used.

    QueueAssignmentAdvisory& makeQueueAssignmentAdvisory();
    QueueAssignmentAdvisory&
    makeQueueAssignmentAdvisory(const QueueAssignmentAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueAssignmentAdvisory&
    makeQueueAssignmentAdvisory(QueueAssignmentAdvisory&& value);
#endif
    // Set the value of this object to be a "QueueAssignmentAdvisory"
    // value.  Optionally specify the 'value' of the
    // "QueueAssignmentAdvisory".  If 'value' is not specified, the default
    // "QueueAssignmentAdvisory" value is used.

    NodeStatusAdvisory& makeNodeStatusAdvisory();
    NodeStatusAdvisory&
    makeNodeStatusAdvisory(const NodeStatusAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    NodeStatusAdvisory& makeNodeStatusAdvisory(NodeStatusAdvisory&& value);
#endif
    // Set the value of this object to be a "NodeStatusAdvisory" value.
    // Optionally specify the 'value' of the "NodeStatusAdvisory".  If
    // 'value' is not specified, the default "NodeStatusAdvisory" value is
    // used.

    LeaderSyncStateQuery& makeLeaderSyncStateQuery();
    LeaderSyncStateQuery&
    makeLeaderSyncStateQuery(const LeaderSyncStateQuery& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncStateQuery&
    makeLeaderSyncStateQuery(LeaderSyncStateQuery&& value);
#endif
    // Set the value of this object to be a "LeaderSyncStateQuery" value.
    // Optionally specify the 'value' of the "LeaderSyncStateQuery".  If
    // 'value' is not specified, the default "LeaderSyncStateQuery" value
    // is used.

    LeaderSyncStateQueryResponse& makeLeaderSyncStateQueryResponse();
    LeaderSyncStateQueryResponse& makeLeaderSyncStateQueryResponse(
        const LeaderSyncStateQueryResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncStateQueryResponse&
    makeLeaderSyncStateQueryResponse(LeaderSyncStateQueryResponse&& value);
#endif
    // Set the value of this object to be a "LeaderSyncStateQueryResponse"
    // value.  Optionally specify the 'value' of the
    // "LeaderSyncStateQueryResponse".  If 'value' is not specified, the
    // default "LeaderSyncStateQueryResponse" value is used.

    LeaderSyncDataQuery& makeLeaderSyncDataQuery();
    LeaderSyncDataQuery&
    makeLeaderSyncDataQuery(const LeaderSyncDataQuery& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncDataQuery& makeLeaderSyncDataQuery(LeaderSyncDataQuery&& value);
#endif
    // Set the value of this object to be a "LeaderSyncDataQuery" value.
    // Optionally specify the 'value' of the "LeaderSyncDataQuery".  If
    // 'value' is not specified, the default "LeaderSyncDataQuery" value is
    // used.

    LeaderSyncDataQueryResponse& makeLeaderSyncDataQueryResponse();
    LeaderSyncDataQueryResponse&
    makeLeaderSyncDataQueryResponse(const LeaderSyncDataQueryResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncDataQueryResponse&
    makeLeaderSyncDataQueryResponse(LeaderSyncDataQueryResponse&& value);
#endif
    // Set the value of this object to be a "LeaderSyncDataQueryResponse"
    // value.  Optionally specify the 'value' of the
    // "LeaderSyncDataQueryResponse".  If 'value' is not specified, the
    // default "LeaderSyncDataQueryResponse" value is used.

    QueueAssignmentRequest& makeQueueAssignmentRequest();
    QueueAssignmentRequest&
    makeQueueAssignmentRequest(const QueueAssignmentRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueAssignmentRequest&
    makeQueueAssignmentRequest(QueueAssignmentRequest&& value);
#endif
    // Set the value of this object to be a "QueueAssignmentRequest" value.
    //  Optionally specify the 'value' of the "QueueAssignmentRequest".  If
    // 'value' is not specified, the default "QueueAssignmentRequest" value
    // is used.

    StorageSyncRequest& makeStorageSyncRequest();
    StorageSyncRequest&
    makeStorageSyncRequest(const StorageSyncRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageSyncRequest& makeStorageSyncRequest(StorageSyncRequest&& value);
#endif
    // Set the value of this object to be a "StorageSyncRequest" value.
    // Optionally specify the 'value' of the "StorageSyncRequest".  If
    // 'value' is not specified, the default "StorageSyncRequest" value is
    // used.

    StorageSyncResponse& makeStorageSyncResponse();
    StorageSyncResponse&
    makeStorageSyncResponse(const StorageSyncResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageSyncResponse& makeStorageSyncResponse(StorageSyncResponse&& value);
#endif
    // Set the value of this object to be a "StorageSyncResponse" value.
    // Optionally specify the 'value' of the "StorageSyncResponse".  If
    // 'value' is not specified, the default "StorageSyncResponse" value is
    // used.

    PartitionSyncStateQuery& makePartitionSyncStateQuery();
    PartitionSyncStateQuery&
    makePartitionSyncStateQuery(const PartitionSyncStateQuery& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncStateQuery&
    makePartitionSyncStateQuery(PartitionSyncStateQuery&& value);
#endif
    // Set the value of this object to be a "PartitionSyncStateQuery"
    // value.  Optionally specify the 'value' of the
    // "PartitionSyncStateQuery".  If 'value' is not specified, the default
    // "PartitionSyncStateQuery" value is used.

    PartitionSyncStateQueryResponse& makePartitionSyncStateQueryResponse();
    PartitionSyncStateQueryResponse& makePartitionSyncStateQueryResponse(
        const PartitionSyncStateQueryResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncStateQueryResponse& makePartitionSyncStateQueryResponse(
        PartitionSyncStateQueryResponse&& value);
#endif
    // Set the value of this object to be a
    // "PartitionSyncStateQueryResponse" value.  Optionally specify the
    // 'value' of the "PartitionSyncStateQueryResponse".  If 'value' is not
    // specified, the default "PartitionSyncStateQueryResponse" value is
    // used.

    PartitionSyncDataQuery& makePartitionSyncDataQuery();
    PartitionSyncDataQuery&
    makePartitionSyncDataQuery(const PartitionSyncDataQuery& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncDataQuery&
    makePartitionSyncDataQuery(PartitionSyncDataQuery&& value);
#endif
    // Set the value of this object to be a "PartitionSyncDataQuery" value.
    //  Optionally specify the 'value' of the "PartitionSyncDataQuery".  If
    // 'value' is not specified, the default "PartitionSyncDataQuery" value
    // is used.

    PartitionSyncDataQueryResponse& makePartitionSyncDataQueryResponse();
    PartitionSyncDataQueryResponse& makePartitionSyncDataQueryResponse(
        const PartitionSyncDataQueryResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncDataQueryResponse&
    makePartitionSyncDataQueryResponse(PartitionSyncDataQueryResponse&& value);
#endif
    // Set the value of this object to be a
    // "PartitionSyncDataQueryResponse" value.  Optionally specify the
    // 'value' of the "PartitionSyncDataQueryResponse".  If 'value' is not
    // specified, the default "PartitionSyncDataQueryResponse" value is
    // used.

    PartitionSyncDataQueryStatus& makePartitionSyncDataQueryStatus();
    PartitionSyncDataQueryStatus& makePartitionSyncDataQueryStatus(
        const PartitionSyncDataQueryStatus& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncDataQueryStatus&
    makePartitionSyncDataQueryStatus(PartitionSyncDataQueryStatus&& value);
#endif
    // Set the value of this object to be a "PartitionSyncDataQueryStatus"
    // value.  Optionally specify the 'value' of the
    // "PartitionSyncDataQueryStatus".  If 'value' is not specified, the
    // default "PartitionSyncDataQueryStatus" value is used.

    PrimaryStatusAdvisory& makePrimaryStatusAdvisory();
    PrimaryStatusAdvisory&
    makePrimaryStatusAdvisory(const PrimaryStatusAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PrimaryStatusAdvisory&
    makePrimaryStatusAdvisory(PrimaryStatusAdvisory&& value);
#endif
    // Set the value of this object to be a "PrimaryStatusAdvisory" value.
    // Optionally specify the 'value' of the "PrimaryStatusAdvisory".  If
    // 'value' is not specified, the default "PrimaryStatusAdvisory" value
    // is used.

    ClusterSyncRequest& makeClusterSyncRequest();
    ClusterSyncRequest&
    makeClusterSyncRequest(const ClusterSyncRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterSyncRequest& makeClusterSyncRequest(ClusterSyncRequest&& value);
#endif
    // Set the value of this object to be a "ClusterSyncRequest" value.
    // Optionally specify the 'value' of the "ClusterSyncRequest".  If
    // 'value' is not specified, the default "ClusterSyncRequest" value is
    // used.

    ClusterSyncResponse& makeClusterSyncResponse();
    ClusterSyncResponse&
    makeClusterSyncResponse(const ClusterSyncResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterSyncResponse& makeClusterSyncResponse(ClusterSyncResponse&& value);
#endif
    // Set the value of this object to be a "ClusterSyncResponse" value.
    // Optionally specify the 'value' of the "ClusterSyncResponse".  If
    // 'value' is not specified, the default "ClusterSyncResponse" value is
    // used.

    QueueUnAssignmentAdvisory& makeQueueUnAssignmentAdvisory();
    QueueUnAssignmentAdvisory&
    makeQueueUnAssignmentAdvisory(const QueueUnAssignmentAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnAssignmentAdvisory&
    makeQueueUnAssignmentAdvisory(QueueUnAssignmentAdvisory&& value);
#endif
    // Set the value of this object to be a "QueueUnAssignmentAdvisory"
    // value.  Optionally specify the 'value' of the
    // "QueueUnAssignmentAdvisory".  If 'value' is not specified, the
    // default "QueueUnAssignmentAdvisory" value is used.

    QueueUnassignedAdvisory& makeQueueUnassignedAdvisory();
    QueueUnassignedAdvisory&
    makeQueueUnassignedAdvisory(const QueueUnassignedAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnassignedAdvisory&
    makeQueueUnassignedAdvisory(QueueUnassignedAdvisory&& value);
#endif
    // Set the value of this object to be a "QueueUnassignedAdvisory"
    // value.  Optionally specify the 'value' of the
    // "QueueUnassignedAdvisory".  If 'value' is not specified, the default
    // "QueueUnassignedAdvisory" value is used.

    LeaderAdvisoryAck& makeLeaderAdvisoryAck();
    LeaderAdvisoryAck& makeLeaderAdvisoryAck(const LeaderAdvisoryAck& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderAdvisoryAck& makeLeaderAdvisoryAck(LeaderAdvisoryAck&& value);
#endif
    // Set the value of this object to be a "LeaderAdvisoryAck" value.
    // Optionally specify the 'value' of the "LeaderAdvisoryAck".  If
    // 'value' is not specified, the default "LeaderAdvisoryAck" value is
    // used.

    LeaderAdvisoryCommit& makeLeaderAdvisoryCommit();
    LeaderAdvisoryCommit&
    makeLeaderAdvisoryCommit(const LeaderAdvisoryCommit& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderAdvisoryCommit&
    makeLeaderAdvisoryCommit(LeaderAdvisoryCommit&& value);
#endif
    // Set the value of this object to be a "LeaderAdvisoryCommit" value.
    // Optionally specify the 'value' of the "LeaderAdvisoryCommit".  If
    // 'value' is not specified, the default "LeaderAdvisoryCommit" value
    // is used.

    StateNotification& makeStateNotification();
    StateNotification& makeStateNotification(const StateNotification& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StateNotification& makeStateNotification(StateNotification&& value);
#endif
    // Set the value of this object to be a "StateNotification" value.
    // Optionally specify the 'value' of the "StateNotification".  If
    // 'value' is not specified, the default "StateNotification" value is
    // used.

    StopRequest& makeStopRequest();
    StopRequest& makeStopRequest(const StopRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StopRequest& makeStopRequest(StopRequest&& value);
#endif
    // Set the value of this object to be a "StopRequest" value.
    // Optionally specify the 'value' of the "StopRequest".  If 'value' is
    // not specified, the default "StopRequest" value is used.

    StopResponse& makeStopResponse();
    StopResponse& makeStopResponse(const StopResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StopResponse& makeStopResponse(StopResponse&& value);
#endif
    // Set the value of this object to be a "StopResponse" value.
    // Optionally specify the 'value' of the "StopResponse".  If 'value' is
    // not specified, the default "StopResponse" value is used.

    QueueUnassignmentRequest& makeQueueUnassignmentRequest();
    QueueUnassignmentRequest&
    makeQueueUnassignmentRequest(const QueueUnassignmentRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnassignmentRequest&
    makeQueueUnassignmentRequest(QueueUnassignmentRequest&& value);
#endif
    // Set the value of this object to be a "QueueUnassignmentRequest"
    // value.  Optionally specify the 'value' of the
    // "QueueUnassignmentRequest".  If 'value' is not specified, the
    // default "QueueUnassignmentRequest" value is used.

    QueueUpdateAdvisory& makeQueueUpdateAdvisory();
    QueueUpdateAdvisory&
    makeQueueUpdateAdvisory(const QueueUpdateAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUpdateAdvisory& makeQueueUpdateAdvisory(QueueUpdateAdvisory&& value);
#endif
    // Set the value of this object to be a "QueueUpdateAdvisory" value.
    // Optionally specify the 'value' of the "QueueUpdateAdvisory".  If
    // 'value' is not specified, the default "QueueUpdateAdvisory" value is
    // used.

    ClusterStateFSMMessage& makeClusterStateFSMMessage();
    ClusterStateFSMMessage&
    makeClusterStateFSMMessage(const ClusterStateFSMMessage& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateFSMMessage&
    makeClusterStateFSMMessage(ClusterStateFSMMessage&& value);
#endif
    // Set the value of this object to be a "ClusterStateFSMMessage" value.
    //  Optionally specify the 'value' of the "ClusterStateFSMMessage".  If
    // 'value' is not specified, the default "ClusterStateFSMMessage" value
    // is used.

    PartitionMessage& makePartitionMessage();
    PartitionMessage& makePartitionMessage(const PartitionMessage& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionMessage& makePartitionMessage(PartitionMessage&& value);
#endif
    // Set the value of this object to be a "PartitionMessage" value.
    // Optionally specify the 'value' of the "PartitionMessage".  If
    // 'value' is not specified, the default "PartitionMessage" value is
    // used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    PartitionPrimaryAdvisory& partitionPrimaryAdvisory();
    // Return a reference to the modifiable "PartitionPrimaryAdvisory"
    // selection of this object if "PartitionPrimaryAdvisory" is the
    // current selection.  The behavior is undefined unless
    // "PartitionPrimaryAdvisory" is the selection of this object.

    LeaderAdvisory& leaderAdvisory();
    // Return a reference to the modifiable "LeaderAdvisory" selection of
    // this object if "LeaderAdvisory" is the current selection.  The
    // behavior is undefined unless "LeaderAdvisory" is the selection of
    // this object.

    QueueAssignmentAdvisory& queueAssignmentAdvisory();
    // Return a reference to the modifiable "QueueAssignmentAdvisory"
    // selection of this object if "QueueAssignmentAdvisory" is the current
    // selection.  The behavior is undefined unless
    // "QueueAssignmentAdvisory" is the selection of this object.

    NodeStatusAdvisory& nodeStatusAdvisory();
    // Return a reference to the modifiable "NodeStatusAdvisory" selection
    // of this object if "NodeStatusAdvisory" is the current selection.
    // The behavior is undefined unless "NodeStatusAdvisory" is the
    // selection of this object.

    LeaderSyncStateQuery& leaderSyncStateQuery();
    // Return a reference to the modifiable "LeaderSyncStateQuery"
    // selection of this object if "LeaderSyncStateQuery" is the current
    // selection.  The behavior is undefined unless "LeaderSyncStateQuery"
    // is the selection of this object.

    LeaderSyncStateQueryResponse& leaderSyncStateQueryResponse();
    // Return a reference to the modifiable "LeaderSyncStateQueryResponse"
    // selection of this object if "LeaderSyncStateQueryResponse" is the
    // current selection.  The behavior is undefined unless
    // "LeaderSyncStateQueryResponse" is the selection of this object.

    LeaderSyncDataQuery& leaderSyncDataQuery();
    // Return a reference to the modifiable "LeaderSyncDataQuery" selection
    // of this object if "LeaderSyncDataQuery" is the current selection.
    // The behavior is undefined unless "LeaderSyncDataQuery" is the
    // selection of this object.

    LeaderSyncDataQueryResponse& leaderSyncDataQueryResponse();
    // Return a reference to the modifiable "LeaderSyncDataQueryResponse"
    // selection of this object if "LeaderSyncDataQueryResponse" is the
    // current selection.  The behavior is undefined unless
    // "LeaderSyncDataQueryResponse" is the selection of this object.

    QueueAssignmentRequest& queueAssignmentRequest();
    // Return a reference to the modifiable "QueueAssignmentRequest"
    // selection of this object if "QueueAssignmentRequest" is the current
    // selection.  The behavior is undefined unless
    // "QueueAssignmentRequest" is the selection of this object.

    StorageSyncRequest& storageSyncRequest();
    // Return a reference to the modifiable "StorageSyncRequest" selection
    // of this object if "StorageSyncRequest" is the current selection.
    // The behavior is undefined unless "StorageSyncRequest" is the
    // selection of this object.

    StorageSyncResponse& storageSyncResponse();
    // Return a reference to the modifiable "StorageSyncResponse" selection
    // of this object if "StorageSyncResponse" is the current selection.
    // The behavior is undefined unless "StorageSyncResponse" is the
    // selection of this object.

    PartitionSyncStateQuery& partitionSyncStateQuery();
    // Return a reference to the modifiable "PartitionSyncStateQuery"
    // selection of this object if "PartitionSyncStateQuery" is the current
    // selection.  The behavior is undefined unless
    // "PartitionSyncStateQuery" is the selection of this object.

    PartitionSyncStateQueryResponse& partitionSyncStateQueryResponse();
    // Return a reference to the modifiable
    // "PartitionSyncStateQueryResponse" selection of this object if
    // "PartitionSyncStateQueryResponse" is the current selection.  The
    // behavior is undefined unless "PartitionSyncStateQueryResponse" is
    // the selection of this object.

    PartitionSyncDataQuery& partitionSyncDataQuery();
    // Return a reference to the modifiable "PartitionSyncDataQuery"
    // selection of this object if "PartitionSyncDataQuery" is the current
    // selection.  The behavior is undefined unless
    // "PartitionSyncDataQuery" is the selection of this object.

    PartitionSyncDataQueryResponse& partitionSyncDataQueryResponse();
    // Return a reference to the modifiable
    // "PartitionSyncDataQueryResponse" selection of this object if
    // "PartitionSyncDataQueryResponse" is the current selection.  The
    // behavior is undefined unless "PartitionSyncDataQueryResponse" is the
    // selection of this object.

    PartitionSyncDataQueryStatus& partitionSyncDataQueryStatus();
    // Return a reference to the modifiable "PartitionSyncDataQueryStatus"
    // selection of this object if "PartitionSyncDataQueryStatus" is the
    // current selection.  The behavior is undefined unless
    // "PartitionSyncDataQueryStatus" is the selection of this object.

    PrimaryStatusAdvisory& primaryStatusAdvisory();
    // Return a reference to the modifiable "PrimaryStatusAdvisory"
    // selection of this object if "PrimaryStatusAdvisory" is the current
    // selection.  The behavior is undefined unless "PrimaryStatusAdvisory"
    // is the selection of this object.

    ClusterSyncRequest& clusterSyncRequest();
    // Return a reference to the modifiable "ClusterSyncRequest" selection
    // of this object if "ClusterSyncRequest" is the current selection.
    // The behavior is undefined unless "ClusterSyncRequest" is the
    // selection of this object.

    ClusterSyncResponse& clusterSyncResponse();
    // Return a reference to the modifiable "ClusterSyncResponse" selection
    // of this object if "ClusterSyncResponse" is the current selection.
    // The behavior is undefined unless "ClusterSyncResponse" is the
    // selection of this object.

    QueueUnAssignmentAdvisory& queueUnAssignmentAdvisory();
    // Return a reference to the modifiable "QueueUnAssignmentAdvisory"
    // selection of this object if "QueueUnAssignmentAdvisory" is the
    // current selection.  The behavior is undefined unless
    // "QueueUnAssignmentAdvisory" is the selection of this object.

    QueueUnassignedAdvisory& queueUnassignedAdvisory();
    // Return a reference to the modifiable "QueueUnassignedAdvisory"
    // selection of this object if "QueueUnassignedAdvisory" is the current
    // selection.  The behavior is undefined unless
    // "QueueUnassignedAdvisory" is the selection of this object.

    LeaderAdvisoryAck& leaderAdvisoryAck();
    // Return a reference to the modifiable "LeaderAdvisoryAck" selection
    // of this object if "LeaderAdvisoryAck" is the current selection.  The
    // behavior is undefined unless "LeaderAdvisoryAck" is the selection of
    // this object.

    LeaderAdvisoryCommit& leaderAdvisoryCommit();
    // Return a reference to the modifiable "LeaderAdvisoryCommit"
    // selection of this object if "LeaderAdvisoryCommit" is the current
    // selection.  The behavior is undefined unless "LeaderAdvisoryCommit"
    // is the selection of this object.

    StateNotification& stateNotification();
    // Return a reference to the modifiable "StateNotification" selection
    // of this object if "StateNotification" is the current selection.  The
    // behavior is undefined unless "StateNotification" is the selection of
    // this object.

    StopRequest& stopRequest();
    // Return a reference to the modifiable "StopRequest" selection of this
    // object if "StopRequest" is the current selection.  The behavior is
    // undefined unless "StopRequest" is the selection of this object.

    StopResponse& stopResponse();
    // Return a reference to the modifiable "StopResponse" selection of
    // this object if "StopResponse" is the current selection.  The
    // behavior is undefined unless "StopResponse" is the selection of this
    // object.

    QueueUnassignmentRequest& queueUnassignmentRequest();
    // Return a reference to the modifiable "QueueUnassignmentRequest"
    // selection of this object if "QueueUnassignmentRequest" is the
    // current selection.  The behavior is undefined unless
    // "QueueUnassignmentRequest" is the selection of this object.

    QueueUpdateAdvisory& queueUpdateAdvisory();
    // Return a reference to the modifiable "QueueUpdateAdvisory" selection
    // of this object if "QueueUpdateAdvisory" is the current selection.
    // The behavior is undefined unless "QueueUpdateAdvisory" is the
    // selection of this object.

    ClusterStateFSMMessage& clusterStateFSMMessage();
    // Return a reference to the modifiable "ClusterStateFSMMessage"
    // selection of this object if "ClusterStateFSMMessage" is the current
    // selection.  The behavior is undefined unless
    // "ClusterStateFSMMessage" is the selection of this object.

    PartitionMessage& partitionMessage();
    // Return a reference to the modifiable "PartitionMessage" selection of
    // this object if "PartitionMessage" is the current selection.  The
    // behavior is undefined unless "PartitionMessage" is the selection of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const PartitionPrimaryAdvisory& partitionPrimaryAdvisory() const;
    // Return a reference to the non-modifiable "PartitionPrimaryAdvisory"
    // selection of this object if "PartitionPrimaryAdvisory" is the
    // current selection.  The behavior is undefined unless
    // "PartitionPrimaryAdvisory" is the selection of this object.

    const LeaderAdvisory& leaderAdvisory() const;
    // Return a reference to the non-modifiable "LeaderAdvisory" selection
    // of this object if "LeaderAdvisory" is the current selection.  The
    // behavior is undefined unless "LeaderAdvisory" is the selection of
    // this object.

    const QueueAssignmentAdvisory& queueAssignmentAdvisory() const;
    // Return a reference to the non-modifiable "QueueAssignmentAdvisory"
    // selection of this object if "QueueAssignmentAdvisory" is the current
    // selection.  The behavior is undefined unless
    // "QueueAssignmentAdvisory" is the selection of this object.

    const NodeStatusAdvisory& nodeStatusAdvisory() const;
    // Return a reference to the non-modifiable "NodeStatusAdvisory"
    // selection of this object if "NodeStatusAdvisory" is the current
    // selection.  The behavior is undefined unless "NodeStatusAdvisory" is
    // the selection of this object.

    const LeaderSyncStateQuery& leaderSyncStateQuery() const;
    // Return a reference to the non-modifiable "LeaderSyncStateQuery"
    // selection of this object if "LeaderSyncStateQuery" is the current
    // selection.  The behavior is undefined unless "LeaderSyncStateQuery"
    // is the selection of this object.

    const LeaderSyncStateQueryResponse& leaderSyncStateQueryResponse() const;
    // Return a reference to the non-modifiable
    // "LeaderSyncStateQueryResponse" selection of this object if
    // "LeaderSyncStateQueryResponse" is the current selection.  The
    // behavior is undefined unless "LeaderSyncStateQueryResponse" is the
    // selection of this object.

    const LeaderSyncDataQuery& leaderSyncDataQuery() const;
    // Return a reference to the non-modifiable "LeaderSyncDataQuery"
    // selection of this object if "LeaderSyncDataQuery" is the current
    // selection.  The behavior is undefined unless "LeaderSyncDataQuery"
    // is the selection of this object.

    const LeaderSyncDataQueryResponse& leaderSyncDataQueryResponse() const;
    // Return a reference to the non-modifiable
    // "LeaderSyncDataQueryResponse" selection of this object if
    // "LeaderSyncDataQueryResponse" is the current selection.  The
    // behavior is undefined unless "LeaderSyncDataQueryResponse" is the
    // selection of this object.

    const QueueAssignmentRequest& queueAssignmentRequest() const;
    // Return a reference to the non-modifiable "QueueAssignmentRequest"
    // selection of this object if "QueueAssignmentRequest" is the current
    // selection.  The behavior is undefined unless
    // "QueueAssignmentRequest" is the selection of this object.

    const StorageSyncRequest& storageSyncRequest() const;
    // Return a reference to the non-modifiable "StorageSyncRequest"
    // selection of this object if "StorageSyncRequest" is the current
    // selection.  The behavior is undefined unless "StorageSyncRequest" is
    // the selection of this object.

    const StorageSyncResponse& storageSyncResponse() const;
    // Return a reference to the non-modifiable "StorageSyncResponse"
    // selection of this object if "StorageSyncResponse" is the current
    // selection.  The behavior is undefined unless "StorageSyncResponse"
    // is the selection of this object.

    const PartitionSyncStateQuery& partitionSyncStateQuery() const;
    // Return a reference to the non-modifiable "PartitionSyncStateQuery"
    // selection of this object if "PartitionSyncStateQuery" is the current
    // selection.  The behavior is undefined unless
    // "PartitionSyncStateQuery" is the selection of this object.

    const PartitionSyncStateQueryResponse&
    partitionSyncStateQueryResponse() const;
    // Return a reference to the non-modifiable
    // "PartitionSyncStateQueryResponse" selection of this object if
    // "PartitionSyncStateQueryResponse" is the current selection.  The
    // behavior is undefined unless "PartitionSyncStateQueryResponse" is
    // the selection of this object.

    const PartitionSyncDataQuery& partitionSyncDataQuery() const;
    // Return a reference to the non-modifiable "PartitionSyncDataQuery"
    // selection of this object if "PartitionSyncDataQuery" is the current
    // selection.  The behavior is undefined unless
    // "PartitionSyncDataQuery" is the selection of this object.

    const PartitionSyncDataQueryResponse&
    partitionSyncDataQueryResponse() const;
    // Return a reference to the non-modifiable
    // "PartitionSyncDataQueryResponse" selection of this object if
    // "PartitionSyncDataQueryResponse" is the current selection.  The
    // behavior is undefined unless "PartitionSyncDataQueryResponse" is the
    // selection of this object.

    const PartitionSyncDataQueryStatus& partitionSyncDataQueryStatus() const;
    // Return a reference to the non-modifiable
    // "PartitionSyncDataQueryStatus" selection of this object if
    // "PartitionSyncDataQueryStatus" is the current selection.  The
    // behavior is undefined unless "PartitionSyncDataQueryStatus" is the
    // selection of this object.

    const PrimaryStatusAdvisory& primaryStatusAdvisory() const;
    // Return a reference to the non-modifiable "PrimaryStatusAdvisory"
    // selection of this object if "PrimaryStatusAdvisory" is the current
    // selection.  The behavior is undefined unless "PrimaryStatusAdvisory"
    // is the selection of this object.

    const ClusterSyncRequest& clusterSyncRequest() const;
    // Return a reference to the non-modifiable "ClusterSyncRequest"
    // selection of this object if "ClusterSyncRequest" is the current
    // selection.  The behavior is undefined unless "ClusterSyncRequest" is
    // the selection of this object.

    const ClusterSyncResponse& clusterSyncResponse() const;
    // Return a reference to the non-modifiable "ClusterSyncResponse"
    // selection of this object if "ClusterSyncResponse" is the current
    // selection.  The behavior is undefined unless "ClusterSyncResponse"
    // is the selection of this object.

    const QueueUnAssignmentAdvisory& queueUnAssignmentAdvisory() const;
    // Return a reference to the non-modifiable "QueueUnAssignmentAdvisory"
    // selection of this object if "QueueUnAssignmentAdvisory" is the
    // current selection.  The behavior is undefined unless
    // "QueueUnAssignmentAdvisory" is the selection of this object.

    const QueueUnassignedAdvisory& queueUnassignedAdvisory() const;
    // Return a reference to the non-modifiable "QueueUnassignedAdvisory"
    // selection of this object if "QueueUnassignedAdvisory" is the current
    // selection.  The behavior is undefined unless
    // "QueueUnassignedAdvisory" is the selection of this object.

    const LeaderAdvisoryAck& leaderAdvisoryAck() const;
    // Return a reference to the non-modifiable "LeaderAdvisoryAck"
    // selection of this object if "LeaderAdvisoryAck" is the current
    // selection.  The behavior is undefined unless "LeaderAdvisoryAck" is
    // the selection of this object.

    const LeaderAdvisoryCommit& leaderAdvisoryCommit() const;
    // Return a reference to the non-modifiable "LeaderAdvisoryCommit"
    // selection of this object if "LeaderAdvisoryCommit" is the current
    // selection.  The behavior is undefined unless "LeaderAdvisoryCommit"
    // is the selection of this object.

    const StateNotification& stateNotification() const;
    // Return a reference to the non-modifiable "StateNotification"
    // selection of this object if "StateNotification" is the current
    // selection.  The behavior is undefined unless "StateNotification" is
    // the selection of this object.

    const StopRequest& stopRequest() const;
    // Return a reference to the non-modifiable "StopRequest" selection of
    // this object if "StopRequest" is the current selection.  The behavior
    // is undefined unless "StopRequest" is the selection of this object.

    const StopResponse& stopResponse() const;
    // Return a reference to the non-modifiable "StopResponse" selection of
    // this object if "StopResponse" is the current selection.  The
    // behavior is undefined unless "StopResponse" is the selection of this
    // object.

    const QueueUnassignmentRequest& queueUnassignmentRequest() const;
    // Return a reference to the non-modifiable "QueueUnassignmentRequest"
    // selection of this object if "QueueUnassignmentRequest" is the
    // current selection.  The behavior is undefined unless
    // "QueueUnassignmentRequest" is the selection of this object.

    const QueueUpdateAdvisory& queueUpdateAdvisory() const;
    // Return a reference to the non-modifiable "QueueUpdateAdvisory"
    // selection of this object if "QueueUpdateAdvisory" is the current
    // selection.  The behavior is undefined unless "QueueUpdateAdvisory"
    // is the selection of this object.

    const ClusterStateFSMMessage& clusterStateFSMMessage() const;
    // Return a reference to the non-modifiable "ClusterStateFSMMessage"
    // selection of this object if "ClusterStateFSMMessage" is the current
    // selection.  The behavior is undefined unless
    // "ClusterStateFSMMessage" is the selection of this object.

    const PartitionMessage& partitionMessage() const;
    // Return a reference to the non-modifiable "PartitionMessage"
    // selection of this object if "PartitionMessage" is the current
    // selection.  The behavior is undefined unless "PartitionMessage" is
    // the selection of this object.

    bool isPartitionPrimaryAdvisoryValue() const;
    // Return 'true' if the value of this object is a
    // "PartitionPrimaryAdvisory" value, and return 'false' otherwise.

    bool isLeaderAdvisoryValue() const;
    // Return 'true' if the value of this object is a "LeaderAdvisory"
    // value, and return 'false' otherwise.

    bool isQueueAssignmentAdvisoryValue() const;
    // Return 'true' if the value of this object is a
    // "QueueAssignmentAdvisory" value, and return 'false' otherwise.

    bool isNodeStatusAdvisoryValue() const;
    // Return 'true' if the value of this object is a "NodeStatusAdvisory"
    // value, and return 'false' otherwise.

    bool isLeaderSyncStateQueryValue() const;
    // Return 'true' if the value of this object is a
    // "LeaderSyncStateQuery" value, and return 'false' otherwise.

    bool isLeaderSyncStateQueryResponseValue() const;
    // Return 'true' if the value of this object is a
    // "LeaderSyncStateQueryResponse" value, and return 'false' otherwise.

    bool isLeaderSyncDataQueryValue() const;
    // Return 'true' if the value of this object is a "LeaderSyncDataQuery"
    // value, and return 'false' otherwise.

    bool isLeaderSyncDataQueryResponseValue() const;
    // Return 'true' if the value of this object is a
    // "LeaderSyncDataQueryResponse" value, and return 'false' otherwise.

    bool isQueueAssignmentRequestValue() const;
    // Return 'true' if the value of this object is a
    // "QueueAssignmentRequest" value, and return 'false' otherwise.

    bool isStorageSyncRequestValue() const;
    // Return 'true' if the value of this object is a "StorageSyncRequest"
    // value, and return 'false' otherwise.

    bool isStorageSyncResponseValue() const;
    // Return 'true' if the value of this object is a "StorageSyncResponse"
    // value, and return 'false' otherwise.

    bool isPartitionSyncStateQueryValue() const;
    // Return 'true' if the value of this object is a
    // "PartitionSyncStateQuery" value, and return 'false' otherwise.

    bool isPartitionSyncStateQueryResponseValue() const;
    // Return 'true' if the value of this object is a
    // "PartitionSyncStateQueryResponse" value, and return 'false'
    // otherwise.

    bool isPartitionSyncDataQueryValue() const;
    // Return 'true' if the value of this object is a
    // "PartitionSyncDataQuery" value, and return 'false' otherwise.

    bool isPartitionSyncDataQueryResponseValue() const;
    // Return 'true' if the value of this object is a
    // "PartitionSyncDataQueryResponse" value, and return 'false'
    // otherwise.

    bool isPartitionSyncDataQueryStatusValue() const;
    // Return 'true' if the value of this object is a
    // "PartitionSyncDataQueryStatus" value, and return 'false' otherwise.

    bool isPrimaryStatusAdvisoryValue() const;
    // Return 'true' if the value of this object is a
    // "PrimaryStatusAdvisory" value, and return 'false' otherwise.

    bool isClusterSyncRequestValue() const;
    // Return 'true' if the value of this object is a "ClusterSyncRequest"
    // value, and return 'false' otherwise.

    bool isClusterSyncResponseValue() const;
    // Return 'true' if the value of this object is a "ClusterSyncResponse"
    // value, and return 'false' otherwise.

    bool isQueueUnAssignmentAdvisoryValue() const;
    // Return 'true' if the value of this object is a
    // "QueueUnAssignmentAdvisory" value, and return 'false' otherwise.

    bool isQueueUnassignedAdvisoryValue() const;
    // Return 'true' if the value of this object is a
    // "QueueUnassignedAdvisory" value, and return 'false' otherwise.

    bool isLeaderAdvisoryAckValue() const;
    // Return 'true' if the value of this object is a "LeaderAdvisoryAck"
    // value, and return 'false' otherwise.

    bool isLeaderAdvisoryCommitValue() const;
    // Return 'true' if the value of this object is a
    // "LeaderAdvisoryCommit" value, and return 'false' otherwise.

    bool isStateNotificationValue() const;
    // Return 'true' if the value of this object is a "StateNotification"
    // value, and return 'false' otherwise.

    bool isStopRequestValue() const;
    // Return 'true' if the value of this object is a "StopRequest" value,
    // and return 'false' otherwise.

    bool isStopResponseValue() const;
    // Return 'true' if the value of this object is a "StopResponse" value,
    // and return 'false' otherwise.

    bool isQueueUnassignmentRequestValue() const;
    // Return 'true' if the value of this object is a
    // "QueueUnassignmentRequest" value, and return 'false' otherwise.

    bool isQueueUpdateAdvisoryValue() const;
    // Return 'true' if the value of this object is a "QueueUpdateAdvisory"
    // value, and return 'false' otherwise.

    bool isClusterStateFSMMessageValue() const;
    // Return 'true' if the value of this object is a
    // "ClusterStateFSMMessage" value, and return 'false' otherwise.

    bool isPartitionMessageValue() const;
    // Return 'true' if the value of this object is a "PartitionMessage"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterMessageChoice& lhs,
                           const ClusterMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ClusterMessageChoice' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterMessageChoice& lhs,
                           const ClusterMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const ClusterMessageChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const ClusterMessageChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterMessageChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterMessageChoice)

namespace bmqp_ctrlmsg {

// ====================
// class ClusterMessage
// ====================

class ClusterMessage {
    // This type is the top level type for any message being sent by a node
    // inside the cluster to one or more peer nodes.  Note that this type of
    // message is not sent outside the cluster.
    // choice.: enumerates all the different types of cluster messages

    // INSTANCE DATA
    ClusterMessageChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterMessage(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterMessage' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterMessage(const ClusterMessage& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'ClusterMessage' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterMessage(ClusterMessage&& original) noexcept;
    // Create an object of type 'ClusterMessage' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterMessage(ClusterMessage&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterMessage' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterMessage();
    // Destroy this object.

    // MANIPULATORS
    ClusterMessage& operator=(const ClusterMessage& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterMessage& operator=(ClusterMessage&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ClusterMessageChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const ClusterMessageChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterMessage& lhs,
                           const ClusterMessage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.choice() == rhs.choice();
    }

    friend bool operator!=(const ClusterMessage& lhs,
                           const ClusterMessage& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const ClusterMessage& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const ClusterMessage& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterMessage'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.choice());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterMessage)

namespace bmqp_ctrlmsg {

// ==========================
// class ControlMessageChoice
// ==========================

class ControlMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Status>               d_status;
        bsls::ObjectBuffer<Disconnect>           d_disconnect;
        bsls::ObjectBuffer<DisconnectResponse>   d_disconnectResponse;
        bsls::ObjectBuffer<AdminCommand>         d_adminCommand;
        bsls::ObjectBuffer<AdminCommandResponse> d_adminCommandResponse;
        bsls::ObjectBuffer<ClusterMessage>       d_clusterMessage;
        bsls::ObjectBuffer<OpenQueue>            d_openQueue;
        bsls::ObjectBuffer<OpenQueueResponse>    d_openQueueResponse;
        bsls::ObjectBuffer<CloseQueue>           d_closeQueue;
        bsls::ObjectBuffer<CloseQueueResponse>   d_closeQueueResponse;
        bsls::ObjectBuffer<ConfigureQueueStream> d_configureQueueStream;
        bsls::ObjectBuffer<ConfigureQueueStreamResponse>
                                            d_configureQueueStreamResponse;
        bsls::ObjectBuffer<ConfigureStream> d_configureStream;
        bsls::ObjectBuffer<ConfigureStreamResponse> d_configureStreamResponse;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ControlMessageChoice& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                       = -1,
        SELECTION_ID_STATUS                          = 0,
        SELECTION_ID_DISCONNECT                      = 1,
        SELECTION_ID_DISCONNECT_RESPONSE             = 2,
        SELECTION_ID_ADMIN_COMMAND                   = 7,
        SELECTION_ID_ADMIN_COMMAND_RESPONSE          = 8,
        SELECTION_ID_CLUSTER_MESSAGE                 = 9,
        SELECTION_ID_OPEN_QUEUE                      = 10,
        SELECTION_ID_OPEN_QUEUE_RESPONSE             = 11,
        SELECTION_ID_CLOSE_QUEUE                     = 12,
        SELECTION_ID_CLOSE_QUEUE_RESPONSE            = 13,
        SELECTION_ID_CONFIGURE_QUEUE_STREAM          = 14,
        SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE = 15,
        SELECTION_ID_CONFIGURE_STREAM                = 16,
        SELECTION_ID_CONFIGURE_STREAM_RESPONSE       = 17
    };

    enum { NUM_SELECTIONS = 14 };

    enum {
        SELECTION_INDEX_STATUS                          = 0,
        SELECTION_INDEX_DISCONNECT                      = 1,
        SELECTION_INDEX_DISCONNECT_RESPONSE             = 2,
        SELECTION_INDEX_ADMIN_COMMAND                   = 3,
        SELECTION_INDEX_ADMIN_COMMAND_RESPONSE          = 4,
        SELECTION_INDEX_CLUSTER_MESSAGE                 = 5,
        SELECTION_INDEX_OPEN_QUEUE                      = 6,
        SELECTION_INDEX_OPEN_QUEUE_RESPONSE             = 7,
        SELECTION_INDEX_CLOSE_QUEUE                     = 8,
        SELECTION_INDEX_CLOSE_QUEUE_RESPONSE            = 9,
        SELECTION_INDEX_CONFIGURE_QUEUE_STREAM          = 10,
        SELECTION_INDEX_CONFIGURE_QUEUE_STREAM_RESPONSE = 11,
        SELECTION_INDEX_CONFIGURE_STREAM                = 12,
        SELECTION_INDEX_CONFIGURE_STREAM_RESPONSE       = 13
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ControlMessageChoice(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ControlMessageChoice' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ControlMessageChoice(const ControlMessageChoice& original,
                         bslma::Allocator*           basicAllocator = 0);
    // Create an object of type 'ControlMessageChoice' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ControlMessageChoice(ControlMessageChoice&& original) noexcept;
    // Create an object of type 'ControlMessageChoice' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ControlMessageChoice(ControlMessageChoice&& original,
                         bslma::Allocator*      basicAllocator);
    // Create an object of type 'ControlMessageChoice' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ControlMessageChoice();
    // Destroy this object.

    // MANIPULATORS
    ControlMessageChoice& operator=(const ControlMessageChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ControlMessageChoice& operator=(ControlMessageChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Status& makeStatus();
    Status& makeStatus(const Status& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Status& makeStatus(Status&& value);
#endif
    // Set the value of this object to be a "Status" value.  Optionally
    // specify the 'value' of the "Status".  If 'value' is not specified,
    // the default "Status" value is used.

    Disconnect& makeDisconnect();
    Disconnect& makeDisconnect(const Disconnect& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Disconnect& makeDisconnect(Disconnect&& value);
#endif
    // Set the value of this object to be a "Disconnect" value.  Optionally
    // specify the 'value' of the "Disconnect".  If 'value' is not
    // specified, the default "Disconnect" value is used.

    DisconnectResponse& makeDisconnectResponse();
    DisconnectResponse&
    makeDisconnectResponse(const DisconnectResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DisconnectResponse& makeDisconnectResponse(DisconnectResponse&& value);
#endif
    // Set the value of this object to be a "DisconnectResponse" value.
    // Optionally specify the 'value' of the "DisconnectResponse".  If
    // 'value' is not specified, the default "DisconnectResponse" value is
    // used.

    AdminCommand& makeAdminCommand();
    AdminCommand& makeAdminCommand(const AdminCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AdminCommand& makeAdminCommand(AdminCommand&& value);
#endif
    // Set the value of this object to be a "AdminCommand" value.
    // Optionally specify the 'value' of the "AdminCommand".  If 'value' is
    // not specified, the default "AdminCommand" value is used.

    AdminCommandResponse& makeAdminCommandResponse();
    AdminCommandResponse&
    makeAdminCommandResponse(const AdminCommandResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AdminCommandResponse&
    makeAdminCommandResponse(AdminCommandResponse&& value);
#endif
    // Set the value of this object to be a "AdminCommandResponse" value.
    // Optionally specify the 'value' of the "AdminCommandResponse".  If
    // 'value' is not specified, the default "AdminCommandResponse" value
    // is used.

    ClusterMessage& makeClusterMessage();
    ClusterMessage& makeClusterMessage(const ClusterMessage& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterMessage& makeClusterMessage(ClusterMessage&& value);
#endif
    // Set the value of this object to be a "ClusterMessage" value.
    // Optionally specify the 'value' of the "ClusterMessage".  If 'value'
    // is not specified, the default "ClusterMessage" value is used.

    OpenQueue& makeOpenQueue();
    OpenQueue& makeOpenQueue(const OpenQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    OpenQueue& makeOpenQueue(OpenQueue&& value);
#endif
    // Set the value of this object to be a "OpenQueue" value.  Optionally
    // specify the 'value' of the "OpenQueue".  If 'value' is not
    // specified, the default "OpenQueue" value is used.

    OpenQueueResponse& makeOpenQueueResponse();
    OpenQueueResponse& makeOpenQueueResponse(const OpenQueueResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    OpenQueueResponse& makeOpenQueueResponse(OpenQueueResponse&& value);
#endif
    // Set the value of this object to be a "OpenQueueResponse" value.
    // Optionally specify the 'value' of the "OpenQueueResponse".  If
    // 'value' is not specified, the default "OpenQueueResponse" value is
    // used.

    CloseQueue& makeCloseQueue();
    CloseQueue& makeCloseQueue(const CloseQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CloseQueue& makeCloseQueue(CloseQueue&& value);
#endif
    // Set the value of this object to be a "CloseQueue" value.  Optionally
    // specify the 'value' of the "CloseQueue".  If 'value' is not
    // specified, the default "CloseQueue" value is used.

    CloseQueueResponse& makeCloseQueueResponse();
    CloseQueueResponse&
    makeCloseQueueResponse(const CloseQueueResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CloseQueueResponse& makeCloseQueueResponse(CloseQueueResponse&& value);
#endif
    // Set the value of this object to be a "CloseQueueResponse" value.
    // Optionally specify the 'value' of the "CloseQueueResponse".  If
    // 'value' is not specified, the default "CloseQueueResponse" value is
    // used.

    ConfigureQueueStream& makeConfigureQueueStream();
    ConfigureQueueStream&
    makeConfigureQueueStream(const ConfigureQueueStream& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureQueueStream&
    makeConfigureQueueStream(ConfigureQueueStream&& value);
#endif
    // Set the value of this object to be a "ConfigureQueueStream" value.
    // Optionally specify the 'value' of the "ConfigureQueueStream".  If
    // 'value' is not specified, the default "ConfigureQueueStream" value
    // is used.

    ConfigureQueueStreamResponse& makeConfigureQueueStreamResponse();
    ConfigureQueueStreamResponse& makeConfigureQueueStreamResponse(
        const ConfigureQueueStreamResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureQueueStreamResponse&
    makeConfigureQueueStreamResponse(ConfigureQueueStreamResponse&& value);
#endif
    // Set the value of this object to be a "ConfigureQueueStreamResponse"
    // value.  Optionally specify the 'value' of the
    // "ConfigureQueueStreamResponse".  If 'value' is not specified, the
    // default "ConfigureQueueStreamResponse" value is used.

    ConfigureStream& makeConfigureStream();
    ConfigureStream& makeConfigureStream(const ConfigureStream& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureStream& makeConfigureStream(ConfigureStream&& value);
#endif
    // Set the value of this object to be a "ConfigureStream" value.
    // Optionally specify the 'value' of the "ConfigureStream".  If 'value'
    // is not specified, the default "ConfigureStream" value is used.

    ConfigureStreamResponse& makeConfigureStreamResponse();
    ConfigureStreamResponse&
    makeConfigureStreamResponse(const ConfigureStreamResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureStreamResponse&
    makeConfigureStreamResponse(ConfigureStreamResponse&& value);
#endif
    // Set the value of this object to be a "ConfigureStreamResponse"
    // value.  Optionally specify the 'value' of the
    // "ConfigureStreamResponse".  If 'value' is not specified, the default
    // "ConfigureStreamResponse" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Status& status();
    // Return a reference to the modifiable "Status" selection of this
    // object if "Status" is the current selection.  The behavior is
    // undefined unless "Status" is the selection of this object.

    Disconnect& disconnect();
    // Return a reference to the modifiable "Disconnect" selection of this
    // object if "Disconnect" is the current selection.  The behavior is
    // undefined unless "Disconnect" is the selection of this object.

    DisconnectResponse& disconnectResponse();
    // Return a reference to the modifiable "DisconnectResponse" selection
    // of this object if "DisconnectResponse" is the current selection.
    // The behavior is undefined unless "DisconnectResponse" is the
    // selection of this object.

    AdminCommand& adminCommand();
    // Return a reference to the modifiable "AdminCommand" selection of
    // this object if "AdminCommand" is the current selection.  The
    // behavior is undefined unless "AdminCommand" is the selection of this
    // object.

    AdminCommandResponse& adminCommandResponse();
    // Return a reference to the modifiable "AdminCommandResponse"
    // selection of this object if "AdminCommandResponse" is the current
    // selection.  The behavior is undefined unless "AdminCommandResponse"
    // is the selection of this object.

    ClusterMessage& clusterMessage();
    // Return a reference to the modifiable "ClusterMessage" selection of
    // this object if "ClusterMessage" is the current selection.  The
    // behavior is undefined unless "ClusterMessage" is the selection of
    // this object.

    OpenQueue& openQueue();
    // Return a reference to the modifiable "OpenQueue" selection of this
    // object if "OpenQueue" is the current selection.  The behavior is
    // undefined unless "OpenQueue" is the selection of this object.

    OpenQueueResponse& openQueueResponse();
    // Return a reference to the modifiable "OpenQueueResponse" selection
    // of this object if "OpenQueueResponse" is the current selection.  The
    // behavior is undefined unless "OpenQueueResponse" is the selection of
    // this object.

    CloseQueue& closeQueue();
    // Return a reference to the modifiable "CloseQueue" selection of this
    // object if "CloseQueue" is the current selection.  The behavior is
    // undefined unless "CloseQueue" is the selection of this object.

    CloseQueueResponse& closeQueueResponse();
    // Return a reference to the modifiable "CloseQueueResponse" selection
    // of this object if "CloseQueueResponse" is the current selection.
    // The behavior is undefined unless "CloseQueueResponse" is the
    // selection of this object.

    ConfigureQueueStream& configureQueueStream();
    // Return a reference to the modifiable "ConfigureQueueStream"
    // selection of this object if "ConfigureQueueStream" is the current
    // selection.  The behavior is undefined unless "ConfigureQueueStream"
    // is the selection of this object.

    ConfigureQueueStreamResponse& configureQueueStreamResponse();
    // Return a reference to the modifiable "ConfigureQueueStreamResponse"
    // selection of this object if "ConfigureQueueStreamResponse" is the
    // current selection.  The behavior is undefined unless
    // "ConfigureQueueStreamResponse" is the selection of this object.

    ConfigureStream& configureStream();
    // Return a reference to the modifiable "ConfigureStream" selection of
    // this object if "ConfigureStream" is the current selection.  The
    // behavior is undefined unless "ConfigureStream" is the selection of
    // this object.

    ConfigureStreamResponse& configureStreamResponse();
    // Return a reference to the modifiable "ConfigureStreamResponse"
    // selection of this object if "ConfigureStreamResponse" is the current
    // selection.  The behavior is undefined unless
    // "ConfigureStreamResponse" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Status& status() const;
    // Return a reference to the non-modifiable "Status" selection of this
    // object if "Status" is the current selection.  The behavior is
    // undefined unless "Status" is the selection of this object.

    const Disconnect& disconnect() const;
    // Return a reference to the non-modifiable "Disconnect" selection of
    // this object if "Disconnect" is the current selection.  The behavior
    // is undefined unless "Disconnect" is the selection of this object.

    const DisconnectResponse& disconnectResponse() const;
    // Return a reference to the non-modifiable "DisconnectResponse"
    // selection of this object if "DisconnectResponse" is the current
    // selection.  The behavior is undefined unless "DisconnectResponse" is
    // the selection of this object.

    const AdminCommand& adminCommand() const;
    // Return a reference to the non-modifiable "AdminCommand" selection of
    // this object if "AdminCommand" is the current selection.  The
    // behavior is undefined unless "AdminCommand" is the selection of this
    // object.

    const AdminCommandResponse& adminCommandResponse() const;
    // Return a reference to the non-modifiable "AdminCommandResponse"
    // selection of this object if "AdminCommandResponse" is the current
    // selection.  The behavior is undefined unless "AdminCommandResponse"
    // is the selection of this object.

    const ClusterMessage& clusterMessage() const;
    // Return a reference to the non-modifiable "ClusterMessage" selection
    // of this object if "ClusterMessage" is the current selection.  The
    // behavior is undefined unless "ClusterMessage" is the selection of
    // this object.

    const OpenQueue& openQueue() const;
    // Return a reference to the non-modifiable "OpenQueue" selection of
    // this object if "OpenQueue" is the current selection.  The behavior
    // is undefined unless "OpenQueue" is the selection of this object.

    const OpenQueueResponse& openQueueResponse() const;
    // Return a reference to the non-modifiable "OpenQueueResponse"
    // selection of this object if "OpenQueueResponse" is the current
    // selection.  The behavior is undefined unless "OpenQueueResponse" is
    // the selection of this object.

    const CloseQueue& closeQueue() const;
    // Return a reference to the non-modifiable "CloseQueue" selection of
    // this object if "CloseQueue" is the current selection.  The behavior
    // is undefined unless "CloseQueue" is the selection of this object.

    const CloseQueueResponse& closeQueueResponse() const;
    // Return a reference to the non-modifiable "CloseQueueResponse"
    // selection of this object if "CloseQueueResponse" is the current
    // selection.  The behavior is undefined unless "CloseQueueResponse" is
    // the selection of this object.

    const ConfigureQueueStream& configureQueueStream() const;
    // Return a reference to the non-modifiable "ConfigureQueueStream"
    // selection of this object if "ConfigureQueueStream" is the current
    // selection.  The behavior is undefined unless "ConfigureQueueStream"
    // is the selection of this object.

    const ConfigureQueueStreamResponse& configureQueueStreamResponse() const;
    // Return a reference to the non-modifiable
    // "ConfigureQueueStreamResponse" selection of this object if
    // "ConfigureQueueStreamResponse" is the current selection.  The
    // behavior is undefined unless "ConfigureQueueStreamResponse" is the
    // selection of this object.

    const ConfigureStream& configureStream() const;
    // Return a reference to the non-modifiable "ConfigureStream" selection
    // of this object if "ConfigureStream" is the current selection.  The
    // behavior is undefined unless "ConfigureStream" is the selection of
    // this object.

    const ConfigureStreamResponse& configureStreamResponse() const;
    // Return a reference to the non-modifiable "ConfigureStreamResponse"
    // selection of this object if "ConfigureStreamResponse" is the current
    // selection.  The behavior is undefined unless
    // "ConfigureStreamResponse" is the selection of this object.

    bool isStatusValue() const;
    // Return 'true' if the value of this object is a "Status" value, and
    // return 'false' otherwise.

    bool isDisconnectValue() const;
    // Return 'true' if the value of this object is a "Disconnect" value,
    // and return 'false' otherwise.

    bool isDisconnectResponseValue() const;
    // Return 'true' if the value of this object is a "DisconnectResponse"
    // value, and return 'false' otherwise.

    bool isAdminCommandValue() const;
    // Return 'true' if the value of this object is a "AdminCommand" value,
    // and return 'false' otherwise.

    bool isAdminCommandResponseValue() const;
    // Return 'true' if the value of this object is a
    // "AdminCommandResponse" value, and return 'false' otherwise.

    bool isClusterMessageValue() const;
    // Return 'true' if the value of this object is a "ClusterMessage"
    // value, and return 'false' otherwise.

    bool isOpenQueueValue() const;
    // Return 'true' if the value of this object is a "OpenQueue" value,
    // and return 'false' otherwise.

    bool isOpenQueueResponseValue() const;
    // Return 'true' if the value of this object is a "OpenQueueResponse"
    // value, and return 'false' otherwise.

    bool isCloseQueueValue() const;
    // Return 'true' if the value of this object is a "CloseQueue" value,
    // and return 'false' otherwise.

    bool isCloseQueueResponseValue() const;
    // Return 'true' if the value of this object is a "CloseQueueResponse"
    // value, and return 'false' otherwise.

    bool isConfigureQueueStreamValue() const;
    // Return 'true' if the value of this object is a
    // "ConfigureQueueStream" value, and return 'false' otherwise.

    bool isConfigureQueueStreamResponseValue() const;
    // Return 'true' if the value of this object is a
    // "ConfigureQueueStreamResponse" value, and return 'false' otherwise.

    bool isConfigureStreamValue() const;
    // Return 'true' if the value of this object is a "ConfigureStream"
    // value, and return 'false' otherwise.

    bool isConfigureStreamResponseValue() const;
    // Return 'true' if the value of this object is a
    // "ConfigureStreamResponse" value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ControlMessageChoice& lhs,
                           const ControlMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ControlMessageChoice' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ControlMessageChoice& lhs,
                           const ControlMessageChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const ControlMessageChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const ControlMessageChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ControlMessageChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ControlMessageChoice)

namespace bmqp_ctrlmsg {

// ====================
// class ControlMessage
// ====================

class ControlMessage {
    // This type is the top level type for any message being sent by a client
    // to the broker or a broker to another broker.  Each message can be
    // associated with an optional 'rId' (requestId) that, if specified, will
    // be set to the same value as part of the response to correlate the
    // request and the response together.
    // rId....: optional id of this specific request choice.: enumerates all
    // the different types of control messages

    // INSTANCE DATA
    ControlMessageChoice     d_choice;
    bdlb::NullableValue<int> d_rId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_R_ID = 0, ATTRIBUTE_ID_CHOICE = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_R_ID = 0, ATTRIBUTE_INDEX_CHOICE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ControlMessage(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ControlMessage' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ControlMessage(const ControlMessage& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'ControlMessage' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ControlMessage(ControlMessage&& original) noexcept;
    // Create an object of type 'ControlMessage' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ControlMessage(ControlMessage&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'ControlMessage' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ControlMessage();
    // Destroy this object.

    // MANIPULATORS
    ControlMessage& operator=(const ControlMessage& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ControlMessage& operator=(ControlMessage&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bdlb::NullableValue<int>& rId();
    // Return a reference to the modifiable "RId" attribute of this object.

    ControlMessageChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bdlb::NullableValue<int>& rId() const;
    // Return a reference offering non-modifiable access to the "RId"
    // attribute of this object.

    const ControlMessageChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ControlMessage& lhs,
                           const ControlMessage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.rId() == rhs.rId() && lhs.choice() == rhs.choice();
    }

    friend bool operator!=(const ControlMessage& lhs,
                           const ControlMessage& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const ControlMessage& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const ControlMessage& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ControlMessage'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.rId());
        hashAppend(hashAlg, object.choice());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ControlMessage)

//=============================================================================
//                          INLINE DEFINITIONS
//=============================================================================

namespace bmqp_ctrlmsg {

// ------------------
// class AdminCommand
// ------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int AdminCommand::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_rerouted,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REROUTED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int AdminCommand::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    case ATTRIBUTE_ID_REROUTED: {
        return manipulator(&d_rerouted,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REROUTED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int AdminCommand::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& AdminCommand::command()
{
    return d_command;
}

inline bool& AdminCommand::rerouted()
{
    return d_rerouted;
}

// ACCESSORS
template <typename t_ACCESSOR>
int AdminCommand::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_rerouted, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REROUTED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int AdminCommand::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    case ATTRIBUTE_ID_REROUTED: {
        return accessor(d_rerouted,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REROUTED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int AdminCommand::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& AdminCommand::command() const
{
    return d_command;
}

inline bool AdminCommand::rerouted() const
{
    return d_rerouted;
}

// --------------------------
// class AdminCommandResponse
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int AdminCommandResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int AdminCommandResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TEXT: {
        return manipulator(&d_text,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int AdminCommandResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& AdminCommandResponse::text()
{
    return d_text;
}

// ACCESSORS
template <typename t_ACCESSOR>
int AdminCommandResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int AdminCommandResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TEXT: {
        return accessor(d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int AdminCommandResponse::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& AdminCommandResponse::text() const
{
    return d_text;
}

// ---------------
// class AppIdInfo
// ---------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int AppIdInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appKey,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int AppIdInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return manipulator(&d_appKey,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int AppIdInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                   const char*    name,
                                   int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& AppIdInfo::appId()
{
    return d_appId;
}

inline bsl::vector<char>& AppIdInfo::appKey()
{
    return d_appKey;
}

// ACCESSORS
template <typename t_ACCESSOR>
int AppIdInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appKey, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int AppIdInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return accessor(d_appKey,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int AppIdInfo::accessAttribute(t_ACCESSOR& accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& AppIdInfo::appId() const
{
    return d_appId;
}

inline const bsl::vector<char>& AppIdInfo::appKey() const
{
    return d_appKey;
}

// --------------------
// class ClientLanguage
// --------------------

// CLASS METHODS
inline int ClientLanguage::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ClientLanguage::print(bsl::ostream&         stream,
                                           ClientLanguage::Value value)
{
    return stream << toString(value);
}

// ----------------
// class ClientType
// ----------------

// CLASS METHODS
inline int ClientType::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ClientType::print(bsl::ostream&     stream,
                                       ClientType::Value value)
{
    return stream << toString(value);
}

// ------------------------
// class CloseQueueResponse
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int CloseQueueResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int CloseQueueResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int CloseQueueResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int CloseQueueResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int CloseQueueResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int CloseQueueResponse::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ------------------------
// class ClusterSyncRequest
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterSyncRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int ClusterSyncRequest::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterSyncRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterSyncRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int ClusterSyncRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterSyncRequest::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// -------------------------
// class ClusterSyncResponse
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterSyncResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int ClusterSyncResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterSyncResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterSyncResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int ClusterSyncResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterSyncResponse::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ------------------
// class ConsumerInfo
// ------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ConsumerInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->maxUnconfirmedMessages());
    hashAppend(hashAlgorithm, this->maxUnconfirmedBytes());
    hashAppend(hashAlgorithm, this->consumerPriority());
    hashAppend(hashAlgorithm, this->consumerPriorityCount());
}

inline bool ConsumerInfo::isEqualTo(const ConsumerInfo& rhs) const
{
    return this->maxUnconfirmedMessages() == rhs.maxUnconfirmedMessages() &&
           this->maxUnconfirmedBytes() == rhs.maxUnconfirmedBytes() &&
           this->consumerPriority() == rhs.consumerPriority() &&
           this->consumerPriorityCount() == rhs.consumerPriorityCount();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ConsumerInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumerPriority,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ConsumerInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return manipulator(
            &d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return manipulator(
            &d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return manipulator(
            &d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return manipulator(
            &d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ConsumerInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Int64& ConsumerInfo::maxUnconfirmedMessages()
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64& ConsumerInfo::maxUnconfirmedBytes()
{
    return d_maxUnconfirmedBytes;
}

inline int& ConsumerInfo::consumerPriority()
{
    return d_consumerPriority;
}

inline int& ConsumerInfo::consumerPriorityCount()
{
    return d_consumerPriorityCount;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ConsumerInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumerPriority,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ConsumerInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return accessor(
            d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return accessor(
            d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return accessor(
            d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return accessor(
            d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ConsumerInfo::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Int64 ConsumerInfo::maxUnconfirmedMessages() const
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64 ConsumerInfo::maxUnconfirmedBytes() const
{
    return d_maxUnconfirmedBytes;
}

inline int ConsumerInfo::consumerPriority() const
{
    return d_consumerPriority;
}

inline int ConsumerInfo::consumerPriorityCount() const
{
    return d_consumerPriorityCount;
}

// ----------------
// class Disconnect
// ----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Disconnect::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int Disconnect::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Disconnect::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int Disconnect::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int Disconnect::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Disconnect::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ------------------------
// class DisconnectResponse
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int DisconnectResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int DisconnectResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int DisconnectResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int DisconnectResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int DisconnectResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int DisconnectResponse::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// --------------------
// class DumpActionType
// --------------------

// CLASS METHODS
inline int DumpActionType::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& DumpActionType::print(bsl::ostream&         stream,
                                           DumpActionType::Value value)
{
    return stream << toString(value);
}

// -----------------
// class DumpMsgType
// -----------------

// CLASS METHODS
inline int DumpMsgType::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& DumpMsgType::print(bsl::ostream&      stream,
                                        DumpMsgType::Value value)
{
    return stream << toString(value);
}

// ----------------------
// class ElectionProposal
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ElectionProposal::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int ElectionProposal::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ElectionProposal::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int ElectionProposal::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int ElectionProposal::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ElectionProposal::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ----------------------
// class ElectionResponse
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ElectionResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int ElectionResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ElectionResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int ElectionResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int ElectionResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ElectionResponse::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// -----------------------
// class ElectorNodeStatus
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ElectorNodeStatus::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_isAvailable,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ElectorNodeStatus::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_IS_AVAILABLE: {
        return manipulator(&d_isAvailable,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ElectorNodeStatus::manipulateAttribute(t_MANIPULATOR& manipulator,
                                           const char*    name,
                                           int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bool& ElectorNodeStatus::isAvailable()
{
    return d_isAvailable;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ElectorNodeStatus::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_isAvailable,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ElectorNodeStatus::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_IS_AVAILABLE: {
        return accessor(d_isAvailable,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ElectorNodeStatus::accessAttribute(t_ACCESSOR& accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bool ElectorNodeStatus::isAvailable() const
{
    return d_isAvailable;
}

// -----------------------
// class ExpressionVersion
// -----------------------

// CLASS METHODS
inline int ExpressionVersion::fromString(Value*             result,
                                         const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ExpressionVersion::print(bsl::ostream&            stream,
                                              ExpressionVersion::Value value)
{
    return stream << toString(value);
}

// ---------------------------------
// class FollowerClusterStateRequest
// ---------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FollowerClusterStateRequest::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int FollowerClusterStateRequest::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FollowerClusterStateRequest::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int FollowerClusterStateRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int FollowerClusterStateRequest::accessAttribute(t_ACCESSOR& accessor,
                                                 int         id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FollowerClusterStateRequest::accessAttribute(t_ACCESSOR& accessor,
                                                 const char* name,
                                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ------------------------
// class FollowerLSNRequest
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FollowerLSNRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int FollowerLSNRequest::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FollowerLSNRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int FollowerLSNRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int FollowerLSNRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FollowerLSNRequest::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// --------------
// class GuidInfo
// --------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int GuidInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clientId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_nanoSecondsFromEpoch,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int GuidInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_ID: {
        return manipulator(&d_clientId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_ID]);
    }
    case ATTRIBUTE_ID_NANO_SECONDS_FROM_EPOCH: {
        return manipulator(
            &d_nanoSecondsFromEpoch,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int GuidInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                  const char*    name,
                                  int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& GuidInfo::clientId()
{
    return d_clientId;
}

inline bsls::Types::Int64& GuidInfo::nanoSecondsFromEpoch()
{
    return d_nanoSecondsFromEpoch;
}

// ACCESSORS
template <typename t_ACCESSOR>
int GuidInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clientId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_nanoSecondsFromEpoch,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int GuidInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_ID: {
        return accessor(d_clientId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_ID]);
    }
    case ATTRIBUTE_ID_NANO_SECONDS_FROM_EPOCH: {
        return accessor(
            d_nanoSecondsFromEpoch,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int GuidInfo::accessAttribute(t_ACCESSOR& accessor,
                              const char* name,
                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& GuidInfo::clientId() const
{
    return d_clientId;
}

inline bsls::Types::Int64 GuidInfo::nanoSecondsFromEpoch() const
{
    return d_nanoSecondsFromEpoch;
}

// -----------------------
// class HeartbeatResponse
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int HeartbeatResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int HeartbeatResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int HeartbeatResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                           const char*    name,
                                           int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int HeartbeatResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int HeartbeatResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int HeartbeatResponse::accessAttribute(t_ACCESSOR& accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ---------------------
// class LeaderHeartbeat
// ---------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderHeartbeat::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int LeaderHeartbeat::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderHeartbeat::manipulateAttribute(t_MANIPULATOR& manipulator,
                                         const char*    name,
                                         int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderHeartbeat::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int LeaderHeartbeat::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderHeartbeat::accessAttribute(t_ACCESSOR& accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ---------------------------
// class LeaderMessageSequence
// ---------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderMessageSequence::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_electorTerm,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LeaderMessageSequence::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ELECTOR_TERM: {
        return manipulator(&d_electorTerm,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderMessageSequence::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               const char*    name,
                                               int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Uint64& LeaderMessageSequence::electorTerm()
{
    return d_electorTerm;
}

inline bsls::Types::Uint64& LeaderMessageSequence::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderMessageSequence::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_electorTerm,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LeaderMessageSequence::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ELECTOR_TERM: {
        return accessor(d_electorTerm,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderMessageSequence::accessAttribute(t_ACCESSOR& accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Uint64 LeaderMessageSequence::electorTerm() const
{
    return d_electorTerm;
}

inline bsls::Types::Uint64 LeaderMessageSequence::sequenceNumber() const
{
    return d_sequenceNumber;
}

// -------------------
// class LeaderPassive
// -------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderPassive::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int LeaderPassive::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderPassive::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderPassive::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int LeaderPassive::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderPassive::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// -------------------------
// class LeaderSyncDataQuery
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderSyncDataQuery::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int LeaderSyncDataQuery::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderSyncDataQuery::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderSyncDataQuery::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int LeaderSyncDataQuery::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderSyncDataQuery::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// --------------------------
// class LeaderSyncStateQuery
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderSyncStateQuery::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int LeaderSyncStateQuery::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderSyncStateQuery::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderSyncStateQuery::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int LeaderSyncStateQuery::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderSyncStateQuery::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// -----------------------------------
// class LeadershipCessionNotification
// -----------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeadershipCessionNotification::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int LeadershipCessionNotification::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeadershipCessionNotification::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeadershipCessionNotification::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int LeadershipCessionNotification::accessAttribute(t_ACCESSOR& accessor,
                                                   int         id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeadershipCessionNotification::accessAttribute(t_ACCESSOR& accessor,
                                                   const char* name,
                                                   int nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ----------------
// class NodeStatus
// ----------------

// CLASS METHODS
inline int NodeStatus::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& NodeStatus::print(bsl::ostream&     stream,
                                       NodeStatus::Value value)
{
    return stream << toString(value);
}

// --------------------------
// class PartitionPrimaryInfo
// --------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PartitionPrimaryInfo::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->primaryNodeId());
    hashAppend(hashAlgorithm, this->primaryLeaseId());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionPrimaryInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionPrimaryInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return manipulator(
            &d_primaryNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionPrimaryInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionPrimaryInfo::partitionId()
{
    return d_partitionId;
}

inline int& PartitionPrimaryInfo::primaryNodeId()
{
    return d_primaryNodeId;
}

inline unsigned int& PartitionPrimaryInfo::primaryLeaseId()
{
    return d_primaryLeaseId;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionPrimaryInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionPrimaryInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return accessor(d_primaryNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionPrimaryInfo::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionPrimaryInfo::partitionId() const
{
    return d_partitionId;
}

inline int PartitionPrimaryInfo::primaryNodeId() const
{
    return d_primaryNodeId;
}

inline unsigned int PartitionPrimaryInfo::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

// -----------------------------
// class PartitionSequenceNumber
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionSequenceNumber::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionSequenceNumber::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionSequenceNumber::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 const char*    name,
                                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& PartitionSequenceNumber::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSequenceNumber::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionSequenceNumber::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionSequenceNumber::accessAttribute(t_ACCESSOR& accessor,
                                             int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionSequenceNumber::accessAttribute(t_ACCESSOR& accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int PartitionSequenceNumber::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64 PartitionSequenceNumber::sequenceNumber() const
{
    return d_sequenceNumber;
}

// ------------------------------------
// class PartitionSyncDataQueryResponse
// ------------------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PartitionSyncDataQueryResponse::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->endPrimaryLeaseId());
    hashAppend(hashAlgorithm, this->endSequenceNum());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionSyncDataQueryResponse::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_endPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_endSequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionSyncDataQueryResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_END_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_endPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUM: {
        return manipulator(
            &d_endSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUM]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionSyncDataQueryResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncDataQueryResponse::partitionId()
{
    return d_partitionId;
}

inline unsigned int& PartitionSyncDataQueryResponse::endPrimaryLeaseId()
{
    return d_endPrimaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSyncDataQueryResponse::endSequenceNum()
{
    return d_endSequenceNum;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionSyncDataQueryResponse::accessAttributes(
    t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endPrimaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endSequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionSyncDataQueryResponse::accessAttribute(t_ACCESSOR& accessor,
                                                    int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_END_PRIMARY_LEASE_ID: {
        return accessor(
            d_endPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUM: {
        return accessor(
            d_endSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUM]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionSyncDataQueryResponse::accessAttribute(t_ACCESSOR& accessor,
                                                    const char* name,
                                                    int nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncDataQueryResponse::partitionId() const
{
    return d_partitionId;
}

inline unsigned int PartitionSyncDataQueryResponse::endPrimaryLeaseId() const
{
    return d_endPrimaryLeaseId;
}

inline bsls::Types::Uint64
PartitionSyncDataQueryResponse::endSequenceNum() const
{
    return d_endSequenceNum;
}

// -----------------------------
// class PartitionSyncStateQuery
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionSyncStateQuery::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionSyncStateQuery::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionSyncStateQuery::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 const char*    name,
                                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncStateQuery::partitionId()
{
    return d_partitionId;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionSyncStateQuery::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionSyncStateQuery::accessAttribute(t_ACCESSOR& accessor,
                                             int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionSyncStateQuery::accessAttribute(t_ACCESSOR& accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncStateQuery::partitionId() const
{
    return d_partitionId;
}

// -------------------
// class PrimaryStatus
// -------------------

// CLASS METHODS
inline int PrimaryStatus::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& PrimaryStatus::print(bsl::ostream&        stream,
                                          PrimaryStatus::Value value)
{
    return stream << toString(value);
}

// ----------------------------
// class QueueAssignmentRequest
// ----------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueAssignmentRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queueUri,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueAssignmentRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return manipulator(&d_queueUri,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueAssignmentRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                const char*    name,
                                                int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueAssignmentRequest::queueUri()
{
    return d_queueUri;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueAssignmentRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queueUri,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueAssignmentRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return accessor(d_queueUri,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueAssignmentRequest::accessAttribute(t_ACCESSOR& accessor,
                                            const char* name,
                                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueAssignmentRequest::queueUri() const
{
    return d_queueUri;
}

// ------------------------------
// class QueueUnassignmentRequest
// ------------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueUnassignmentRequest::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->queueUri());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->queueKey());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueUnassignmentRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queueUri,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queueKey,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueUnassignmentRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                  int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return manipulator(&d_queueUri,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_QUEUE_KEY: {
        return manipulator(&d_queueKey,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueUnassignmentRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                  const char*    name,
                                                  int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueUnassignmentRequest::queueUri()
{
    return d_queueUri;
}

inline int& QueueUnassignmentRequest::partitionId()
{
    return d_partitionId;
}

inline bsl::vector<char>& QueueUnassignmentRequest::queueKey()
{
    return d_queueKey;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueUnassignmentRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queueUri,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queueKey,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueUnassignmentRequest::accessAttribute(t_ACCESSOR& accessor,
                                              int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return accessor(d_queueUri,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_QUEUE_KEY: {
        return accessor(d_queueKey,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueUnassignmentRequest::accessAttribute(t_ACCESSOR& accessor,
                                              const char* name,
                                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueUnassignmentRequest::queueUri() const
{
    return d_queueUri;
}

inline int QueueUnassignmentRequest::partitionId() const
{
    return d_partitionId;
}

inline const bsl::vector<char>& QueueUnassignmentRequest::queueKey() const
{
    return d_queueKey;
}

// --------------------------
// class RegistrationResponse
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RegistrationResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int RegistrationResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RegistrationResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int RegistrationResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int RegistrationResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RegistrationResponse::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ---------------------
// class ReplicaDataType
// ---------------------

// CLASS METHODS
inline int ReplicaDataType::fromString(Value*             result,
                                       const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ReplicaDataType::print(bsl::ostream&          stream,
                                            ReplicaDataType::Value value)
{
    return stream << toString(value);
}

// ------------------------------
// class ReverseConnectionRequest
// ------------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ReverseConnectionRequest::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->protocolVersion());
    hashAppend(hashAlgorithm, this->clusterName());
    hashAppend(hashAlgorithm, this->clusterNodeId());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ReverseConnectionRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_protocolVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ReverseConnectionRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                  int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return manipulator(
            &d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CLUSTER_NODE_ID: {
        return manipulator(
            &d_clusterNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ReverseConnectionRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                  const char*    name,
                                                  int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& ReverseConnectionRequest::protocolVersion()
{
    return d_protocolVersion;
}

inline bsl::string& ReverseConnectionRequest::clusterName()
{
    return d_clusterName;
}

inline int& ReverseConnectionRequest::clusterNodeId()
{
    return d_clusterNodeId;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ReverseConnectionRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_protocolVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ReverseConnectionRequest::accessAttribute(t_ACCESSOR& accessor,
                                              int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return accessor(
            d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CLUSTER_NODE_ID: {
        return accessor(d_clusterNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ReverseConnectionRequest::accessAttribute(t_ACCESSOR& accessor,
                                              const char* name,
                                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int ReverseConnectionRequest::protocolVersion() const
{
    return d_protocolVersion;
}

inline const bsl::string& ReverseConnectionRequest::clusterName() const
{
    return d_clusterName;
}

inline int ReverseConnectionRequest::clusterNodeId() const
{
    return d_clusterNodeId;
}

// --------------------------
// class RoutingConfiguration
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RoutingConfiguration::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RoutingConfiguration::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_FLAGS: {
        return manipulator(&d_flags,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RoutingConfiguration::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Uint64& RoutingConfiguration::flags()
{
    return d_flags;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RoutingConfiguration::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RoutingConfiguration::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_FLAGS: {
        return accessor(d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RoutingConfiguration::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Uint64 RoutingConfiguration::flags() const
{
    return d_flags;
}

// -------------------------------
// class RoutingConfigurationFlags
// -------------------------------

// CLASS METHODS
inline int RoutingConfigurationFlags::fromString(Value*             result,
                                                 const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream&
RoutingConfigurationFlags::print(bsl::ostream&                    stream,
                                 RoutingConfigurationFlags::Value value)
{
    return stream << toString(value);
}

// ---------------------
// class ScoutingRequest
// ---------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ScoutingRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int ScoutingRequest::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ScoutingRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                         const char*    name,
                                         int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int ScoutingRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int ScoutingRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ScoutingRequest::accessAttribute(t_ACCESSOR& accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// ----------------------
// class ScoutingResponse
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ScoutingResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_willVote,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WILL_VOTE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ScoutingResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_WILL_VOTE: {
        return manipulator(&d_willVote,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WILL_VOTE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ScoutingResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bool& ScoutingResponse::willVote()
{
    return d_willVote;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ScoutingResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_willVote,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WILL_VOTE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ScoutingResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_WILL_VOTE: {
        return accessor(d_willVote,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WILL_VOTE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ScoutingResponse::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bool ScoutingResponse::willVote() const
{
    return d_willVote;
}

// --------------------
// class StatusCategory
// --------------------

// CLASS METHODS
inline int StatusCategory::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& StatusCategory::print(bsl::ostream&         stream,
                                           StatusCategory::Value value)
{
    return stream << toString(value);
}

// -----------------
// class StopRequest
// -----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StopRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StopRequest::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StopRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StopRequest::clusterName()
{
    return d_clusterName;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StopRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StopRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StopRequest::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StopRequest::clusterName() const
{
    return d_clusterName;
}

// ------------------
// class StopResponse
// ------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StopResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StopResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StopResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StopResponse::clusterName()
{
    return d_clusterName;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StopResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StopResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StopResponse::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StopResponse::clusterName() const
{
    return d_clusterName;
}

// -----------------------------
// class StorageSyncResponseType
// -----------------------------

// CLASS METHODS
inline int StorageSyncResponseType::fromString(Value*             result,
                                               const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream&
StorageSyncResponseType::print(bsl::ostream&                  stream,
                               StorageSyncResponseType::Value value)
{
    return stream << toString(value);
}

// --------------------
// class SubQueueIdInfo
// --------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int SubQueueIdInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int SubQueueIdInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID: {
        return manipulator(&d_subId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int SubQueueIdInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& SubQueueIdInfo::subId()
{
    return d_subId;
}

inline bsl::string& SubQueueIdInfo::appId()
{
    return d_appId;
}

// ACCESSORS
template <typename t_ACCESSOR>
int SubQueueIdInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int SubQueueIdInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID: {
        return accessor(d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int SubQueueIdInfo::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int SubQueueIdInfo::subId() const
{
    return d_subId;
}

inline const bsl::string& SubQueueIdInfo::appId() const
{
    return d_appId;
}

// ---------------
// class SyncPoint
// ---------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void SyncPoint::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->primaryLeaseId());
    hashAppend(hashAlgorithm, this->sequenceNum());
    hashAppend(hashAlgorithm, this->dataFileOffsetDwords());
    hashAppend(hashAlgorithm, this->qlistFileOffsetWords());
}

inline bool SyncPoint::isEqualTo(const SyncPoint& rhs) const
{
    return this->primaryLeaseId() == rhs.primaryLeaseId() &&
           this->sequenceNum() == rhs.sequenceNum() &&
           this->dataFileOffsetDwords() == rhs.dataFileOffsetDwords() &&
           this->qlistFileOffsetWords() == rhs.qlistFileOffsetWords();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int SyncPoint::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_dataFileOffsetDwords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_qlistFileOffsetWords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int SyncPoint::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return manipulator(&d_sequenceNum,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_DATA_FILE_OFFSET_DWORDS: {
        return manipulator(
            &d_dataFileOffsetDwords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS]);
    }
    case ATTRIBUTE_ID_QLIST_FILE_OFFSET_WORDS: {
        return manipulator(
            &d_qlistFileOffsetWords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int SyncPoint::manipulateAttribute(t_MANIPULATOR& manipulator,
                                   const char*    name,
                                   int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& SyncPoint::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64& SyncPoint::sequenceNum()
{
    return d_sequenceNum;
}

inline unsigned int& SyncPoint::dataFileOffsetDwords()
{
    return d_dataFileOffsetDwords;
}

inline unsigned int& SyncPoint::qlistFileOffsetWords()
{
    return d_qlistFileOffsetWords;
}

// ACCESSORS
template <typename t_ACCESSOR>
int SyncPoint::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_dataFileOffsetDwords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_qlistFileOffsetWords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int SyncPoint::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return accessor(d_sequenceNum,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_DATA_FILE_OFFSET_DWORDS: {
        return accessor(
            d_dataFileOffsetDwords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS]);
    }
    case ATTRIBUTE_ID_QLIST_FILE_OFFSET_WORDS: {
        return accessor(
            d_qlistFileOffsetWords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int SyncPoint::accessAttribute(t_ACCESSOR& accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int SyncPoint::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64 SyncPoint::sequenceNum() const
{
    return d_sequenceNum;
}

inline unsigned int SyncPoint::dataFileOffsetDwords() const
{
    return d_dataFileOffsetDwords;
}

inline unsigned int SyncPoint::qlistFileOffsetWords() const
{
    return d_qlistFileOffsetWords;
}

// --------------------
// class ClientIdentity
// --------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClientIdentity::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->protocolVersion());
    hashAppend(hashAlgorithm, this->sdkVersion());
    hashAppend(hashAlgorithm, this->clientType());
    hashAppend(hashAlgorithm, this->processName());
    hashAppend(hashAlgorithm, this->pid());
    hashAppend(hashAlgorithm, this->sessionId());
    hashAppend(hashAlgorithm, this->hostName());
    hashAppend(hashAlgorithm, this->features());
    hashAppend(hashAlgorithm, this->clusterName());
    hashAppend(hashAlgorithm, this->clusterNodeId());
    hashAppend(hashAlgorithm, this->sdkLanguage());
    hashAppend(hashAlgorithm, this->guidInfo());
}

inline bool ClientIdentity::isEqualTo(const ClientIdentity& rhs) const
{
    return this->protocolVersion() == rhs.protocolVersion() &&
           this->sdkVersion() == rhs.sdkVersion() &&
           this->clientType() == rhs.clientType() &&
           this->processName() == rhs.processName() &&
           this->pid() == rhs.pid() && this->sessionId() == rhs.sessionId() &&
           this->hostName() == rhs.hostName() &&
           this->features() == rhs.features() &&
           this->clusterName() == rhs.clusterName() &&
           this->clusterNodeId() == rhs.clusterNodeId() &&
           this->sdkLanguage() == rhs.sdkLanguage() &&
           this->guidInfo() == rhs.guidInfo();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClientIdentity::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_protocolVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sdkVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clientType,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_processName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROCESS_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_pid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sessionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SESSION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_hostName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_features,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FEATURES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sdkLanguage,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_LANGUAGE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_guidInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID_INFO]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClientIdentity::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return manipulator(
            &d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_SDK_VERSION: {
        return manipulator(&d_sdkVersion,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_VERSION]);
    }
    case ATTRIBUTE_ID_CLIENT_TYPE: {
        return manipulator(&d_clientType,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_TYPE]);
    }
    case ATTRIBUTE_ID_PROCESS_NAME: {
        return manipulator(&d_processName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROCESS_NAME]);
    }
    case ATTRIBUTE_ID_PID: {
        return manipulator(&d_pid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PID]);
    }
    case ATTRIBUTE_ID_SESSION_ID: {
        return manipulator(&d_sessionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SESSION_ID]);
    }
    case ATTRIBUTE_ID_HOST_NAME: {
        return manipulator(&d_hostName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    }
    case ATTRIBUTE_ID_FEATURES: {
        return manipulator(&d_features,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FEATURES]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CLUSTER_NODE_ID: {
        return manipulator(
            &d_clusterNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    }
    case ATTRIBUTE_ID_SDK_LANGUAGE: {
        return manipulator(&d_sdkLanguage,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_LANGUAGE]);
    }
    case ATTRIBUTE_ID_GUID_INFO: {
        return manipulator(&d_guidInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID_INFO]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClientIdentity::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& ClientIdentity::protocolVersion()
{
    return d_protocolVersion;
}

inline int& ClientIdentity::sdkVersion()
{
    return d_sdkVersion;
}

inline ClientType::Value& ClientIdentity::clientType()
{
    return d_clientType;
}

inline bsl::string& ClientIdentity::processName()
{
    return d_processName;
}

inline int& ClientIdentity::pid()
{
    return d_pid;
}

inline int& ClientIdentity::sessionId()
{
    return d_sessionId;
}

inline bsl::string& ClientIdentity::hostName()
{
    return d_hostName;
}

inline bsl::string& ClientIdentity::features()
{
    return d_features;
}

inline bsl::string& ClientIdentity::clusterName()
{
    return d_clusterName;
}

inline int& ClientIdentity::clusterNodeId()
{
    return d_clusterNodeId;
}

inline ClientLanguage::Value& ClientIdentity::sdkLanguage()
{
    return d_sdkLanguage;
}

inline GuidInfo& ClientIdentity::guidInfo()
{
    return d_guidInfo;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClientIdentity::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_protocolVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sdkVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clientType,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_processName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROCESS_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_pid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sessionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SESSION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_hostName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_features, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FEATURES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sdkLanguage,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_LANGUAGE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_guidInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID_INFO]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClientIdentity::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return accessor(
            d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_SDK_VERSION: {
        return accessor(d_sdkVersion,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_VERSION]);
    }
    case ATTRIBUTE_ID_CLIENT_TYPE: {
        return accessor(d_clientType,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_TYPE]);
    }
    case ATTRIBUTE_ID_PROCESS_NAME: {
        return accessor(d_processName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROCESS_NAME]);
    }
    case ATTRIBUTE_ID_PID: {
        return accessor(d_pid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PID]);
    }
    case ATTRIBUTE_ID_SESSION_ID: {
        return accessor(d_sessionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SESSION_ID]);
    }
    case ATTRIBUTE_ID_HOST_NAME: {
        return accessor(d_hostName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    }
    case ATTRIBUTE_ID_FEATURES: {
        return accessor(d_features,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FEATURES]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CLUSTER_NODE_ID: {
        return accessor(d_clusterNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    }
    case ATTRIBUTE_ID_SDK_LANGUAGE: {
        return accessor(d_sdkLanguage,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_LANGUAGE]);
    }
    case ATTRIBUTE_ID_GUID_INFO: {
        return accessor(d_guidInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID_INFO]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClientIdentity::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int ClientIdentity::protocolVersion() const
{
    return d_protocolVersion;
}

inline int ClientIdentity::sdkVersion() const
{
    return d_sdkVersion;
}

inline ClientType::Value ClientIdentity::clientType() const
{
    return d_clientType;
}

inline const bsl::string& ClientIdentity::processName() const
{
    return d_processName;
}

inline int ClientIdentity::pid() const
{
    return d_pid;
}

inline int ClientIdentity::sessionId() const
{
    return d_sessionId;
}

inline const bsl::string& ClientIdentity::hostName() const
{
    return d_hostName;
}

inline const bsl::string& ClientIdentity::features() const
{
    return d_features;
}

inline const bsl::string& ClientIdentity::clusterName() const
{
    return d_clusterName;
}

inline int ClientIdentity::clusterNodeId() const
{
    return d_clusterNodeId;
}

inline ClientLanguage::Value ClientIdentity::sdkLanguage() const
{
    return d_sdkLanguage;
}

inline const GuidInfo& ClientIdentity::guidInfo() const
{
    return d_guidInfo;
}

// ------------------
// class DumpMessages
// ------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DumpMessages::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->msgTypeToDump());
    hashAppend(hashAlgorithm, this->dumpActionType());
    hashAppend(hashAlgorithm, this->dumpActionValue());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int DumpMessages::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_msgTypeToDump,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_dumpActionType,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_dumpActionValue,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_VALUE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int DumpMessages::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MSG_TYPE_TO_DUMP: {
        return manipulator(
            &d_msgTypeToDump,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP]);
    }
    case ATTRIBUTE_ID_DUMP_ACTION_TYPE: {
        return manipulator(
            &d_dumpActionType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_TYPE]);
    }
    case ATTRIBUTE_ID_DUMP_ACTION_VALUE: {
        return manipulator(
            &d_dumpActionValue,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_VALUE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int DumpMessages::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline DumpMsgType::Value& DumpMessages::msgTypeToDump()
{
    return d_msgTypeToDump;
}

inline DumpActionType::Value& DumpMessages::dumpActionType()
{
    return d_dumpActionType;
}

inline int& DumpMessages::dumpActionValue()
{
    return d_dumpActionValue;
}

// ACCESSORS
template <typename t_ACCESSOR>
int DumpMessages::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_msgTypeToDump,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_dumpActionType,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_dumpActionValue,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_VALUE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int DumpMessages::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MSG_TYPE_TO_DUMP: {
        return accessor(
            d_msgTypeToDump,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP]);
    }
    case ATTRIBUTE_ID_DUMP_ACTION_TYPE: {
        return accessor(
            d_dumpActionType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_TYPE]);
    }
    case ATTRIBUTE_ID_DUMP_ACTION_VALUE: {
        return accessor(
            d_dumpActionValue,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_VALUE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int DumpMessages::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline DumpMsgType::Value DumpMessages::msgTypeToDump() const
{
    return d_msgTypeToDump;
}

inline DumpActionType::Value DumpMessages::dumpActionType() const
{
    return d_dumpActionType;
}

inline int DumpMessages::dumpActionValue() const
{
    return d_dumpActionValue;
}

// --------------------------
// class ElectorMessageChoice
// --------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ElectorMessageChoice::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ElectorMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ELECTION_PROPOSAL:
        hashAppend(hashAlgorithm, this->electionProposal());
        break;
    case Class::SELECTION_ID_ELECTION_RESPONSE:
        hashAppend(hashAlgorithm, this->electionResponse());
        break;
    case Class::SELECTION_ID_LEADER_HEARTBEAT:
        hashAppend(hashAlgorithm, this->leaderHeartbeat());
        break;
    case Class::SELECTION_ID_ELECTOR_NODE_STATUS:
        hashAppend(hashAlgorithm, this->electorNodeStatus());
        break;
    case Class::SELECTION_ID_HEARTBEAT_RESPONSE:
        hashAppend(hashAlgorithm, this->heartbeatResponse());
        break;
    case Class::SELECTION_ID_SCOUTING_REQUEST:
        hashAppend(hashAlgorithm, this->scoutingRequest());
        break;
    case Class::SELECTION_ID_SCOUTING_RESPONSE:
        hashAppend(hashAlgorithm, this->scoutingResponse());
        break;
    case Class::SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION:
        hashAppend(hashAlgorithm, this->leadershipCessionNotification());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
ElectorMessageChoice::isEqualTo(const ElectorMessageChoice& rhs) const
{
    typedef ElectorMessageChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ELECTION_PROPOSAL:
            return this->electionProposal() == rhs.electionProposal();
        case Class::SELECTION_ID_ELECTION_RESPONSE:
            return this->electionResponse() == rhs.electionResponse();
        case Class::SELECTION_ID_LEADER_HEARTBEAT:
            return this->leaderHeartbeat() == rhs.leaderHeartbeat();
        case Class::SELECTION_ID_ELECTOR_NODE_STATUS:
            return this->electorNodeStatus() == rhs.electorNodeStatus();
        case Class::SELECTION_ID_HEARTBEAT_RESPONSE:
            return this->heartbeatResponse() == rhs.heartbeatResponse();
        case Class::SELECTION_ID_SCOUTING_REQUEST:
            return this->scoutingRequest() == rhs.scoutingRequest();
        case Class::SELECTION_ID_SCOUTING_RESPONSE:
            return this->scoutingResponse() == rhs.scoutingResponse();
        case Class::SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION:
            return this->leadershipCessionNotification() ==
                   rhs.leadershipCessionNotification();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ElectorMessageChoice::ElectorMessageChoice()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline ElectorMessageChoice::~ElectorMessageChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ElectorMessageChoice::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ElectorMessageChoice::SELECTION_ID_ELECTION_PROPOSAL:
        return manipulator(
            &d_electionProposal.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTION_PROPOSAL]);
    case ElectorMessageChoice::SELECTION_ID_ELECTION_RESPONSE:
        return manipulator(
            &d_electionResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTION_RESPONSE]);
    case ElectorMessageChoice::SELECTION_ID_LEADER_HEARTBEAT:
        return manipulator(
            &d_leaderHeartbeat.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_HEARTBEAT]);
    case ElectorMessageChoice::SELECTION_ID_ELECTOR_NODE_STATUS:
        return manipulator(
            &d_electorNodeStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR_NODE_STATUS]);
    case ElectorMessageChoice::SELECTION_ID_HEARTBEAT_RESPONSE:
        return manipulator(
            &d_heartbeatResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_HEARTBEAT_RESPONSE]);
    case ElectorMessageChoice::SELECTION_ID_SCOUTING_REQUEST:
        return manipulator(
            &d_scoutingRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_SCOUTING_REQUEST]);
    case ElectorMessageChoice::SELECTION_ID_SCOUTING_RESPONSE:
        return manipulator(
            &d_scoutingResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_SCOUTING_RESPONSE]);
    case ElectorMessageChoice::SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION:
        return manipulator(
            &d_leadershipCessionNotification.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_LEADERSHIP_CESSION_NOTIFICATION]);
    default:
        BSLS_ASSERT(ElectorMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ElectionProposal& ElectorMessageChoice::electionProposal()
{
    BSLS_ASSERT(SELECTION_ID_ELECTION_PROPOSAL == d_selectionId);
    return d_electionProposal.object();
}

inline ElectionResponse& ElectorMessageChoice::electionResponse()
{
    BSLS_ASSERT(SELECTION_ID_ELECTION_RESPONSE == d_selectionId);
    return d_electionResponse.object();
}

inline LeaderHeartbeat& ElectorMessageChoice::leaderHeartbeat()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_HEARTBEAT == d_selectionId);
    return d_leaderHeartbeat.object();
}

inline ElectorNodeStatus& ElectorMessageChoice::electorNodeStatus()
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR_NODE_STATUS == d_selectionId);
    return d_electorNodeStatus.object();
}

inline HeartbeatResponse& ElectorMessageChoice::heartbeatResponse()
{
    BSLS_ASSERT(SELECTION_ID_HEARTBEAT_RESPONSE == d_selectionId);
    return d_heartbeatResponse.object();
}

inline ScoutingRequest& ElectorMessageChoice::scoutingRequest()
{
    BSLS_ASSERT(SELECTION_ID_SCOUTING_REQUEST == d_selectionId);
    return d_scoutingRequest.object();
}

inline ScoutingResponse& ElectorMessageChoice::scoutingResponse()
{
    BSLS_ASSERT(SELECTION_ID_SCOUTING_RESPONSE == d_selectionId);
    return d_scoutingResponse.object();
}

inline LeadershipCessionNotification&
ElectorMessageChoice::leadershipCessionNotification()
{
    BSLS_ASSERT(SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION == d_selectionId);
    return d_leadershipCessionNotification.object();
}

// ACCESSORS
inline int ElectorMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ElectorMessageChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ELECTION_PROPOSAL:
        return accessor(
            d_electionProposal.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTION_PROPOSAL]);
    case SELECTION_ID_ELECTION_RESPONSE:
        return accessor(
            d_electionResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTION_RESPONSE]);
    case SELECTION_ID_LEADER_HEARTBEAT:
        return accessor(
            d_leaderHeartbeat.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_HEARTBEAT]);
    case SELECTION_ID_ELECTOR_NODE_STATUS:
        return accessor(
            d_electorNodeStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR_NODE_STATUS]);
    case SELECTION_ID_HEARTBEAT_RESPONSE:
        return accessor(
            d_heartbeatResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_HEARTBEAT_RESPONSE]);
    case SELECTION_ID_SCOUTING_REQUEST:
        return accessor(
            d_scoutingRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_SCOUTING_REQUEST]);
    case SELECTION_ID_SCOUTING_RESPONSE:
        return accessor(
            d_scoutingResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_SCOUTING_RESPONSE]);
    case SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION:
        return accessor(d_leadershipCessionNotification.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_LEADERSHIP_CESSION_NOTIFICATION]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ElectionProposal& ElectorMessageChoice::electionProposal() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTION_PROPOSAL == d_selectionId);
    return d_electionProposal.object();
}

inline const ElectionResponse& ElectorMessageChoice::electionResponse() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTION_RESPONSE == d_selectionId);
    return d_electionResponse.object();
}

inline const LeaderHeartbeat& ElectorMessageChoice::leaderHeartbeat() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_HEARTBEAT == d_selectionId);
    return d_leaderHeartbeat.object();
}

inline const ElectorNodeStatus& ElectorMessageChoice::electorNodeStatus() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR_NODE_STATUS == d_selectionId);
    return d_electorNodeStatus.object();
}

inline const HeartbeatResponse& ElectorMessageChoice::heartbeatResponse() const
{
    BSLS_ASSERT(SELECTION_ID_HEARTBEAT_RESPONSE == d_selectionId);
    return d_heartbeatResponse.object();
}

inline const ScoutingRequest& ElectorMessageChoice::scoutingRequest() const
{
    BSLS_ASSERT(SELECTION_ID_SCOUTING_REQUEST == d_selectionId);
    return d_scoutingRequest.object();
}

inline const ScoutingResponse& ElectorMessageChoice::scoutingResponse() const
{
    BSLS_ASSERT(SELECTION_ID_SCOUTING_RESPONSE == d_selectionId);
    return d_scoutingResponse.object();
}

inline const LeadershipCessionNotification&
ElectorMessageChoice::leadershipCessionNotification() const
{
    BSLS_ASSERT(SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION == d_selectionId);
    return d_leadershipCessionNotification.object();
}

inline bool ElectorMessageChoice::isElectionProposalValue() const
{
    return SELECTION_ID_ELECTION_PROPOSAL == d_selectionId;
}

inline bool ElectorMessageChoice::isElectionResponseValue() const
{
    return SELECTION_ID_ELECTION_RESPONSE == d_selectionId;
}

inline bool ElectorMessageChoice::isLeaderHeartbeatValue() const
{
    return SELECTION_ID_LEADER_HEARTBEAT == d_selectionId;
}

inline bool ElectorMessageChoice::isElectorNodeStatusValue() const
{
    return SELECTION_ID_ELECTOR_NODE_STATUS == d_selectionId;
}

inline bool ElectorMessageChoice::isHeartbeatResponseValue() const
{
    return SELECTION_ID_HEARTBEAT_RESPONSE == d_selectionId;
}

inline bool ElectorMessageChoice::isScoutingRequestValue() const
{
    return SELECTION_ID_SCOUTING_REQUEST == d_selectionId;
}

inline bool ElectorMessageChoice::isScoutingResponseValue() const
{
    return SELECTION_ID_SCOUTING_RESPONSE == d_selectionId;
}

inline bool ElectorMessageChoice::isLeadershipCessionNotificationValue() const
{
    return SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION == d_selectionId;
}

inline bool ElectorMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------
// class Expression
// ----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Expression::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_version,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Expression::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_VERSION: {
        return manipulator(&d_version,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    }
    case ATTRIBUTE_ID_TEXT: {
        return manipulator(&d_text,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Expression::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ExpressionVersion::Value& Expression::version()
{
    return d_version;
}

inline bsl::string& Expression::text()
{
    return d_text;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Expression::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_version, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Expression::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_VERSION: {
        return accessor(d_version,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    }
    case ATTRIBUTE_ID_TEXT: {
        return accessor(d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Expression::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline ExpressionVersion::Value Expression::version() const
{
    return d_version;
}

inline const bsl::string& Expression::text() const
{
    return d_text;
}

// -------------------------
// class FollowerLSNResponse
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FollowerLSNResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int FollowerLSNResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FollowerLSNResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& FollowerLSNResponse::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int FollowerLSNResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int FollowerLSNResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FollowerLSNResponse::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence& FollowerLSNResponse::sequenceNumber() const
{
    return d_sequenceNumber;
}

// -----------------------
// class LeaderAdvisoryAck
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderAdvisoryAck::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_sequenceNumberAcked,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LeaderAdvisoryAck::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER_ACKED: {
        return manipulator(
            &d_sequenceNumberAcked,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderAdvisoryAck::manipulateAttribute(t_MANIPULATOR& manipulator,
                                           const char*    name,
                                           int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& LeaderAdvisoryAck::sequenceNumberAcked()
{
    return d_sequenceNumberAcked;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderAdvisoryAck::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_sequenceNumberAcked,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LeaderAdvisoryAck::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER_ACKED: {
        return accessor(
            d_sequenceNumberAcked,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderAdvisoryAck::accessAttribute(t_ACCESSOR& accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
LeaderAdvisoryAck::sequenceNumberAcked() const
{
    return d_sequenceNumberAcked;
}

// --------------------------
// class LeaderAdvisoryCommit
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderAdvisoryCommit::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_sequenceNumberCommitted,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LeaderAdvisoryCommit::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER_COMMITTED: {
        return manipulator(
            &d_sequenceNumberCommitted,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderAdvisoryCommit::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& LeaderAdvisoryCommit::sequenceNumber()
{
    return d_sequenceNumber;
}

inline LeaderMessageSequence& LeaderAdvisoryCommit::sequenceNumberCommitted()
{
    return d_sequenceNumberCommitted;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderAdvisoryCommit::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_sequenceNumberCommitted,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LeaderAdvisoryCommit::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER_COMMITTED: {
        return accessor(
            d_sequenceNumberCommitted,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderAdvisoryCommit::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
LeaderAdvisoryCommit::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const LeaderMessageSequence&
LeaderAdvisoryCommit::sequenceNumberCommitted() const
{
    return d_sequenceNumberCommitted;
}

// ----------------------------------
// class LeaderSyncStateQueryResponse
// ----------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderSyncStateQueryResponse::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_leaderMessageSequence,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LeaderSyncStateQueryResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE: {
        return manipulator(
            &d_leaderMessageSequence,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderSyncStateQueryResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence&
LeaderSyncStateQueryResponse::leaderMessageSequence()
{
    return d_leaderMessageSequence;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderSyncStateQueryResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_leaderMessageSequence,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LeaderSyncStateQueryResponse::accessAttribute(t_ACCESSOR& accessor,
                                                  int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE: {
        return accessor(
            d_leaderMessageSequence,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderSyncStateQueryResponse::accessAttribute(t_ACCESSOR& accessor,
                                                  const char* name,
                                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
LeaderSyncStateQueryResponse::leaderMessageSequence() const
{
    return d_leaderMessageSequence;
}

// ------------------------
// class NodeStatusAdvisory
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int NodeStatusAdvisory::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int NodeStatusAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int NodeStatusAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline NodeStatus::Value& NodeStatusAdvisory::status()
{
    return d_status;
}

// ACCESSORS
template <typename t_ACCESSOR>
int NodeStatusAdvisory::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int NodeStatusAdvisory::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int NodeStatusAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline NodeStatus::Value NodeStatusAdvisory::status() const
{
    return d_status;
}

// ------------------------------
// class PartitionPrimaryAdvisory
// ------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionPrimaryAdvisory::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitions,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionPrimaryAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                  int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITIONS: {
        return manipulator(&d_partitions,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionPrimaryAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                  const char*    name,
                                                  int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& PartitionPrimaryAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline bsl::vector<PartitionPrimaryInfo>&
PartitionPrimaryAdvisory::partitions()
{
    return d_partitions;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionPrimaryAdvisory::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitions,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionPrimaryAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                              int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITIONS: {
        return accessor(d_partitions,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionPrimaryAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                              const char* name,
                                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
PartitionPrimaryAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const bsl::vector<PartitionPrimaryInfo>&
PartitionPrimaryAdvisory::partitions() const
{
    return d_partitions;
}

// -------------------------
// class PrimaryStateRequest
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PrimaryStateRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PrimaryStateRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PrimaryStateRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PrimaryStateRequest::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& PrimaryStateRequest::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PrimaryStateRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PrimaryStateRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PrimaryStateRequest::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PrimaryStateRequest::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
PrimaryStateRequest::sequenceNumber() const
{
    return d_sequenceNumber;
}

// --------------------------
// class PrimaryStateResponse
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PrimaryStateResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PrimaryStateResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PrimaryStateResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PrimaryStateResponse::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& PrimaryStateResponse::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PrimaryStateResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PrimaryStateResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PrimaryStateResponse::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PrimaryStateResponse::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
PrimaryStateResponse::sequenceNumber() const
{
    return d_sequenceNumber;
}

// ---------------------------
// class PrimaryStatusAdvisory
// ---------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PrimaryStatusAdvisory::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->primaryLeaseId());
    hashAppend(hashAlgorithm, this->status());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PrimaryStatusAdvisory::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PrimaryStatusAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PrimaryStatusAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               const char*    name,
                                               int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PrimaryStatusAdvisory::partitionId()
{
    return d_partitionId;
}

inline unsigned int& PrimaryStatusAdvisory::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline PrimaryStatus::Value& PrimaryStatusAdvisory::status()
{
    return d_status;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PrimaryStatusAdvisory::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PrimaryStatusAdvisory::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PrimaryStatusAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PrimaryStatusAdvisory::partitionId() const
{
    return d_partitionId;
}

inline unsigned int PrimaryStatusAdvisory::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline PrimaryStatus::Value PrimaryStatusAdvisory::status() const
{
    return d_status;
}

// ---------------------------
// class QueueHandleParameters
// ---------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueHandleParameters::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->uri());
    hashAppend(hashAlgorithm, this->qId());
    hashAppend(hashAlgorithm, this->subIdInfo());
    hashAppend(hashAlgorithm, this->flags());
    hashAppend(hashAlgorithm, this->readCount());
    hashAppend(hashAlgorithm, this->writeCount());
    hashAppend(hashAlgorithm, this->adminCount());
}

inline bool
QueueHandleParameters::isEqualTo(const QueueHandleParameters& rhs) const
{
    return this->uri() == rhs.uri() && this->qId() == rhs.qId() &&
           this->subIdInfo() == rhs.subIdInfo() &&
           this->flags() == rhs.flags() &&
           this->readCount() == rhs.readCount() &&
           this->writeCount() == rhs.writeCount() &&
           this->adminCount() == rhs.adminCount();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueHandleParameters::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_subIdInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_readCount,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_READ_COUNT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_writeCount,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WRITE_COUNT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_adminCount,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADMIN_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueHandleParameters::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_Q_ID: {
        return manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_SUB_ID_INFO: {
        return manipulator(&d_subIdInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    }
    case ATTRIBUTE_ID_FLAGS: {
        return manipulator(&d_flags,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    }
    case ATTRIBUTE_ID_READ_COUNT: {
        return manipulator(&d_readCount,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_READ_COUNT]);
    }
    case ATTRIBUTE_ID_WRITE_COUNT: {
        return manipulator(&d_writeCount,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WRITE_COUNT]);
    }
    case ATTRIBUTE_ID_ADMIN_COUNT: {
        return manipulator(&d_adminCount,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADMIN_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueHandleParameters::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               const char*    name,
                                               int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueHandleParameters::uri()
{
    return d_uri;
}

inline unsigned int& QueueHandleParameters::qId()
{
    return d_qId;
}

inline bdlb::NullableValue<SubQueueIdInfo>& QueueHandleParameters::subIdInfo()
{
    return d_subIdInfo;
}

inline bsls::Types::Uint64& QueueHandleParameters::flags()
{
    return d_flags;
}

inline int& QueueHandleParameters::readCount()
{
    return d_readCount;
}

inline int& QueueHandleParameters::writeCount()
{
    return d_writeCount;
}

inline int& QueueHandleParameters::adminCount()
{
    return d_adminCount;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueHandleParameters::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_subIdInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_readCount,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_READ_COUNT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_writeCount,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WRITE_COUNT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_adminCount,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADMIN_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueHandleParameters::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_Q_ID: {
        return accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_SUB_ID_INFO: {
        return accessor(d_subIdInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    }
    case ATTRIBUTE_ID_FLAGS: {
        return accessor(d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    }
    case ATTRIBUTE_ID_READ_COUNT: {
        return accessor(d_readCount,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_READ_COUNT]);
    }
    case ATTRIBUTE_ID_WRITE_COUNT: {
        return accessor(d_writeCount,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WRITE_COUNT]);
    }
    case ATTRIBUTE_ID_ADMIN_COUNT: {
        return accessor(d_adminCount,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADMIN_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueHandleParameters::accessAttribute(t_ACCESSOR& accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueHandleParameters::uri() const
{
    return d_uri;
}

inline unsigned int QueueHandleParameters::qId() const
{
    return d_qId;
}

inline const bdlb::NullableValue<SubQueueIdInfo>&
QueueHandleParameters::subIdInfo() const
{
    return d_subIdInfo;
}

inline bsls::Types::Uint64 QueueHandleParameters::flags() const
{
    return d_flags;
}

inline int QueueHandleParameters::readCount() const
{
    return d_readCount;
}

inline int QueueHandleParameters::writeCount() const
{
    return d_writeCount;
}

inline int QueueHandleParameters::adminCount() const
{
    return d_adminCount;
}

// ---------------
// class QueueInfo
// ---------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->uri());
    hashAppend(hashAlgorithm, this->key());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->appIds());
}

inline bool QueueInfo::isEqualTo(const QueueInfo& rhs) const
{
    return this->uri() == rhs.uri() && this->key() == rhs.key() &&
           this->partitionId() == rhs.partitionId() &&
           this->appIds() == rhs.appIds();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_IDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_KEY: {
        return manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_APP_IDS: {
        return manipulator(&d_appIds,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_IDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                   const char*    name,
                                   int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueInfo::uri()
{
    return d_uri;
}

inline bsl::vector<char>& QueueInfo::key()
{
    return d_key;
}

inline int& QueueInfo::partitionId()
{
    return d_partitionId;
}

inline bsl::vector<AppIdInfo>& QueueInfo::appIds()
{
    return d_appIds;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appIds, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_IDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_KEY: {
        return accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_APP_IDS: {
        return accessor(d_appIds,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_IDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueInfo::accessAttribute(t_ACCESSOR& accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueInfo::uri() const
{
    return d_uri;
}

inline const bsl::vector<char>& QueueInfo::key() const
{
    return d_key;
}

inline int QueueInfo::partitionId() const
{
    return d_partitionId;
}

inline const bsl::vector<AppIdInfo>& QueueInfo::appIds() const
{
    return d_appIds;
}

// ---------------------
// class QueueInfoUpdate
// ---------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueInfoUpdate::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->uri());
    hashAppend(hashAlgorithm, this->key());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->addedAppIds());
    hashAppend(hashAlgorithm, this->removedAppIds());
    hashAppend(hashAlgorithm, this->domain());
}

inline bool QueueInfoUpdate::isEqualTo(const QueueInfoUpdate& rhs) const
{
    return this->uri() == rhs.uri() && this->key() == rhs.key() &&
           this->partitionId() == rhs.partitionId() &&
           this->addedAppIds() == rhs.addedAppIds() &&
           this->removedAppIds() == rhs.removedAppIds() &&
           this->domain() == rhs.domain();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueInfoUpdate::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_addedAppIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADDED_APP_IDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_removedAppIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOVED_APP_IDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_domain, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAIN]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueInfoUpdate::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_KEY: {
        return manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_ADDED_APP_IDS: {
        return manipulator(
            &d_addedAppIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADDED_APP_IDS]);
    }
    case ATTRIBUTE_ID_REMOVED_APP_IDS: {
        return manipulator(
            &d_removedAppIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOVED_APP_IDS]);
    }
    case ATTRIBUTE_ID_DOMAIN: {
        return manipulator(&d_domain,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAIN]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueInfoUpdate::manipulateAttribute(t_MANIPULATOR& manipulator,
                                         const char*    name,
                                         int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueInfoUpdate::uri()
{
    return d_uri;
}

inline bsl::vector<char>& QueueInfoUpdate::key()
{
    return d_key;
}

inline int& QueueInfoUpdate::partitionId()
{
    return d_partitionId;
}

inline bsl::vector<AppIdInfo>& QueueInfoUpdate::addedAppIds()
{
    return d_addedAppIds;
}

inline bsl::vector<AppIdInfo>& QueueInfoUpdate::removedAppIds()
{
    return d_removedAppIds;
}

inline bsl::string& QueueInfoUpdate::domain()
{
    return d_domain;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueInfoUpdate::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_addedAppIds,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADDED_APP_IDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_removedAppIds,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOVED_APP_IDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_domain, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAIN]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueInfoUpdate::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_KEY: {
        return accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_ADDED_APP_IDS: {
        return accessor(d_addedAppIds,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADDED_APP_IDS]);
    }
    case ATTRIBUTE_ID_REMOVED_APP_IDS: {
        return accessor(d_removedAppIds,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOVED_APP_IDS]);
    }
    case ATTRIBUTE_ID_DOMAIN: {
        return accessor(d_domain,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAIN]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueInfoUpdate::accessAttribute(t_ACCESSOR& accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueInfoUpdate::uri() const
{
    return d_uri;
}

inline const bsl::vector<char>& QueueInfoUpdate::key() const
{
    return d_key;
}

inline int QueueInfoUpdate::partitionId() const
{
    return d_partitionId;
}

inline const bsl::vector<AppIdInfo>& QueueInfoUpdate::addedAppIds() const
{
    return d_addedAppIds;
}

inline const bsl::vector<AppIdInfo>& QueueInfoUpdate::removedAppIds() const
{
    return d_removedAppIds;
}

inline const bsl::string& QueueInfoUpdate::domain() const
{
    return d_domain;
}

// ---------------------------
// class QueueStreamParameters
// ---------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueStreamParameters::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->subIdInfo());
    hashAppend(hashAlgorithm, this->maxUnconfirmedMessages());
    hashAppend(hashAlgorithm, this->maxUnconfirmedBytes());
    hashAppend(hashAlgorithm, this->consumerPriority());
    hashAppend(hashAlgorithm, this->consumerPriorityCount());
}

inline bool
QueueStreamParameters::isEqualTo(const QueueStreamParameters& rhs) const
{
    return this->subIdInfo() == rhs.subIdInfo() &&
           this->maxUnconfirmedMessages() == rhs.maxUnconfirmedMessages() &&
           this->maxUnconfirmedBytes() == rhs.maxUnconfirmedBytes() &&
           this->consumerPriority() == rhs.consumerPriority() &&
           this->consumerPriorityCount() == rhs.consumerPriorityCount();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueStreamParameters::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_subIdInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumerPriority,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueStreamParameters::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID_INFO: {
        return manipulator(&d_subIdInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return manipulator(
            &d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return manipulator(
            &d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return manipulator(
            &d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return manipulator(
            &d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueStreamParameters::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               const char*    name,
                                               int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bdlb::NullableValue<SubQueueIdInfo>& QueueStreamParameters::subIdInfo()
{
    return d_subIdInfo;
}

inline bsls::Types::Int64& QueueStreamParameters::maxUnconfirmedMessages()
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64& QueueStreamParameters::maxUnconfirmedBytes()
{
    return d_maxUnconfirmedBytes;
}

inline int& QueueStreamParameters::consumerPriority()
{
    return d_consumerPriority;
}

inline int& QueueStreamParameters::consumerPriorityCount()
{
    return d_consumerPriorityCount;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueStreamParameters::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_subIdInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumerPriority,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueStreamParameters::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID_INFO: {
        return accessor(d_subIdInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return accessor(
            d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return accessor(
            d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return accessor(
            d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return accessor(
            d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueStreamParameters::accessAttribute(t_ACCESSOR& accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bdlb::NullableValue<SubQueueIdInfo>&
QueueStreamParameters::subIdInfo() const
{
    return d_subIdInfo;
}

inline bsls::Types::Int64 QueueStreamParameters::maxUnconfirmedMessages() const
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64 QueueStreamParameters::maxUnconfirmedBytes() const
{
    return d_maxUnconfirmedBytes;
}

inline int QueueStreamParameters::consumerPriority() const
{
    return d_consumerPriority;
}

inline int QueueStreamParameters::consumerPriorityCount() const
{
    return d_consumerPriorityCount;
}

// -------------------------
// class RegistrationRequest
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RegistrationRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RegistrationRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RegistrationRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& RegistrationRequest::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RegistrationRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RegistrationRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RegistrationRequest::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence& RegistrationRequest::sequenceNumber() const
{
    return d_sequenceNumber;
}

// ------------------------
// class ReplicaDataRequest
// ------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ReplicaDataRequest::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->replicaDataType());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->beginSequenceNumber());
    hashAppend(hashAlgorithm, this->endSequenceNumber());
}

inline bool ReplicaDataRequest::isEqualTo(const ReplicaDataRequest& rhs) const
{
    return this->replicaDataType() == rhs.replicaDataType() &&
           this->partitionId() == rhs.partitionId() &&
           this->beginSequenceNumber() == rhs.beginSequenceNumber() &&
           this->endSequenceNumber() == rhs.endSequenceNumber();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ReplicaDataRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_replicaDataType,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_beginSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_endSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ReplicaDataRequest::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REPLICA_DATA_TYPE: {
        return manipulator(
            &d_replicaDataType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER: {
        return manipulator(
            &d_beginSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUMBER: {
        return manipulator(
            &d_endSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ReplicaDataRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ReplicaDataType::Value& ReplicaDataRequest::replicaDataType()
{
    return d_replicaDataType;
}

inline int& ReplicaDataRequest::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& ReplicaDataRequest::beginSequenceNumber()
{
    return d_beginSequenceNumber;
}

inline PartitionSequenceNumber& ReplicaDataRequest::endSequenceNumber()
{
    return d_endSequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ReplicaDataRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_replicaDataType,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_beginSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endSequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ReplicaDataRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REPLICA_DATA_TYPE: {
        return accessor(
            d_replicaDataType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER: {
        return accessor(
            d_beginSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUMBER: {
        return accessor(
            d_endSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ReplicaDataRequest::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline ReplicaDataType::Value ReplicaDataRequest::replicaDataType() const
{
    return d_replicaDataType;
}

inline int ReplicaDataRequest::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
ReplicaDataRequest::beginSequenceNumber() const
{
    return d_beginSequenceNumber;
}

inline const PartitionSequenceNumber&
ReplicaDataRequest::endSequenceNumber() const
{
    return d_endSequenceNumber;
}

// -------------------------
// class ReplicaDataResponse
// -------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ReplicaDataResponse::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->replicaDataType());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->beginSequenceNumber());
    hashAppend(hashAlgorithm, this->endSequenceNumber());
}

inline bool
ReplicaDataResponse::isEqualTo(const ReplicaDataResponse& rhs) const
{
    return this->replicaDataType() == rhs.replicaDataType() &&
           this->partitionId() == rhs.partitionId() &&
           this->beginSequenceNumber() == rhs.beginSequenceNumber() &&
           this->endSequenceNumber() == rhs.endSequenceNumber();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ReplicaDataResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_replicaDataType,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_beginSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_endSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ReplicaDataResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REPLICA_DATA_TYPE: {
        return manipulator(
            &d_replicaDataType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER: {
        return manipulator(
            &d_beginSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUMBER: {
        return manipulator(
            &d_endSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ReplicaDataResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ReplicaDataType::Value& ReplicaDataResponse::replicaDataType()
{
    return d_replicaDataType;
}

inline int& ReplicaDataResponse::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& ReplicaDataResponse::beginSequenceNumber()
{
    return d_beginSequenceNumber;
}

inline PartitionSequenceNumber& ReplicaDataResponse::endSequenceNumber()
{
    return d_endSequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ReplicaDataResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_replicaDataType,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_beginSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endSequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ReplicaDataResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REPLICA_DATA_TYPE: {
        return accessor(
            d_replicaDataType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER: {
        return accessor(
            d_beginSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUMBER: {
        return accessor(
            d_endSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ReplicaDataResponse::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline ReplicaDataType::Value ReplicaDataResponse::replicaDataType() const
{
    return d_replicaDataType;
}

inline int ReplicaDataResponse::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
ReplicaDataResponse::beginSequenceNumber() const
{
    return d_beginSequenceNumber;
}

inline const PartitionSequenceNumber&
ReplicaDataResponse::endSequenceNumber() const
{
    return d_endSequenceNumber;
}

// -------------------------
// class ReplicaStateRequest
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ReplicaStateRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ReplicaStateRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ReplicaStateRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& ReplicaStateRequest::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& ReplicaStateRequest::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ReplicaStateRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ReplicaStateRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ReplicaStateRequest::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int ReplicaStateRequest::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
ReplicaStateRequest::sequenceNumber() const
{
    return d_sequenceNumber;
}

// --------------------------
// class ReplicaStateResponse
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ReplicaStateResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ReplicaStateResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ReplicaStateResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& ReplicaStateResponse::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& ReplicaStateResponse::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ReplicaStateResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ReplicaStateResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ReplicaStateResponse::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int ReplicaStateResponse::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
ReplicaStateResponse::sequenceNumber() const
{
    return d_sequenceNumber;
}

// -----------------------------
// class StateNotificationChoice
// -----------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StateNotificationChoice::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef StateNotificationChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_LEADER_PASSIVE:
        hashAppend(hashAlgorithm, this->leaderPassive());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
StateNotificationChoice::isEqualTo(const StateNotificationChoice& rhs) const
{
    typedef StateNotificationChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_LEADER_PASSIVE:
            return this->leaderPassive() == rhs.leaderPassive();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline StateNotificationChoice::StateNotificationChoice()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline StateNotificationChoice::~StateNotificationChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int StateNotificationChoice::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StateNotificationChoice::SELECTION_ID_LEADER_PASSIVE:
        return manipulator(
            &d_leaderPassive.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_PASSIVE]);
    default:
        BSLS_ASSERT(StateNotificationChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline LeaderPassive& StateNotificationChoice::leaderPassive()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_PASSIVE == d_selectionId);
    return d_leaderPassive.object();
}

// ACCESSORS
inline int StateNotificationChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int StateNotificationChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_LEADER_PASSIVE:
        return accessor(d_leaderPassive.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_PASSIVE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const LeaderPassive& StateNotificationChoice::leaderPassive() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_PASSIVE == d_selectionId);
    return d_leaderPassive.object();
}

inline bool StateNotificationChoice::isLeaderPassiveValue() const
{
    return SELECTION_ID_LEADER_PASSIVE == d_selectionId;
}

inline bool StateNotificationChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ------------
// class Status
// ------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void Status::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->category());
    hashAppend(hashAlgorithm, this->code());
    hashAppend(hashAlgorithm, this->message());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Status::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_category,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CATEGORY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_code, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CODE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_message,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Status::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CATEGORY: {
        return manipulator(&d_category,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CATEGORY]);
    }
    case ATTRIBUTE_ID_CODE: {
        return manipulator(&d_code,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CODE]);
    }
    case ATTRIBUTE_ID_MESSAGE: {
        return manipulator(&d_message,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Status::manipulateAttribute(t_MANIPULATOR& manipulator,
                                const char*    name,
                                int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline StatusCategory::Value& Status::category()
{
    return d_category;
}

inline int& Status::code()
{
    return d_code;
}

inline bsl::string& Status::message()
{
    return d_message;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Status::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_category, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CATEGORY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_code, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CODE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_message, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Status::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CATEGORY: {
        return accessor(d_category,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CATEGORY]);
    }
    case ATTRIBUTE_ID_CODE: {
        return accessor(d_code, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CODE]);
    }
    case ATTRIBUTE_ID_MESSAGE: {
        return accessor(d_message,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Status::accessAttribute(t_ACCESSOR& accessor,
                            const char* name,
                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline StatusCategory::Value Status::category() const
{
    return d_category;
}

inline int Status::code() const
{
    return d_code;
}

inline const bsl::string& Status::message() const
{
    return d_message;
}

// -------------------------
// class StorageSyncResponse
// -------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StorageSyncResponse::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->storageSyncResponseType());
    hashAppend(hashAlgorithm, this->beginSyncPoint());
    hashAppend(hashAlgorithm, this->endSyncPoint());
}

inline bool
StorageSyncResponse::isEqualTo(const StorageSyncResponse& rhs) const
{
    return this->partitionId() == rhs.partitionId() &&
           this->storageSyncResponseType() == rhs.storageSyncResponseType() &&
           this->beginSyncPoint() == rhs.beginSyncPoint() &&
           this->endSyncPoint() == rhs.endSyncPoint();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageSyncResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_storageSyncResponseType,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_beginSyncPoint,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_endSyncPoint,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StorageSyncResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STORAGE_SYNC_RESPONSE_TYPE: {
        return manipulator(
            &d_storageSyncResponseType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE]);
    }
    case ATTRIBUTE_ID_BEGIN_SYNC_POINT: {
        return manipulator(
            &d_beginSyncPoint,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT]);
    }
    case ATTRIBUTE_ID_END_SYNC_POINT: {
        return manipulator(
            &d_endSyncPoint,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StorageSyncResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& StorageSyncResponse::partitionId()
{
    return d_partitionId;
}

inline StorageSyncResponseType::Value&
StorageSyncResponse::storageSyncResponseType()
{
    return d_storageSyncResponseType;
}

inline SyncPoint& StorageSyncResponse::beginSyncPoint()
{
    return d_beginSyncPoint;
}

inline SyncPoint& StorageSyncResponse::endSyncPoint()
{
    return d_endSyncPoint;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StorageSyncResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_storageSyncResponseType,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_beginSyncPoint,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endSyncPoint,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StorageSyncResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STORAGE_SYNC_RESPONSE_TYPE: {
        return accessor(
            d_storageSyncResponseType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE]);
    }
    case ATTRIBUTE_ID_BEGIN_SYNC_POINT: {
        return accessor(
            d_beginSyncPoint,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT]);
    }
    case ATTRIBUTE_ID_END_SYNC_POINT: {
        return accessor(d_endSyncPoint,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StorageSyncResponse::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int StorageSyncResponse::partitionId() const
{
    return d_partitionId;
}

inline StorageSyncResponseType::Value
StorageSyncResponse::storageSyncResponseType() const
{
    return d_storageSyncResponseType;
}

inline const SyncPoint& StorageSyncResponse::beginSyncPoint() const
{
    return d_beginSyncPoint;
}

inline const SyncPoint& StorageSyncResponse::endSyncPoint() const
{
    return d_endSyncPoint;
}

// -------------------------
// class SyncPointOffsetPair
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int SyncPointOffsetPair::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_syncPoint,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_offset, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int SyncPointOffsetPair::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SYNC_POINT: {
        return manipulator(&d_syncPoint,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SYNC_POINT]);
    }
    case ATTRIBUTE_ID_OFFSET: {
        return manipulator(&d_offset,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int SyncPointOffsetPair::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline SyncPoint& SyncPointOffsetPair::syncPoint()
{
    return d_syncPoint;
}

inline bsls::Types::Uint64& SyncPointOffsetPair::offset()
{
    return d_offset;
}

// ACCESSORS
template <typename t_ACCESSOR>
int SyncPointOffsetPair::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_syncPoint,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_offset, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int SyncPointOffsetPair::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SYNC_POINT: {
        return accessor(d_syncPoint,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SYNC_POINT]);
    }
    case ATTRIBUTE_ID_OFFSET: {
        return accessor(d_offset,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int SyncPointOffsetPair::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const SyncPoint& SyncPointOffsetPair::syncPoint() const
{
    return d_syncPoint;
}

inline bsls::Types::Uint64 SyncPointOffsetPair::offset() const
{
    return d_offset;
}

// --------------------
// class BrokerResponse
// --------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void BrokerResponse::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->result());
    hashAppend(hashAlgorithm, this->protocolVersion());
    hashAppend(hashAlgorithm, this->brokerVersion());
    hashAppend(hashAlgorithm, this->isDeprecatedSdk());
    hashAppend(hashAlgorithm, this->brokerIdentity());
}

inline bool BrokerResponse::isEqualTo(const BrokerResponse& rhs) const
{
    return this->result() == rhs.result() &&
           this->protocolVersion() == rhs.protocolVersion() &&
           this->brokerVersion() == rhs.brokerVersion() &&
           this->isDeprecatedSdk() == rhs.isDeprecatedSdk() &&
           this->brokerIdentity() == rhs.brokerIdentity();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int BrokerResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_result, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_protocolVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_brokerVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isDeprecatedSdk,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DEPRECATED_SDK]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_brokerIdentity,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_IDENTITY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int BrokerResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_RESULT: {
        return manipulator(&d_result,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    }
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return manipulator(
            &d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_BROKER_VERSION: {
        return manipulator(
            &d_brokerVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_VERSION]);
    }
    case ATTRIBUTE_ID_IS_DEPRECATED_SDK: {
        return manipulator(
            &d_isDeprecatedSdk,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DEPRECATED_SDK]);
    }
    case ATTRIBUTE_ID_BROKER_IDENTITY: {
        return manipulator(
            &d_brokerIdentity,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_IDENTITY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int BrokerResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline Status& BrokerResponse::result()
{
    return d_result;
}

inline int& BrokerResponse::protocolVersion()
{
    return d_protocolVersion;
}

inline int& BrokerResponse::brokerVersion()
{
    return d_brokerVersion;
}

inline bool& BrokerResponse::isDeprecatedSdk()
{
    return d_isDeprecatedSdk;
}

inline ClientIdentity& BrokerResponse::brokerIdentity()
{
    return d_brokerIdentity;
}

// ACCESSORS
template <typename t_ACCESSOR>
int BrokerResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_result, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_protocolVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_brokerVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isDeprecatedSdk,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DEPRECATED_SDK]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_brokerIdentity,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_IDENTITY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int BrokerResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_RESULT: {
        return accessor(d_result,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    }
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return accessor(
            d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_BROKER_VERSION: {
        return accessor(d_brokerVersion,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_VERSION]);
    }
    case ATTRIBUTE_ID_IS_DEPRECATED_SDK: {
        return accessor(
            d_isDeprecatedSdk,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DEPRECATED_SDK]);
    }
    case ATTRIBUTE_ID_BROKER_IDENTITY: {
        return accessor(d_brokerIdentity,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_IDENTITY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int BrokerResponse::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const Status& BrokerResponse::result() const
{
    return d_result;
}

inline int BrokerResponse::protocolVersion() const
{
    return d_protocolVersion;
}

inline int BrokerResponse::brokerVersion() const
{
    return d_brokerVersion;
}

inline bool BrokerResponse::isDeprecatedSdk() const
{
    return d_isDeprecatedSdk;
}

inline const ClientIdentity& BrokerResponse::brokerIdentity() const
{
    return d_brokerIdentity;
}

// ----------------
// class CloseQueue
// ----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int CloseQueue::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_handleParameters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isFinal,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_FINAL]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int CloseQueue::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HANDLE_PARAMETERS: {
        return manipulator(
            &d_handleParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    }
    case ATTRIBUTE_ID_IS_FINAL: {
        return manipulator(&d_isFinal,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_FINAL]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int CloseQueue::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline QueueHandleParameters& CloseQueue::handleParameters()
{
    return d_handleParameters;
}

inline bool& CloseQueue::isFinal()
{
    return d_isFinal;
}

// ACCESSORS
template <typename t_ACCESSOR>
int CloseQueue::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_handleParameters,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isFinal, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_FINAL]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int CloseQueue::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HANDLE_PARAMETERS: {
        return accessor(
            d_handleParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    }
    case ATTRIBUTE_ID_IS_FINAL: {
        return accessor(d_isFinal,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_FINAL]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int CloseQueue::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const QueueHandleParameters& CloseQueue::handleParameters() const
{
    return d_handleParameters;
}

inline bool CloseQueue::isFinal() const
{
    return d_isFinal;
}

// --------------------------
// class ConfigureQueueStream
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ConfigureQueueStream::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_streamParameters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ConfigureQueueStream::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_Q_ID: {
        return manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS: {
        return manipulator(
            &d_streamParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ConfigureQueueStream::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& ConfigureQueueStream::qId()
{
    return d_qId;
}

inline QueueStreamParameters& ConfigureQueueStream::streamParameters()
{
    return d_streamParameters;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ConfigureQueueStream::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_streamParameters,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ConfigureQueueStream::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_Q_ID: {
        return accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS: {
        return accessor(
            d_streamParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ConfigureQueueStream::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int ConfigureQueueStream::qId() const
{
    return d_qId;
}

inline const QueueStreamParameters&
ConfigureQueueStream::streamParameters() const
{
    return d_streamParameters;
}

// --------------------
// class ElectorMessage
// --------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ElectorMessage::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_term, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TERM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ElectorMessage::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TERM: {
        return manipulator(&d_term,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TERM]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ElectorMessage::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Uint64& ElectorMessage::term()
{
    return d_term;
}

inline ElectorMessageChoice& ElectorMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ElectorMessage::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_term, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TERM]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ElectorMessage::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TERM: {
        return accessor(d_term, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TERM]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ElectorMessage::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Uint64 ElectorMessage::term() const
{
    return d_term;
}

inline const ElectorMessageChoice& ElectorMessage::choice() const
{
    return d_choice;
}

// --------------------
// class LeaderAdvisory
// --------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void LeaderAdvisory::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->sequenceNumber());
    hashAppend(hashAlgorithm, this->partitions());
    hashAppend(hashAlgorithm, this->queues());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderAdvisory::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitions,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LeaderAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITIONS: {
        return manipulator(&d_partitions,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& LeaderAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline bsl::vector<PartitionPrimaryInfo>& LeaderAdvisory::partitions()
{
    return d_partitions;
}

inline bsl::vector<QueueInfo>& LeaderAdvisory::queues()
{
    return d_queues;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderAdvisory::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitions,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LeaderAdvisory::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITIONS: {
        return accessor(d_partitions,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence& LeaderAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const bsl::vector<PartitionPrimaryInfo>&
LeaderAdvisory::partitions() const
{
    return d_partitions;
}

inline const bsl::vector<QueueInfo>& LeaderAdvisory::queues() const
{
    return d_queues;
}

// ---------------
// class OpenQueue
// ---------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int OpenQueue::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_handleParameters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int OpenQueue::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HANDLE_PARAMETERS: {
        return manipulator(
            &d_handleParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int OpenQueue::manipulateAttribute(t_MANIPULATOR& manipulator,
                                   const char*    name,
                                   int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline QueueHandleParameters& OpenQueue::handleParameters()
{
    return d_handleParameters;
}

// ACCESSORS
template <typename t_ACCESSOR>
int OpenQueue::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_handleParameters,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int OpenQueue::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HANDLE_PARAMETERS: {
        return accessor(
            d_handleParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int OpenQueue::accessAttribute(t_ACCESSOR& accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const QueueHandleParameters& OpenQueue::handleParameters() const
{
    return d_handleParameters;
}

// ----------------------------
// class PartitionMessageChoice
// ----------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PartitionMessageChoice::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef PartitionMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_REPLICA_STATE_REQUEST:
        hashAppend(hashAlgorithm, this->replicaStateRequest());
        break;
    case Class::SELECTION_ID_REPLICA_STATE_RESPONSE:
        hashAppend(hashAlgorithm, this->replicaStateResponse());
        break;
    case Class::SELECTION_ID_PRIMARY_STATE_REQUEST:
        hashAppend(hashAlgorithm, this->primaryStateRequest());
        break;
    case Class::SELECTION_ID_PRIMARY_STATE_RESPONSE:
        hashAppend(hashAlgorithm, this->primaryStateResponse());
        break;
    case Class::SELECTION_ID_REPLICA_DATA_REQUEST:
        hashAppend(hashAlgorithm, this->replicaDataRequest());
        break;
    case Class::SELECTION_ID_REPLICA_DATA_RESPONSE:
        hashAppend(hashAlgorithm, this->replicaDataResponse());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
PartitionMessageChoice::isEqualTo(const PartitionMessageChoice& rhs) const
{
    typedef PartitionMessageChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_REPLICA_STATE_REQUEST:
            return this->replicaStateRequest() == rhs.replicaStateRequest();
        case Class::SELECTION_ID_REPLICA_STATE_RESPONSE:
            return this->replicaStateResponse() == rhs.replicaStateResponse();
        case Class::SELECTION_ID_PRIMARY_STATE_REQUEST:
            return this->primaryStateRequest() == rhs.primaryStateRequest();
        case Class::SELECTION_ID_PRIMARY_STATE_RESPONSE:
            return this->primaryStateResponse() == rhs.primaryStateResponse();
        case Class::SELECTION_ID_REPLICA_DATA_REQUEST:
            return this->replicaDataRequest() == rhs.replicaDataRequest();
        case Class::SELECTION_ID_REPLICA_DATA_RESPONSE:
            return this->replicaDataResponse() == rhs.replicaDataResponse();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline PartitionMessageChoice::PartitionMessageChoice()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline PartitionMessageChoice::~PartitionMessageChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionMessageChoice::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case PartitionMessageChoice::SELECTION_ID_REPLICA_STATE_REQUEST:
        return manipulator(
            &d_replicaStateRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_STATE_REQUEST]);
    case PartitionMessageChoice::SELECTION_ID_REPLICA_STATE_RESPONSE:
        return manipulator(
            &d_replicaStateResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_STATE_RESPONSE]);
    case PartitionMessageChoice::SELECTION_ID_PRIMARY_STATE_REQUEST:
        return manipulator(
            &d_primaryStateRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATE_REQUEST]);
    case PartitionMessageChoice::SELECTION_ID_PRIMARY_STATE_RESPONSE:
        return manipulator(
            &d_primaryStateResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATE_RESPONSE]);
    case PartitionMessageChoice::SELECTION_ID_REPLICA_DATA_REQUEST:
        return manipulator(
            &d_replicaDataRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_DATA_REQUEST]);
    case PartitionMessageChoice::SELECTION_ID_REPLICA_DATA_RESPONSE:
        return manipulator(
            &d_replicaDataResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_DATA_RESPONSE]);
    default:
        BSLS_ASSERT(PartitionMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ReplicaStateRequest& PartitionMessageChoice::replicaStateRequest()
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_STATE_REQUEST == d_selectionId);
    return d_replicaStateRequest.object();
}

inline ReplicaStateResponse& PartitionMessageChoice::replicaStateResponse()
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_STATE_RESPONSE == d_selectionId);
    return d_replicaStateResponse.object();
}

inline PrimaryStateRequest& PartitionMessageChoice::primaryStateRequest()
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATE_REQUEST == d_selectionId);
    return d_primaryStateRequest.object();
}

inline PrimaryStateResponse& PartitionMessageChoice::primaryStateResponse()
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATE_RESPONSE == d_selectionId);
    return d_primaryStateResponse.object();
}

inline ReplicaDataRequest& PartitionMessageChoice::replicaDataRequest()
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_DATA_REQUEST == d_selectionId);
    return d_replicaDataRequest.object();
}

inline ReplicaDataResponse& PartitionMessageChoice::replicaDataResponse()
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_DATA_RESPONSE == d_selectionId);
    return d_replicaDataResponse.object();
}

// ACCESSORS
inline int PartitionMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int PartitionMessageChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_REPLICA_STATE_REQUEST:
        return accessor(
            d_replicaStateRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_STATE_REQUEST]);
    case SELECTION_ID_REPLICA_STATE_RESPONSE:
        return accessor(
            d_replicaStateResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_STATE_RESPONSE]);
    case SELECTION_ID_PRIMARY_STATE_REQUEST:
        return accessor(
            d_primaryStateRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATE_REQUEST]);
    case SELECTION_ID_PRIMARY_STATE_RESPONSE:
        return accessor(
            d_primaryStateResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATE_RESPONSE]);
    case SELECTION_ID_REPLICA_DATA_REQUEST:
        return accessor(
            d_replicaDataRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_DATA_REQUEST]);
    case SELECTION_ID_REPLICA_DATA_RESPONSE:
        return accessor(
            d_replicaDataResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_DATA_RESPONSE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ReplicaStateRequest&
PartitionMessageChoice::replicaStateRequest() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_STATE_REQUEST == d_selectionId);
    return d_replicaStateRequest.object();
}

inline const ReplicaStateResponse&
PartitionMessageChoice::replicaStateResponse() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_STATE_RESPONSE == d_selectionId);
    return d_replicaStateResponse.object();
}

inline const PrimaryStateRequest&
PartitionMessageChoice::primaryStateRequest() const
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATE_REQUEST == d_selectionId);
    return d_primaryStateRequest.object();
}

inline const PrimaryStateResponse&
PartitionMessageChoice::primaryStateResponse() const
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATE_RESPONSE == d_selectionId);
    return d_primaryStateResponse.object();
}

inline const ReplicaDataRequest&
PartitionMessageChoice::replicaDataRequest() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_DATA_REQUEST == d_selectionId);
    return d_replicaDataRequest.object();
}

inline const ReplicaDataResponse&
PartitionMessageChoice::replicaDataResponse() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_DATA_RESPONSE == d_selectionId);
    return d_replicaDataResponse.object();
}

inline bool PartitionMessageChoice::isReplicaStateRequestValue() const
{
    return SELECTION_ID_REPLICA_STATE_REQUEST == d_selectionId;
}

inline bool PartitionMessageChoice::isReplicaStateResponseValue() const
{
    return SELECTION_ID_REPLICA_STATE_RESPONSE == d_selectionId;
}

inline bool PartitionMessageChoice::isPrimaryStateRequestValue() const
{
    return SELECTION_ID_PRIMARY_STATE_REQUEST == d_selectionId;
}

inline bool PartitionMessageChoice::isPrimaryStateResponseValue() const
{
    return SELECTION_ID_PRIMARY_STATE_RESPONSE == d_selectionId;
}

inline bool PartitionMessageChoice::isReplicaDataRequestValue() const
{
    return SELECTION_ID_REPLICA_DATA_REQUEST == d_selectionId;
}

inline bool PartitionMessageChoice::isReplicaDataResponseValue() const
{
    return SELECTION_ID_REPLICA_DATA_RESPONSE == d_selectionId;
}

inline bool PartitionMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------------------
// class PartitionSyncDataQuery
// ----------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PartitionSyncDataQuery::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->lastPrimaryLeaseId());
    hashAppend(hashAlgorithm, this->lastSequenceNum());
    hashAppend(hashAlgorithm, this->uptoPrimaryLeaseId());
    hashAppend(hashAlgorithm, this->uptoSequenceNum());
    hashAppend(hashAlgorithm, this->lastSyncPointOffsetPair());
}

inline bool
PartitionSyncDataQuery::isEqualTo(const PartitionSyncDataQuery& rhs) const
{
    return this->partitionId() == rhs.partitionId() &&
           this->lastPrimaryLeaseId() == rhs.lastPrimaryLeaseId() &&
           this->lastSequenceNum() == rhs.lastSequenceNum() &&
           this->uptoPrimaryLeaseId() == rhs.uptoPrimaryLeaseId() &&
           this->uptoSequenceNum() == rhs.uptoSequenceNum() &&
           this->lastSyncPointOffsetPair() == rhs.lastSyncPointOffsetPair();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionSyncDataQuery::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_lastPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_lastSequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_uptoPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_uptoSequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_lastSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionSyncDataQuery::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_LAST_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_lastPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_LAST_SEQUENCE_NUM: {
        return manipulator(
            &d_lastSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_UPTO_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_uptoPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_UPTO_SEQUENCE_NUM: {
        return manipulator(
            &d_uptoSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR: {
        return manipulator(
            &d_lastSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionSyncDataQuery::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                const char*    name,
                                                int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncDataQuery::partitionId()
{
    return d_partitionId;
}

inline unsigned int& PartitionSyncDataQuery::lastPrimaryLeaseId()
{
    return d_lastPrimaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSyncDataQuery::lastSequenceNum()
{
    return d_lastSequenceNum;
}

inline unsigned int& PartitionSyncDataQuery::uptoPrimaryLeaseId()
{
    return d_uptoPrimaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSyncDataQuery::uptoSequenceNum()
{
    return d_uptoSequenceNum;
}

inline SyncPointOffsetPair& PartitionSyncDataQuery::lastSyncPointOffsetPair()
{
    return d_lastSyncPointOffsetPair;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionSyncDataQuery::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_lastPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_lastSequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_uptoPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_uptoSequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_lastSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionSyncDataQuery::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_LAST_PRIMARY_LEASE_ID: {
        return accessor(
            d_lastPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_LAST_SEQUENCE_NUM: {
        return accessor(
            d_lastSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_UPTO_PRIMARY_LEASE_ID: {
        return accessor(
            d_uptoPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_UPTO_SEQUENCE_NUM: {
        return accessor(
            d_uptoSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR: {
        return accessor(
            d_lastSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionSyncDataQuery::accessAttribute(t_ACCESSOR& accessor,
                                            const char* name,
                                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncDataQuery::partitionId() const
{
    return d_partitionId;
}

inline unsigned int PartitionSyncDataQuery::lastPrimaryLeaseId() const
{
    return d_lastPrimaryLeaseId;
}

inline bsls::Types::Uint64 PartitionSyncDataQuery::lastSequenceNum() const
{
    return d_lastSequenceNum;
}

inline unsigned int PartitionSyncDataQuery::uptoPrimaryLeaseId() const
{
    return d_uptoPrimaryLeaseId;
}

inline bsls::Types::Uint64 PartitionSyncDataQuery::uptoSequenceNum() const
{
    return d_uptoSequenceNum;
}

inline const SyncPointOffsetPair&
PartitionSyncDataQuery::lastSyncPointOffsetPair() const
{
    return d_lastSyncPointOffsetPair;
}

// ----------------------------------
// class PartitionSyncDataQueryStatus
// ----------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionSyncDataQueryStatus::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionSyncDataQueryStatus::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionSyncDataQueryStatus::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncDataQueryStatus::partitionId()
{
    return d_partitionId;
}

inline Status& PartitionSyncDataQueryStatus::status()
{
    return d_status;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionSyncDataQueryStatus::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionSyncDataQueryStatus::accessAttribute(t_ACCESSOR& accessor,
                                                  int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionSyncDataQueryStatus::accessAttribute(t_ACCESSOR& accessor,
                                                  const char* name,
                                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncDataQueryStatus::partitionId() const
{
    return d_partitionId;
}

inline const Status& PartitionSyncDataQueryStatus::status() const
{
    return d_status;
}

// -------------------------------------
// class PartitionSyncStateQueryResponse
// -------------------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PartitionSyncStateQueryResponse::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->primaryLeaseId());
    hashAppend(hashAlgorithm, this->sequenceNum());
    hashAppend(hashAlgorithm, this->lastSyncPointOffsetPair());
}

inline bool PartitionSyncStateQueryResponse::isEqualTo(
    const PartitionSyncStateQueryResponse& rhs) const
{
    return this->partitionId() == rhs.partitionId() &&
           this->primaryLeaseId() == rhs.primaryLeaseId() &&
           this->sequenceNum() == rhs.sequenceNum() &&
           this->lastSyncPointOffsetPair() == rhs.lastSyncPointOffsetPair();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionSyncStateQueryResponse::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_lastSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionSyncStateQueryResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return manipulator(&d_sequenceNum,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR: {
        return manipulator(
            &d_lastSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionSyncStateQueryResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncStateQueryResponse::partitionId()
{
    return d_partitionId;
}

inline unsigned int& PartitionSyncStateQueryResponse::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSyncStateQueryResponse::sequenceNum()
{
    return d_sequenceNum;
}

inline SyncPointOffsetPair&
PartitionSyncStateQueryResponse::lastSyncPointOffsetPair()
{
    return d_lastSyncPointOffsetPair;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionSyncStateQueryResponse::accessAttributes(
    t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_lastSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionSyncStateQueryResponse::accessAttribute(t_ACCESSOR& accessor,
                                                     int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return accessor(d_sequenceNum,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR: {
        return accessor(
            d_lastSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionSyncStateQueryResponse::accessAttribute(t_ACCESSOR& accessor,
                                                     const char* name,
                                                     int nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncStateQueryResponse::partitionId() const
{
    return d_partitionId;
}

inline unsigned int PartitionSyncStateQueryResponse::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64 PartitionSyncStateQueryResponse::sequenceNum() const
{
    return d_sequenceNum;
}

inline const SyncPointOffsetPair&
PartitionSyncStateQueryResponse::lastSyncPointOffsetPair() const
{
    return d_lastSyncPointOffsetPair;
}

// -----------------------------
// class QueueAssignmentAdvisory
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueAssignmentAdvisory::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueAssignmentAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueAssignmentAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 const char*    name,
                                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& QueueAssignmentAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline bsl::vector<QueueInfo>& QueueAssignmentAdvisory::queues()
{
    return d_queues;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueAssignmentAdvisory::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueAssignmentAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                             int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueAssignmentAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
QueueAssignmentAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const bsl::vector<QueueInfo>& QueueAssignmentAdvisory::queues() const
{
    return d_queues;
}

// -------------------------------
// class QueueUnAssignmentAdvisory
// -------------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueUnAssignmentAdvisory::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->primaryNodeId());
    hashAppend(hashAlgorithm, this->primaryLeaseId());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->queues());
}

inline bool QueueUnAssignmentAdvisory::isEqualTo(
    const QueueUnAssignmentAdvisory& rhs) const
{
    return this->primaryNodeId() == rhs.primaryNodeId() &&
           this->primaryLeaseId() == rhs.primaryLeaseId() &&
           this->partitionId() == rhs.partitionId() &&
           this->queues() == rhs.queues();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueUnAssignmentAdvisory::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_primaryNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueUnAssignmentAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                   int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return manipulator(
            &d_primaryNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueUnAssignmentAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                   const char*    name,
                                                   int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& QueueUnAssignmentAdvisory::primaryNodeId()
{
    return d_primaryNodeId;
}

inline unsigned int& QueueUnAssignmentAdvisory::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline int& QueueUnAssignmentAdvisory::partitionId()
{
    return d_partitionId;
}

inline bsl::vector<QueueInfo>& QueueUnAssignmentAdvisory::queues()
{
    return d_queues;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueUnAssignmentAdvisory::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_primaryNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueUnAssignmentAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                               int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return accessor(d_primaryNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueUnAssignmentAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                               const char* name,
                                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int QueueUnAssignmentAdvisory::primaryNodeId() const
{
    return d_primaryNodeId;
}

inline unsigned int QueueUnAssignmentAdvisory::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline int QueueUnAssignmentAdvisory::partitionId() const
{
    return d_partitionId;
}

inline const bsl::vector<QueueInfo>& QueueUnAssignmentAdvisory::queues() const
{
    return d_queues;
}

// -----------------------------
// class QueueUnassignedAdvisory
// -----------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueUnassignedAdvisory::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->sequenceNumber());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->primaryLeaseId());
    hashAppend(hashAlgorithm, this->primaryNodeId());
    hashAppend(hashAlgorithm, this->queues());
}

inline bool
QueueUnassignedAdvisory::isEqualTo(const QueueUnassignedAdvisory& rhs) const
{
    return this->sequenceNumber() == rhs.sequenceNumber() &&
           this->partitionId() == rhs.partitionId() &&
           this->primaryLeaseId() == rhs.primaryLeaseId() &&
           this->primaryNodeId() == rhs.primaryNodeId() &&
           this->queues() == rhs.queues();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueUnassignedAdvisory::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueUnassignedAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return manipulator(
            &d_primaryNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueUnassignedAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 const char*    name,
                                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& QueueUnassignedAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline int& QueueUnassignedAdvisory::partitionId()
{
    return d_partitionId;
}

inline unsigned int& QueueUnassignedAdvisory::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline int& QueueUnassignedAdvisory::primaryNodeId()
{
    return d_primaryNodeId;
}

inline bsl::vector<QueueInfo>& QueueUnassignedAdvisory::queues()
{
    return d_queues;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueUnassignedAdvisory::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueUnassignedAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                             int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return accessor(d_primaryNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueUnassignedAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
QueueUnassignedAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline int QueueUnassignedAdvisory::partitionId() const
{
    return d_partitionId;
}

inline unsigned int QueueUnassignedAdvisory::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline int QueueUnassignedAdvisory::primaryNodeId() const
{
    return d_primaryNodeId;
}

inline const bsl::vector<QueueInfo>& QueueUnassignedAdvisory::queues() const
{
    return d_queues;
}

// -------------------------
// class QueueUpdateAdvisory
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueUpdateAdvisory::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queueUpdates,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_UPDATES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueUpdateAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_QUEUE_UPDATES: {
        return manipulator(
            &d_queueUpdates,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_UPDATES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueUpdateAdvisory::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& QueueUpdateAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline bsl::vector<QueueInfoUpdate>& QueueUpdateAdvisory::queueUpdates()
{
    return d_queueUpdates;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueUpdateAdvisory::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queueUpdates,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_UPDATES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueUpdateAdvisory::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_QUEUE_UPDATES: {
        return accessor(d_queueUpdates,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_UPDATES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueUpdateAdvisory::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence& QueueUpdateAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const bsl::vector<QueueInfoUpdate>&
QueueUpdateAdvisory::queueUpdates() const
{
    return d_queueUpdates;
}

// -----------------------
// class StateNotification
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StateNotification::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StateNotification::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StateNotification::manipulateAttribute(t_MANIPULATOR& manipulator,
                                           const char*    name,
                                           int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline StateNotificationChoice& StateNotification::choice()
{
    return d_choice;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StateNotification::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StateNotification::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StateNotification::accessAttribute(t_ACCESSOR& accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const StateNotificationChoice& StateNotification::choice() const
{
    return d_choice;
}

// ------------------------
// class StorageSyncRequest
// ------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StorageSyncRequest::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->beginSyncPointOffsetPair());
    hashAppend(hashAlgorithm, this->endSyncPointOffsetPair());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageSyncRequest::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_beginSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_endSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StorageSyncRequest::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SYNC_POINT_OFFSET_PAIR: {
        return manipulator(&d_beginSyncPointOffsetPair,
                           ATTRIBUTE_INFO_ARRAY
                               [ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR]);
    }
    case ATTRIBUTE_ID_END_SYNC_POINT_OFFSET_PAIR: {
        return manipulator(
            &d_endSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StorageSyncRequest::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& StorageSyncRequest::partitionId()
{
    return d_partitionId;
}

inline bdlb::NullableValue<SyncPointOffsetPair>&
StorageSyncRequest::beginSyncPointOffsetPair()
{
    return d_beginSyncPointOffsetPair;
}

inline bdlb::NullableValue<SyncPointOffsetPair>&
StorageSyncRequest::endSyncPointOffsetPair()
{
    return d_endSyncPointOffsetPair;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StorageSyncRequest::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_beginSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_endSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StorageSyncRequest::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SYNC_POINT_OFFSET_PAIR: {
        return accessor(d_beginSyncPointOffsetPair,
                        ATTRIBUTE_INFO_ARRAY
                            [ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR]);
    }
    case ATTRIBUTE_ID_END_SYNC_POINT_OFFSET_PAIR: {
        return accessor(
            d_endSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StorageSyncRequest::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int StorageSyncRequest::partitionId() const
{
    return d_partitionId;
}

inline const bdlb::NullableValue<SyncPointOffsetPair>&
StorageSyncRequest::beginSyncPointOffsetPair() const
{
    return d_beginSyncPointOffsetPair;
}

inline const bdlb::NullableValue<SyncPointOffsetPair>&
StorageSyncRequest::endSyncPointOffsetPair() const
{
    return d_endSyncPointOffsetPair;
}

// ------------------
// class Subscription
// ------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void Subscription::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->sId());
    hashAppend(hashAlgorithm, this->expression());
    hashAppend(hashAlgorithm, this->consumers());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Subscription::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_S_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_expression,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumers,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Subscription::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_S_ID: {
        return manipulator(&d_sId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_S_ID]);
    }
    case ATTRIBUTE_ID_EXPRESSION: {
        return manipulator(&d_expression,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    }
    case ATTRIBUTE_ID_CONSUMERS: {
        return manipulator(&d_consumers,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Subscription::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& Subscription::sId()
{
    return d_sId;
}

inline Expression& Subscription::expression()
{
    return d_expression;
}

inline bsl::vector<ConsumerInfo>& Subscription::consumers()
{
    return d_consumers;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Subscription::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_S_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_expression,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumers,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Subscription::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_S_ID: {
        return accessor(d_sId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_S_ID]);
    }
    case ATTRIBUTE_ID_EXPRESSION: {
        return accessor(d_expression,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    }
    case ATTRIBUTE_ID_CONSUMERS: {
        return accessor(d_consumers,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Subscription::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int Subscription::sId() const
{
    return d_sId;
}

inline const Expression& Subscription::expression() const
{
    return d_expression;
}

inline const bsl::vector<ConsumerInfo>& Subscription::consumers() const
{
    return d_consumers;
}

// ----------------------------------
// class ConfigureQueueStreamResponse
// ----------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ConfigureQueueStreamResponse::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_request,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ConfigureQueueStreamResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REQUEST: {
        return manipulator(&d_request,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ConfigureQueueStreamResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ConfigureQueueStream& ConfigureQueueStreamResponse::request()
{
    return d_request;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ConfigureQueueStreamResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_request, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ConfigureQueueStreamResponse::accessAttribute(t_ACCESSOR& accessor,
                                                  int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REQUEST: {
        return accessor(d_request,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ConfigureQueueStreamResponse::accessAttribute(t_ACCESSOR& accessor,
                                                  const char* name,
                                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const ConfigureQueueStream&
ConfigureQueueStreamResponse::request() const
{
    return d_request;
}

// ----------------------------------
// class FollowerClusterStateResponse
// ----------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FollowerClusterStateResponse::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_clusterStateSnapshot,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int FollowerClusterStateResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_STATE_SNAPSHOT: {
        return manipulator(
            &d_clusterStateSnapshot,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FollowerClusterStateResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderAdvisory& FollowerClusterStateResponse::clusterStateSnapshot()
{
    return d_clusterStateSnapshot;
}

// ACCESSORS
template <typename t_ACCESSOR>
int FollowerClusterStateResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_clusterStateSnapshot,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int FollowerClusterStateResponse::accessAttribute(t_ACCESSOR& accessor,
                                                  int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_STATE_SNAPSHOT: {
        return accessor(
            d_clusterStateSnapshot,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FollowerClusterStateResponse::accessAttribute(t_ACCESSOR& accessor,
                                                  const char* name,
                                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderAdvisory&
FollowerClusterStateResponse::clusterStateSnapshot() const
{
    return d_clusterStateSnapshot;
}

// ---------------------------------
// class LeaderSyncDataQueryResponse
// ---------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderSyncDataQueryResponse::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_leaderSyncData,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_SYNC_DATA]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LeaderSyncDataQueryResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEADER_SYNC_DATA: {
        return manipulator(
            &d_leaderSyncData,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_SYNC_DATA]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderSyncDataQueryResponse::manipulateAttribute(
    t_MANIPULATOR& manipulator,
    const char*    name,
    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderAdvisory& LeaderSyncDataQueryResponse::leaderSyncData()
{
    return d_leaderSyncData;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderSyncDataQueryResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_leaderSyncData,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_SYNC_DATA]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LeaderSyncDataQueryResponse::accessAttribute(t_ACCESSOR& accessor,
                                                 int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEADER_SYNC_DATA: {
        return accessor(
            d_leaderSyncData,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_SYNC_DATA]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderSyncDataQueryResponse::accessAttribute(t_ACCESSOR& accessor,
                                                 const char* name,
                                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderAdvisory&
LeaderSyncDataQueryResponse::leaderSyncData() const
{
    return d_leaderSyncData;
}

// ------------------------
// class NegotiationMessage
// ------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void NegotiationMessage::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef NegotiationMessage Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_CLIENT_IDENTITY:
        hashAppend(hashAlgorithm, this->clientIdentity());
        break;
    case Class::SELECTION_ID_BROKER_RESPONSE:
        hashAppend(hashAlgorithm, this->brokerResponse());
        break;
    case Class::SELECTION_ID_REVERSE_CONNECTION_REQUEST:
        hashAppend(hashAlgorithm, this->reverseConnectionRequest());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool NegotiationMessage::isEqualTo(const NegotiationMessage& rhs) const
{
    typedef NegotiationMessage Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_CLIENT_IDENTITY:
            return this->clientIdentity() == rhs.clientIdentity();
        case Class::SELECTION_ID_BROKER_RESPONSE:
            return this->brokerResponse() == rhs.brokerResponse();
        case Class::SELECTION_ID_REVERSE_CONNECTION_REQUEST:
            return this->reverseConnectionRequest() ==
                   rhs.reverseConnectionRequest();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline NegotiationMessage::NegotiationMessage(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline NegotiationMessage::~NegotiationMessage()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int NegotiationMessage::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case NegotiationMessage::SELECTION_ID_CLIENT_IDENTITY:
        return manipulator(
            &d_clientIdentity.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLIENT_IDENTITY]);
    case NegotiationMessage::SELECTION_ID_BROKER_RESPONSE:
        return manipulator(
            &d_brokerResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_RESPONSE]);
    case NegotiationMessage::SELECTION_ID_REVERSE_CONNECTION_REQUEST:
        return manipulator(
            &d_reverseConnectionRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REVERSE_CONNECTION_REQUEST]);
    default:
        BSLS_ASSERT(NegotiationMessage::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ClientIdentity& NegotiationMessage::clientIdentity()
{
    BSLS_ASSERT(SELECTION_ID_CLIENT_IDENTITY == d_selectionId);
    return d_clientIdentity.object();
}

inline BrokerResponse& NegotiationMessage::brokerResponse()
{
    BSLS_ASSERT(SELECTION_ID_BROKER_RESPONSE == d_selectionId);
    return d_brokerResponse.object();
}

inline ReverseConnectionRequest& NegotiationMessage::reverseConnectionRequest()
{
    BSLS_ASSERT(SELECTION_ID_REVERSE_CONNECTION_REQUEST == d_selectionId);
    return d_reverseConnectionRequest.object();
}

// ACCESSORS
inline int NegotiationMessage::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int NegotiationMessage::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_CLIENT_IDENTITY:
        return accessor(d_clientIdentity.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLIENT_IDENTITY]);
    case SELECTION_ID_BROKER_RESPONSE:
        return accessor(d_brokerResponse.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_RESPONSE]);
    case SELECTION_ID_REVERSE_CONNECTION_REQUEST:
        return accessor(
            d_reverseConnectionRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REVERSE_CONNECTION_REQUEST]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ClientIdentity& NegotiationMessage::clientIdentity() const
{
    BSLS_ASSERT(SELECTION_ID_CLIENT_IDENTITY == d_selectionId);
    return d_clientIdentity.object();
}

inline const BrokerResponse& NegotiationMessage::brokerResponse() const
{
    BSLS_ASSERT(SELECTION_ID_BROKER_RESPONSE == d_selectionId);
    return d_brokerResponse.object();
}

inline const ReverseConnectionRequest&
NegotiationMessage::reverseConnectionRequest() const
{
    BSLS_ASSERT(SELECTION_ID_REVERSE_CONNECTION_REQUEST == d_selectionId);
    return d_reverseConnectionRequest.object();
}

inline bool NegotiationMessage::isClientIdentityValue() const
{
    return SELECTION_ID_CLIENT_IDENTITY == d_selectionId;
}

inline bool NegotiationMessage::isBrokerResponseValue() const
{
    return SELECTION_ID_BROKER_RESPONSE == d_selectionId;
}

inline bool NegotiationMessage::isReverseConnectionRequestValue() const
{
    return SELECTION_ID_REVERSE_CONNECTION_REQUEST == d_selectionId;
}

inline bool NegotiationMessage::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------------
// class OpenQueueResponse
// -----------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void OpenQueueResponse::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->originalRequest());
    hashAppend(hashAlgorithm, this->routingConfiguration());
    hashAppend(hashAlgorithm, this->deduplicationTimeMs());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int OpenQueueResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_originalRequest,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ORIGINAL_REQUEST]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_routingConfiguration,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING_CONFIGURATION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_deduplicationTimeMs,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int OpenQueueResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ORIGINAL_REQUEST: {
        return manipulator(
            &d_originalRequest,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ORIGINAL_REQUEST]);
    }
    case ATTRIBUTE_ID_ROUTING_CONFIGURATION: {
        return manipulator(
            &d_routingConfiguration,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING_CONFIGURATION]);
    }
    case ATTRIBUTE_ID_DEDUPLICATION_TIME_MS: {
        return manipulator(
            &d_deduplicationTimeMs,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int OpenQueueResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                           const char*    name,
                                           int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline OpenQueue& OpenQueueResponse::originalRequest()
{
    return d_originalRequest;
}

inline RoutingConfiguration& OpenQueueResponse::routingConfiguration()
{
    return d_routingConfiguration;
}

inline int& OpenQueueResponse::deduplicationTimeMs()
{
    return d_deduplicationTimeMs;
}

// ACCESSORS
template <typename t_ACCESSOR>
int OpenQueueResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_originalRequest,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ORIGINAL_REQUEST]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_routingConfiguration,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING_CONFIGURATION]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_deduplicationTimeMs,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int OpenQueueResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ORIGINAL_REQUEST: {
        return accessor(
            d_originalRequest,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ORIGINAL_REQUEST]);
    }
    case ATTRIBUTE_ID_ROUTING_CONFIGURATION: {
        return accessor(
            d_routingConfiguration,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING_CONFIGURATION]);
    }
    case ATTRIBUTE_ID_DEDUPLICATION_TIME_MS: {
        return accessor(
            d_deduplicationTimeMs,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int OpenQueueResponse::accessAttribute(t_ACCESSOR& accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const OpenQueue& OpenQueueResponse::originalRequest() const
{
    return d_originalRequest;
}

inline const RoutingConfiguration&
OpenQueueResponse::routingConfiguration() const
{
    return d_routingConfiguration;
}

inline int OpenQueueResponse::deduplicationTimeMs() const
{
    return d_deduplicationTimeMs;
}

// ----------------------
// class PartitionMessage
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionMessage::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionMessage::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionMessage::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline PartitionMessageChoice& PartitionMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionMessage::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionMessage::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionMessage::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const PartitionMessageChoice& PartitionMessage::choice() const
{
    return d_choice;
}

// ----------------------
// class StreamParameters
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StreamParameters::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_subscriptions,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTIONS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StreamParameters::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_SUBSCRIPTIONS: {
        return manipulator(
            &d_subscriptions,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StreamParameters::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StreamParameters::appId()
{
    return d_appId;
}

inline bsl::vector<Subscription>& StreamParameters::subscriptions()
{
    return d_subscriptions;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StreamParameters::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_subscriptions,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTIONS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StreamParameters::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_SUBSCRIPTIONS: {
        return accessor(d_subscriptions,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StreamParameters::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StreamParameters::appId() const
{
    return d_appId;
}

inline const bsl::vector<Subscription>& StreamParameters::subscriptions() const
{
    return d_subscriptions;
}

// ----------------------------------
// class ClusterStateFSMMessageChoice
// ----------------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterStateFSMMessageChoice::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ClusterStateFSMMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_FOLLOWER_L_S_N_REQUEST:
        hashAppend(hashAlgorithm, this->followerLSNRequest());
        break;
    case Class::SELECTION_ID_FOLLOWER_L_S_N_RESPONSE:
        hashAppend(hashAlgorithm, this->followerLSNResponse());
        break;
    case Class::SELECTION_ID_REGISTRATION_REQUEST:
        hashAppend(hashAlgorithm, this->registrationRequest());
        break;
    case Class::SELECTION_ID_REGISTRATION_RESPONSE:
        hashAppend(hashAlgorithm, this->registrationResponse());
        break;
    case Class::SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST:
        hashAppend(hashAlgorithm, this->followerClusterStateRequest());
        break;
    case Class::SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE:
        hashAppend(hashAlgorithm, this->followerClusterStateResponse());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ClusterStateFSMMessageChoice::isEqualTo(
    const ClusterStateFSMMessageChoice& rhs) const
{
    typedef ClusterStateFSMMessageChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_FOLLOWER_L_S_N_REQUEST:
            return this->followerLSNRequest() == rhs.followerLSNRequest();
        case Class::SELECTION_ID_FOLLOWER_L_S_N_RESPONSE:
            return this->followerLSNResponse() == rhs.followerLSNResponse();
        case Class::SELECTION_ID_REGISTRATION_REQUEST:
            return this->registrationRequest() == rhs.registrationRequest();
        case Class::SELECTION_ID_REGISTRATION_RESPONSE:
            return this->registrationResponse() == rhs.registrationResponse();
        case Class::SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST:
            return this->followerClusterStateRequest() ==
                   rhs.followerClusterStateRequest();
        case Class::SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE:
            return this->followerClusterStateResponse() ==
                   rhs.followerClusterStateResponse();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ClusterStateFSMMessageChoice::ClusterStateFSMMessageChoice(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClusterStateFSMMessageChoice::~ClusterStateFSMMessageChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterStateFSMMessageChoice::manipulateSelection(
    t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClusterStateFSMMessageChoice::SELECTION_ID_FOLLOWER_L_S_N_REQUEST:
        return manipulator(
            &d_followerLSNRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FOLLOWER_L_S_N_REQUEST]);
    case ClusterStateFSMMessageChoice::SELECTION_ID_FOLLOWER_L_S_N_RESPONSE:
        return manipulator(
            &d_followerLSNResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FOLLOWER_L_S_N_RESPONSE]);
    case ClusterStateFSMMessageChoice::SELECTION_ID_REGISTRATION_REQUEST:
        return manipulator(
            &d_registrationRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REGISTRATION_REQUEST]);
    case ClusterStateFSMMessageChoice::SELECTION_ID_REGISTRATION_RESPONSE:
        return manipulator(
            &d_registrationResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REGISTRATION_RESPONSE]);
    case ClusterStateFSMMessageChoice::
        SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST:
        return manipulator(
            &d_followerClusterStateRequest.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_REQUEST]);
    case ClusterStateFSMMessageChoice::
        SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE:
        return manipulator(
            &d_followerClusterStateResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_RESPONSE]);
    default:
        BSLS_ASSERT(ClusterStateFSMMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline FollowerLSNRequest& ClusterStateFSMMessageChoice::followerLSNRequest()
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_L_S_N_REQUEST == d_selectionId);
    return d_followerLSNRequest.object();
}

inline FollowerLSNResponse& ClusterStateFSMMessageChoice::followerLSNResponse()
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_L_S_N_RESPONSE == d_selectionId);
    return d_followerLSNResponse.object();
}

inline RegistrationRequest& ClusterStateFSMMessageChoice::registrationRequest()
{
    BSLS_ASSERT(SELECTION_ID_REGISTRATION_REQUEST == d_selectionId);
    return d_registrationRequest.object();
}

inline RegistrationResponse&
ClusterStateFSMMessageChoice::registrationResponse()
{
    BSLS_ASSERT(SELECTION_ID_REGISTRATION_RESPONSE == d_selectionId);
    return d_registrationResponse.object();
}

inline FollowerClusterStateRequest&
ClusterStateFSMMessageChoice::followerClusterStateRequest()
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST == d_selectionId);
    return d_followerClusterStateRequest.object();
}

inline FollowerClusterStateResponse&
ClusterStateFSMMessageChoice::followerClusterStateResponse()
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE == d_selectionId);
    return d_followerClusterStateResponse.object();
}

// ACCESSORS
inline int ClusterStateFSMMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ClusterStateFSMMessageChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_FOLLOWER_L_S_N_REQUEST:
        return accessor(
            d_followerLSNRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FOLLOWER_L_S_N_REQUEST]);
    case SELECTION_ID_FOLLOWER_L_S_N_RESPONSE:
        return accessor(
            d_followerLSNResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FOLLOWER_L_S_N_RESPONSE]);
    case SELECTION_ID_REGISTRATION_REQUEST:
        return accessor(
            d_registrationRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REGISTRATION_REQUEST]);
    case SELECTION_ID_REGISTRATION_RESPONSE:
        return accessor(
            d_registrationResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REGISTRATION_RESPONSE]);
    case SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST:
        return accessor(d_followerClusterStateRequest.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_REQUEST]);
    case SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE:
        return accessor(d_followerClusterStateResponse.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_RESPONSE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const FollowerLSNRequest&
ClusterStateFSMMessageChoice::followerLSNRequest() const
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_L_S_N_REQUEST == d_selectionId);
    return d_followerLSNRequest.object();
}

inline const FollowerLSNResponse&
ClusterStateFSMMessageChoice::followerLSNResponse() const
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_L_S_N_RESPONSE == d_selectionId);
    return d_followerLSNResponse.object();
}

inline const RegistrationRequest&
ClusterStateFSMMessageChoice::registrationRequest() const
{
    BSLS_ASSERT(SELECTION_ID_REGISTRATION_REQUEST == d_selectionId);
    return d_registrationRequest.object();
}

inline const RegistrationResponse&
ClusterStateFSMMessageChoice::registrationResponse() const
{
    BSLS_ASSERT(SELECTION_ID_REGISTRATION_RESPONSE == d_selectionId);
    return d_registrationResponse.object();
}

inline const FollowerClusterStateRequest&
ClusterStateFSMMessageChoice::followerClusterStateRequest() const
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST == d_selectionId);
    return d_followerClusterStateRequest.object();
}

inline const FollowerClusterStateResponse&
ClusterStateFSMMessageChoice::followerClusterStateResponse() const
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE == d_selectionId);
    return d_followerClusterStateResponse.object();
}

inline bool ClusterStateFSMMessageChoice::isFollowerLSNRequestValue() const
{
    return SELECTION_ID_FOLLOWER_L_S_N_REQUEST == d_selectionId;
}

inline bool ClusterStateFSMMessageChoice::isFollowerLSNResponseValue() const
{
    return SELECTION_ID_FOLLOWER_L_S_N_RESPONSE == d_selectionId;
}

inline bool ClusterStateFSMMessageChoice::isRegistrationRequestValue() const
{
    return SELECTION_ID_REGISTRATION_REQUEST == d_selectionId;
}

inline bool ClusterStateFSMMessageChoice::isRegistrationResponseValue() const
{
    return SELECTION_ID_REGISTRATION_RESPONSE == d_selectionId;
}

inline bool
ClusterStateFSMMessageChoice::isFollowerClusterStateRequestValue() const
{
    return SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST == d_selectionId;
}

inline bool
ClusterStateFSMMessageChoice::isFollowerClusterStateResponseValue() const
{
    return SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE == d_selectionId;
}

inline bool ClusterStateFSMMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ---------------------
// class ConfigureStream
// ---------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ConfigureStream::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_streamParameters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ConfigureStream::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_Q_ID: {
        return manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS: {
        return manipulator(
            &d_streamParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ConfigureStream::manipulateAttribute(t_MANIPULATOR& manipulator,
                                         const char*    name,
                                         int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& ConfigureStream::qId()
{
    return d_qId;
}

inline StreamParameters& ConfigureStream::streamParameters()
{
    return d_streamParameters;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ConfigureStream::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_streamParameters,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ConfigureStream::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_Q_ID: {
        return accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS: {
        return accessor(
            d_streamParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ConfigureStream::accessAttribute(t_ACCESSOR& accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int ConfigureStream::qId() const
{
    return d_qId;
}

inline const StreamParameters& ConfigureStream::streamParameters() const
{
    return d_streamParameters;
}

// ----------------------------
// class ClusterStateFSMMessage
// ----------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterStateFSMMessage::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterStateFSMMessage::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterStateFSMMessage::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                const char*    name,
                                                int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ClusterStateFSMMessageChoice& ClusterStateFSMMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterStateFSMMessage::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterStateFSMMessage::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterStateFSMMessage::accessAttribute(t_ACCESSOR& accessor,
                                            const char* name,
                                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const ClusterStateFSMMessageChoice&
ClusterStateFSMMessage::choice() const
{
    return d_choice;
}

// -----------------------------
// class ConfigureStreamResponse
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ConfigureStreamResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_request,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ConfigureStreamResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REQUEST: {
        return manipulator(&d_request,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ConfigureStreamResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 const char*    name,
                                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ConfigureStream& ConfigureStreamResponse::request()
{
    return d_request;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ConfigureStreamResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_request, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ConfigureStreamResponse::accessAttribute(t_ACCESSOR& accessor,
                                             int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REQUEST: {
        return accessor(d_request,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ConfigureStreamResponse::accessAttribute(t_ACCESSOR& accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const ConfigureStream& ConfigureStreamResponse::request() const
{
    return d_request;
}

// --------------------------
// class ClusterMessageChoice
// --------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterMessageChoice::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ClusterMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_PARTITION_PRIMARY_ADVISORY:
        hashAppend(hashAlgorithm, this->partitionPrimaryAdvisory());
        break;
    case Class::SELECTION_ID_LEADER_ADVISORY:
        hashAppend(hashAlgorithm, this->leaderAdvisory());
        break;
    case Class::SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY:
        hashAppend(hashAlgorithm, this->queueAssignmentAdvisory());
        break;
    case Class::SELECTION_ID_NODE_STATUS_ADVISORY:
        hashAppend(hashAlgorithm, this->nodeStatusAdvisory());
        break;
    case Class::SELECTION_ID_LEADER_SYNC_STATE_QUERY:
        hashAppend(hashAlgorithm, this->leaderSyncStateQuery());
        break;
    case Class::SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE:
        hashAppend(hashAlgorithm, this->leaderSyncStateQueryResponse());
        break;
    case Class::SELECTION_ID_LEADER_SYNC_DATA_QUERY:
        hashAppend(hashAlgorithm, this->leaderSyncDataQuery());
        break;
    case Class::SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE:
        hashAppend(hashAlgorithm, this->leaderSyncDataQueryResponse());
        break;
    case Class::SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST:
        hashAppend(hashAlgorithm, this->queueAssignmentRequest());
        break;
    case Class::SELECTION_ID_STORAGE_SYNC_REQUEST:
        hashAppend(hashAlgorithm, this->storageSyncRequest());
        break;
    case Class::SELECTION_ID_STORAGE_SYNC_RESPONSE:
        hashAppend(hashAlgorithm, this->storageSyncResponse());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_STATE_QUERY:
        hashAppend(hashAlgorithm, this->partitionSyncStateQuery());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE:
        hashAppend(hashAlgorithm, this->partitionSyncStateQueryResponse());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY:
        hashAppend(hashAlgorithm, this->partitionSyncDataQuery());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE:
        hashAppend(hashAlgorithm, this->partitionSyncDataQueryResponse());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS:
        hashAppend(hashAlgorithm, this->partitionSyncDataQueryStatus());
        break;
    case Class::SELECTION_ID_PRIMARY_STATUS_ADVISORY:
        hashAppend(hashAlgorithm, this->primaryStatusAdvisory());
        break;
    case Class::SELECTION_ID_CLUSTER_SYNC_REQUEST:
        hashAppend(hashAlgorithm, this->clusterSyncRequest());
        break;
    case Class::SELECTION_ID_CLUSTER_SYNC_RESPONSE:
        hashAppend(hashAlgorithm, this->clusterSyncResponse());
        break;
    case Class::SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY:
        hashAppend(hashAlgorithm, this->queueUnAssignmentAdvisory());
        break;
    case Class::SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY:
        hashAppend(hashAlgorithm, this->queueUnassignedAdvisory());
        break;
    case Class::SELECTION_ID_LEADER_ADVISORY_ACK:
        hashAppend(hashAlgorithm, this->leaderAdvisoryAck());
        break;
    case Class::SELECTION_ID_LEADER_ADVISORY_COMMIT:
        hashAppend(hashAlgorithm, this->leaderAdvisoryCommit());
        break;
    case Class::SELECTION_ID_STATE_NOTIFICATION:
        hashAppend(hashAlgorithm, this->stateNotification());
        break;
    case Class::SELECTION_ID_STOP_REQUEST:
        hashAppend(hashAlgorithm, this->stopRequest());
        break;
    case Class::SELECTION_ID_STOP_RESPONSE:
        hashAppend(hashAlgorithm, this->stopResponse());
        break;
    case Class::SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST:
        hashAppend(hashAlgorithm, this->queueUnassignmentRequest());
        break;
    case Class::SELECTION_ID_QUEUE_UPDATE_ADVISORY:
        hashAppend(hashAlgorithm, this->queueUpdateAdvisory());
        break;
    case Class::SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE:
        hashAppend(hashAlgorithm, this->clusterStateFSMMessage());
        break;
    case Class::SELECTION_ID_PARTITION_MESSAGE:
        hashAppend(hashAlgorithm, this->partitionMessage());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
ClusterMessageChoice::isEqualTo(const ClusterMessageChoice& rhs) const
{
    typedef ClusterMessageChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_PARTITION_PRIMARY_ADVISORY:
            return this->partitionPrimaryAdvisory() ==
                   rhs.partitionPrimaryAdvisory();
        case Class::SELECTION_ID_LEADER_ADVISORY:
            return this->leaderAdvisory() == rhs.leaderAdvisory();
        case Class::SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY:
            return this->queueAssignmentAdvisory() ==
                   rhs.queueAssignmentAdvisory();
        case Class::SELECTION_ID_NODE_STATUS_ADVISORY:
            return this->nodeStatusAdvisory() == rhs.nodeStatusAdvisory();
        case Class::SELECTION_ID_LEADER_SYNC_STATE_QUERY:
            return this->leaderSyncStateQuery() == rhs.leaderSyncStateQuery();
        case Class::SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE:
            return this->leaderSyncStateQueryResponse() ==
                   rhs.leaderSyncStateQueryResponse();
        case Class::SELECTION_ID_LEADER_SYNC_DATA_QUERY:
            return this->leaderSyncDataQuery() == rhs.leaderSyncDataQuery();
        case Class::SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE:
            return this->leaderSyncDataQueryResponse() ==
                   rhs.leaderSyncDataQueryResponse();
        case Class::SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST:
            return this->queueAssignmentRequest() ==
                   rhs.queueAssignmentRequest();
        case Class::SELECTION_ID_STORAGE_SYNC_REQUEST:
            return this->storageSyncRequest() == rhs.storageSyncRequest();
        case Class::SELECTION_ID_STORAGE_SYNC_RESPONSE:
            return this->storageSyncResponse() == rhs.storageSyncResponse();
        case Class::SELECTION_ID_PARTITION_SYNC_STATE_QUERY:
            return this->partitionSyncStateQuery() ==
                   rhs.partitionSyncStateQuery();
        case Class::SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE:
            return this->partitionSyncStateQueryResponse() ==
                   rhs.partitionSyncStateQueryResponse();
        case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY:
            return this->partitionSyncDataQuery() ==
                   rhs.partitionSyncDataQuery();
        case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE:
            return this->partitionSyncDataQueryResponse() ==
                   rhs.partitionSyncDataQueryResponse();
        case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS:
            return this->partitionSyncDataQueryStatus() ==
                   rhs.partitionSyncDataQueryStatus();
        case Class::SELECTION_ID_PRIMARY_STATUS_ADVISORY:
            return this->primaryStatusAdvisory() ==
                   rhs.primaryStatusAdvisory();
        case Class::SELECTION_ID_CLUSTER_SYNC_REQUEST:
            return this->clusterSyncRequest() == rhs.clusterSyncRequest();
        case Class::SELECTION_ID_CLUSTER_SYNC_RESPONSE:
            return this->clusterSyncResponse() == rhs.clusterSyncResponse();
        case Class::SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY:
            return this->queueUnAssignmentAdvisory() ==
                   rhs.queueUnAssignmentAdvisory();
        case Class::SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY:
            return this->queueUnassignedAdvisory() ==
                   rhs.queueUnassignedAdvisory();
        case Class::SELECTION_ID_LEADER_ADVISORY_ACK:
            return this->leaderAdvisoryAck() == rhs.leaderAdvisoryAck();
        case Class::SELECTION_ID_LEADER_ADVISORY_COMMIT:
            return this->leaderAdvisoryCommit() == rhs.leaderAdvisoryCommit();
        case Class::SELECTION_ID_STATE_NOTIFICATION:
            return this->stateNotification() == rhs.stateNotification();
        case Class::SELECTION_ID_STOP_REQUEST:
            return this->stopRequest() == rhs.stopRequest();
        case Class::SELECTION_ID_STOP_RESPONSE:
            return this->stopResponse() == rhs.stopResponse();
        case Class::SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST:
            return this->queueUnassignmentRequest() ==
                   rhs.queueUnassignmentRequest();
        case Class::SELECTION_ID_QUEUE_UPDATE_ADVISORY:
            return this->queueUpdateAdvisory() == rhs.queueUpdateAdvisory();
        case Class::SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE:
            return this->clusterStateFSMMessage() ==
                   rhs.clusterStateFSMMessage();
        case Class::SELECTION_ID_PARTITION_MESSAGE:
            return this->partitionMessage() == rhs.partitionMessage();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ClusterMessageChoice::ClusterMessageChoice(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClusterMessageChoice::~ClusterMessageChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterMessageChoice::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClusterMessageChoice::SELECTION_ID_PARTITION_PRIMARY_ADVISORY:
        return manipulator(
            &d_partitionPrimaryAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_PRIMARY_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_ADVISORY:
        return manipulator(
            &d_leaderAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY:
        return manipulator(
            &d_queueAssignmentAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_ASSIGNMENT_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_NODE_STATUS_ADVISORY:
        return manipulator(
            &d_nodeStatusAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_NODE_STATUS_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_SYNC_STATE_QUERY:
        return manipulator(
            &d_leaderSyncStateQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_SYNC_STATE_QUERY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE:
        return manipulator(
            &d_leaderSyncStateQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_LEADER_SYNC_STATE_QUERY_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_SYNC_DATA_QUERY:
        return manipulator(
            &d_leaderSyncDataQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_SYNC_DATA_QUERY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE:
        return manipulator(
            &d_leaderSyncDataQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_LEADER_SYNC_DATA_QUERY_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST:
        return manipulator(
            &d_queueAssignmentRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_ASSIGNMENT_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_STORAGE_SYNC_REQUEST:
        return manipulator(
            &d_storageSyncRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_SYNC_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_STORAGE_SYNC_RESPONSE:
        return manipulator(
            &d_storageSyncResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_SYNC_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_SYNC_STATE_QUERY:
        return manipulator(
            &d_partitionSyncStateQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY]);
    case ClusterMessageChoice::
        SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE:
        return manipulator(
            &d_partitionSyncStateQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_SYNC_DATA_QUERY:
        return manipulator(
            &d_partitionSyncDataQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE:
        return manipulator(
            &d_partitionSyncDataQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS:
        return manipulator(
            &d_partitionSyncDataQueryStatus.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_STATUS]);
    case ClusterMessageChoice::SELECTION_ID_PRIMARY_STATUS_ADVISORY:
        return manipulator(
            &d_primaryStatusAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATUS_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_CLUSTER_SYNC_REQUEST:
        return manipulator(
            &d_clusterSyncRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_SYNC_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_CLUSTER_SYNC_RESPONSE:
        return manipulator(
            &d_clusterSyncResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_SYNC_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY:
        return manipulator(&d_queueUnAssignmentAdvisory.object(),
                           SELECTION_INFO_ARRAY
                               [SELECTION_INDEX_QUEUE_UN_ASSIGNMENT_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY:
        return manipulator(
            &d_queueUnassignedAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UNASSIGNED_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_ADVISORY_ACK:
        return manipulator(
            &d_leaderAdvisoryAck.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY_ACK]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_ADVISORY_COMMIT:
        return manipulator(
            &d_leaderAdvisoryCommit.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY_COMMIT]);
    case ClusterMessageChoice::SELECTION_ID_STATE_NOTIFICATION:
        return manipulator(
            &d_stateNotification.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STATE_NOTIFICATION]);
    case ClusterMessageChoice::SELECTION_ID_STOP_REQUEST:
        return manipulator(&d_stopRequest.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STOP_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_STOP_RESPONSE:
        return manipulator(
            &d_stopResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STOP_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST:
        return manipulator(
            &d_queueUnassignmentRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UNASSIGNMENT_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_UPDATE_ADVISORY:
        return manipulator(
            &d_queueUpdateAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UPDATE_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE:
        return manipulator(
            &d_clusterStateFSMMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STATE_F_S_M_MESSAGE]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_MESSAGE:
        return manipulator(
            &d_partitionMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_MESSAGE]);
    default:
        BSLS_ASSERT(ClusterMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline PartitionPrimaryAdvisory&
ClusterMessageChoice::partitionPrimaryAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_PRIMARY_ADVISORY == d_selectionId);
    return d_partitionPrimaryAdvisory.object();
}

inline LeaderAdvisory& ClusterMessageChoice::leaderAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY == d_selectionId);
    return d_leaderAdvisory.object();
}

inline QueueAssignmentAdvisory& ClusterMessageChoice::queueAssignmentAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY == d_selectionId);
    return d_queueAssignmentAdvisory.object();
}

inline NodeStatusAdvisory& ClusterMessageChoice::nodeStatusAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_NODE_STATUS_ADVISORY == d_selectionId);
    return d_nodeStatusAdvisory.object();
}

inline LeaderSyncStateQuery& ClusterMessageChoice::leaderSyncStateQuery()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_STATE_QUERY == d_selectionId);
    return d_leaderSyncStateQuery.object();
}

inline LeaderSyncStateQueryResponse&
ClusterMessageChoice::leaderSyncStateQueryResponse()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE ==
                d_selectionId);
    return d_leaderSyncStateQueryResponse.object();
}

inline LeaderSyncDataQuery& ClusterMessageChoice::leaderSyncDataQuery()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_DATA_QUERY == d_selectionId);
    return d_leaderSyncDataQuery.object();
}

inline LeaderSyncDataQueryResponse&
ClusterMessageChoice::leaderSyncDataQueryResponse()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE == d_selectionId);
    return d_leaderSyncDataQueryResponse.object();
}

inline QueueAssignmentRequest& ClusterMessageChoice::queueAssignmentRequest()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST == d_selectionId);
    return d_queueAssignmentRequest.object();
}

inline StorageSyncRequest& ClusterMessageChoice::storageSyncRequest()
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_SYNC_REQUEST == d_selectionId);
    return d_storageSyncRequest.object();
}

inline StorageSyncResponse& ClusterMessageChoice::storageSyncResponse()
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_SYNC_RESPONSE == d_selectionId);
    return d_storageSyncResponse.object();
}

inline PartitionSyncStateQuery& ClusterMessageChoice::partitionSyncStateQuery()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_STATE_QUERY == d_selectionId);
    return d_partitionSyncStateQuery.object();
}

inline PartitionSyncStateQueryResponse&
ClusterMessageChoice::partitionSyncStateQueryResponse()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE ==
                d_selectionId);
    return d_partitionSyncStateQueryResponse.object();
}

inline PartitionSyncDataQuery& ClusterMessageChoice::partitionSyncDataQuery()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY == d_selectionId);
    return d_partitionSyncDataQuery.object();
}

inline PartitionSyncDataQueryResponse&
ClusterMessageChoice::partitionSyncDataQueryResponse()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE ==
                d_selectionId);
    return d_partitionSyncDataQueryResponse.object();
}

inline PartitionSyncDataQueryStatus&
ClusterMessageChoice::partitionSyncDataQueryStatus()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS ==
                d_selectionId);
    return d_partitionSyncDataQueryStatus.object();
}

inline PrimaryStatusAdvisory& ClusterMessageChoice::primaryStatusAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATUS_ADVISORY == d_selectionId);
    return d_primaryStatusAdvisory.object();
}

inline ClusterSyncRequest& ClusterMessageChoice::clusterSyncRequest()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_SYNC_REQUEST == d_selectionId);
    return d_clusterSyncRequest.object();
}

inline ClusterSyncResponse& ClusterMessageChoice::clusterSyncResponse()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_SYNC_RESPONSE == d_selectionId);
    return d_clusterSyncResponse.object();
}

inline QueueUnAssignmentAdvisory&
ClusterMessageChoice::queueUnAssignmentAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY == d_selectionId);
    return d_queueUnAssignmentAdvisory.object();
}

inline QueueUnassignedAdvisory& ClusterMessageChoice::queueUnassignedAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY == d_selectionId);
    return d_queueUnassignedAdvisory.object();
}

inline LeaderAdvisoryAck& ClusterMessageChoice::leaderAdvisoryAck()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY_ACK == d_selectionId);
    return d_leaderAdvisoryAck.object();
}

inline LeaderAdvisoryCommit& ClusterMessageChoice::leaderAdvisoryCommit()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY_COMMIT == d_selectionId);
    return d_leaderAdvisoryCommit.object();
}

inline StateNotification& ClusterMessageChoice::stateNotification()
{
    BSLS_ASSERT(SELECTION_ID_STATE_NOTIFICATION == d_selectionId);
    return d_stateNotification.object();
}

inline StopRequest& ClusterMessageChoice::stopRequest()
{
    BSLS_ASSERT(SELECTION_ID_STOP_REQUEST == d_selectionId);
    return d_stopRequest.object();
}

inline StopResponse& ClusterMessageChoice::stopResponse()
{
    BSLS_ASSERT(SELECTION_ID_STOP_RESPONSE == d_selectionId);
    return d_stopResponse.object();
}

inline QueueUnassignmentRequest&
ClusterMessageChoice::queueUnassignmentRequest()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST == d_selectionId);
    return d_queueUnassignmentRequest.object();
}

inline QueueUpdateAdvisory& ClusterMessageChoice::queueUpdateAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UPDATE_ADVISORY == d_selectionId);
    return d_queueUpdateAdvisory.object();
}

inline ClusterStateFSMMessage& ClusterMessageChoice::clusterStateFSMMessage()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE == d_selectionId);
    return d_clusterStateFSMMessage.object();
}

inline PartitionMessage& ClusterMessageChoice::partitionMessage()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_MESSAGE == d_selectionId);
    return d_partitionMessage.object();
}

// ACCESSORS
inline int ClusterMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ClusterMessageChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_PARTITION_PRIMARY_ADVISORY:
        return accessor(
            d_partitionPrimaryAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_PRIMARY_ADVISORY]);
    case SELECTION_ID_LEADER_ADVISORY:
        return accessor(d_leaderAdvisory.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY]);
    case SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY:
        return accessor(
            d_queueAssignmentAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_ASSIGNMENT_ADVISORY]);
    case SELECTION_ID_NODE_STATUS_ADVISORY:
        return accessor(
            d_nodeStatusAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_NODE_STATUS_ADVISORY]);
    case SELECTION_ID_LEADER_SYNC_STATE_QUERY:
        return accessor(
            d_leaderSyncStateQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_SYNC_STATE_QUERY]);
    case SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE:
        return accessor(
            d_leaderSyncStateQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_LEADER_SYNC_STATE_QUERY_RESPONSE]);
    case SELECTION_ID_LEADER_SYNC_DATA_QUERY:
        return accessor(
            d_leaderSyncDataQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_SYNC_DATA_QUERY]);
    case SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE:
        return accessor(d_leaderSyncDataQueryResponse.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_LEADER_SYNC_DATA_QUERY_RESPONSE]);
    case SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST:
        return accessor(
            d_queueAssignmentRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_ASSIGNMENT_REQUEST]);
    case SELECTION_ID_STORAGE_SYNC_REQUEST:
        return accessor(
            d_storageSyncRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_SYNC_REQUEST]);
    case SELECTION_ID_STORAGE_SYNC_RESPONSE:
        return accessor(
            d_storageSyncResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_SYNC_RESPONSE]);
    case SELECTION_ID_PARTITION_SYNC_STATE_QUERY:
        return accessor(
            d_partitionSyncStateQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY]);
    case SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE:
        return accessor(
            d_partitionSyncStateQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY_RESPONSE]);
    case SELECTION_ID_PARTITION_SYNC_DATA_QUERY:
        return accessor(
            d_partitionSyncDataQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY]);
    case SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE:
        return accessor(
            d_partitionSyncDataQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_RESPONSE]);
    case SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS:
        return accessor(
            d_partitionSyncDataQueryStatus.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_STATUS]);
    case SELECTION_ID_PRIMARY_STATUS_ADVISORY:
        return accessor(
            d_primaryStatusAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATUS_ADVISORY]);
    case SELECTION_ID_CLUSTER_SYNC_REQUEST:
        return accessor(
            d_clusterSyncRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_SYNC_REQUEST]);
    case SELECTION_ID_CLUSTER_SYNC_RESPONSE:
        return accessor(
            d_clusterSyncResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_SYNC_RESPONSE]);
    case SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY:
        return accessor(d_queueUnAssignmentAdvisory.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_QUEUE_UN_ASSIGNMENT_ADVISORY]);
    case SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY:
        return accessor(
            d_queueUnassignedAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UNASSIGNED_ADVISORY]);
    case SELECTION_ID_LEADER_ADVISORY_ACK:
        return accessor(
            d_leaderAdvisoryAck.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY_ACK]);
    case SELECTION_ID_LEADER_ADVISORY_COMMIT:
        return accessor(
            d_leaderAdvisoryCommit.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY_COMMIT]);
    case SELECTION_ID_STATE_NOTIFICATION:
        return accessor(
            d_stateNotification.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STATE_NOTIFICATION]);
    case SELECTION_ID_STOP_REQUEST:
        return accessor(d_stopRequest.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STOP_REQUEST]);
    case SELECTION_ID_STOP_RESPONSE:
        return accessor(d_stopResponse.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STOP_RESPONSE]);
    case SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST:
        return accessor(
            d_queueUnassignmentRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UNASSIGNMENT_REQUEST]);
    case SELECTION_ID_QUEUE_UPDATE_ADVISORY:
        return accessor(
            d_queueUpdateAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UPDATE_ADVISORY]);
    case SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE:
        return accessor(
            d_clusterStateFSMMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STATE_F_S_M_MESSAGE]);
    case SELECTION_ID_PARTITION_MESSAGE:
        return accessor(
            d_partitionMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_MESSAGE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const PartitionPrimaryAdvisory&
ClusterMessageChoice::partitionPrimaryAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_PRIMARY_ADVISORY == d_selectionId);
    return d_partitionPrimaryAdvisory.object();
}

inline const LeaderAdvisory& ClusterMessageChoice::leaderAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY == d_selectionId);
    return d_leaderAdvisory.object();
}

inline const QueueAssignmentAdvisory&
ClusterMessageChoice::queueAssignmentAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY == d_selectionId);
    return d_queueAssignmentAdvisory.object();
}

inline const NodeStatusAdvisory&
ClusterMessageChoice::nodeStatusAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_NODE_STATUS_ADVISORY == d_selectionId);
    return d_nodeStatusAdvisory.object();
}

inline const LeaderSyncStateQuery&
ClusterMessageChoice::leaderSyncStateQuery() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_STATE_QUERY == d_selectionId);
    return d_leaderSyncStateQuery.object();
}

inline const LeaderSyncStateQueryResponse&
ClusterMessageChoice::leaderSyncStateQueryResponse() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE ==
                d_selectionId);
    return d_leaderSyncStateQueryResponse.object();
}

inline const LeaderSyncDataQuery&
ClusterMessageChoice::leaderSyncDataQuery() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_DATA_QUERY == d_selectionId);
    return d_leaderSyncDataQuery.object();
}

inline const LeaderSyncDataQueryResponse&
ClusterMessageChoice::leaderSyncDataQueryResponse() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE == d_selectionId);
    return d_leaderSyncDataQueryResponse.object();
}

inline const QueueAssignmentRequest&
ClusterMessageChoice::queueAssignmentRequest() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST == d_selectionId);
    return d_queueAssignmentRequest.object();
}

inline const StorageSyncRequest&
ClusterMessageChoice::storageSyncRequest() const
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_SYNC_REQUEST == d_selectionId);
    return d_storageSyncRequest.object();
}

inline const StorageSyncResponse&
ClusterMessageChoice::storageSyncResponse() const
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_SYNC_RESPONSE == d_selectionId);
    return d_storageSyncResponse.object();
}

inline const PartitionSyncStateQuery&
ClusterMessageChoice::partitionSyncStateQuery() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_STATE_QUERY == d_selectionId);
    return d_partitionSyncStateQuery.object();
}

inline const PartitionSyncStateQueryResponse&
ClusterMessageChoice::partitionSyncStateQueryResponse() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE ==
                d_selectionId);
    return d_partitionSyncStateQueryResponse.object();
}

inline const PartitionSyncDataQuery&
ClusterMessageChoice::partitionSyncDataQuery() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY == d_selectionId);
    return d_partitionSyncDataQuery.object();
}

inline const PartitionSyncDataQueryResponse&
ClusterMessageChoice::partitionSyncDataQueryResponse() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE ==
                d_selectionId);
    return d_partitionSyncDataQueryResponse.object();
}

inline const PartitionSyncDataQueryStatus&
ClusterMessageChoice::partitionSyncDataQueryStatus() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS ==
                d_selectionId);
    return d_partitionSyncDataQueryStatus.object();
}

inline const PrimaryStatusAdvisory&
ClusterMessageChoice::primaryStatusAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATUS_ADVISORY == d_selectionId);
    return d_primaryStatusAdvisory.object();
}

inline const ClusterSyncRequest&
ClusterMessageChoice::clusterSyncRequest() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_SYNC_REQUEST == d_selectionId);
    return d_clusterSyncRequest.object();
}

inline const ClusterSyncResponse&
ClusterMessageChoice::clusterSyncResponse() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_SYNC_RESPONSE == d_selectionId);
    return d_clusterSyncResponse.object();
}

inline const QueueUnAssignmentAdvisory&
ClusterMessageChoice::queueUnAssignmentAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY == d_selectionId);
    return d_queueUnAssignmentAdvisory.object();
}

inline const QueueUnassignedAdvisory&
ClusterMessageChoice::queueUnassignedAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY == d_selectionId);
    return d_queueUnassignedAdvisory.object();
}

inline const LeaderAdvisoryAck& ClusterMessageChoice::leaderAdvisoryAck() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY_ACK == d_selectionId);
    return d_leaderAdvisoryAck.object();
}

inline const LeaderAdvisoryCommit&
ClusterMessageChoice::leaderAdvisoryCommit() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY_COMMIT == d_selectionId);
    return d_leaderAdvisoryCommit.object();
}

inline const StateNotification& ClusterMessageChoice::stateNotification() const
{
    BSLS_ASSERT(SELECTION_ID_STATE_NOTIFICATION == d_selectionId);
    return d_stateNotification.object();
}

inline const StopRequest& ClusterMessageChoice::stopRequest() const
{
    BSLS_ASSERT(SELECTION_ID_STOP_REQUEST == d_selectionId);
    return d_stopRequest.object();
}

inline const StopResponse& ClusterMessageChoice::stopResponse() const
{
    BSLS_ASSERT(SELECTION_ID_STOP_RESPONSE == d_selectionId);
    return d_stopResponse.object();
}

inline const QueueUnassignmentRequest&
ClusterMessageChoice::queueUnassignmentRequest() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST == d_selectionId);
    return d_queueUnassignmentRequest.object();
}

inline const QueueUpdateAdvisory&
ClusterMessageChoice::queueUpdateAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UPDATE_ADVISORY == d_selectionId);
    return d_queueUpdateAdvisory.object();
}

inline const ClusterStateFSMMessage&
ClusterMessageChoice::clusterStateFSMMessage() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE == d_selectionId);
    return d_clusterStateFSMMessage.object();
}

inline const PartitionMessage& ClusterMessageChoice::partitionMessage() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_MESSAGE == d_selectionId);
    return d_partitionMessage.object();
}

inline bool ClusterMessageChoice::isPartitionPrimaryAdvisoryValue() const
{
    return SELECTION_ID_PARTITION_PRIMARY_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderAdvisoryValue() const
{
    return SELECTION_ID_LEADER_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueAssignmentAdvisoryValue() const
{
    return SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isNodeStatusAdvisoryValue() const
{
    return SELECTION_ID_NODE_STATUS_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderSyncStateQueryValue() const
{
    return SELECTION_ID_LEADER_SYNC_STATE_QUERY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderSyncStateQueryResponseValue() const
{
    return SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderSyncDataQueryValue() const
{
    return SELECTION_ID_LEADER_SYNC_DATA_QUERY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderSyncDataQueryResponseValue() const
{
    return SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueAssignmentRequestValue() const
{
    return SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isStorageSyncRequestValue() const
{
    return SELECTION_ID_STORAGE_SYNC_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isStorageSyncResponseValue() const
{
    return SELECTION_ID_STORAGE_SYNC_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionSyncStateQueryValue() const
{
    return SELECTION_ID_PARTITION_SYNC_STATE_QUERY == d_selectionId;
}

inline bool
ClusterMessageChoice::isPartitionSyncStateQueryResponseValue() const
{
    return SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionSyncDataQueryValue() const
{
    return SELECTION_ID_PARTITION_SYNC_DATA_QUERY == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionSyncDataQueryResponseValue() const
{
    return SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionSyncDataQueryStatusValue() const
{
    return SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS == d_selectionId;
}

inline bool ClusterMessageChoice::isPrimaryStatusAdvisoryValue() const
{
    return SELECTION_ID_PRIMARY_STATUS_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isClusterSyncRequestValue() const
{
    return SELECTION_ID_CLUSTER_SYNC_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isClusterSyncResponseValue() const
{
    return SELECTION_ID_CLUSTER_SYNC_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueUnAssignmentAdvisoryValue() const
{
    return SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueUnassignedAdvisoryValue() const
{
    return SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderAdvisoryAckValue() const
{
    return SELECTION_ID_LEADER_ADVISORY_ACK == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderAdvisoryCommitValue() const
{
    return SELECTION_ID_LEADER_ADVISORY_COMMIT == d_selectionId;
}

inline bool ClusterMessageChoice::isStateNotificationValue() const
{
    return SELECTION_ID_STATE_NOTIFICATION == d_selectionId;
}

inline bool ClusterMessageChoice::isStopRequestValue() const
{
    return SELECTION_ID_STOP_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isStopResponseValue() const
{
    return SELECTION_ID_STOP_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueUnassignmentRequestValue() const
{
    return SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueUpdateAdvisoryValue() const
{
    return SELECTION_ID_QUEUE_UPDATE_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isClusterStateFSMMessageValue() const
{
    return SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionMessageValue() const
{
    return SELECTION_ID_PARTITION_MESSAGE == d_selectionId;
}

inline bool ClusterMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class ClusterMessage
// --------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterMessage::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterMessage::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterMessage::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ClusterMessageChoice& ClusterMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterMessage::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterMessage::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterMessage::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const ClusterMessageChoice& ClusterMessage::choice() const
{
    return d_choice;
}

// --------------------------
// class ControlMessageChoice
// --------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ControlMessageChoice::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ControlMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_STATUS:
        hashAppend(hashAlgorithm, this->status());
        break;
    case Class::SELECTION_ID_DISCONNECT:
        hashAppend(hashAlgorithm, this->disconnect());
        break;
    case Class::SELECTION_ID_DISCONNECT_RESPONSE:
        hashAppend(hashAlgorithm, this->disconnectResponse());
        break;
    case Class::SELECTION_ID_ADMIN_COMMAND:
        hashAppend(hashAlgorithm, this->adminCommand());
        break;
    case Class::SELECTION_ID_ADMIN_COMMAND_RESPONSE:
        hashAppend(hashAlgorithm, this->adminCommandResponse());
        break;
    case Class::SELECTION_ID_CLUSTER_MESSAGE:
        hashAppend(hashAlgorithm, this->clusterMessage());
        break;
    case Class::SELECTION_ID_OPEN_QUEUE:
        hashAppend(hashAlgorithm, this->openQueue());
        break;
    case Class::SELECTION_ID_OPEN_QUEUE_RESPONSE:
        hashAppend(hashAlgorithm, this->openQueueResponse());
        break;
    case Class::SELECTION_ID_CLOSE_QUEUE:
        hashAppend(hashAlgorithm, this->closeQueue());
        break;
    case Class::SELECTION_ID_CLOSE_QUEUE_RESPONSE:
        hashAppend(hashAlgorithm, this->closeQueueResponse());
        break;
    case Class::SELECTION_ID_CONFIGURE_QUEUE_STREAM:
        hashAppend(hashAlgorithm, this->configureQueueStream());
        break;
    case Class::SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE:
        hashAppend(hashAlgorithm, this->configureQueueStreamResponse());
        break;
    case Class::SELECTION_ID_CONFIGURE_STREAM:
        hashAppend(hashAlgorithm, this->configureStream());
        break;
    case Class::SELECTION_ID_CONFIGURE_STREAM_RESPONSE:
        hashAppend(hashAlgorithm, this->configureStreamResponse());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
ControlMessageChoice::isEqualTo(const ControlMessageChoice& rhs) const
{
    typedef ControlMessageChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_STATUS: return this->status() == rhs.status();
        case Class::SELECTION_ID_DISCONNECT:
            return this->disconnect() == rhs.disconnect();
        case Class::SELECTION_ID_DISCONNECT_RESPONSE:
            return this->disconnectResponse() == rhs.disconnectResponse();
        case Class::SELECTION_ID_ADMIN_COMMAND:
            return this->adminCommand() == rhs.adminCommand();
        case Class::SELECTION_ID_ADMIN_COMMAND_RESPONSE:
            return this->adminCommandResponse() == rhs.adminCommandResponse();
        case Class::SELECTION_ID_CLUSTER_MESSAGE:
            return this->clusterMessage() == rhs.clusterMessage();
        case Class::SELECTION_ID_OPEN_QUEUE:
            return this->openQueue() == rhs.openQueue();
        case Class::SELECTION_ID_OPEN_QUEUE_RESPONSE:
            return this->openQueueResponse() == rhs.openQueueResponse();
        case Class::SELECTION_ID_CLOSE_QUEUE:
            return this->closeQueue() == rhs.closeQueue();
        case Class::SELECTION_ID_CLOSE_QUEUE_RESPONSE:
            return this->closeQueueResponse() == rhs.closeQueueResponse();
        case Class::SELECTION_ID_CONFIGURE_QUEUE_STREAM:
            return this->configureQueueStream() == rhs.configureQueueStream();
        case Class::SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE:
            return this->configureQueueStreamResponse() ==
                   rhs.configureQueueStreamResponse();
        case Class::SELECTION_ID_CONFIGURE_STREAM:
            return this->configureStream() == rhs.configureStream();
        case Class::SELECTION_ID_CONFIGURE_STREAM_RESPONSE:
            return this->configureStreamResponse() ==
                   rhs.configureStreamResponse();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ControlMessageChoice::ControlMessageChoice(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ControlMessageChoice::~ControlMessageChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ControlMessageChoice::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ControlMessageChoice::SELECTION_ID_STATUS:
        return manipulator(&d_status.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STATUS]);
    case ControlMessageChoice::SELECTION_ID_DISCONNECT:
        return manipulator(&d_disconnect.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DISCONNECT]);
    case ControlMessageChoice::SELECTION_ID_DISCONNECT_RESPONSE:
        return manipulator(
            &d_disconnectResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_DISCONNECT_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_ADMIN_COMMAND:
        return manipulator(
            &d_adminCommand.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ADMIN_COMMAND]);
    case ControlMessageChoice::SELECTION_ID_ADMIN_COMMAND_RESPONSE:
        return manipulator(
            &d_adminCommandResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ADMIN_COMMAND_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_CLUSTER_MESSAGE:
        return manipulator(
            &d_clusterMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_MESSAGE]);
    case ControlMessageChoice::SELECTION_ID_OPEN_QUEUE:
        return manipulator(&d_openQueue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_OPEN_QUEUE]);
    case ControlMessageChoice::SELECTION_ID_OPEN_QUEUE_RESPONSE:
        return manipulator(
            &d_openQueueResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_OPEN_QUEUE_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_CLOSE_QUEUE:
        return manipulator(&d_closeQueue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLOSE_QUEUE]);
    case ControlMessageChoice::SELECTION_ID_CLOSE_QUEUE_RESPONSE:
        return manipulator(
            &d_closeQueueResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLOSE_QUEUE_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_CONFIGURE_QUEUE_STREAM:
        return manipulator(
            &d_configureQueueStream.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_QUEUE_STREAM]);
    case ControlMessageChoice::SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE:
        return manipulator(
            &d_configureQueueStreamResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_CONFIGURE_QUEUE_STREAM_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_CONFIGURE_STREAM:
        return manipulator(
            &d_configureStream.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_STREAM]);
    case ControlMessageChoice::SELECTION_ID_CONFIGURE_STREAM_RESPONSE:
        return manipulator(
            &d_configureStreamResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_STREAM_RESPONSE]);
    default:
        BSLS_ASSERT(ControlMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline Status& ControlMessageChoice::status()
{
    BSLS_ASSERT(SELECTION_ID_STATUS == d_selectionId);
    return d_status.object();
}

inline Disconnect& ControlMessageChoice::disconnect()
{
    BSLS_ASSERT(SELECTION_ID_DISCONNECT == d_selectionId);
    return d_disconnect.object();
}

inline DisconnectResponse& ControlMessageChoice::disconnectResponse()
{
    BSLS_ASSERT(SELECTION_ID_DISCONNECT_RESPONSE == d_selectionId);
    return d_disconnectResponse.object();
}

inline AdminCommand& ControlMessageChoice::adminCommand()
{
    BSLS_ASSERT(SELECTION_ID_ADMIN_COMMAND == d_selectionId);
    return d_adminCommand.object();
}

inline AdminCommandResponse& ControlMessageChoice::adminCommandResponse()
{
    BSLS_ASSERT(SELECTION_ID_ADMIN_COMMAND_RESPONSE == d_selectionId);
    return d_adminCommandResponse.object();
}

inline ClusterMessage& ControlMessageChoice::clusterMessage()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_MESSAGE == d_selectionId);
    return d_clusterMessage.object();
}

inline OpenQueue& ControlMessageChoice::openQueue()
{
    BSLS_ASSERT(SELECTION_ID_OPEN_QUEUE == d_selectionId);
    return d_openQueue.object();
}

inline OpenQueueResponse& ControlMessageChoice::openQueueResponse()
{
    BSLS_ASSERT(SELECTION_ID_OPEN_QUEUE_RESPONSE == d_selectionId);
    return d_openQueueResponse.object();
}

inline CloseQueue& ControlMessageChoice::closeQueue()
{
    BSLS_ASSERT(SELECTION_ID_CLOSE_QUEUE == d_selectionId);
    return d_closeQueue.object();
}

inline CloseQueueResponse& ControlMessageChoice::closeQueueResponse()
{
    BSLS_ASSERT(SELECTION_ID_CLOSE_QUEUE_RESPONSE == d_selectionId);
    return d_closeQueueResponse.object();
}

inline ConfigureQueueStream& ControlMessageChoice::configureQueueStream()
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_QUEUE_STREAM == d_selectionId);
    return d_configureQueueStream.object();
}

inline ConfigureQueueStreamResponse&
ControlMessageChoice::configureQueueStreamResponse()
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE == d_selectionId);
    return d_configureQueueStreamResponse.object();
}

inline ConfigureStream& ControlMessageChoice::configureStream()
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_STREAM == d_selectionId);
    return d_configureStream.object();
}

inline ConfigureStreamResponse& ControlMessageChoice::configureStreamResponse()
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_STREAM_RESPONSE == d_selectionId);
    return d_configureStreamResponse.object();
}

// ACCESSORS
inline int ControlMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ControlMessageChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_STATUS:
        return accessor(d_status.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STATUS]);
    case SELECTION_ID_DISCONNECT:
        return accessor(d_disconnect.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DISCONNECT]);
    case SELECTION_ID_DISCONNECT_RESPONSE:
        return accessor(
            d_disconnectResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_DISCONNECT_RESPONSE]);
    case SELECTION_ID_ADMIN_COMMAND:
        return accessor(d_adminCommand.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ADMIN_COMMAND]);
    case SELECTION_ID_ADMIN_COMMAND_RESPONSE:
        return accessor(
            d_adminCommandResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ADMIN_COMMAND_RESPONSE]);
    case SELECTION_ID_CLUSTER_MESSAGE:
        return accessor(d_clusterMessage.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_MESSAGE]);
    case SELECTION_ID_OPEN_QUEUE:
        return accessor(d_openQueue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_OPEN_QUEUE]);
    case SELECTION_ID_OPEN_QUEUE_RESPONSE:
        return accessor(
            d_openQueueResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_OPEN_QUEUE_RESPONSE]);
    case SELECTION_ID_CLOSE_QUEUE:
        return accessor(d_closeQueue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLOSE_QUEUE]);
    case SELECTION_ID_CLOSE_QUEUE_RESPONSE:
        return accessor(
            d_closeQueueResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLOSE_QUEUE_RESPONSE]);
    case SELECTION_ID_CONFIGURE_QUEUE_STREAM:
        return accessor(
            d_configureQueueStream.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_QUEUE_STREAM]);
    case SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE:
        return accessor(d_configureQueueStreamResponse.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_CONFIGURE_QUEUE_STREAM_RESPONSE]);
    case SELECTION_ID_CONFIGURE_STREAM:
        return accessor(
            d_configureStream.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_STREAM]);
    case SELECTION_ID_CONFIGURE_STREAM_RESPONSE:
        return accessor(
            d_configureStreamResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_STREAM_RESPONSE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Status& ControlMessageChoice::status() const
{
    BSLS_ASSERT(SELECTION_ID_STATUS == d_selectionId);
    return d_status.object();
}

inline const Disconnect& ControlMessageChoice::disconnect() const
{
    BSLS_ASSERT(SELECTION_ID_DISCONNECT == d_selectionId);
    return d_disconnect.object();
}

inline const DisconnectResponse&
ControlMessageChoice::disconnectResponse() const
{
    BSLS_ASSERT(SELECTION_ID_DISCONNECT_RESPONSE == d_selectionId);
    return d_disconnectResponse.object();
}

inline const AdminCommand& ControlMessageChoice::adminCommand() const
{
    BSLS_ASSERT(SELECTION_ID_ADMIN_COMMAND == d_selectionId);
    return d_adminCommand.object();
}

inline const AdminCommandResponse&
ControlMessageChoice::adminCommandResponse() const
{
    BSLS_ASSERT(SELECTION_ID_ADMIN_COMMAND_RESPONSE == d_selectionId);
    return d_adminCommandResponse.object();
}

inline const ClusterMessage& ControlMessageChoice::clusterMessage() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_MESSAGE == d_selectionId);
    return d_clusterMessage.object();
}

inline const OpenQueue& ControlMessageChoice::openQueue() const
{
    BSLS_ASSERT(SELECTION_ID_OPEN_QUEUE == d_selectionId);
    return d_openQueue.object();
}

inline const OpenQueueResponse& ControlMessageChoice::openQueueResponse() const
{
    BSLS_ASSERT(SELECTION_ID_OPEN_QUEUE_RESPONSE == d_selectionId);
    return d_openQueueResponse.object();
}

inline const CloseQueue& ControlMessageChoice::closeQueue() const
{
    BSLS_ASSERT(SELECTION_ID_CLOSE_QUEUE == d_selectionId);
    return d_closeQueue.object();
}

inline const CloseQueueResponse&
ControlMessageChoice::closeQueueResponse() const
{
    BSLS_ASSERT(SELECTION_ID_CLOSE_QUEUE_RESPONSE == d_selectionId);
    return d_closeQueueResponse.object();
}

inline const ConfigureQueueStream&
ControlMessageChoice::configureQueueStream() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_QUEUE_STREAM == d_selectionId);
    return d_configureQueueStream.object();
}

inline const ConfigureQueueStreamResponse&
ControlMessageChoice::configureQueueStreamResponse() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE == d_selectionId);
    return d_configureQueueStreamResponse.object();
}

inline const ConfigureStream& ControlMessageChoice::configureStream() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_STREAM == d_selectionId);
    return d_configureStream.object();
}

inline const ConfigureStreamResponse&
ControlMessageChoice::configureStreamResponse() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_STREAM_RESPONSE == d_selectionId);
    return d_configureStreamResponse.object();
}

inline bool ControlMessageChoice::isStatusValue() const
{
    return SELECTION_ID_STATUS == d_selectionId;
}

inline bool ControlMessageChoice::isDisconnectValue() const
{
    return SELECTION_ID_DISCONNECT == d_selectionId;
}

inline bool ControlMessageChoice::isDisconnectResponseValue() const
{
    return SELECTION_ID_DISCONNECT_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isAdminCommandValue() const
{
    return SELECTION_ID_ADMIN_COMMAND == d_selectionId;
}

inline bool ControlMessageChoice::isAdminCommandResponseValue() const
{
    return SELECTION_ID_ADMIN_COMMAND_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isClusterMessageValue() const
{
    return SELECTION_ID_CLUSTER_MESSAGE == d_selectionId;
}

inline bool ControlMessageChoice::isOpenQueueValue() const
{
    return SELECTION_ID_OPEN_QUEUE == d_selectionId;
}

inline bool ControlMessageChoice::isOpenQueueResponseValue() const
{
    return SELECTION_ID_OPEN_QUEUE_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isCloseQueueValue() const
{
    return SELECTION_ID_CLOSE_QUEUE == d_selectionId;
}

inline bool ControlMessageChoice::isCloseQueueResponseValue() const
{
    return SELECTION_ID_CLOSE_QUEUE_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isConfigureQueueStreamValue() const
{
    return SELECTION_ID_CONFIGURE_QUEUE_STREAM == d_selectionId;
}

inline bool ControlMessageChoice::isConfigureQueueStreamResponseValue() const
{
    return SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isConfigureStreamValue() const
{
    return SELECTION_ID_CONFIGURE_STREAM == d_selectionId;
}

inline bool ControlMessageChoice::isConfigureStreamResponseValue() const
{
    return SELECTION_ID_CONFIGURE_STREAM_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class ControlMessage
// --------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ControlMessage::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_rId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_R_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ControlMessage::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_R_ID: {
        return manipulator(&d_rId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_R_ID]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ControlMessage::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bdlb::NullableValue<int>& ControlMessage::rId()
{
    return d_rId;
}

inline ControlMessageChoice& ControlMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ControlMessage::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_rId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_R_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ControlMessage::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_R_ID: {
        return accessor(d_rId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_R_ID]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ControlMessage::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bdlb::NullableValue<int>& ControlMessage::rId() const
{
    return d_rId;
}

inline const ControlMessageChoice& ControlMessage::choice() const
{
    return d_choice;
}

}  // close package namespace

// FREE FUNCTIONS

}  // close enterprise namespace
#endif

// GENERATED BY @BLP_BAS_CODEGEN_VERSION@
// USING bas_codegen.pl -m msg --noAggregateConversion --noExternalization
// --noIdent --package bmqp_ctrlmsg --msgComponent messages bmqp_ctrlmsg.xsd
// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright 2024 Bloomberg Finance L.P. All rights reserved.
//      Property of Bloomberg Finance L.P. (BFLP)
//      This software is made available solely pursuant to the
//      terms of a BFLP license agreement which governs its use.
// ------------------------------- END-OF-FILE --------------------------------
