// Copyright 2014-2023 Bloomberg Finance L.P.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// bmqp_ctrlmsg_messages.h          *DO NOT EDIT*          @generated -*-C++-*-
#ifndef INCLUDED_BMQP_CTRLMSG_MESSAGES
#define INCLUDED_BMQP_CTRLMSG_MESSAGES

//@PURPOSE: Provide value-semantic attribute classes

#include <bslalg_typetraits.h>

#include <bdlat_attributeinfo.h>

#include <bdlat_enumeratorinfo.h>

#include <bdlat_selectioninfo.h>

#include <bdlat_typetraits.h>

#include <bslh_hash.h>
#include <bsls_objectbuffer.h>

#include <bslma_default.h>

#include <bsls_assert.h>

#include <bdlb_nullablevalue.h>

#include <bsl_string.h>

#include <bsl_vector.h>

#include <bsls_types.h>

#include <bsl_iosfwd.h>
#include <bsl_limits.h>

#include <bsl_ostream.h>
#include <bsl_string.h>

namespace BloombergLP {

namespace bslma {
class Allocator;
}

namespace bmqp_ctrlmsg {
class AdminCommand;
}
namespace bmqp_ctrlmsg {
class AdminCommandResponse;
}
namespace bmqp_ctrlmsg {
class AppIdInfo;
}
namespace bmqp_ctrlmsg {
class CloseQueueResponse;
}
namespace bmqp_ctrlmsg {
class ClusterSyncRequest;
}
namespace bmqp_ctrlmsg {
class ClusterSyncResponse;
}
namespace bmqp_ctrlmsg {
class ConsumerInfo;
}
namespace bmqp_ctrlmsg {
class Disconnect;
}
namespace bmqp_ctrlmsg {
class DisconnectResponse;
}
namespace bmqp_ctrlmsg {
class ElectionProposal;
}
namespace bmqp_ctrlmsg {
class ElectionResponse;
}
namespace bmqp_ctrlmsg {
class ElectorNodeStatus;
}
namespace bmqp_ctrlmsg {
class FollowerClusterStateRequest;
}
namespace bmqp_ctrlmsg {
class FollowerLSNRequest;
}
namespace bmqp_ctrlmsg {
class GuidInfo;
}
namespace bmqp_ctrlmsg {
class HeartbeatResponse;
}
namespace bmqp_ctrlmsg {
class LeaderHeartbeat;
}
namespace bmqp_ctrlmsg {
class LeaderMessageSequence;
}
namespace bmqp_ctrlmsg {
class LeaderPassive;
}
namespace bmqp_ctrlmsg {
class LeaderSyncDataQuery;
}
namespace bmqp_ctrlmsg {
class LeaderSyncStateQuery;
}
namespace bmqp_ctrlmsg {
class LeadershipCessionNotification;
}
namespace bmqp_ctrlmsg {
class PartitionPrimaryInfo;
}
namespace bmqp_ctrlmsg {
class PartitionSequenceNumber;
}
namespace bmqp_ctrlmsg {
class PartitionSyncDataQueryResponse;
}
namespace bmqp_ctrlmsg {
class PartitionSyncStateQuery;
}
namespace bmqp_ctrlmsg {
class QueueAssignmentRequest;
}
namespace bmqp_ctrlmsg {
class QueueUnassignmentRequest;
}
namespace bmqp_ctrlmsg {
class RegistrationResponse;
}
namespace bmqp_ctrlmsg {
class ReverseConnectionRequest;
}
namespace bmqp_ctrlmsg {
class RoutingConfiguration;
}
namespace bmqp_ctrlmsg {
class ScoutingRequest;
}
namespace bmqp_ctrlmsg {
class ScoutingResponse;
}
namespace bmqp_ctrlmsg {
class StopRequest;
}
namespace bmqp_ctrlmsg {
class StopResponse;
}
namespace bmqp_ctrlmsg {
class SubQueueIdInfo;
}
namespace bmqp_ctrlmsg {
class SyncPoint;
}
namespace bmqp_ctrlmsg {
class ClientIdentity;
}
namespace bmqp_ctrlmsg {
class DumpMessages;
}
namespace bmqp_ctrlmsg {
class ElectorMessageChoice;
}
namespace bmqp_ctrlmsg {
class Expression;
}
namespace bmqp_ctrlmsg {
class FollowerLSNResponse;
}
namespace bmqp_ctrlmsg {
class LeaderAdvisoryAck;
}
namespace bmqp_ctrlmsg {
class LeaderAdvisoryCommit;
}
namespace bmqp_ctrlmsg {
class LeaderSyncStateQueryResponse;
}
namespace bmqp_ctrlmsg {
class NodeStatusAdvisory;
}
namespace bmqp_ctrlmsg {
class PartitionPrimaryAdvisory;
}
namespace bmqp_ctrlmsg {
class PrimaryStateRequest;
}
namespace bmqp_ctrlmsg {
class PrimaryStateResponse;
}
namespace bmqp_ctrlmsg {
class PrimaryStatusAdvisory;
}
namespace bmqp_ctrlmsg {
class QueueHandleParameters;
}
namespace bmqp_ctrlmsg {
class QueueInfo;
}
namespace bmqp_ctrlmsg {
class QueueInfoUpdate;
}
namespace bmqp_ctrlmsg {
class QueueStreamParameters;
}
namespace bmqp_ctrlmsg {
class RegistrationRequest;
}
namespace bmqp_ctrlmsg {
class ReplicaDataRequest;
}
namespace bmqp_ctrlmsg {
class ReplicaDataResponse;
}
namespace bmqp_ctrlmsg {
class ReplicaStateRequest;
}
namespace bmqp_ctrlmsg {
class ReplicaStateResponse;
}
namespace bmqp_ctrlmsg {
class StateNotificationChoice;
}
namespace bmqp_ctrlmsg {
class Status;
}
namespace bmqp_ctrlmsg {
class StorageSyncResponse;
}
namespace bmqp_ctrlmsg {
class SyncPointOffsetPair;
}
namespace bmqp_ctrlmsg {
class BrokerResponse;
}
namespace bmqp_ctrlmsg {
class CloseQueue;
}
namespace bmqp_ctrlmsg {
class ConfigureQueueStream;
}
namespace bmqp_ctrlmsg {
class ElectorMessage;
}
namespace bmqp_ctrlmsg {
class LeaderAdvisory;
}
namespace bmqp_ctrlmsg {
class OpenQueue;
}
namespace bmqp_ctrlmsg {
class PartitionMessageChoice;
}
namespace bmqp_ctrlmsg {
class PartitionSyncDataQuery;
}
namespace bmqp_ctrlmsg {
class PartitionSyncDataQueryStatus;
}
namespace bmqp_ctrlmsg {
class PartitionSyncStateQueryResponse;
}
namespace bmqp_ctrlmsg {
class QueueAssignmentAdvisory;
}
namespace bmqp_ctrlmsg {
class QueueUnAssignmentAdvisory;
}
namespace bmqp_ctrlmsg {
class QueueUnassignedAdvisory;
}
namespace bmqp_ctrlmsg {
class QueueUpdateAdvisory;
}
namespace bmqp_ctrlmsg {
class StateNotification;
}
namespace bmqp_ctrlmsg {
class StorageSyncRequest;
}
namespace bmqp_ctrlmsg {
class Subscription;
}
namespace bmqp_ctrlmsg {
class ConfigureQueueStreamResponse;
}
namespace bmqp_ctrlmsg {
class FollowerClusterStateResponse;
}
namespace bmqp_ctrlmsg {
class LeaderSyncDataQueryResponse;
}
namespace bmqp_ctrlmsg {
class NegotiationMessage;
}
namespace bmqp_ctrlmsg {
class OpenQueueResponse;
}
namespace bmqp_ctrlmsg {
class PartitionMessage;
}
namespace bmqp_ctrlmsg {
class StreamParameters;
}
namespace bmqp_ctrlmsg {
class ClusterStateFSMMessageChoice;
}
namespace bmqp_ctrlmsg {
class ConfigureStream;
}
namespace bmqp_ctrlmsg {
class ClusterStateFSMMessage;
}
namespace bmqp_ctrlmsg {
class ConfigureStreamResponse;
}
namespace bmqp_ctrlmsg {
class ClusterMessageChoice;
}
namespace bmqp_ctrlmsg {
class ClusterMessage;
}
namespace bmqp_ctrlmsg {
class ControlMessageChoice;
}
namespace bmqp_ctrlmsg {
class ControlMessage;
}
namespace bmqp_ctrlmsg {

// ==================
// class AdminCommand
// ==================

/// This request is sent by the admin client to execute the specified
/// command on the broker.  Command is expected in a human-friendly text
/// format, to get a list of available commands `help` command can be sent.
class AdminCommand {
    // INSTANCE DATA
    bsl::string d_command;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_COMMAND = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_COMMAND = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `AdminCommand` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit AdminCommand(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `AdminCommand` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    AdminCommand(const AdminCommand& original,
                 bslma::Allocator*   basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `AdminCommand` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    AdminCommand(AdminCommand&& original) noexcept;

    /// Create an object of type `AdminCommand` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    AdminCommand(AdminCommand&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~AdminCommand();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    AdminCommand& operator=(const AdminCommand& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    AdminCommand& operator=(AdminCommand&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Command" attribute of this
    /// object.
    bsl::string& command();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Command" attribute of this
    /// object.
    const bsl::string& command() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const AdminCommand& lhs, const AdminCommand& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const AdminCommand& lhs, const AdminCommand& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const AdminCommand& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `AdminCommand`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::AdminCommand& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::AdminCommand)

namespace bmqp_ctrlmsg {

// ==========================
// class AdminCommandResponse
// ==========================

/// This response is sent by the broker to the admin client in response to
/// an `AdminCommand` request with the command execution results.  The
/// resulting text can be both non-structured text or represent a valid
/// json, depending on specific command.  Also it can contain error message
/// if some problem occured.
class AdminCommandResponse {
    // INSTANCE DATA
    bsl::string d_text;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_TEXT = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_TEXT = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `AdminCommandResponse` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit AdminCommandResponse(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `AdminCommandResponse` having the value of
    /// the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    AdminCommandResponse(const AdminCommandResponse& original,
                         bslma::Allocator*           basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `AdminCommandResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    AdminCommandResponse(AdminCommandResponse&& original) noexcept;

    /// Create an object of type `AdminCommandResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    AdminCommandResponse(AdminCommandResponse&& original,
                         bslma::Allocator*      basicAllocator);
#endif

    /// Destroy this object.
    ~AdminCommandResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    AdminCommandResponse& operator=(const AdminCommandResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    AdminCommandResponse& operator=(AdminCommandResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Text" attribute of this
    /// object.
    bsl::string& text();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Text" attribute of this
    /// object.
    const bsl::string& text() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const AdminCommandResponse& lhs,
                       const AdminCommandResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const AdminCommandResponse& lhs,
                       const AdminCommandResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const AdminCommandResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `AdminCommandResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::AdminCommandResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::AdminCommandResponse)

namespace bmqp_ctrlmsg {

// ===============
// class AppIdInfo
// ===============

/// This type represents the details of an application id, that is the app
/// id string and app key bytes for a queue.
class AppIdInfo {
    // INSTANCE DATA
    bsl::vector<char> d_appKey;
    bsl::string       d_appId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_APP_ID = 0, ATTRIBUTE_ID_APP_KEY = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_APP_ID = 0, ATTRIBUTE_INDEX_APP_KEY = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `AppIdInfo` having the default value.  Use
    /// the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit AppIdInfo(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `AppIdInfo` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    AppIdInfo(const AppIdInfo& original, bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `AppIdInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    AppIdInfo(AppIdInfo&& original) noexcept;

    /// Create an object of type `AppIdInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    AppIdInfo(AppIdInfo&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~AppIdInfo();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    AppIdInfo& operator=(const AppIdInfo& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    AppIdInfo& operator=(AppIdInfo&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "AppId" attribute of this
    /// object.
    bsl::string& appId();

    /// Return a reference to the modifiable "AppKey" attribute of this
    /// object.
    bsl::vector<char>& appKey();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "AppId" attribute of this
    /// object.
    const bsl::string& appId() const;

    /// Return a reference to the non-modifiable "AppKey" attribute of this
    /// object.
    const bsl::vector<char>& appKey() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const AppIdInfo& lhs, const AppIdInfo& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const AppIdInfo& lhs, const AppIdInfo& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const AppIdInfo& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `AppIdInfo`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                hashAlg,
                const bmqp_ctrlmsg::AppIdInfo& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::AppIdInfo)

namespace bmqp_ctrlmsg {

// ====================
// class ClientLanguage
// ====================

/// Enumeration of the various types of language which can be used by a
/// client.
struct ClientLanguage {
  public:
    // TYPES
    enum Value { E_UNKNOWN = 0, E_CPP = 1, E_JAVA = 2 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                ClientLanguage::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::ClientLanguage)

namespace bmqp_ctrlmsg {

// ================
// class ClientType
// ================

/// Enumeration of the various types of client which can connect to the
/// bmqbrkr.
struct ClientType {
  public:
    // TYPES
    enum Value {
        E_UNKNOWN   = 0,
        E_TCPCLIENT = 1,
        E_TCPBROKER = 2,
        E_TCPADMIN  = 3
    };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, ClientType::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::ClientType)

namespace bmqp_ctrlmsg {

// ========================
// class CloseQueueResponse
// ========================

/// Response of a `CloseQueue` request, indicating success of the operation.
class CloseQueueResponse {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `CloseQueueResponse` having the default
    /// value.
    CloseQueueResponse();

    /// Create an object of type `CloseQueueResponse` having the value of
    /// the specified `original` object.
    CloseQueueResponse(const CloseQueueResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `CloseQueueResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    CloseQueueResponse(CloseQueueResponse&& original) = default;
#endif

    /// Destroy this object.
    ~CloseQueueResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    CloseQueueResponse& operator=(const CloseQueueResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    CloseQueueResponse& operator=(CloseQueueResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const CloseQueueResponse& lhs,
                       const CloseQueueResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const CloseQueueResponse& lhs,
                       const CloseQueueResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&             stream,
                                const CloseQueueResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `CloseQueueResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::CloseQueueResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::CloseQueueResponse)

namespace bmqp_ctrlmsg {

// ========================
// class ClusterSyncRequest
// ========================

/// This type represents a message sent by a cluster member node to all
/// peers, in order to ensure sync (think of it as a distributed latch
/// between all nodes in the cluster).  Each peer, upon reception of this
/// request, is expected to reply with a `ClusterSyncResponse` message.
class ClusterSyncRequest {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ClusterSyncRequest` having the default
    /// value.
    ClusterSyncRequest();

    /// Create an object of type `ClusterSyncRequest` having the value of
    /// the specified `original` object.
    ClusterSyncRequest(const ClusterSyncRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ClusterSyncRequest` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ClusterSyncRequest(ClusterSyncRequest&& original) = default;
#endif

    /// Destroy this object.
    ~ClusterSyncRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ClusterSyncRequest& operator=(const ClusterSyncRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ClusterSyncRequest& operator=(ClusterSyncRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ClusterSyncRequest& lhs,
                       const ClusterSyncRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ClusterSyncRequest& lhs,
                       const ClusterSyncRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&             stream,
                                const ClusterSyncRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ClusterSyncRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::ClusterSyncRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterSyncRequest)

namespace bmqp_ctrlmsg {

// =========================
// class ClusterSyncResponse
// =========================

/// This type represents a message sent by a cluster member node, in
/// response to a `ClusterSyncRequest`.
class ClusterSyncResponse {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ClusterSyncResponse` having the default
    /// value.
    ClusterSyncResponse();

    /// Create an object of type `ClusterSyncResponse` having the value of
    /// the specified `original` object.
    ClusterSyncResponse(const ClusterSyncResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ClusterSyncResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ClusterSyncResponse(ClusterSyncResponse&& original) = default;
#endif

    /// Destroy this object.
    ~ClusterSyncResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ClusterSyncResponse& operator=(const ClusterSyncResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ClusterSyncResponse& operator=(ClusterSyncResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ClusterSyncResponse& lhs,
                       const ClusterSyncResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ClusterSyncResponse& lhs,
                       const ClusterSyncResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const ClusterSyncResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ClusterSyncResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::ClusterSyncResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterSyncResponse)

namespace bmqp_ctrlmsg {

// ==================
// class ConsumerInfo
// ==================

/// This complex type contains various parameters required by an upstream
/// node to configure subscription for a queue handle that has already been
/// created.
/// maxUnconfirmedMessages.: maximum number of outstanding delivered but
/// pending confirmation from the client maxUnconfirmedBytes....: maximum
/// cumulated bytes of all outstanding delivered but pending confirmation
/// messages from the client consumerPriority.......: priority as advertised
/// by the downstream node for this subscription consumerPriorityCount..:
/// weight of the subscription as advertised by the downstream node, having
/// above-mentioned consumer priority
class ConsumerInfo {
    // INSTANCE DATA
    bsls::Types::Int64 d_maxUnconfirmedMessages;
    bsls::Types::Int64 d_maxUnconfirmedBytes;
    int                d_consumerPriority;
    int                d_consumerPriorityCount;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES = 0,
        ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES    = 1,
        ATTRIBUTE_ID_CONSUMER_PRIORITY        = 2,
        ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT  = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES = 0,
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES    = 1,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY        = 2,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT  = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bsls::Types::Int64
        DEFAULT_INITIALIZER_MAX_UNCONFIRMED_MESSAGES;

    static const bsls::Types::Int64 DEFAULT_INITIALIZER_MAX_UNCONFIRMED_BYTES;

    static const int DEFAULT_INITIALIZER_CONSUMER_PRIORITY;

    static const int DEFAULT_INITIALIZER_CONSUMER_PRIORITY_COUNT;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ConsumerInfo` having the default value.
    ConsumerInfo();

    /// Create an object of type `ConsumerInfo` having the value of the
    /// specified `original` object.
    ConsumerInfo(const ConsumerInfo& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ConsumerInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ConsumerInfo(ConsumerInfo&& original) = default;
#endif

    /// Destroy this object.
    ~ConsumerInfo();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ConsumerInfo& operator=(const ConsumerInfo& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ConsumerInfo& operator=(ConsumerInfo&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "MaxUnconfirmedMessages"
    /// attribute of this object.
    bsls::Types::Int64& maxUnconfirmedMessages();

    /// Return a reference to the modifiable "MaxUnconfirmedBytes" attribute
    /// of this object.
    bsls::Types::Int64& maxUnconfirmedBytes();

    /// Return a reference to the modifiable "ConsumerPriority" attribute of
    /// this object.
    int& consumerPriority();

    /// Return a reference to the modifiable "ConsumerPriorityCount"
    /// attribute of this object.
    int& consumerPriorityCount();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "MaxUnconfirmedMessages"
    /// attribute of this object.
    bsls::Types::Int64 maxUnconfirmedMessages() const;

    /// Return a reference to the non-modifiable "MaxUnconfirmedBytes"
    /// attribute of this object.
    bsls::Types::Int64 maxUnconfirmedBytes() const;

    /// Return a reference to the non-modifiable "ConsumerPriority"
    /// attribute of this object.
    int consumerPriority() const;

    /// Return a reference to the non-modifiable "ConsumerPriorityCount"
    /// attribute of this object.
    int consumerPriorityCount() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ConsumerInfo& lhs, const ConsumerInfo& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ConsumerInfo& lhs, const ConsumerInfo& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const ConsumerInfo& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ConsumerInfo`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::ConsumerInfo& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ConsumerInfo)

namespace bmqp_ctrlmsg {

// ================
// class Disconnect
// ================

/// This request is sent by the SDK to the broker to perform a gracefull
/// clean shutdown.
class Disconnect {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `Disconnect` having the default value.
    Disconnect();

    /// Create an object of type `Disconnect` having the value of the
    /// specified `original` object.
    Disconnect(const Disconnect& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `Disconnect` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    Disconnect(Disconnect&& original) = default;
#endif

    /// Destroy this object.
    ~Disconnect();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    Disconnect& operator=(const Disconnect& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    Disconnect& operator=(Disconnect&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const Disconnect& lhs, const Disconnect& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const Disconnect& lhs, const Disconnect& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const Disconnect& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `Disconnect`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                 hashAlg,
                const bmqp_ctrlmsg::Disconnect& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::Disconnect)

namespace bmqp_ctrlmsg {

// ========================
// class DisconnectResponse
// ========================

/// This response is sent by the broker to the SDK in response to a
/// `Disconnect` request, to acknowledge reception of the request and
/// indicate to the client it's good to close the channel.
class DisconnectResponse {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `DisconnectResponse` having the default
    /// value.
    DisconnectResponse();

    /// Create an object of type `DisconnectResponse` having the value of
    /// the specified `original` object.
    DisconnectResponse(const DisconnectResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `DisconnectResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    DisconnectResponse(DisconnectResponse&& original) = default;
#endif

    /// Destroy this object.
    ~DisconnectResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    DisconnectResponse& operator=(const DisconnectResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    DisconnectResponse& operator=(DisconnectResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const DisconnectResponse& lhs,
                       const DisconnectResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const DisconnectResponse& lhs,
                       const DisconnectResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&             stream,
                                const DisconnectResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `DisconnectResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::DisconnectResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::DisconnectResponse)

namespace bmqp_ctrlmsg {

// ====================
// class DumpActionType
// ====================

struct DumpActionType {
  public:
    // TYPES
    enum Value {
        E_ON              = 0,
        E_OFF             = 1,
        E_MESSAGE_COUNT   = 2,
        E_TIME_IN_SECONDS = 3
    };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                DumpActionType::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::DumpActionType)

namespace bmqp_ctrlmsg {

// =================
// class DumpMsgType
// =================

struct DumpMsgType {
  public:
    // TYPES
    enum Value {
        E_INCOMING = 0,
        E_OUTGOING = 1,
        E_PUSH     = 2,
        E_ACK      = 3,
        E_PUT      = 4,
        E_CONFIRM  = 5
    };

    enum { NUM_ENUMERATORS = 6 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, DumpMsgType::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::DumpMsgType)

namespace bmqp_ctrlmsg {

// ======================
// class ElectionProposal
// ======================

/// This type represents an election proposal from a given node in the BMQ
/// leader election algorithm.
class ElectionProposal {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ElectionProposal` having the default
    /// value.
    ElectionProposal();

    /// Create an object of type `ElectionProposal` having the value of the
    /// specified `original` object.
    ElectionProposal(const ElectionProposal& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ElectionProposal` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ElectionProposal(ElectionProposal&& original) = default;
#endif

    /// Destroy this object.
    ~ElectionProposal();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ElectionProposal& operator=(const ElectionProposal& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ElectionProposal& operator=(ElectionProposal&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ElectionProposal& lhs,
                       const ElectionProposal& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ElectionProposal& lhs,
                       const ElectionProposal& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&           stream,
                                const ElectionProposal& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ElectionProposal`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::ElectionProposal& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ElectionProposal)

namespace bmqp_ctrlmsg {

// ======================
// class ElectionResponse
// ======================

/// This type represents an election response from a given node in the BMQ
/// leader election algorithm.
class ElectionResponse {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ElectionResponse` having the default
    /// value.
    ElectionResponse();

    /// Create an object of type `ElectionResponse` having the value of the
    /// specified `original` object.
    ElectionResponse(const ElectionResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ElectionResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ElectionResponse(ElectionResponse&& original) = default;
#endif

    /// Destroy this object.
    ~ElectionResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ElectionResponse& operator=(const ElectionResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ElectionResponse& operator=(ElectionResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ElectionResponse& lhs,
                       const ElectionResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ElectionResponse& lhs,
                       const ElectionResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&           stream,
                                const ElectionResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ElectionResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::ElectionResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ElectionResponse)

namespace bmqp_ctrlmsg {

// =======================
// class ElectorNodeStatus
// =======================

/// This type represents a notification from a node about its status.
/// isAvailable..: flag indicated whether an elector node is available or
/// not.
class ElectorNodeStatus {
    // INSTANCE DATA
    bool d_isAvailable;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_IS_AVAILABLE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_IS_AVAILABLE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ElectorNodeStatus` having the default
    /// value.
    ElectorNodeStatus();

    /// Create an object of type `ElectorNodeStatus` having the value of the
    /// specified `original` object.
    ElectorNodeStatus(const ElectorNodeStatus& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ElectorNodeStatus` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ElectorNodeStatus(ElectorNodeStatus&& original) = default;
#endif

    /// Destroy this object.
    ~ElectorNodeStatus();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ElectorNodeStatus& operator=(const ElectorNodeStatus& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ElectorNodeStatus& operator=(ElectorNodeStatus&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "IsAvailable" attribute of this
    /// object.
    bool& isAvailable();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "IsAvailable" attribute of
    /// this object.
    bool isAvailable() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ElectorNodeStatus& lhs,
                       const ElectorNodeStatus& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ElectorNodeStatus& lhs,
                       const ElectorNodeStatus& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&            stream,
                                const ElectorNodeStatus& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ElectorNodeStatus`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::ElectorNodeStatus& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ElectorNodeStatus)

namespace bmqp_ctrlmsg {

// =======================
// class ExpressionVersion
// =======================

/// Enumeration of the various expression versions.
struct ExpressionVersion {
  public:
    // TYPES
    enum Value { E_UNDEFINED = 0, E_VERSION_1 = 1 };

    enum { NUM_ENUMERATORS = 2 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&            stream,
                                ExpressionVersion::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::ExpressionVersion)

namespace bmqp_ctrlmsg {

// =================================
// class FollowerClusterStateRequest
// =================================

/// This type represents a request sent by the leader to the highest LSN
/// follower to obtain its cluster state snapshot.
class FollowerClusterStateRequest {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `FollowerClusterStateRequest` having the
    /// default value.
    FollowerClusterStateRequest();

    /// Create an object of type `FollowerClusterStateRequest` having the
    /// value of the specified `original` object.
    FollowerClusterStateRequest(const FollowerClusterStateRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `FollowerClusterStateRequest` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    FollowerClusterStateRequest(FollowerClusterStateRequest&& original) =
        default;
#endif

    /// Destroy this object.
    ~FollowerClusterStateRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    FollowerClusterStateRequest&
    operator=(const FollowerClusterStateRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    FollowerClusterStateRequest& operator=(FollowerClusterStateRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const FollowerClusterStateRequest& lhs,
                       const FollowerClusterStateRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const FollowerClusterStateRequest& lhs,
                       const FollowerClusterStateRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                      stream,
                                const FollowerClusterStateRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `FollowerClusterStateRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                  hashAlg,
                const bmqp_ctrlmsg::FollowerClusterStateRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::FollowerClusterStateRequest)

namespace bmqp_ctrlmsg {

// ========================
// class FollowerLSNRequest
// ========================

/// This type represents a request sent by the leader to a follower to query
/// its leader-sequence number.
class FollowerLSNRequest {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `FollowerLSNRequest` having the default
    /// value.
    FollowerLSNRequest();

    /// Create an object of type `FollowerLSNRequest` having the value of
    /// the specified `original` object.
    FollowerLSNRequest(const FollowerLSNRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `FollowerLSNRequest` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    FollowerLSNRequest(FollowerLSNRequest&& original) = default;
#endif

    /// Destroy this object.
    ~FollowerLSNRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    FollowerLSNRequest& operator=(const FollowerLSNRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    FollowerLSNRequest& operator=(FollowerLSNRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const FollowerLSNRequest& lhs,
                       const FollowerLSNRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const FollowerLSNRequest& lhs,
                       const FollowerLSNRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&             stream,
                                const FollowerLSNRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `FollowerLSNRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::FollowerLSNRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::FollowerLSNRequest)

namespace bmqp_ctrlmsg {

// ==============
// class GuidInfo
// ==============

/// This represents the `clientId` and `nanoSecondsFromEpoch` provided by
/// bmqp::MessageGUIDGenerator.  Sending them to the broker will allow to
/// retrieve the source and compute the absolute time of a GUID.
/// clientId..............: SDK client ID nanoSecondsFromEpoch..: number of
/// nano seconds from epoch
class GuidInfo {
    // INSTANCE DATA
    bsls::Types::Int64 d_nanoSecondsFromEpoch;
    bsl::string        d_clientId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CLIENT_ID               = 0,
        ATTRIBUTE_ID_NANO_SECONDS_FROM_EPOCH = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_CLIENT_ID               = 0,
        ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const char DEFAULT_INITIALIZER_CLIENT_ID[];

    static const bsls::Types::Int64
        DEFAULT_INITIALIZER_NANO_SECONDS_FROM_EPOCH;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `GuidInfo` having the default value.  Use
    /// the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit GuidInfo(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `GuidInfo` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    GuidInfo(const GuidInfo& original, bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `GuidInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    GuidInfo(GuidInfo&& original) noexcept;

    /// Create an object of type `GuidInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    GuidInfo(GuidInfo&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~GuidInfo();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    GuidInfo& operator=(const GuidInfo& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    GuidInfo& operator=(GuidInfo&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ClientId" attribute of this
    /// object.
    bsl::string& clientId();

    /// Return a reference to the modifiable "NanoSecondsFromEpoch"
    /// attribute of this object.
    bsls::Types::Int64& nanoSecondsFromEpoch();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ClientId" attribute of
    /// this object.
    const bsl::string& clientId() const;

    /// Return a reference to the non-modifiable "NanoSecondsFromEpoch"
    /// attribute of this object.
    bsls::Types::Int64 nanoSecondsFromEpoch() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const GuidInfo& lhs, const GuidInfo& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const GuidInfo& lhs, const GuidInfo& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const GuidInfo& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `GuidInfo`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM& hashAlg, const bmqp_ctrlmsg::GuidInfo& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::GuidInfo)

namespace bmqp_ctrlmsg {

// =======================
// class HeartbeatResponse
// =======================

/// This type represents a response sent by a peer node to the node which
/// sent it a leader heartbeat message.
class HeartbeatResponse {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `HeartbeatResponse` having the default
    /// value.
    HeartbeatResponse();

    /// Create an object of type `HeartbeatResponse` having the value of the
    /// specified `original` object.
    HeartbeatResponse(const HeartbeatResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `HeartbeatResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    HeartbeatResponse(HeartbeatResponse&& original) = default;
#endif

    /// Destroy this object.
    ~HeartbeatResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    HeartbeatResponse& operator=(const HeartbeatResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    HeartbeatResponse& operator=(HeartbeatResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const HeartbeatResponse& lhs,
                       const HeartbeatResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const HeartbeatResponse& lhs,
                       const HeartbeatResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&            stream,
                                const HeartbeatResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `HeartbeatResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::HeartbeatResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::HeartbeatResponse)

namespace bmqp_ctrlmsg {

// =====================
// class LeaderHeartbeat
// =====================

/// This type represents a heartbeat from the leader node in the BMQ leader
/// election algorithm.
class LeaderHeartbeat {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderHeartbeat` having the default value.
    LeaderHeartbeat();

    /// Create an object of type `LeaderHeartbeat` having the value of the
    /// specified `original` object.
    LeaderHeartbeat(const LeaderHeartbeat& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderHeartbeat` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    LeaderHeartbeat(LeaderHeartbeat&& original) = default;
#endif

    /// Destroy this object.
    ~LeaderHeartbeat();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderHeartbeat& operator=(const LeaderHeartbeat& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderHeartbeat& operator=(LeaderHeartbeat&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderHeartbeat& lhs, const LeaderHeartbeat& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderHeartbeat& lhs, const LeaderHeartbeat& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&          stream,
                                const LeaderHeartbeat& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderHeartbeat`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                      hashAlg,
                const bmqp_ctrlmsg::LeaderHeartbeat& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::LeaderHeartbeat)

namespace bmqp_ctrlmsg {

// ===========================
// class LeaderMessageSequence
// ===========================

/// This type represents the sequence number of a message/advisory/response
/// sent by the leader.
class LeaderMessageSequence {
    // INSTANCE DATA
    bsls::Types::Uint64 d_electorTerm;
    bsls::Types::Uint64 d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_ELECTOR_TERM = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_ELECTOR_TERM    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderMessageSequence` having the default
    /// value.
    LeaderMessageSequence();

    /// Create an object of type `LeaderMessageSequence` having the value of
    /// the specified `original` object.
    LeaderMessageSequence(const LeaderMessageSequence& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderMessageSequence` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    LeaderMessageSequence(LeaderMessageSequence&& original) = default;
#endif

    /// Destroy this object.
    ~LeaderMessageSequence();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderMessageSequence& operator=(const LeaderMessageSequence& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderMessageSequence& operator=(LeaderMessageSequence&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ElectorTerm" attribute of this
    /// object.
    bsls::Types::Uint64& electorTerm();

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    bsls::Types::Uint64& sequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ElectorTerm" attribute of
    /// this object.
    bsls::Types::Uint64 electorTerm() const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    bsls::Types::Uint64 sequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderMessageSequence& lhs,
                       const LeaderMessageSequence& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderMessageSequence& lhs,
                       const LeaderMessageSequence& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                stream,
                                const LeaderMessageSequence& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderMessageSequence`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                            hashAlg,
                const bmqp_ctrlmsg::LeaderMessageSequence& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderMessageSequence)

namespace bmqp_ctrlmsg {

// ===================
// class LeaderPassive
// ===================

/// This type represents a particular type of cluster issue whereby the
/// leader is seen as passive by a follower node, resulting in invalid
/// cluster state.
class LeaderPassive {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderPassive` having the default value.
    LeaderPassive();

    /// Create an object of type `LeaderPassive` having the value of the
    /// specified `original` object.
    LeaderPassive(const LeaderPassive& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderPassive` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    LeaderPassive(LeaderPassive&& original) = default;
#endif

    /// Destroy this object.
    ~LeaderPassive();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderPassive& operator=(const LeaderPassive& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderPassive& operator=(LeaderPassive&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderPassive& lhs, const LeaderPassive& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderPassive& lhs, const LeaderPassive& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&        stream,
                                const LeaderPassive& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderPassive`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                    hashAlg,
                const bmqp_ctrlmsg::LeaderPassive& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::LeaderPassive)

namespace bmqp_ctrlmsg {

// =========================
// class LeaderSyncDataQuery
// =========================

/// This type represents a request sent by current leader to a follower to
/// ask follower to send the leader its partition/primary mapping and queue
/// information.
class LeaderSyncDataQuery {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderSyncDataQuery` having the default
    /// value.
    LeaderSyncDataQuery();

    /// Create an object of type `LeaderSyncDataQuery` having the value of
    /// the specified `original` object.
    LeaderSyncDataQuery(const LeaderSyncDataQuery& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderSyncDataQuery` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    LeaderSyncDataQuery(LeaderSyncDataQuery&& original) = default;
#endif

    /// Destroy this object.
    ~LeaderSyncDataQuery();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderSyncDataQuery& operator=(const LeaderSyncDataQuery& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderSyncDataQuery& operator=(LeaderSyncDataQuery&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderSyncDataQuery& lhs,
                       const LeaderSyncDataQuery& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderSyncDataQuery& lhs,
                       const LeaderSyncDataQuery& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const LeaderSyncDataQuery& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderSyncDataQuery`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::LeaderSyncDataQuery& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderSyncDataQuery)

namespace bmqp_ctrlmsg {

// ==========================
// class LeaderSyncStateQuery
// ==========================

/// This type represents a request sent by current leader to a follower to
/// query follower's view of the cluster state maintained by the leader.
class LeaderSyncStateQuery {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderSyncStateQuery` having the default
    /// value.
    LeaderSyncStateQuery();

    /// Create an object of type `LeaderSyncStateQuery` having the value of
    /// the specified `original` object.
    LeaderSyncStateQuery(const LeaderSyncStateQuery& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderSyncStateQuery` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    LeaderSyncStateQuery(LeaderSyncStateQuery&& original) = default;
#endif

    /// Destroy this object.
    ~LeaderSyncStateQuery();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderSyncStateQuery& operator=(const LeaderSyncStateQuery& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderSyncStateQuery& operator=(LeaderSyncStateQuery&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderSyncStateQuery& lhs,
                       const LeaderSyncStateQuery& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderSyncStateQuery& lhs,
                       const LeaderSyncStateQuery& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const LeaderSyncStateQuery& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderSyncStateQuery`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::LeaderSyncStateQuery& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderSyncStateQuery)

namespace bmqp_ctrlmsg {

// ===================================
// class LeadershipCessionNotification
// ===================================

/// This type represents a notification signalling cession of leadership
/// from the leader node in the BMQ leader election algorithm.
class LeadershipCessionNotification {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeadershipCessionNotification` having the
    /// default value.
    LeadershipCessionNotification();

    /// Create an object of type `LeadershipCessionNotification` having the
    /// value of the specified `original` object.
    LeadershipCessionNotification(
        const LeadershipCessionNotification& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeadershipCessionNotification` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    LeadershipCessionNotification(LeadershipCessionNotification&& original) =
        default;
#endif

    /// Destroy this object.
    ~LeadershipCessionNotification();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeadershipCessionNotification&
    operator=(const LeadershipCessionNotification& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeadershipCessionNotification&
    operator=(LeadershipCessionNotification&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeadershipCessionNotification& lhs,
                       const LeadershipCessionNotification& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeadershipCessionNotification& lhs,
                       const LeadershipCessionNotification& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                        stream,
                                const LeadershipCessionNotification& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeadershipCessionNotification`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                    hashAlg,
                const bmqp_ctrlmsg::LeadershipCessionNotification& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeadershipCessionNotification)

namespace bmqp_ctrlmsg {

// ================
// class NodeStatus
// ================

/// Enumeration of the various node states.
struct NodeStatus {
  public:
    // TYPES
    enum Value {
        E_UNKNOWN     = 0,
        E_STARTING    = 10,
        E_AVAILABLE   = 20,
        E_STOPPING    = 30,
        E_UNAVAILABLE = 40
    };

    enum { NUM_ENUMERATORS = 5 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, NodeStatus::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::NodeStatus)

namespace bmqp_ctrlmsg {

// ==========================
// class PartitionPrimaryInfo
// ==========================

/// This type represents the details of parition->primary node mapping.
class PartitionPrimaryInfo {
    // INSTANCE DATA
    unsigned int d_primaryLeaseId;
    int          d_partitionId;
    int          d_primaryNodeId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID     = 0,
        ATTRIBUTE_ID_PRIMARY_NODE_ID  = 1,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID     = 0,
        ATTRIBUTE_INDEX_PRIMARY_NODE_ID  = 1,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionPrimaryInfo` having the default
    /// value.
    PartitionPrimaryInfo();

    /// Create an object of type `PartitionPrimaryInfo` having the value of
    /// the specified `original` object.
    PartitionPrimaryInfo(const PartitionPrimaryInfo& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionPrimaryInfo` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    PartitionPrimaryInfo(PartitionPrimaryInfo&& original) = default;
#endif

    /// Destroy this object.
    ~PartitionPrimaryInfo();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionPrimaryInfo& operator=(const PartitionPrimaryInfo& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionPrimaryInfo& operator=(PartitionPrimaryInfo&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "PrimaryNodeId" attribute of
    /// this object.
    int& primaryNodeId();

    /// Return a reference to the modifiable "PrimaryLeaseId" attribute of
    /// this object.
    unsigned int& primaryLeaseId();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "PrimaryNodeId" attribute
    /// of this object.
    int primaryNodeId() const;

    /// Return a reference to the non-modifiable "PrimaryLeaseId" attribute
    /// of this object.
    unsigned int primaryLeaseId() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionPrimaryInfo& lhs,
                       const PartitionPrimaryInfo& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionPrimaryInfo& lhs,
                       const PartitionPrimaryInfo& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const PartitionPrimaryInfo& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionPrimaryInfo`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::PartitionPrimaryInfo& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionPrimaryInfo)

namespace bmqp_ctrlmsg {

// =============================
// class PartitionSequenceNumber
// =============================

/// This type represents the logical sequence number in a partition.
class PartitionSequenceNumber {
    // INSTANCE DATA
    bsls::Types::Uint64 d_sequenceNumber;
    unsigned int        d_primaryLeaseId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 0,
        ATTRIBUTE_ID_SEQUENCE_NUMBER  = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER  = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionSequenceNumber` having the
    /// default value.
    PartitionSequenceNumber();

    /// Create an object of type `PartitionSequenceNumber` having the value
    /// of the specified `original` object.
    PartitionSequenceNumber(const PartitionSequenceNumber& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionSequenceNumber` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    PartitionSequenceNumber(PartitionSequenceNumber&& original) = default;
#endif

    /// Destroy this object.
    ~PartitionSequenceNumber();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionSequenceNumber& operator=(const PartitionSequenceNumber& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionSequenceNumber& operator=(PartitionSequenceNumber&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PrimaryLeaseId" attribute of
    /// this object.
    unsigned int& primaryLeaseId();

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    bsls::Types::Uint64& sequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PrimaryLeaseId" attribute
    /// of this object.
    unsigned int primaryLeaseId() const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    bsls::Types::Uint64 sequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionSequenceNumber& lhs,
                       const PartitionSequenceNumber& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionSequenceNumber& lhs,
                       const PartitionSequenceNumber& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                  stream,
                                const PartitionSequenceNumber& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionSequenceNumber`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::PartitionSequenceNumber& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSequenceNumber)

namespace bmqp_ctrlmsg {

// ====================================
// class PartitionSyncDataQueryResponse
// ====================================

/// This type represents a message sent by a peer node to the new primary in
/// response to PartitionSyncDataQuery.
/// partitionId....: The corresponding partitionId
class PartitionSyncDataQueryResponse {
    // INSTANCE DATA
    bsls::Types::Uint64 d_endSequenceNum;
    unsigned int        d_endPrimaryLeaseId;
    int                 d_partitionId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID         = 0,
        ATTRIBUTE_ID_END_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_ID_END_SEQUENCE_NUM     = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID         = 0,
        ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_INDEX_END_SEQUENCE_NUM     = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionSyncDataQueryResponse` having the
    /// default value.
    PartitionSyncDataQueryResponse();

    /// Create an object of type `PartitionSyncDataQueryResponse` having the
    /// value of the specified `original` object.
    PartitionSyncDataQueryResponse(
        const PartitionSyncDataQueryResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionSyncDataQueryResponse` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    PartitionSyncDataQueryResponse(PartitionSyncDataQueryResponse&& original) =
        default;
#endif

    /// Destroy this object.
    ~PartitionSyncDataQueryResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionSyncDataQueryResponse&
    operator=(const PartitionSyncDataQueryResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionSyncDataQueryResponse&
    operator=(PartitionSyncDataQueryResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "EndPrimaryLeaseId" attribute
    /// of this object.
    unsigned int& endPrimaryLeaseId();

    /// Return a reference to the modifiable "EndSequenceNum" attribute of
    /// this object.
    bsls::Types::Uint64& endSequenceNum();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "EndPrimaryLeaseId"
    /// attribute of this object.
    unsigned int endPrimaryLeaseId() const;

    /// Return a reference to the non-modifiable "EndSequenceNum" attribute
    /// of this object.
    bsls::Types::Uint64 endSequenceNum() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionSyncDataQueryResponse& lhs,
                       const PartitionSyncDataQueryResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionSyncDataQueryResponse& lhs,
                       const PartitionSyncDataQueryResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                         stream,
                                const PartitionSyncDataQueryResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionSyncDataQueryResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                     hashAlg,
                const bmqp_ctrlmsg::PartitionSyncDataQueryResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncDataQueryResponse)

namespace bmqp_ctrlmsg {

// =============================
// class PartitionSyncStateQuery
// =============================

/// This type represents a request sent by a new primary node to all its
/// AVAILABLE peers to query their current state for a given partition.
/// partitionId: The corresponding partitionId
class PartitionSyncStateQuery {
    // INSTANCE DATA
    int d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_PARTITION_ID = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_PARTITION_ID;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionSyncStateQuery` having the
    /// default value.
    PartitionSyncStateQuery();

    /// Create an object of type `PartitionSyncStateQuery` having the value
    /// of the specified `original` object.
    PartitionSyncStateQuery(const PartitionSyncStateQuery& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionSyncStateQuery` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    PartitionSyncStateQuery(PartitionSyncStateQuery&& original) = default;
#endif

    /// Destroy this object.
    ~PartitionSyncStateQuery();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionSyncStateQuery& operator=(const PartitionSyncStateQuery& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionSyncStateQuery& operator=(PartitionSyncStateQuery&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionSyncStateQuery& lhs,
                       const PartitionSyncStateQuery& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionSyncStateQuery& lhs,
                       const PartitionSyncStateQuery& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                  stream,
                                const PartitionSyncStateQuery& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionSyncStateQuery`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::PartitionSyncStateQuery& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncStateQuery)

namespace bmqp_ctrlmsg {

// ===================
// class PrimaryStatus
// ===================

/// Enumeration of the various primary status.
struct PrimaryStatus {
  public:
    // TYPES
    enum Value { E_UNDEFINED = 0, E_PASSIVE = 1, E_ACTIVE = 5 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&        stream,
                                PrimaryStatus::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::PrimaryStatus)

namespace bmqp_ctrlmsg {

// ============================
// class QueueAssignmentRequest
// ============================

/// This type represents a request, sent to the leader, to assign the queue
/// with the specified `queueUri`.
class QueueAssignmentRequest {
    // INSTANCE DATA
    bsl::string d_queueUri;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_QUEUE_URI = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_QUEUE_URI = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueAssignmentRequest` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit QueueAssignmentRequest(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueAssignmentRequest` having the value
    /// of the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueAssignmentRequest(const QueueAssignmentRequest& original,
                           bslma::Allocator*             basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueAssignmentRequest` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    QueueAssignmentRequest(QueueAssignmentRequest&& original) noexcept;

    /// Create an object of type `QueueAssignmentRequest` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    QueueAssignmentRequest(QueueAssignmentRequest&& original,
                           bslma::Allocator*        basicAllocator);
#endif

    /// Destroy this object.
    ~QueueAssignmentRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueAssignmentRequest& operator=(const QueueAssignmentRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueAssignmentRequest& operator=(QueueAssignmentRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "QueueUri" attribute of this
    /// object.
    bsl::string& queueUri();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "QueueUri" attribute of
    /// this object.
    const bsl::string& queueUri() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueAssignmentRequest& lhs,
                       const QueueAssignmentRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueAssignmentRequest& lhs,
                       const QueueAssignmentRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                 stream,
                                const QueueAssignmentRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueAssignmentRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                             hashAlg,
                const bmqp_ctrlmsg::QueueAssignmentRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueAssignmentRequest)

namespace bmqp_ctrlmsg {

// ==============================
// class QueueUnassignmentRequest
// ==============================

/// This type represents a request, sent to the leader, to unassign the
/// queue with the specified `queueUri`.
class QueueUnassignmentRequest {
    // INSTANCE DATA
    bsl::vector<char> d_queueKey;
    bsl::string       d_queueUri;
    int               d_partitionId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_QUEUE_URI    = 0,
        ATTRIBUTE_ID_PARTITION_ID = 1,
        ATTRIBUTE_ID_QUEUE_KEY    = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_QUEUE_URI    = 0,
        ATTRIBUTE_INDEX_PARTITION_ID = 1,
        ATTRIBUTE_INDEX_QUEUE_KEY    = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueUnassignmentRequest` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit QueueUnassignmentRequest(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueUnassignmentRequest` having the value
    /// of the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueUnassignmentRequest(const QueueUnassignmentRequest& original,
                             bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueUnassignmentRequest` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    QueueUnassignmentRequest(QueueUnassignmentRequest&& original) noexcept;

    /// Create an object of type `QueueUnassignmentRequest` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    QueueUnassignmentRequest(QueueUnassignmentRequest&& original,
                             bslma::Allocator*          basicAllocator);
#endif

    /// Destroy this object.
    ~QueueUnassignmentRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueUnassignmentRequest& operator=(const QueueUnassignmentRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueUnassignmentRequest& operator=(QueueUnassignmentRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "QueueUri" attribute of this
    /// object.
    bsl::string& queueUri();

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "QueueKey" attribute of this
    /// object.
    bsl::vector<char>& queueKey();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "QueueUri" attribute of
    /// this object.
    const bsl::string& queueUri() const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "QueueKey" attribute of
    /// this object.
    const bsl::vector<char>& queueKey() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueUnassignmentRequest& lhs,
                       const QueueUnassignmentRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueUnassignmentRequest& lhs,
                       const QueueUnassignmentRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                   stream,
                                const QueueUnassignmentRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueUnassignmentRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                               hashAlg,
                const bmqp_ctrlmsg::QueueUnassignmentRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueUnassignmentRequest)

namespace bmqp_ctrlmsg {

// ==========================
// class RegistrationResponse
// ==========================

/// This type represents a response to the `RegistrationRequest` sent by the
/// leader to a follower.
class RegistrationResponse {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `RegistrationResponse` having the default
    /// value.
    RegistrationResponse();

    /// Create an object of type `RegistrationResponse` having the value of
    /// the specified `original` object.
    RegistrationResponse(const RegistrationResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `RegistrationResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    RegistrationResponse(RegistrationResponse&& original) = default;
#endif

    /// Destroy this object.
    ~RegistrationResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    RegistrationResponse& operator=(const RegistrationResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    RegistrationResponse& operator=(RegistrationResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const RegistrationResponse& lhs,
                       const RegistrationResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const RegistrationResponse& lhs,
                       const RegistrationResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const RegistrationResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `RegistrationResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::RegistrationResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::RegistrationResponse)

namespace bmqp_ctrlmsg {

// =====================
// class ReplicaDataType
// =====================

/// Enumeration of the various replica data request/response types.
struct ReplicaDataType {
  public:
    // TYPES
    enum Value { E_UNKNOWN = 0, E_PULL = 10, E_PUSH = 20, E_DROP = 30 };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&          stream,
                                ReplicaDataType::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::ReplicaDataType)

namespace bmqp_ctrlmsg {

// ==============================
// class ReverseConnectionRequest
// ==============================

/// This negotiation message is used as the first message exchanged in the
/// case of reverse connection: the `connecting` out peer sends that message
/// once the connection is established, indicating to the remote peer that
/// it should use this connection as the communication channel for the
/// `clusterNodeId` of the `clusterName`.
/// protocolVersion...: protocol version used by this broker
/// clusterName.......: the name of the cluster this connection is about
/// clusterNodeId.....: the nodeId of the node in that cluster (note that
/// the -1 default corresponds to `mqbnet::Cluster::k_INVALID_NODE_ID`).
class ReverseConnectionRequest {
    // INSTANCE DATA
    bsl::string d_clusterName;
    int         d_protocolVersion;
    int         d_clusterNodeId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PROTOCOL_VERSION = 0,
        ATTRIBUTE_ID_CLUSTER_NAME     = 1,
        ATTRIBUTE_ID_CLUSTER_NODE_ID  = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PROTOCOL_VERSION = 0,
        ATTRIBUTE_INDEX_CLUSTER_NAME     = 1,
        ATTRIBUTE_INDEX_CLUSTER_NODE_ID  = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const char DEFAULT_INITIALIZER_CLUSTER_NAME[];

    static const int DEFAULT_INITIALIZER_CLUSTER_NODE_ID;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ReverseConnectionRequest` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit ReverseConnectionRequest(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ReverseConnectionRequest` having the value
    /// of the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ReverseConnectionRequest(const ReverseConnectionRequest& original,
                             bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ReverseConnectionRequest` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    ReverseConnectionRequest(ReverseConnectionRequest&& original) noexcept;

    /// Create an object of type `ReverseConnectionRequest` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    ReverseConnectionRequest(ReverseConnectionRequest&& original,
                             bslma::Allocator*          basicAllocator);
#endif

    /// Destroy this object.
    ~ReverseConnectionRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ReverseConnectionRequest& operator=(const ReverseConnectionRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ReverseConnectionRequest& operator=(ReverseConnectionRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ProtocolVersion" attribute of
    /// this object.
    int& protocolVersion();

    /// Return a reference to the modifiable "ClusterName" attribute of this
    /// object.
    bsl::string& clusterName();

    /// Return a reference to the modifiable "ClusterNodeId" attribute of
    /// this object.
    int& clusterNodeId();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ProtocolVersion" attribute
    /// of this object.
    int protocolVersion() const;

    /// Return a reference to the non-modifiable "ClusterName" attribute of
    /// this object.
    const bsl::string& clusterName() const;

    /// Return a reference to the non-modifiable "ClusterNodeId" attribute
    /// of this object.
    int clusterNodeId() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ReverseConnectionRequest& lhs,
                       const ReverseConnectionRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ReverseConnectionRequest& lhs,
                       const ReverseConnectionRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                   stream,
                                const ReverseConnectionRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ReverseConnectionRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                               hashAlg,
                const bmqp_ctrlmsg::ReverseConnectionRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReverseConnectionRequest)

namespace bmqp_ctrlmsg {

// ==========================
// class RoutingConfiguration
// ==========================

/// This complex type contains various attributes required by the downstream
/// node to route messages to the consumers attached to it.
/// flags.: Flags representing the routing configuration
class RoutingConfiguration {
    // INSTANCE DATA

    // This is an unsigned representation with flag bits specified on the
    // `RoutingConfigurationFlags` type.
    bsls::Types::Uint64 d_flags;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_FLAGS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_FLAGS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `RoutingConfiguration` having the default
    /// value.
    RoutingConfiguration();

    /// Create an object of type `RoutingConfiguration` having the value of
    /// the specified `original` object.
    RoutingConfiguration(const RoutingConfiguration& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `RoutingConfiguration` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    RoutingConfiguration(RoutingConfiguration&& original) = default;
#endif

    /// Destroy this object.
    ~RoutingConfiguration();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    RoutingConfiguration& operator=(const RoutingConfiguration& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    RoutingConfiguration& operator=(RoutingConfiguration&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Flags" attribute of this
    /// object.
    bsls::Types::Uint64& flags();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Flags" attribute of this
    /// object.
    bsls::Types::Uint64 flags() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const RoutingConfiguration& lhs,
                       const RoutingConfiguration& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const RoutingConfiguration& lhs,
                       const RoutingConfiguration& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const RoutingConfiguration& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `RoutingConfiguration`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::RoutingConfiguration& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::RoutingConfiguration)

namespace bmqp_ctrlmsg {

// ===============================
// class RoutingConfigurationFlags
// ===============================

/// This flag encodes configuration on how messages should be routed to
/// downstream consumers.
/// E_AT_MOST_ONCE..............: This indicates that this domain is
/// configured with at-most-once semantics.  This in turn means that
/// confirms are optional and acknowledgments (if required) will always be
/// send, even if there's message loss.  E_DELIVER_CONSUMER_PRIORITY.: This
/// flag indicates that only downstream consumers having the highest
/// consumer should be considered as available destination for a message.
/// E_DELIVER_ALL...............: This flag indicates that messages should
/// be delivered to all available downstream consumers (after some added
/// filtering based on other flags, such as `E_DELIVER_CONSUMER_PRIORITY`).
/// E_HAS_MULTIPLE_SUB_STREAMS..: This flag indicates that multiple
/// downstream consumers should be considered as available destination for a
/// message.
struct RoutingConfigurationFlags {
  public:
    // TYPES
    enum Value {
        E_AT_MOST_ONCE              = 0,
        E_DELIVER_CONSUMER_PRIORITY = 1,
        E_DELIVER_ALL               = 2,
        E_HAS_MULTIPLE_SUB_STREAMS  = 3
    };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                    stream,
                                RoutingConfigurationFlags::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::RoutingConfigurationFlags)

namespace bmqp_ctrlmsg {

// =====================
// class ScoutingRequest
// =====================

/// This type represents a request sent by a peer node to gauge the interest
/// peer nodes in supporting it, with the term specified in the top level
/// type.
class ScoutingRequest {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ScoutingRequest` having the default value.
    ScoutingRequest();

    /// Create an object of type `ScoutingRequest` having the value of the
    /// specified `original` object.
    ScoutingRequest(const ScoutingRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ScoutingRequest` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ScoutingRequest(ScoutingRequest&& original) = default;
#endif

    /// Destroy this object.
    ~ScoutingRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ScoutingRequest& operator=(const ScoutingRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ScoutingRequest& operator=(ScoutingRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ScoutingRequest& lhs, const ScoutingRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ScoutingRequest& lhs, const ScoutingRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&          stream,
                                const ScoutingRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ScoutingRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                      hashAlg,
                const bmqp_ctrlmsg::ScoutingRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ScoutingRequest)

namespace bmqp_ctrlmsg {

// ======================
// class ScoutingResponse
// ======================

/// This type represents a message sent by a peer node as a response to the
/// scouting request from another peer.
/// willVote..: boolean indicating if this peer will support an election
/// proposal from the requester node with the term specified in the top
/// level type.
class ScoutingResponse {
    // INSTANCE DATA
    bool d_willVote;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_WILL_VOTE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_WILL_VOTE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ScoutingResponse` having the default
    /// value.
    ScoutingResponse();

    /// Create an object of type `ScoutingResponse` having the value of the
    /// specified `original` object.
    ScoutingResponse(const ScoutingResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ScoutingResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ScoutingResponse(ScoutingResponse&& original) = default;
#endif

    /// Destroy this object.
    ~ScoutingResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ScoutingResponse& operator=(const ScoutingResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ScoutingResponse& operator=(ScoutingResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "WillVote" attribute of this
    /// object.
    bool& willVote();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "WillVote" attribute of
    /// this object.
    bool willVote() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ScoutingResponse& lhs,
                       const ScoutingResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ScoutingResponse& lhs,
                       const ScoutingResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&           stream,
                                const ScoutingResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ScoutingResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::ScoutingResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ScoutingResponse)

namespace bmqp_ctrlmsg {

// ====================
// class StatusCategory
// ====================

/// Enumeration of the various status categories.  Some categories (TIMEOUT,
/// CANCELED) should not be sent by the broker, but adding them in that enum
/// will make it possible from the SDK (which could fire those errors in
/// response of a request) to simulate such response from the broker and
/// hence allow to use a single code path for the response handling.  ##
/// This enum must remain in sync with `bmqt_resultcode::GenericResult`
struct StatusCategory {
  public:
    // TYPES
    enum Value {
        E_SUCCESS          = 0,
        E_UNKNOWN          = -1,
        E_TIMEOUT          = -2,
        E_NOT_CONNECTED    = -3,
        E_CANCELED         = -4,
        E_NOT_SUPPORTED    = -5,
        E_REFUSED          = -6,
        E_INVALID_ARGUMENT = -7,
        E_NOT_READY        = -8
    };

    enum { NUM_ENUMERATORS = 9 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                StatusCategory::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::StatusCategory)

namespace bmqp_ctrlmsg {

// =================
// class StopRequest
// =================

/// This type represents a request sent by a cluster member node upon
/// graceful shutdown / going into maintenance mode.
class StopRequest {
    // INSTANCE DATA
    bsl::string d_clusterName;
    int         d_version;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CLUSTER_NAME = 0, ATTRIBUTE_ID_VERSION = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_CLUSTER_NAME = 0, ATTRIBUTE_INDEX_VERSION = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_VERSION;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `StopRequest` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit StopRequest(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `StopRequest` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    StopRequest(const StopRequest& original,
                bslma::Allocator*  basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `StopRequest` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    StopRequest(StopRequest&& original) noexcept;

    /// Create an object of type `StopRequest` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    StopRequest(StopRequest&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~StopRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    StopRequest& operator=(const StopRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    StopRequest& operator=(StopRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ClusterName" attribute of this
    /// object.
    bsl::string& clusterName();

    /// Return a reference to the non-modifiable "Version" attribute of this
    /// object.
    int& version();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ClusterName" attribute of
    /// this object.
    const bsl::string& clusterName() const;

    /// Return a reference to the non-modifiable "Version" attribute of this
    /// object.
    int version() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const StopRequest& lhs, const StopRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const StopRequest& lhs, const StopRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const StopRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `StopRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                  hashAlg,
                const bmqp_ctrlmsg::StopRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StopRequest)

namespace bmqp_ctrlmsg {

// ==================
// class StopResponse
// ==================

/// This type represents a response sent by a cluster member node or proxy
/// after completing processing stopRequest.
/// clusterName: Must match the one in corresponding stopRequest
class StopResponse {
    // INSTANCE DATA
    bsl::string d_clusterName;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CLUSTER_NAME = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CLUSTER_NAME = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `StopResponse` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit StopResponse(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `StopResponse` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    StopResponse(const StopResponse& original,
                 bslma::Allocator*   basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `StopResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    StopResponse(StopResponse&& original) noexcept;

    /// Create an object of type `StopResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    StopResponse(StopResponse&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~StopResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    StopResponse& operator=(const StopResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    StopResponse& operator=(StopResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ClusterName" attribute of this
    /// object.
    bsl::string& clusterName();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ClusterName" attribute of
    /// this object.
    const bsl::string& clusterName() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const StopResponse& lhs, const StopResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const StopResponse& lhs, const StopResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const StopResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `StopResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::StopResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StopResponse)

namespace bmqp_ctrlmsg {

// =============================
// class StorageSyncResponseType
// =============================

/// Enumeration of the various categories for storage sync response.
struct StorageSyncResponseType {
  public:
    // TYPES
    enum Value {
        E_UNDEFINED = 0,
        E_PATCH     = 1,
        E_FILE      = 2,
        E_IN_SYNC   = 3,
        E_EMPTY     = 4
    };

    enum { NUM_ENUMERATORS = 5 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS

    /// Return the string representation exactly matching the enumerator
    /// name corresponding to the specified enumeration `value`.
    static const char* toString(Value value);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string` of the specified `stringLength`.  Return 0 on
    /// success, and a non-zero value with no effect on `result` otherwise
    /// (i.e., `string` does not match any enumerator).
    static int fromString(Value* result, const char* string, int stringLength);

    /// Load into the specified `result` the enumerator matching the
    /// specified `string`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `string` does not match any
    /// enumerator).
    static int fromString(Value* result, const bsl::string& string);

    /// Load into the specified `result` the enumerator matching the
    /// specified `number`.  Return 0 on success, and a non-zero value with
    /// no effect on `result` otherwise (i.e., `number` does not match any
    /// enumerator).
    static int fromInt(Value* result, int number);

    /// Write to the specified `stream` the string representation of
    /// the specified enumeration `value`.  Return a reference to
    /// the modifiable `stream`.
    static bsl::ostream& print(bsl::ostream& stream, Value value);
};

// FREE OPERATORS

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                  stream,
                                StorageSyncResponseType::Value rhs);

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(bmqp_ctrlmsg::StorageSyncResponseType)

namespace bmqp_ctrlmsg {

// ====================
// class SubQueueIdInfo
// ====================

/// This complex type contains various attributes which uniquely identify a
/// subQueueId (which typically would represent a fanout consumer).
/// subId.: Id of the subQueue appId.: Application-provided unique string
/// identifier for a given fanout consumer
class SubQueueIdInfo {
    // INSTANCE DATA
    bsl::string  d_appId;
    unsigned int d_subId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SUB_ID = 0, ATTRIBUTE_ID_APP_ID = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SUB_ID = 0, ATTRIBUTE_INDEX_APP_ID = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const unsigned int DEFAULT_INITIALIZER_SUB_ID;

    static const char DEFAULT_INITIALIZER_APP_ID[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `SubQueueIdInfo` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit SubQueueIdInfo(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `SubQueueIdInfo` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    SubQueueIdInfo(const SubQueueIdInfo& original,
                   bslma::Allocator*     basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `SubQueueIdInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    SubQueueIdInfo(SubQueueIdInfo&& original) noexcept;

    /// Create an object of type `SubQueueIdInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    SubQueueIdInfo(SubQueueIdInfo&&  original,
                   bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~SubQueueIdInfo();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    SubQueueIdInfo& operator=(const SubQueueIdInfo& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    SubQueueIdInfo& operator=(SubQueueIdInfo&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SubId" attribute of this
    /// object.
    unsigned int& subId();

    /// Return a reference to the modifiable "AppId" attribute of this
    /// object.
    bsl::string& appId();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SubId" attribute of this
    /// object.
    unsigned int subId() const;

    /// Return a reference to the non-modifiable "AppId" attribute of this
    /// object.
    const bsl::string& appId() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const SubQueueIdInfo& lhs, const SubQueueIdInfo& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const SubQueueIdInfo& lhs, const SubQueueIdInfo& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                const SubQueueIdInfo& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `SubQueueIdInfo`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::SubQueueIdInfo& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::SubQueueIdInfo)

namespace bmqp_ctrlmsg {

// ===============
// class SyncPoint
// ===============

/// This type represents a `sync point` for a given partition (file store)
/// in the BMQ replicated state machine.  Note that sync point is sent as a
/// binary message, not a schema message.  This type exists in this schema
/// solely as a convenience for using a generated type instead of writing
/// one by hand.
/// partitionId.............: Id of the applicable partition (file store)
/// primaryLeaseId..........: LeaseId of the sender node (primary for the
/// partition) primaryNodeId...........: NodeId of the sender (primary for
/// the partition) sequenceNum.............: Sequence number of the last
/// message dataFilePositionDwords..: Position of data file when this sync
/// point was issued.
class SyncPoint {
    // INSTANCE DATA
    bsls::Types::Uint64 d_sequenceNum;
    unsigned int        d_primaryLeaseId;
    unsigned int        d_dataFileOffsetDwords;
    unsigned int        d_qlistFileOffsetWords;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PRIMARY_LEASE_ID        = 0,
        ATTRIBUTE_ID_SEQUENCE_NUM            = 1,
        ATTRIBUTE_ID_DATA_FILE_OFFSET_DWORDS = 2,
        ATTRIBUTE_ID_QLIST_FILE_OFFSET_WORDS = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID        = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUM            = 1,
        ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS = 2,
        ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `SyncPoint` having the default value.
    SyncPoint();

    /// Create an object of type `SyncPoint` having the value of the
    /// specified `original` object.
    SyncPoint(const SyncPoint& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `SyncPoint` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    SyncPoint(SyncPoint&& original) = default;
#endif

    /// Destroy this object.
    ~SyncPoint();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    SyncPoint& operator=(const SyncPoint& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    SyncPoint& operator=(SyncPoint&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PrimaryLeaseId" attribute of
    /// this object.
    unsigned int& primaryLeaseId();

    /// Return a reference to the modifiable "SequenceNum" attribute of this
    /// object.
    bsls::Types::Uint64& sequenceNum();

    /// Return a reference to the modifiable "DataFileOffsetDwords"
    /// attribute of this object.
    unsigned int& dataFileOffsetDwords();

    /// Return a reference to the modifiable "QlistFileOffsetWords"
    /// attribute of this object.
    unsigned int& qlistFileOffsetWords();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PrimaryLeaseId" attribute
    /// of this object.
    unsigned int primaryLeaseId() const;

    /// Return a reference to the non-modifiable "SequenceNum" attribute of
    /// this object.
    bsls::Types::Uint64 sequenceNum() const;

    /// Return a reference to the non-modifiable "DataFileOffsetDwords"
    /// attribute of this object.
    unsigned int dataFileOffsetDwords() const;

    /// Return a reference to the non-modifiable "QlistFileOffsetWords"
    /// attribute of this object.
    unsigned int qlistFileOffsetWords() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const SyncPoint& lhs, const SyncPoint& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const SyncPoint& lhs, const SyncPoint& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const SyncPoint& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `SyncPoint`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                hashAlg,
                const bmqp_ctrlmsg::SyncPoint& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::SyncPoint)

namespace bmqp_ctrlmsg {

// ====================
// class ClientIdentity
// ====================

/// This represents the `identification` sent by a client to the broker
/// during connection negotiation.
/// protocolVersion...: protocol version used by this client
/// sdkVersion........: version of the SDK used by this client
/// clientType........: type of client trying to connect to the bmqbrkr
/// processName.......: name of the process pid...............: PID of the
/// process sessionId.........: instance count of the session in the task
/// hostName..........: name of the host where the client is running
/// features..........: a space separated list of supported features by the
/// client clusterName.......: used only when `clientType` is `E_TCPBROKER`
/// and contains the name of the Cluster responsible for establishing this
/// inter-broker connectivity; whether this is about a Cluster proxy or a
/// Cluster member.  clusterNodeId.....: used only when `clientType` is
/// `E_TCPBROKER` and contains the node id of the broker in that cluster, or
/// -1 if the broker  is not part of the cluster (i.e., a -1 value for
/// `clusterNodeId` indicates this connection is about a Cluster proxy; note
/// that this -1 must be equal to `mqbnet::Cluster::k_INVALID_NODE_ID`).
/// sdkLanguage.......: language of the SDK used by this client.
/// guidInfo..........: data provided by bmqp::MessageGUIDGenerator.
/// Contains clientId, current timer tick and number of seconds from epoch.
class ClientIdentity {
    // INSTANCE DATA
    bsl::string           d_processName;
    bsl::string           d_hostName;
    bsl::string           d_features;
    bsl::string           d_clusterName;
    GuidInfo              d_guidInfo;
    int                   d_protocolVersion;
    int                   d_sdkVersion;
    int                   d_pid;
    int                   d_sessionId;
    int                   d_clusterNodeId;
    ClientType::Value     d_clientType;
    ClientLanguage::Value d_sdkLanguage;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PROTOCOL_VERSION = 0,
        ATTRIBUTE_ID_SDK_VERSION      = 1,
        ATTRIBUTE_ID_CLIENT_TYPE      = 2,
        ATTRIBUTE_ID_PROCESS_NAME     = 3,
        ATTRIBUTE_ID_PID              = 4,
        ATTRIBUTE_ID_SESSION_ID       = 5,
        ATTRIBUTE_ID_HOST_NAME        = 6,
        ATTRIBUTE_ID_FEATURES         = 7,
        ATTRIBUTE_ID_CLUSTER_NAME     = 8,
        ATTRIBUTE_ID_CLUSTER_NODE_ID  = 9,
        ATTRIBUTE_ID_SDK_LANGUAGE     = 10,
        ATTRIBUTE_ID_GUID_INFO        = 11
    };

    enum { NUM_ATTRIBUTES = 12 };

    enum {
        ATTRIBUTE_INDEX_PROTOCOL_VERSION = 0,
        ATTRIBUTE_INDEX_SDK_VERSION      = 1,
        ATTRIBUTE_INDEX_CLIENT_TYPE      = 2,
        ATTRIBUTE_INDEX_PROCESS_NAME     = 3,
        ATTRIBUTE_INDEX_PID              = 4,
        ATTRIBUTE_INDEX_SESSION_ID       = 5,
        ATTRIBUTE_INDEX_HOST_NAME        = 6,
        ATTRIBUTE_INDEX_FEATURES         = 7,
        ATTRIBUTE_INDEX_CLUSTER_NAME     = 8,
        ATTRIBUTE_INDEX_CLUSTER_NODE_ID  = 9,
        ATTRIBUTE_INDEX_SDK_LANGUAGE     = 10,
        ATTRIBUTE_INDEX_GUID_INFO        = 11
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_SDK_VERSION;

    static const char DEFAULT_INITIALIZER_PROCESS_NAME[];

    static const int DEFAULT_INITIALIZER_PID;

    static const int DEFAULT_INITIALIZER_SESSION_ID;

    static const char DEFAULT_INITIALIZER_HOST_NAME[];

    static const char DEFAULT_INITIALIZER_FEATURES[];

    static const char DEFAULT_INITIALIZER_CLUSTER_NAME[];

    static const int DEFAULT_INITIALIZER_CLUSTER_NODE_ID;

    static const ClientLanguage::Value DEFAULT_INITIALIZER_SDK_LANGUAGE;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ClientIdentity` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit ClientIdentity(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ClientIdentity` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ClientIdentity(const ClientIdentity& original,
                   bslma::Allocator*     basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ClientIdentity` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ClientIdentity(ClientIdentity&& original) noexcept;

    /// Create an object of type `ClientIdentity` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    ClientIdentity(ClientIdentity&&  original,
                   bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~ClientIdentity();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ClientIdentity& operator=(const ClientIdentity& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ClientIdentity& operator=(ClientIdentity&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ProtocolVersion" attribute of
    /// this object.
    int& protocolVersion();

    /// Return a reference to the modifiable "SdkVersion" attribute of this
    /// object.
    int& sdkVersion();

    /// Return a reference to the modifiable "ClientType" attribute of this
    /// object.
    ClientType::Value& clientType();

    /// Return a reference to the modifiable "ProcessName" attribute of this
    /// object.
    bsl::string& processName();

    /// Return a reference to the modifiable "Pid" attribute of this object.
    int& pid();

    /// Return a reference to the modifiable "SessionId" attribute of this
    /// object.
    int& sessionId();

    /// Return a reference to the modifiable "HostName" attribute of this
    /// object.
    bsl::string& hostName();

    /// Return a reference to the modifiable "Features" attribute of this
    /// object.
    bsl::string& features();

    /// Return a reference to the modifiable "ClusterName" attribute of this
    /// object.
    bsl::string& clusterName();

    /// Return a reference to the modifiable "ClusterNodeId" attribute of
    /// this object.
    int& clusterNodeId();

    /// Return a reference to the modifiable "SdkLanguage" attribute of this
    /// object.
    ClientLanguage::Value& sdkLanguage();

    /// Return a reference to the modifiable "GuidInfo" attribute of this
    /// object.
    GuidInfo& guidInfo();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ProtocolVersion" attribute
    /// of this object.
    int protocolVersion() const;

    /// Return a reference to the non-modifiable "SdkVersion" attribute of
    /// this object.
    int sdkVersion() const;

    /// Return a reference to the non-modifiable "ClientType" attribute of
    /// this object.
    ClientType::Value clientType() const;

    /// Return a reference to the non-modifiable "ProcessName" attribute of
    /// this object.
    const bsl::string& processName() const;

    /// Return a reference to the non-modifiable "Pid" attribute of this
    /// object.
    int pid() const;

    /// Return a reference to the non-modifiable "SessionId" attribute of
    /// this object.
    int sessionId() const;

    /// Return a reference to the non-modifiable "HostName" attribute of
    /// this object.
    const bsl::string& hostName() const;

    /// Return a reference to the non-modifiable "Features" attribute of
    /// this object.
    const bsl::string& features() const;

    /// Return a reference to the non-modifiable "ClusterName" attribute of
    /// this object.
    const bsl::string& clusterName() const;

    /// Return a reference to the non-modifiable "ClusterNodeId" attribute
    /// of this object.
    int clusterNodeId() const;

    /// Return a reference to the non-modifiable "SdkLanguage" attribute of
    /// this object.
    ClientLanguage::Value sdkLanguage() const;

    /// Return a reference to the non-modifiable "GuidInfo" attribute of
    /// this object.
    const GuidInfo& guidInfo() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ClientIdentity& lhs, const ClientIdentity& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ClientIdentity& lhs, const ClientIdentity& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                const ClientIdentity& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ClientIdentity`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::ClientIdentity& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClientIdentity)

namespace bmqp_ctrlmsg {

// ==================
// class DumpMessages
// ==================

class DumpMessages {
    // INSTANCE DATA
    int                   d_dumpActionValue;
    DumpMsgType::Value    d_msgTypeToDump;
    DumpActionType::Value d_dumpActionType;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_MSG_TYPE_TO_DUMP  = 0,
        ATTRIBUTE_ID_DUMP_ACTION_TYPE  = 1,
        ATTRIBUTE_ID_DUMP_ACTION_VALUE = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP  = 0,
        ATTRIBUTE_INDEX_DUMP_ACTION_TYPE  = 1,
        ATTRIBUTE_INDEX_DUMP_ACTION_VALUE = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_DUMP_ACTION_VALUE;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `DumpMessages` having the default value.
    DumpMessages();

    /// Create an object of type `DumpMessages` having the value of the
    /// specified `original` object.
    DumpMessages(const DumpMessages& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `DumpMessages` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    DumpMessages(DumpMessages&& original) = default;
#endif

    /// Destroy this object.
    ~DumpMessages();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    DumpMessages& operator=(const DumpMessages& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    DumpMessages& operator=(DumpMessages&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "MsgTypeToDump" attribute of
    /// this object.
    DumpMsgType::Value& msgTypeToDump();

    /// Return a reference to the modifiable "DumpActionType" attribute of
    /// this object.
    DumpActionType::Value& dumpActionType();

    /// Return a reference to the modifiable "DumpActionValue" attribute of
    /// this object.
    int& dumpActionValue();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "MsgTypeToDump" attribute
    /// of this object.
    DumpMsgType::Value msgTypeToDump() const;

    /// Return a reference to the non-modifiable "DumpActionType" attribute
    /// of this object.
    DumpActionType::Value dumpActionType() const;

    /// Return a reference to the non-modifiable "DumpActionValue" attribute
    /// of this object.
    int dumpActionValue() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const DumpMessages& lhs, const DumpMessages& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const DumpMessages& lhs, const DumpMessages& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const DumpMessages& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `DumpMessages`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::DumpMessages& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::DumpMessages)

namespace bmqp_ctrlmsg {

// ==========================
// class ElectorMessageChoice
// ==========================

class ElectorMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ElectionProposal>  d_electionProposal;
        bsls::ObjectBuffer<ElectionResponse>  d_electionResponse;
        bsls::ObjectBuffer<LeaderHeartbeat>   d_leaderHeartbeat;
        bsls::ObjectBuffer<ElectorNodeStatus> d_electorNodeStatus;
        bsls::ObjectBuffer<HeartbeatResponse> d_heartbeatResponse;
        bsls::ObjectBuffer<ScoutingRequest>   d_scoutingRequest;
        bsls::ObjectBuffer<ScoutingResponse>  d_scoutingResponse;
        bsls::ObjectBuffer<LeadershipCessionNotification>
            d_leadershipCessionNotification;
    };

    int d_selectionId;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                       = -1,
        SELECTION_ID_ELECTION_PROPOSAL               = 0,
        SELECTION_ID_ELECTION_RESPONSE               = 1,
        SELECTION_ID_LEADER_HEARTBEAT                = 2,
        SELECTION_ID_ELECTOR_NODE_STATUS             = 3,
        SELECTION_ID_HEARTBEAT_RESPONSE              = 4,
        SELECTION_ID_SCOUTING_REQUEST                = 5,
        SELECTION_ID_SCOUTING_RESPONSE               = 6,
        SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION = 7
    };

    enum { NUM_SELECTIONS = 8 };

    enum {
        SELECTION_INDEX_ELECTION_PROPOSAL               = 0,
        SELECTION_INDEX_ELECTION_RESPONSE               = 1,
        SELECTION_INDEX_LEADER_HEARTBEAT                = 2,
        SELECTION_INDEX_ELECTOR_NODE_STATUS             = 3,
        SELECTION_INDEX_HEARTBEAT_RESPONSE              = 4,
        SELECTION_INDEX_SCOUTING_REQUEST                = 5,
        SELECTION_INDEX_SCOUTING_RESPONSE               = 6,
        SELECTION_INDEX_LEADERSHIP_CESSION_NOTIFICATION = 7
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS

    /// Return selection information for the selection indicated by the
    /// specified `id` if the selection exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);

    /// Return selection information for the selection indicated by the
    /// specified `name` of the specified `nameLength` if the selection
    /// exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ElectorMessageChoice` having the default
    /// value.
    ElectorMessageChoice();

    /// Create an object of type `ElectorMessageChoice` having the value of
    /// the specified `original` object.
    ElectorMessageChoice(const ElectorMessageChoice& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ElectorMessageChoice` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ElectorMessageChoice(ElectorMessageChoice&& original) noexcept;
#endif

    /// Destroy this object.
    ~ElectorMessageChoice();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ElectorMessageChoice& operator=(const ElectorMessageChoice& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ElectorMessageChoice& operator=(ElectorMessageChoice&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon default
    /// construction).
    void reset();

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `selectionId`.  Return 0 on success, and
    /// non-zero value otherwise (i.e., the selection is not found).
    int makeSelection(int selectionId);

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `name` of the specified `nameLength`.
    /// Return 0 on success, and non-zero value otherwise (i.e., the
    /// selection is not found).
    int makeSelection(const char* name, int nameLength);

    ElectionProposal& makeElectionProposal();
    ElectionProposal& makeElectionProposal(const ElectionProposal& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectionProposal& makeElectionProposal(ElectionProposal&& value);
#endif
    // Set the value of this object to be a "ElectionProposal" value.
    // Optionally specify the 'value' of the "ElectionProposal".  If
    // 'value' is not specified, the default "ElectionProposal" value is
    // used.

    ElectionResponse& makeElectionResponse();
    ElectionResponse& makeElectionResponse(const ElectionResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectionResponse& makeElectionResponse(ElectionResponse&& value);
#endif
    // Set the value of this object to be a "ElectionResponse" value.
    // Optionally specify the 'value' of the "ElectionResponse".  If
    // 'value' is not specified, the default "ElectionResponse" value is
    // used.

    LeaderHeartbeat& makeLeaderHeartbeat();
    LeaderHeartbeat& makeLeaderHeartbeat(const LeaderHeartbeat& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderHeartbeat& makeLeaderHeartbeat(LeaderHeartbeat&& value);
#endif
    // Set the value of this object to be a "LeaderHeartbeat" value.
    // Optionally specify the 'value' of the "LeaderHeartbeat".  If 'value'
    // is not specified, the default "LeaderHeartbeat" value is used.

    ElectorNodeStatus& makeElectorNodeStatus();
    ElectorNodeStatus& makeElectorNodeStatus(const ElectorNodeStatus& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorNodeStatus& makeElectorNodeStatus(ElectorNodeStatus&& value);
#endif
    // Set the value of this object to be a "ElectorNodeStatus" value.
    // Optionally specify the 'value' of the "ElectorNodeStatus".  If
    // 'value' is not specified, the default "ElectorNodeStatus" value is
    // used.

    HeartbeatResponse& makeHeartbeatResponse();
    HeartbeatResponse& makeHeartbeatResponse(const HeartbeatResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    HeartbeatResponse& makeHeartbeatResponse(HeartbeatResponse&& value);
#endif
    // Set the value of this object to be a "HeartbeatResponse" value.
    // Optionally specify the 'value' of the "HeartbeatResponse".  If
    // 'value' is not specified, the default "HeartbeatResponse" value is
    // used.

    ScoutingRequest& makeScoutingRequest();
    ScoutingRequest& makeScoutingRequest(const ScoutingRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ScoutingRequest& makeScoutingRequest(ScoutingRequest&& value);
#endif
    // Set the value of this object to be a "ScoutingRequest" value.
    // Optionally specify the 'value' of the "ScoutingRequest".  If 'value'
    // is not specified, the default "ScoutingRequest" value is used.

    ScoutingResponse& makeScoutingResponse();
    ScoutingResponse& makeScoutingResponse(const ScoutingResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ScoutingResponse& makeScoutingResponse(ScoutingResponse&& value);
#endif
    // Set the value of this object to be a "ScoutingResponse" value.
    // Optionally specify the 'value' of the "ScoutingResponse".  If
    // 'value' is not specified, the default "ScoutingResponse" value is
    // used.

    LeadershipCessionNotification& makeLeadershipCessionNotification();
    LeadershipCessionNotification& makeLeadershipCessionNotification(
        const LeadershipCessionNotification& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeadershipCessionNotification&
    makeLeadershipCessionNotification(LeadershipCessionNotification&& value);
#endif
    // Set the value of this object to be a "LeadershipCessionNotification"
    // value.  Optionally specify the 'value' of the
    // "LeadershipCessionNotification".  If 'value' is not specified, the
    // default "LeadershipCessionNotification" value is used.

    /// Invoke the specified `manipulator` on the address of the modifiable
    /// selection, supplying `manipulator` with the corresponding selection
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if this object has a defined selection,
    /// and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateSelection(MANIPULATOR& manipulator);

    /// Return a reference to the modifiable "ElectionProposal" selection of
    /// this object if "ElectionProposal" is the current selection.  The
    /// behavior is undefined unless "ElectionProposal" is the selection of
    /// this object.
    ElectionProposal& electionProposal();

    /// Return a reference to the modifiable "ElectionResponse" selection of
    /// this object if "ElectionResponse" is the current selection.  The
    /// behavior is undefined unless "ElectionResponse" is the selection of
    /// this object.
    ElectionResponse& electionResponse();

    /// Return a reference to the modifiable "LeaderHeartbeat" selection of
    /// this object if "LeaderHeartbeat" is the current selection.  The
    /// behavior is undefined unless "LeaderHeartbeat" is the selection of
    /// this object.
    LeaderHeartbeat& leaderHeartbeat();

    /// Return a reference to the modifiable "ElectorNodeStatus" selection
    /// of this object if "ElectorNodeStatus" is the current selection.  The
    /// behavior is undefined unless "ElectorNodeStatus" is the selection of
    /// this object.
    ElectorNodeStatus& electorNodeStatus();

    /// Return a reference to the modifiable "HeartbeatResponse" selection
    /// of this object if "HeartbeatResponse" is the current selection.  The
    /// behavior is undefined unless "HeartbeatResponse" is the selection of
    /// this object.
    HeartbeatResponse& heartbeatResponse();

    /// Return a reference to the modifiable "ScoutingRequest" selection of
    /// this object if "ScoutingRequest" is the current selection.  The
    /// behavior is undefined unless "ScoutingRequest" is the selection of
    /// this object.
    ScoutingRequest& scoutingRequest();

    /// Return a reference to the modifiable "ScoutingResponse" selection of
    /// this object if "ScoutingResponse" is the current selection.  The
    /// behavior is undefined unless "ScoutingResponse" is the selection of
    /// this object.
    ScoutingResponse& scoutingResponse();

    /// Return a reference to the modifiable "LeadershipCessionNotification"
    /// selection of this object if "LeadershipCessionNotification" is the
    /// current selection.  The behavior is undefined unless
    /// "LeadershipCessionNotification" is the selection of this object.
    LeadershipCessionNotification& leadershipCessionNotification();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Return the id of the current selection if the selection is defined,
    /// and -1 otherwise.
    int selectionId() const;

    /// Invoke the specified `accessor` on the non-modifiable selection,
    /// supplying `accessor` with the corresponding selection information
    /// structure.  Return the value returned from the invocation of
    /// `accessor` if this object has a defined selection, and -1 otherwise.
    template <class ACCESSOR>
    int accessSelection(ACCESSOR& accessor) const;

    /// Return a reference to the non-modifiable "ElectionProposal"
    /// selection of this object if "ElectionProposal" is the current
    /// selection.  The behavior is undefined unless "ElectionProposal" is
    /// the selection of this object.
    const ElectionProposal& electionProposal() const;

    /// Return a reference to the non-modifiable "ElectionResponse"
    /// selection of this object if "ElectionResponse" is the current
    /// selection.  The behavior is undefined unless "ElectionResponse" is
    /// the selection of this object.
    const ElectionResponse& electionResponse() const;

    /// Return a reference to the non-modifiable "LeaderHeartbeat" selection
    /// of this object if "LeaderHeartbeat" is the current selection.  The
    /// behavior is undefined unless "LeaderHeartbeat" is the selection of
    /// this object.
    const LeaderHeartbeat& leaderHeartbeat() const;

    /// Return a reference to the non-modifiable "ElectorNodeStatus"
    /// selection of this object if "ElectorNodeStatus" is the current
    /// selection.  The behavior is undefined unless "ElectorNodeStatus" is
    /// the selection of this object.
    const ElectorNodeStatus& electorNodeStatus() const;

    /// Return a reference to the non-modifiable "HeartbeatResponse"
    /// selection of this object if "HeartbeatResponse" is the current
    /// selection.  The behavior is undefined unless "HeartbeatResponse" is
    /// the selection of this object.
    const HeartbeatResponse& heartbeatResponse() const;

    /// Return a reference to the non-modifiable "ScoutingRequest" selection
    /// of this object if "ScoutingRequest" is the current selection.  The
    /// behavior is undefined unless "ScoutingRequest" is the selection of
    /// this object.
    const ScoutingRequest& scoutingRequest() const;

    /// Return a reference to the non-modifiable "ScoutingResponse"
    /// selection of this object if "ScoutingResponse" is the current
    /// selection.  The behavior is undefined unless "ScoutingResponse" is
    /// the selection of this object.
    const ScoutingResponse& scoutingResponse() const;

    /// Return a reference to the non-modifiable
    /// "LeadershipCessionNotification" selection of this object if
    /// "LeadershipCessionNotification" is the current selection.  The
    /// behavior is undefined unless "LeadershipCessionNotification" is the
    /// selection of this object.
    const LeadershipCessionNotification& leadershipCessionNotification() const;

    /// Return `true` if the value of this object is a "ElectionProposal"
    /// value, and return `false` otherwise.
    bool isElectionProposalValue() const;

    /// Return `true` if the value of this object is a "ElectionResponse"
    /// value, and return `false` otherwise.
    bool isElectionResponseValue() const;

    /// Return `true` if the value of this object is a "LeaderHeartbeat"
    /// value, and return `false` otherwise.
    bool isLeaderHeartbeatValue() const;

    /// Return `true` if the value of this object is a "ElectorNodeStatus"
    /// value, and return `false` otherwise.
    bool isElectorNodeStatusValue() const;

    /// Return `true` if the value of this object is a "HeartbeatResponse"
    /// value, and return `false` otherwise.
    bool isHeartbeatResponseValue() const;

    /// Return `true` if the value of this object is a "ScoutingRequest"
    /// value, and return `false` otherwise.
    bool isScoutingRequestValue() const;

    /// Return `true` if the value of this object is a "ScoutingResponse"
    /// value, and return `false` otherwise.
    bool isScoutingResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "LeadershipCessionNotification" value, and return `false` otherwise.
    bool isLeadershipCessionNotificationValue() const;

    /// Return `true` if the value of this object is undefined, and `false`
    /// otherwise.
    bool isUndefinedValue() const;

    /// Return the symbolic name of the current selection of this object.
    const char* selectionName() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` objects have the same
/// value, and `false` otherwise.  Two `ElectorMessageChoice` objects have the
/// same value if either the selections in both objects have the same ids and
/// the same values, or both selections are undefined.
inline bool operator==(const ElectorMessageChoice& lhs,
                       const ElectorMessageChoice& rhs);

/// Return `true` if the specified `lhs` and `rhs` objects do not have the
/// same values, as determined by `operator==`, and `false` otherwise.
inline bool operator!=(const ElectorMessageChoice& lhs,
                       const ElectorMessageChoice& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const ElectorMessageChoice& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ElectorMessageChoice`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ElectorMessageChoice& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ElectorMessageChoice)

namespace bmqp_ctrlmsg {

// ================
// class Expression
// ================

/// This complex type contains expression to evaluate when selecting
/// Subscription for delivery.
/// version................: expression version (default is HSL)
/// text...................: textual representation of the expression
class Expression {
    // INSTANCE DATA
    bsl::string              d_text;
    ExpressionVersion::Value d_version;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_VERSION = 0, ATTRIBUTE_ID_TEXT = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_VERSION = 0, ATTRIBUTE_INDEX_TEXT = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const ExpressionVersion::Value DEFAULT_INITIALIZER_VERSION;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `Expression` having the default value.  Use
    /// the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit Expression(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `Expression` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    Expression(const Expression& original,
               bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `Expression` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    Expression(Expression&& original) noexcept;

    /// Create an object of type `Expression` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    Expression(Expression&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~Expression();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    Expression& operator=(const Expression& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    Expression& operator=(Expression&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Version" attribute of this
    /// object.
    ExpressionVersion::Value& version();

    /// Return a reference to the modifiable "Text" attribute of this
    /// object.
    bsl::string& text();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Version" attribute of this
    /// object.
    ExpressionVersion::Value version() const;

    /// Return a reference to the non-modifiable "Text" attribute of this
    /// object.
    const bsl::string& text() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const Expression& lhs, const Expression& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const Expression& lhs, const Expression& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const Expression& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `Expression`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                 hashAlg,
                const bmqp_ctrlmsg::Expression& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::Expression)

namespace bmqp_ctrlmsg {

// =========================
// class FollowerLSNResponse
// =========================

/// This type represents a response to the `FollowerLSNRequest` sent by a
/// follower to the leader.
/// sequenceNumber..: Follower's leader-sequence number
class FollowerLSNResponse {
    // INSTANCE DATA
    LeaderMessageSequence d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `FollowerLSNResponse` having the default
    /// value.
    FollowerLSNResponse();

    /// Create an object of type `FollowerLSNResponse` having the value of
    /// the specified `original` object.
    FollowerLSNResponse(const FollowerLSNResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `FollowerLSNResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    FollowerLSNResponse(FollowerLSNResponse&& original) = default;
#endif

    /// Destroy this object.
    ~FollowerLSNResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    FollowerLSNResponse& operator=(const FollowerLSNResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    FollowerLSNResponse& operator=(FollowerLSNResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    LeaderMessageSequence& sequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const LeaderMessageSequence& sequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const FollowerLSNResponse& lhs,
                       const FollowerLSNResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const FollowerLSNResponse& lhs,
                       const FollowerLSNResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const FollowerLSNResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `FollowerLSNResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::FollowerLSNResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::FollowerLSNResponse)

namespace bmqp_ctrlmsg {

// =======================
// class LeaderAdvisoryAck
// =======================

/// This type represents a one way message indicating receipt of a specific
/// leader advisory.
class LeaderAdvisoryAck {
    // INSTANCE DATA
    LeaderMessageSequence d_sequenceNumberAcked;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER_ACKED = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderAdvisoryAck` having the default
    /// value.
    LeaderAdvisoryAck();

    /// Create an object of type `LeaderAdvisoryAck` having the value of the
    /// specified `original` object.
    LeaderAdvisoryAck(const LeaderAdvisoryAck& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderAdvisoryAck` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    LeaderAdvisoryAck(LeaderAdvisoryAck&& original) = default;
#endif

    /// Destroy this object.
    ~LeaderAdvisoryAck();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderAdvisoryAck& operator=(const LeaderAdvisoryAck& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderAdvisoryAck& operator=(LeaderAdvisoryAck&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumberAcked" attribute
    /// of this object.
    LeaderMessageSequence& sequenceNumberAcked();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumberAcked"
    /// attribute of this object.
    const LeaderMessageSequence& sequenceNumberAcked() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderAdvisoryAck& lhs,
                       const LeaderAdvisoryAck& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderAdvisoryAck& lhs,
                       const LeaderAdvisoryAck& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&            stream,
                                const LeaderAdvisoryAck& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderAdvisoryAck`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::LeaderAdvisoryAck& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderAdvisoryAck)

namespace bmqp_ctrlmsg {

// ==========================
// class LeaderAdvisoryCommit
// ==========================

/// This type represents a one way message indicating commit of a specific
/// leader advisory.
class LeaderAdvisoryCommit {
    // INSTANCE DATA
    LeaderMessageSequence d_sequenceNumber;
    LeaderMessageSequence d_sequenceNumberCommitted;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SEQUENCE_NUMBER           = 0,
        ATTRIBUTE_ID_SEQUENCE_NUMBER_COMMITTED = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER           = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderAdvisoryCommit` having the default
    /// value.
    LeaderAdvisoryCommit();

    /// Create an object of type `LeaderAdvisoryCommit` having the value of
    /// the specified `original` object.
    LeaderAdvisoryCommit(const LeaderAdvisoryCommit& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderAdvisoryCommit` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    LeaderAdvisoryCommit(LeaderAdvisoryCommit&& original) = default;
#endif

    /// Destroy this object.
    ~LeaderAdvisoryCommit();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderAdvisoryCommit& operator=(const LeaderAdvisoryCommit& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderAdvisoryCommit& operator=(LeaderAdvisoryCommit&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    LeaderMessageSequence& sequenceNumber();

    /// Return a reference to the modifiable "SequenceNumberCommitted"
    /// attribute of this object.
    LeaderMessageSequence& sequenceNumberCommitted();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const LeaderMessageSequence& sequenceNumber() const;

    /// Return a reference to the non-modifiable "SequenceNumberCommitted"
    /// attribute of this object.
    const LeaderMessageSequence& sequenceNumberCommitted() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderAdvisoryCommit& lhs,
                       const LeaderAdvisoryCommit& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderAdvisoryCommit& lhs,
                       const LeaderAdvisoryCommit& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const LeaderAdvisoryCommit& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderAdvisoryCommit`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::LeaderAdvisoryCommit& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderAdvisoryCommit)

namespace bmqp_ctrlmsg {

// ==================================
// class LeaderSyncStateQueryResponse
// ==================================

/// This type represents a response to the `LeaderSyncStateQuery` sent by
/// the follower to the leader.
class LeaderSyncStateQueryResponse {
    // INSTANCE DATA
    LeaderMessageSequence d_leaderMessageSequence;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderSyncStateQueryResponse` having the
    /// default value.
    LeaderSyncStateQueryResponse();

    /// Create an object of type `LeaderSyncStateQueryResponse` having the
    /// value of the specified `original` object.
    LeaderSyncStateQueryResponse(const LeaderSyncStateQueryResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderSyncStateQueryResponse` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    LeaderSyncStateQueryResponse(LeaderSyncStateQueryResponse&& original) =
        default;
#endif

    /// Destroy this object.
    ~LeaderSyncStateQueryResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderSyncStateQueryResponse&
    operator=(const LeaderSyncStateQueryResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderSyncStateQueryResponse&
    operator=(LeaderSyncStateQueryResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "LeaderMessageSequence"
    /// attribute of this object.
    LeaderMessageSequence& leaderMessageSequence();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "LeaderMessageSequence"
    /// attribute of this object.
    const LeaderMessageSequence& leaderMessageSequence() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderSyncStateQueryResponse& lhs,
                       const LeaderSyncStateQueryResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderSyncStateQueryResponse& lhs,
                       const LeaderSyncStateQueryResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                       stream,
                                const LeaderSyncStateQueryResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderSyncStateQueryResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::LeaderSyncStateQueryResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderSyncStateQueryResponse)

namespace bmqp_ctrlmsg {

// ========================
// class NodeStatusAdvisory
// ========================

/// This type represents a one way message sent by a node to its peers
/// whenever its status changes, as it deemed by the node itself.
class NodeStatusAdvisory {
    // INSTANCE DATA
    NodeStatus::Value d_status;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_STATUS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_STATUS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `NodeStatusAdvisory` having the default
    /// value.
    NodeStatusAdvisory();

    /// Create an object of type `NodeStatusAdvisory` having the value of
    /// the specified `original` object.
    NodeStatusAdvisory(const NodeStatusAdvisory& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `NodeStatusAdvisory` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    NodeStatusAdvisory(NodeStatusAdvisory&& original) = default;
#endif

    /// Destroy this object.
    ~NodeStatusAdvisory();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    NodeStatusAdvisory& operator=(const NodeStatusAdvisory& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    NodeStatusAdvisory& operator=(NodeStatusAdvisory&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Status" attribute of this
    /// object.
    NodeStatus::Value& status();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Status" attribute of this
    /// object.
    NodeStatus::Value status() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const NodeStatusAdvisory& lhs,
                       const NodeStatusAdvisory& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const NodeStatusAdvisory& lhs,
                       const NodeStatusAdvisory& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&             stream,
                                const NodeStatusAdvisory& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `NodeStatusAdvisory`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::NodeStatusAdvisory& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::NodeStatusAdvisory)

namespace bmqp_ctrlmsg {

// ==============================
// class PartitionPrimaryAdvisory
// ==============================

/// This type represents a one way message sent by the leader to all
/// followers with a mapping of partition -> primary node, and other
/// relevant infomration.
class PartitionPrimaryAdvisory {
    // INSTANCE DATA
    bsl::vector<PartitionPrimaryInfo> d_partitions;
    LeaderMessageSequence             d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0, ATTRIBUTE_ID_PARTITIONS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0,
        ATTRIBUTE_INDEX_PARTITIONS      = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionPrimaryAdvisory` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit PartitionPrimaryAdvisory(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `PartitionPrimaryAdvisory` having the value
    /// of the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    PartitionPrimaryAdvisory(const PartitionPrimaryAdvisory& original,
                             bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionPrimaryAdvisory` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    PartitionPrimaryAdvisory(PartitionPrimaryAdvisory&& original) noexcept;

    /// Create an object of type `PartitionPrimaryAdvisory` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    PartitionPrimaryAdvisory(PartitionPrimaryAdvisory&& original,
                             bslma::Allocator*          basicAllocator);
#endif

    /// Destroy this object.
    ~PartitionPrimaryAdvisory();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionPrimaryAdvisory& operator=(const PartitionPrimaryAdvisory& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionPrimaryAdvisory& operator=(PartitionPrimaryAdvisory&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    LeaderMessageSequence& sequenceNumber();

    /// Return a reference to the modifiable "Partitions" attribute of this
    /// object.
    bsl::vector<PartitionPrimaryInfo>& partitions();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const LeaderMessageSequence& sequenceNumber() const;

    /// Return a reference to the non-modifiable "Partitions" attribute of
    /// this object.
    const bsl::vector<PartitionPrimaryInfo>& partitions() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionPrimaryAdvisory& lhs,
                       const PartitionPrimaryAdvisory& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionPrimaryAdvisory& lhs,
                       const PartitionPrimaryAdvisory& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                   stream,
                                const PartitionPrimaryAdvisory& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionPrimaryAdvisory`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                               hashAlg,
                const bmqp_ctrlmsg::PartitionPrimaryAdvisory& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionPrimaryAdvisory)

namespace bmqp_ctrlmsg {

// =========================
// class PrimaryStateRequest
// =========================

/// This type represents a request sent to the primary by a replica to ask
/// for primary's sequence number.  The replica also sends it own sequence
/// number as part of this request.
/// partitionId:    partition id for corresponding partition.
/// sequenceNumber: Replica's sequence number for corresponding partition.
class PrimaryStateRequest {
    // INSTANCE DATA
    PartitionSequenceNumber d_sequenceNumber;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PrimaryStateRequest` having the default
    /// value.
    PrimaryStateRequest();

    /// Create an object of type `PrimaryStateRequest` having the value of
    /// the specified `original` object.
    PrimaryStateRequest(const PrimaryStateRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PrimaryStateRequest` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    PrimaryStateRequest(PrimaryStateRequest&& original) = default;
#endif

    /// Destroy this object.
    ~PrimaryStateRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PrimaryStateRequest& operator=(const PrimaryStateRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PrimaryStateRequest& operator=(PrimaryStateRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    PartitionSequenceNumber& sequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const PartitionSequenceNumber& sequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PrimaryStateRequest& lhs,
                       const PrimaryStateRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PrimaryStateRequest& lhs,
                       const PrimaryStateRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const PrimaryStateRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PrimaryStateRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::PrimaryStateRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PrimaryStateRequest)

namespace bmqp_ctrlmsg {

// ==========================
// class PrimaryStateResponse
// ==========================

/// This type represents a response sent by a primary to the replica along
/// with its sequence number.
/// partitionId:    partition id for corresponding partition.
/// sequenceNumber: Primary's sequence number for corresponding partition.
class PrimaryStateResponse {
    // INSTANCE DATA
    PartitionSequenceNumber d_sequenceNumber;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PrimaryStateResponse` having the default
    /// value.
    PrimaryStateResponse();

    /// Create an object of type `PrimaryStateResponse` having the value of
    /// the specified `original` object.
    PrimaryStateResponse(const PrimaryStateResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PrimaryStateResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    PrimaryStateResponse(PrimaryStateResponse&& original) = default;
#endif

    /// Destroy this object.
    ~PrimaryStateResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PrimaryStateResponse& operator=(const PrimaryStateResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PrimaryStateResponse& operator=(PrimaryStateResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    PartitionSequenceNumber& sequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const PartitionSequenceNumber& sequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PrimaryStateResponse& lhs,
                       const PrimaryStateResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PrimaryStateResponse& lhs,
                       const PrimaryStateResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const PrimaryStateResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PrimaryStateResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::PrimaryStateResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PrimaryStateResponse)

namespace bmqp_ctrlmsg {

// ===========================
// class PrimaryStatusAdvisory
// ===========================

/// This type represents a message sent by a primary node to the replicas
/// whenever primary's status changes.
/// partitionId..: The corresponding partitionId status.......: Status of
/// the query
class PrimaryStatusAdvisory {
    // INSTANCE DATA
    unsigned int         d_primaryLeaseId;
    int                  d_partitionId;
    PrimaryStatus::Value d_status;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID     = 0,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_ID_STATUS           = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID     = 0,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_INDEX_STATUS           = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const PrimaryStatus::Value DEFAULT_INITIALIZER_STATUS;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PrimaryStatusAdvisory` having the default
    /// value.
    PrimaryStatusAdvisory();

    /// Create an object of type `PrimaryStatusAdvisory` having the value of
    /// the specified `original` object.
    PrimaryStatusAdvisory(const PrimaryStatusAdvisory& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PrimaryStatusAdvisory` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    PrimaryStatusAdvisory(PrimaryStatusAdvisory&& original) = default;
#endif

    /// Destroy this object.
    ~PrimaryStatusAdvisory();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PrimaryStatusAdvisory& operator=(const PrimaryStatusAdvisory& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PrimaryStatusAdvisory& operator=(PrimaryStatusAdvisory&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "PrimaryLeaseId" attribute of
    /// this object.
    unsigned int& primaryLeaseId();

    /// Return a reference to the modifiable "Status" attribute of this
    /// object.
    PrimaryStatus::Value& status();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "PrimaryLeaseId" attribute
    /// of this object.
    unsigned int primaryLeaseId() const;

    /// Return a reference to the non-modifiable "Status" attribute of this
    /// object.
    PrimaryStatus::Value status() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PrimaryStatusAdvisory& lhs,
                       const PrimaryStatusAdvisory& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PrimaryStatusAdvisory& lhs,
                       const PrimaryStatusAdvisory& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                stream,
                                const PrimaryStatusAdvisory& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PrimaryStatusAdvisory`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                            hashAlg,
                const bmqp_ctrlmsg::PrimaryStatusAdvisory& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PrimaryStatusAdvisory)

namespace bmqp_ctrlmsg {

// ===========================
// class QueueHandleParameters
// ===========================

/// This complex type contains various parameters required by an upstream
/// node to create a queue handle for the requester.
/// uri........: URI of the queue to open qId........: id that will be used
/// to reference this queue subIdInfo..: Optional SubQueueId info,
/// applicable if requester is a fanout consumer flags......: flags to use
/// when opening the queue readCount..: the number of `downstream` reader
/// clients aggregated in this open queue request writeCount.: the number of
/// `downstream` writer clients aggregated in this open queue request
/// adminCount.: the number of `downstream` admin clients aggregated in this
/// open queue request
class QueueHandleParameters {
    // INSTANCE DATA
    bsls::Types::Uint64                 d_flags;
    bsl::string                         d_uri;
    bdlb::NullableValue<SubQueueIdInfo> d_subIdInfo;
    unsigned int                        d_qId;
    int                                 d_readCount;
    int                                 d_writeCount;
    int                                 d_adminCount;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_URI         = 0,
        ATTRIBUTE_ID_Q_ID        = 1,
        ATTRIBUTE_ID_SUB_ID_INFO = 2,
        ATTRIBUTE_ID_FLAGS       = 3,
        ATTRIBUTE_ID_READ_COUNT  = 4,
        ATTRIBUTE_ID_WRITE_COUNT = 5,
        ATTRIBUTE_ID_ADMIN_COUNT = 6
    };

    enum { NUM_ATTRIBUTES = 7 };

    enum {
        ATTRIBUTE_INDEX_URI         = 0,
        ATTRIBUTE_INDEX_Q_ID        = 1,
        ATTRIBUTE_INDEX_SUB_ID_INFO = 2,
        ATTRIBUTE_INDEX_FLAGS       = 3,
        ATTRIBUTE_INDEX_READ_COUNT  = 4,
        ATTRIBUTE_INDEX_WRITE_COUNT = 5,
        ATTRIBUTE_INDEX_ADMIN_COUNT = 6
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_READ_COUNT;

    static const int DEFAULT_INITIALIZER_WRITE_COUNT;

    static const int DEFAULT_INITIALIZER_ADMIN_COUNT;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueHandleParameters` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit QueueHandleParameters(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueHandleParameters` having the value of
    /// the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueHandleParameters(const QueueHandleParameters& original,
                          bslma::Allocator*            basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueHandleParameters` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    QueueHandleParameters(QueueHandleParameters&& original) noexcept;

    /// Create an object of type `QueueHandleParameters` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    QueueHandleParameters(QueueHandleParameters&& original,
                          bslma::Allocator*       basicAllocator);
#endif

    /// Destroy this object.
    ~QueueHandleParameters();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueHandleParameters& operator=(const QueueHandleParameters& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueHandleParameters& operator=(QueueHandleParameters&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Uri" attribute of this object.
    bsl::string& uri();

    /// Return a reference to the modifiable "QId" attribute of this object.
    unsigned int& qId();

    /// Return a reference to the modifiable "SubIdInfo" attribute of this
    /// object.
    bdlb::NullableValue<SubQueueIdInfo>& subIdInfo();

    /// Return a reference to the modifiable "Flags" attribute of this
    /// object.
    bsls::Types::Uint64& flags();

    /// Return a reference to the modifiable "ReadCount" attribute of this
    /// object.
    int& readCount();

    /// Return a reference to the modifiable "WriteCount" attribute of this
    /// object.
    int& writeCount();

    /// Return a reference to the modifiable "AdminCount" attribute of this
    /// object.
    int& adminCount();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Uri" attribute of this
    /// object.
    const bsl::string& uri() const;

    /// Return a reference to the non-modifiable "QId" attribute of this
    /// object.
    unsigned int qId() const;

    /// Return a reference to the non-modifiable "SubIdInfo" attribute of
    /// this object.
    const bdlb::NullableValue<SubQueueIdInfo>& subIdInfo() const;

    /// Return a reference to the non-modifiable "Flags" attribute of this
    /// object.
    bsls::Types::Uint64 flags() const;

    /// Return a reference to the non-modifiable "ReadCount" attribute of
    /// this object.
    int readCount() const;

    /// Return a reference to the non-modifiable "WriteCount" attribute of
    /// this object.
    int writeCount() const;

    /// Return a reference to the non-modifiable "AdminCount" attribute of
    /// this object.
    int adminCount() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueHandleParameters& lhs,
                       const QueueHandleParameters& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueHandleParameters& lhs,
                       const QueueHandleParameters& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                stream,
                                const QueueHandleParameters& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueHandleParameters`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                            hashAlg,
                const bmqp_ctrlmsg::QueueHandleParameters& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueHandleParameters)

namespace bmqp_ctrlmsg {

// ===============
// class QueueInfo
// ===============

/// This type represents a queue assignment, that is the key and partitionId
/// assigned to a given URI.
class QueueInfo {
    // INSTANCE DATA
    bsl::vector<char>      d_key;
    bsl::vector<AppIdInfo> d_appIds;
    bsl::string            d_uri;
    int                    d_partitionId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_URI          = 0,
        ATTRIBUTE_ID_KEY          = 1,
        ATTRIBUTE_ID_PARTITION_ID = 2,
        ATTRIBUTE_ID_APP_IDS      = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_URI          = 0,
        ATTRIBUTE_INDEX_KEY          = 1,
        ATTRIBUTE_INDEX_PARTITION_ID = 2,
        ATTRIBUTE_INDEX_APP_IDS      = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueInfo` having the default value.  Use
    /// the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit QueueInfo(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueInfo` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueInfo(const QueueInfo& original, bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    QueueInfo(QueueInfo&& original) noexcept;

    /// Create an object of type `QueueInfo` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    QueueInfo(QueueInfo&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~QueueInfo();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueInfo& operator=(const QueueInfo& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueInfo& operator=(QueueInfo&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Uri" attribute of this object.
    bsl::string& uri();

    /// Return a reference to the modifiable "Key" attribute of this object.
    bsl::vector<char>& key();

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "AppIds" attribute of this
    /// object.
    bsl::vector<AppIdInfo>& appIds();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Uri" attribute of this
    /// object.
    const bsl::string& uri() const;

    /// Return a reference to the non-modifiable "Key" attribute of this
    /// object.
    const bsl::vector<char>& key() const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "AppIds" attribute of this
    /// object.
    const bsl::vector<AppIdInfo>& appIds() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueInfo& lhs, const QueueInfo& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueInfo& lhs, const QueueInfo& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const QueueInfo& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueInfo`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                hashAlg,
                const bmqp_ctrlmsg::QueueInfo& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueInfo)

namespace bmqp_ctrlmsg {

// =====================
// class QueueInfoUpdate
// =====================

/// This type represents a queue update, that is the added or removed appIds
/// for a given URI.  In the case of (un)registering appIds for a domain
/// without any queues present, the `domain` field will be populated whereas
/// the `uri`, `key` and `partitionId` will all be set to null/invalid.
class QueueInfoUpdate {
    // INSTANCE DATA
    bsl::vector<char>      d_key;
    bsl::vector<AppIdInfo> d_addedAppIds;
    bsl::vector<AppIdInfo> d_removedAppIds;
    bsl::string            d_uri;
    bsl::string            d_domain;
    int                    d_partitionId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_URI             = 0,
        ATTRIBUTE_ID_KEY             = 1,
        ATTRIBUTE_ID_PARTITION_ID    = 2,
        ATTRIBUTE_ID_ADDED_APP_IDS   = 3,
        ATTRIBUTE_ID_REMOVED_APP_IDS = 4,
        ATTRIBUTE_ID_DOMAIN          = 5
    };

    enum { NUM_ATTRIBUTES = 6 };

    enum {
        ATTRIBUTE_INDEX_URI             = 0,
        ATTRIBUTE_INDEX_KEY             = 1,
        ATTRIBUTE_INDEX_PARTITION_ID    = 2,
        ATTRIBUTE_INDEX_ADDED_APP_IDS   = 3,
        ATTRIBUTE_INDEX_REMOVED_APP_IDS = 4,
        ATTRIBUTE_INDEX_DOMAIN          = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueInfoUpdate` having the default value.
    ///  Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit QueueInfoUpdate(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueInfoUpdate` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueInfoUpdate(const QueueInfoUpdate& original,
                    bslma::Allocator*      basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueInfoUpdate` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    QueueInfoUpdate(QueueInfoUpdate&& original) noexcept;

    /// Create an object of type `QueueInfoUpdate` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    QueueInfoUpdate(QueueInfoUpdate&& original,
                    bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~QueueInfoUpdate();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueInfoUpdate& operator=(const QueueInfoUpdate& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueInfoUpdate& operator=(QueueInfoUpdate&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Uri" attribute of this object.
    bsl::string& uri();

    /// Return a reference to the modifiable "Key" attribute of this object.
    bsl::vector<char>& key();

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "AddedAppIds" attribute of this
    /// object.
    bsl::vector<AppIdInfo>& addedAppIds();

    /// Return a reference to the modifiable "RemovedAppIds" attribute of
    /// this object.
    bsl::vector<AppIdInfo>& removedAppIds();

    /// Return a reference to the modifiable "Domain" attribute of this
    /// object.
    bsl::string& domain();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Uri" attribute of this
    /// object.
    const bsl::string& uri() const;

    /// Return a reference to the non-modifiable "Key" attribute of this
    /// object.
    const bsl::vector<char>& key() const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "AddedAppIds" attribute of
    /// this object.
    const bsl::vector<AppIdInfo>& addedAppIds() const;

    /// Return a reference to the non-modifiable "RemovedAppIds" attribute
    /// of this object.
    const bsl::vector<AppIdInfo>& removedAppIds() const;

    /// Return a reference to the non-modifiable "Domain" attribute of this
    /// object.
    const bsl::string& domain() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueInfoUpdate& lhs, const QueueInfoUpdate& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueInfoUpdate& lhs, const QueueInfoUpdate& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&          stream,
                                const QueueInfoUpdate& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueInfoUpdate`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                      hashAlg,
                const bmqp_ctrlmsg::QueueInfoUpdate& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueInfoUpdate)

namespace bmqp_ctrlmsg {

// ===========================
// class QueueStreamParameters
// ===========================

/// This complex type contains various parameters required by an upstream
/// node to configure a queue handle (i.e., a "stream") that has already
/// been created.
/// subIdInfo..............: Optional subQueueId identifying the stream in
/// case downstream node represents a fanout consumer
/// maxUnconfirmedMessages.: maximum number of outstanding delivered but
/// pending confirmation from the client maxUnconfirmedBytes....: maximum
/// cumulated bytes of all outstanding delivered but pending confirmation
/// messages from the client consumerPriority.......: priority as advertised
/// by the downstream node for this stream consumerPriorityCount..: weight
/// of the stream as advertised by the downstream node, having
/// above-mentioned consumer priority
class QueueStreamParameters {
    // INSTANCE DATA
    bsls::Types::Int64                  d_maxUnconfirmedMessages;
    bsls::Types::Int64                  d_maxUnconfirmedBytes;
    bdlb::NullableValue<SubQueueIdInfo> d_subIdInfo;
    int                                 d_consumerPriority;
    int                                 d_consumerPriorityCount;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SUB_ID_INFO              = 0,
        ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES = 1,
        ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES    = 2,
        ATTRIBUTE_ID_CONSUMER_PRIORITY        = 3,
        ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT  = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_SUB_ID_INFO              = 0,
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES = 1,
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES    = 2,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY        = 3,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT  = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bsls::Types::Int64
        DEFAULT_INITIALIZER_MAX_UNCONFIRMED_MESSAGES;

    static const bsls::Types::Int64 DEFAULT_INITIALIZER_MAX_UNCONFIRMED_BYTES;

    static const int DEFAULT_INITIALIZER_CONSUMER_PRIORITY;

    static const int DEFAULT_INITIALIZER_CONSUMER_PRIORITY_COUNT;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueStreamParameters` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit QueueStreamParameters(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueStreamParameters` having the value of
    /// the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueStreamParameters(const QueueStreamParameters& original,
                          bslma::Allocator*            basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueStreamParameters` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    QueueStreamParameters(QueueStreamParameters&& original) noexcept;

    /// Create an object of type `QueueStreamParameters` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    QueueStreamParameters(QueueStreamParameters&& original,
                          bslma::Allocator*       basicAllocator);
#endif

    /// Destroy this object.
    ~QueueStreamParameters();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueStreamParameters& operator=(const QueueStreamParameters& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueStreamParameters& operator=(QueueStreamParameters&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SubIdInfo" attribute of this
    /// object.
    bdlb::NullableValue<SubQueueIdInfo>& subIdInfo();

    /// Return a reference to the modifiable "MaxUnconfirmedMessages"
    /// attribute of this object.
    bsls::Types::Int64& maxUnconfirmedMessages();

    /// Return a reference to the modifiable "MaxUnconfirmedBytes" attribute
    /// of this object.
    bsls::Types::Int64& maxUnconfirmedBytes();

    /// Return a reference to the modifiable "ConsumerPriority" attribute of
    /// this object.
    int& consumerPriority();

    /// Return a reference to the modifiable "ConsumerPriorityCount"
    /// attribute of this object.
    int& consumerPriorityCount();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SubIdInfo" attribute of
    /// this object.
    const bdlb::NullableValue<SubQueueIdInfo>& subIdInfo() const;

    /// Return a reference to the non-modifiable "MaxUnconfirmedMessages"
    /// attribute of this object.
    bsls::Types::Int64 maxUnconfirmedMessages() const;

    /// Return a reference to the non-modifiable "MaxUnconfirmedBytes"
    /// attribute of this object.
    bsls::Types::Int64 maxUnconfirmedBytes() const;

    /// Return a reference to the non-modifiable "ConsumerPriority"
    /// attribute of this object.
    int consumerPriority() const;

    /// Return a reference to the non-modifiable "ConsumerPriorityCount"
    /// attribute of this object.
    int consumerPriorityCount() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueStreamParameters& lhs,
                       const QueueStreamParameters& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueStreamParameters& lhs,
                       const QueueStreamParameters& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                stream,
                                const QueueStreamParameters& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueStreamParameters`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                            hashAlg,
                const bmqp_ctrlmsg::QueueStreamParameters& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueStreamParameters)

namespace bmqp_ctrlmsg {

// =========================
// class RegistrationRequest
// =========================

/// This type represents a request sent by a follower to the leader to
/// register its leader-sequence number.
/// sequenceNumber..: Follower's leader-sequence number
class RegistrationRequest {
    // INSTANCE DATA
    LeaderMessageSequence d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `RegistrationRequest` having the default
    /// value.
    RegistrationRequest();

    /// Create an object of type `RegistrationRequest` having the value of
    /// the specified `original` object.
    RegistrationRequest(const RegistrationRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `RegistrationRequest` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    RegistrationRequest(RegistrationRequest&& original) = default;
#endif

    /// Destroy this object.
    ~RegistrationRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    RegistrationRequest& operator=(const RegistrationRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    RegistrationRequest& operator=(RegistrationRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    LeaderMessageSequence& sequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const LeaderMessageSequence& sequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const RegistrationRequest& lhs,
                       const RegistrationRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const RegistrationRequest& lhs,
                       const RegistrationRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const RegistrationRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `RegistrationRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::RegistrationRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::RegistrationRequest)

namespace bmqp_ctrlmsg {

// ========================
// class ReplicaDataRequest
// ========================

/// This type represents a request sent to the replica by the primary to
/// start the synchronization of data.
/// replicaDataType:     type of request i.e.  PULL, PUSH or DROP for
/// corresponding partition.  partitionId:         partition id for
/// corresponding partition.  beginSequenceNumber: Primary's begin sequence
/// number for corresponding partition for corresponding data chunks.
/// endSequenceNumber:   Primary's end sequence number for corresponding
/// partition for corresponding data chunks.
class ReplicaDataRequest {
    // INSTANCE DATA
    PartitionSequenceNumber d_beginSequenceNumber;
    PartitionSequenceNumber d_endSequenceNumber;
    int                     d_partitionId;
    ReplicaDataType::Value  d_replicaDataType;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_REPLICA_DATA_TYPE     = 0,
        ATTRIBUTE_ID_PARTITION_ID          = 1,
        ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER = 2,
        ATTRIBUTE_ID_END_SEQUENCE_NUMBER   = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_REPLICA_DATA_TYPE     = 0,
        ATTRIBUTE_INDEX_PARTITION_ID          = 1,
        ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER = 2,
        ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER   = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ReplicaDataRequest` having the default
    /// value.
    ReplicaDataRequest();

    /// Create an object of type `ReplicaDataRequest` having the value of
    /// the specified `original` object.
    ReplicaDataRequest(const ReplicaDataRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ReplicaDataRequest` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ReplicaDataRequest(ReplicaDataRequest&& original) = default;
#endif

    /// Destroy this object.
    ~ReplicaDataRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ReplicaDataRequest& operator=(const ReplicaDataRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ReplicaDataRequest& operator=(ReplicaDataRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ReplicaDataType" attribute of
    /// this object.
    ReplicaDataType::Value& replicaDataType();

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "BeginSequenceNumber" attribute
    /// of this object.
    PartitionSequenceNumber& beginSequenceNumber();

    /// Return a reference to the modifiable "EndSequenceNumber" attribute
    /// of this object.
    PartitionSequenceNumber& endSequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ReplicaDataType" attribute
    /// of this object.
    ReplicaDataType::Value replicaDataType() const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "BeginSequenceNumber"
    /// attribute of this object.
    const PartitionSequenceNumber& beginSequenceNumber() const;

    /// Return a reference to the non-modifiable "EndSequenceNumber"
    /// attribute of this object.
    const PartitionSequenceNumber& endSequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ReplicaDataRequest& lhs,
                       const ReplicaDataRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ReplicaDataRequest& lhs,
                       const ReplicaDataRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&             stream,
                                const ReplicaDataRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ReplicaDataRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::ReplicaDataRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReplicaDataRequest)

namespace bmqp_ctrlmsg {

// =========================
// class ReplicaDataResponse
// =========================

/// This type represents a response sent by a replica to the primary for the
/// data synchronization request received by it.
/// replicaDataType:     type of request received i.e.  PULL, PUSH or DROP
/// for corresponding partition.  Note, this field will be set as per the
/// request received and the primary purpose of sending this field back in
/// response is for debugging and sanity checking.  partitionId:
/// partition id for corresponding partition.  beginSequenceNumber:
/// Replica's begin sequence number for corresponding partition for
/// corresponding data chunks.  endSequenceNumber:   Replica's end sequence
/// number for corresponding partition for corresponding data chunks.
class ReplicaDataResponse {
    // INSTANCE DATA
    PartitionSequenceNumber d_beginSequenceNumber;
    PartitionSequenceNumber d_endSequenceNumber;
    int                     d_partitionId;
    ReplicaDataType::Value  d_replicaDataType;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_REPLICA_DATA_TYPE     = 0,
        ATTRIBUTE_ID_PARTITION_ID          = 1,
        ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER = 2,
        ATTRIBUTE_ID_END_SEQUENCE_NUMBER   = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_REPLICA_DATA_TYPE     = 0,
        ATTRIBUTE_INDEX_PARTITION_ID          = 1,
        ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER = 2,
        ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER   = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ReplicaDataResponse` having the default
    /// value.
    ReplicaDataResponse();

    /// Create an object of type `ReplicaDataResponse` having the value of
    /// the specified `original` object.
    ReplicaDataResponse(const ReplicaDataResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ReplicaDataResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ReplicaDataResponse(ReplicaDataResponse&& original) = default;
#endif

    /// Destroy this object.
    ~ReplicaDataResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ReplicaDataResponse& operator=(const ReplicaDataResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ReplicaDataResponse& operator=(ReplicaDataResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ReplicaDataType" attribute of
    /// this object.
    ReplicaDataType::Value& replicaDataType();

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "BeginSequenceNumber" attribute
    /// of this object.
    PartitionSequenceNumber& beginSequenceNumber();

    /// Return a reference to the modifiable "EndSequenceNumber" attribute
    /// of this object.
    PartitionSequenceNumber& endSequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ReplicaDataType" attribute
    /// of this object.
    ReplicaDataType::Value replicaDataType() const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "BeginSequenceNumber"
    /// attribute of this object.
    const PartitionSequenceNumber& beginSequenceNumber() const;

    /// Return a reference to the non-modifiable "EndSequenceNumber"
    /// attribute of this object.
    const PartitionSequenceNumber& endSequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ReplicaDataResponse& lhs,
                       const ReplicaDataResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ReplicaDataResponse& lhs,
                       const ReplicaDataResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const ReplicaDataResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ReplicaDataResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::ReplicaDataResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReplicaDataResponse)

namespace bmqp_ctrlmsg {

// =========================
// class ReplicaStateRequest
// =========================

/// This type represents a request sent to the replica by the primary to ask
/// for replica's sequence number.  The primary also sends its own sequence
/// number as part of this request.
/// partitionId:    partition id for corresponding partition.
/// sequenceNumber: Primary's sequence number for corresponding partition.
class ReplicaStateRequest {
    // INSTANCE DATA
    PartitionSequenceNumber d_sequenceNumber;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ReplicaStateRequest` having the default
    /// value.
    ReplicaStateRequest();

    /// Create an object of type `ReplicaStateRequest` having the value of
    /// the specified `original` object.
    ReplicaStateRequest(const ReplicaStateRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ReplicaStateRequest` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ReplicaStateRequest(ReplicaStateRequest&& original) = default;
#endif

    /// Destroy this object.
    ~ReplicaStateRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ReplicaStateRequest& operator=(const ReplicaStateRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ReplicaStateRequest& operator=(ReplicaStateRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    PartitionSequenceNumber& sequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const PartitionSequenceNumber& sequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ReplicaStateRequest& lhs,
                       const ReplicaStateRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ReplicaStateRequest& lhs,
                       const ReplicaStateRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const ReplicaStateRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ReplicaStateRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::ReplicaStateRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReplicaStateRequest)

namespace bmqp_ctrlmsg {

// ==========================
// class ReplicaStateResponse
// ==========================

/// This type represents a response sent by a replica to the primary along
/// with its sequence number.
/// partitionId:    partition id for corresponding partition.
/// sequenceNumber: Replica's sequence number for corresponding partition.
class ReplicaStateResponse {
    // INSTANCE DATA
    PartitionSequenceNumber d_sequenceNumber;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ReplicaStateResponse` having the default
    /// value.
    ReplicaStateResponse();

    /// Create an object of type `ReplicaStateResponse` having the value of
    /// the specified `original` object.
    ReplicaStateResponse(const ReplicaStateResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ReplicaStateResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ReplicaStateResponse(ReplicaStateResponse&& original) = default;
#endif

    /// Destroy this object.
    ~ReplicaStateResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ReplicaStateResponse& operator=(const ReplicaStateResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ReplicaStateResponse& operator=(ReplicaStateResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    PartitionSequenceNumber& sequenceNumber();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const PartitionSequenceNumber& sequenceNumber() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ReplicaStateResponse& lhs,
                       const ReplicaStateResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ReplicaStateResponse& lhs,
                       const ReplicaStateResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const ReplicaStateResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ReplicaStateResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ReplicaStateResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ReplicaStateResponse)

namespace bmqp_ctrlmsg {

// =============================
// class StateNotificationChoice
// =============================

class StateNotificationChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<LeaderPassive> d_leaderPassive;
    };

    int d_selectionId;

  public:
    // TYPES

    enum { SELECTION_ID_UNDEFINED = -1, SELECTION_ID_LEADER_PASSIVE = 0 };

    enum { NUM_SELECTIONS = 1 };

    enum { SELECTION_INDEX_LEADER_PASSIVE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS

    /// Return selection information for the selection indicated by the
    /// specified `id` if the selection exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);

    /// Return selection information for the selection indicated by the
    /// specified `name` of the specified `nameLength` if the selection
    /// exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `StateNotificationChoice` having the
    /// default value.
    StateNotificationChoice();

    /// Create an object of type `StateNotificationChoice` having the value
    /// of the specified `original` object.
    StateNotificationChoice(const StateNotificationChoice& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `StateNotificationChoice` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    StateNotificationChoice(StateNotificationChoice&& original) noexcept;
#endif

    /// Destroy this object.
    ~StateNotificationChoice();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    StateNotificationChoice& operator=(const StateNotificationChoice& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    StateNotificationChoice& operator=(StateNotificationChoice&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon default
    /// construction).
    void reset();

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `selectionId`.  Return 0 on success, and
    /// non-zero value otherwise (i.e., the selection is not found).
    int makeSelection(int selectionId);

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `name` of the specified `nameLength`.
    /// Return 0 on success, and non-zero value otherwise (i.e., the
    /// selection is not found).
    int makeSelection(const char* name, int nameLength);

    LeaderPassive& makeLeaderPassive();
    LeaderPassive& makeLeaderPassive(const LeaderPassive& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderPassive& makeLeaderPassive(LeaderPassive&& value);
#endif
    // Set the value of this object to be a "LeaderPassive" value.
    // Optionally specify the 'value' of the "LeaderPassive".  If 'value'
    // is not specified, the default "LeaderPassive" value is used.

    /// Invoke the specified `manipulator` on the address of the modifiable
    /// selection, supplying `manipulator` with the corresponding selection
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if this object has a defined selection,
    /// and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateSelection(MANIPULATOR& manipulator);

    /// Return a reference to the modifiable "LeaderPassive" selection of
    /// this object if "LeaderPassive" is the current selection.  The
    /// behavior is undefined unless "LeaderPassive" is the selection of
    /// this object.
    LeaderPassive& leaderPassive();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Return the id of the current selection if the selection is defined,
    /// and -1 otherwise.
    int selectionId() const;

    /// Invoke the specified `accessor` on the non-modifiable selection,
    /// supplying `accessor` with the corresponding selection information
    /// structure.  Return the value returned from the invocation of
    /// `accessor` if this object has a defined selection, and -1 otherwise.
    template <class ACCESSOR>
    int accessSelection(ACCESSOR& accessor) const;

    /// Return a reference to the non-modifiable "LeaderPassive" selection
    /// of this object if "LeaderPassive" is the current selection.  The
    /// behavior is undefined unless "LeaderPassive" is the selection of
    /// this object.
    const LeaderPassive& leaderPassive() const;

    /// Return `true` if the value of this object is a "LeaderPassive"
    /// value, and return `false` otherwise.
    bool isLeaderPassiveValue() const;

    /// Return `true` if the value of this object is undefined, and `false`
    /// otherwise.
    bool isUndefinedValue() const;

    /// Return the symbolic name of the current selection of this object.
    const char* selectionName() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` objects have the same
/// value, and `false` otherwise.  Two `StateNotificationChoice` objects have
/// the same value if either the selections in both objects have the same ids
/// and the same values, or both selections are undefined.
inline bool operator==(const StateNotificationChoice& lhs,
                       const StateNotificationChoice& rhs);

/// Return `true` if the specified `lhs` and `rhs` objects do not have the
/// same values, as determined by `operator==`, and `false` otherwise.
inline bool operator!=(const StateNotificationChoice& lhs,
                       const StateNotificationChoice& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                  stream,
                                const StateNotificationChoice& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `StateNotificationChoice`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::StateNotificationChoice& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StateNotificationChoice)

namespace bmqp_ctrlmsg {

// ============
// class Status
// ============

/// Generic type to represent a status.
/// category.: the category of the status code.....: an integer value
/// representing the error message..: an optional string describing the
/// error
class Status {
    // INSTANCE DATA
    bsl::string           d_message;
    int                   d_code;
    StatusCategory::Value d_category;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CATEGORY = 0,
        ATTRIBUTE_ID_CODE     = 1,
        ATTRIBUTE_ID_MESSAGE  = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_CATEGORY = 0,
        ATTRIBUTE_INDEX_CODE     = 1,
        ATTRIBUTE_INDEX_MESSAGE  = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const char DEFAULT_INITIALIZER_MESSAGE[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `Status` having the default value.  Use the
    /// optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit Status(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `Status` having the value of the specified
    /// `original` object.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    Status(const Status& original, bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `Status` having the value of the specified
    /// `original` object.  After performing this action, the `original`
    /// object will be left in a valid, but unspecified state.
    Status(Status&& original) noexcept;

    /// Create an object of type `Status` having the value of the specified
    /// `original` object.  After performing this action, the `original`
    /// object will be left in a valid, but unspecified state.  Use the
    /// optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    Status(Status&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~Status();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    Status& operator=(const Status& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    Status& operator=(Status&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Category" attribute of this
    /// object.
    StatusCategory::Value& category();

    /// Return a reference to the modifiable "Code" attribute of this
    /// object.
    int& code();

    /// Return a reference to the modifiable "Message" attribute of this
    /// object.
    bsl::string& message();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Category" attribute of
    /// this object.
    StatusCategory::Value category() const;

    /// Return a reference to the non-modifiable "Code" attribute of this
    /// object.
    int code() const;

    /// Return a reference to the non-modifiable "Message" attribute of this
    /// object.
    const bsl::string& message() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const Status& lhs, const Status& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const Status& lhs, const Status& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const Status& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `Status`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM& hashAlg, const bmqp_ctrlmsg::Status& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::Status)

namespace bmqp_ctrlmsg {

// =========================
// class StorageSyncResponse
// =========================

/// This type represents the message sent by the peer node in response to a
/// storage sync request.
/// partitionId..............: The corresponding partitionId
/// storageSyncResponseType..: Type of storage sync response (enumeration)
/// beginSyncPoint...........: Starting sync point of the sent storage
/// endSyncPoint.............: Ending sync point of the sent storage
class StorageSyncResponse {
    // INSTANCE DATA
    SyncPoint                      d_beginSyncPoint;
    SyncPoint                      d_endSyncPoint;
    int                            d_partitionId;
    StorageSyncResponseType::Value d_storageSyncResponseType;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID               = 0,
        ATTRIBUTE_ID_STORAGE_SYNC_RESPONSE_TYPE = 1,
        ATTRIBUTE_ID_BEGIN_SYNC_POINT           = 2,
        ATTRIBUTE_ID_END_SYNC_POINT             = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID               = 0,
        ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE = 1,
        ATTRIBUTE_INDEX_BEGIN_SYNC_POINT           = 2,
        ATTRIBUTE_INDEX_END_SYNC_POINT             = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `StorageSyncResponse` having the default
    /// value.
    StorageSyncResponse();

    /// Create an object of type `StorageSyncResponse` having the value of
    /// the specified `original` object.
    StorageSyncResponse(const StorageSyncResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `StorageSyncResponse` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    StorageSyncResponse(StorageSyncResponse&& original) = default;
#endif

    /// Destroy this object.
    ~StorageSyncResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    StorageSyncResponse& operator=(const StorageSyncResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    StorageSyncResponse& operator=(StorageSyncResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "StorageSyncResponseType"
    /// attribute of this object.
    StorageSyncResponseType::Value& storageSyncResponseType();

    /// Return a reference to the modifiable "BeginSyncPoint" attribute of
    /// this object.
    SyncPoint& beginSyncPoint();

    /// Return a reference to the modifiable "EndSyncPoint" attribute of
    /// this object.
    SyncPoint& endSyncPoint();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "StorageSyncResponseType"
    /// attribute of this object.
    StorageSyncResponseType::Value storageSyncResponseType() const;

    /// Return a reference to the non-modifiable "BeginSyncPoint" attribute
    /// of this object.
    const SyncPoint& beginSyncPoint() const;

    /// Return a reference to the non-modifiable "EndSyncPoint" attribute of
    /// this object.
    const SyncPoint& endSyncPoint() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const StorageSyncResponse& lhs,
                       const StorageSyncResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const StorageSyncResponse& lhs,
                       const StorageSyncResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const StorageSyncResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `StorageSyncResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::StorageSyncResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StorageSyncResponse)

namespace bmqp_ctrlmsg {

// =========================
// class SyncPointOffsetPair
// =========================

/// A pair of SyncPt and the offset in the journal where that SyncPt
/// appears.  Note that in future, we may introduce a journal-offset field
/// in the SyncPt itself, but that could be different from the offset of
/// SyncPt itself.
class SyncPointOffsetPair {
    // INSTANCE DATA
    bsls::Types::Uint64 d_offset;
    SyncPoint           d_syncPoint;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SYNC_POINT = 0, ATTRIBUTE_ID_OFFSET = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SYNC_POINT = 0, ATTRIBUTE_INDEX_OFFSET = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `SyncPointOffsetPair` having the default
    /// value.
    SyncPointOffsetPair();

    /// Create an object of type `SyncPointOffsetPair` having the value of
    /// the specified `original` object.
    SyncPointOffsetPair(const SyncPointOffsetPair& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `SyncPointOffsetPair` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    SyncPointOffsetPair(SyncPointOffsetPair&& original) = default;
#endif

    /// Destroy this object.
    ~SyncPointOffsetPair();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    SyncPointOffsetPair& operator=(const SyncPointOffsetPair& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    SyncPointOffsetPair& operator=(SyncPointOffsetPair&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SyncPoint" attribute of this
    /// object.
    SyncPoint& syncPoint();

    /// Return a reference to the modifiable "Offset" attribute of this
    /// object.
    bsls::Types::Uint64& offset();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SyncPoint" attribute of
    /// this object.
    const SyncPoint& syncPoint() const;

    /// Return a reference to the non-modifiable "Offset" attribute of this
    /// object.
    bsls::Types::Uint64 offset() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const SyncPointOffsetPair& lhs,
                       const SyncPointOffsetPair& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const SyncPointOffsetPair& lhs,
                       const SyncPointOffsetPair& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const SyncPointOffsetPair& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `SyncPointOffsetPair`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::SyncPointOffsetPair& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::SyncPointOffsetPair)

namespace bmqp_ctrlmsg {

// ====================
// class BrokerResponse
// ====================

/// This represents the response from the broker to a `ClientIdentity`
/// message during connection negotiation.
/// result..........: the result of the negotiation protocolVersion.:
/// protocol version used by the bmqbrkr brokerVersion...: version of the
/// broker isDeprecatedSdk.: is the version of the client's SDK version
/// deprecated
class BrokerResponse {
    // INSTANCE DATA
    Status         d_result;
    ClientIdentity d_brokerIdentity;
    int            d_protocolVersion;
    int            d_brokerVersion;
    bool           d_isDeprecatedSdk;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_RESULT            = 0,
        ATTRIBUTE_ID_PROTOCOL_VERSION  = 1,
        ATTRIBUTE_ID_BROKER_VERSION    = 2,
        ATTRIBUTE_ID_IS_DEPRECATED_SDK = 3,
        ATTRIBUTE_ID_BROKER_IDENTITY   = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_RESULT            = 0,
        ATTRIBUTE_INDEX_PROTOCOL_VERSION  = 1,
        ATTRIBUTE_INDEX_BROKER_VERSION    = 2,
        ATTRIBUTE_INDEX_IS_DEPRECATED_SDK = 3,
        ATTRIBUTE_INDEX_BROKER_IDENTITY   = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bool DEFAULT_INITIALIZER_IS_DEPRECATED_SDK;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `BrokerResponse` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit BrokerResponse(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `BrokerResponse` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    BrokerResponse(const BrokerResponse& original,
                   bslma::Allocator*     basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `BrokerResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    BrokerResponse(BrokerResponse&& original) noexcept;

    /// Create an object of type `BrokerResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    BrokerResponse(BrokerResponse&&  original,
                   bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~BrokerResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    BrokerResponse& operator=(const BrokerResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    BrokerResponse& operator=(BrokerResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Result" attribute of this
    /// object.
    Status& result();

    /// Return a reference to the modifiable "ProtocolVersion" attribute of
    /// this object.
    int& protocolVersion();

    /// Return a reference to the modifiable "BrokerVersion" attribute of
    /// this object.
    int& brokerVersion();

    /// Return a reference to the modifiable "IsDeprecatedSdk" attribute of
    /// this object.
    bool& isDeprecatedSdk();

    /// Return a reference to the modifiable "BrokerIdentity" attribute of
    /// this object.
    ClientIdentity& brokerIdentity();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Result" attribute of this
    /// object.
    const Status& result() const;

    /// Return a reference to the non-modifiable "ProtocolVersion" attribute
    /// of this object.
    int protocolVersion() const;

    /// Return a reference to the non-modifiable "BrokerVersion" attribute
    /// of this object.
    int brokerVersion() const;

    /// Return a reference to the non-modifiable "IsDeprecatedSdk" attribute
    /// of this object.
    bool isDeprecatedSdk() const;

    /// Return a reference to the non-modifiable "BrokerIdentity" attribute
    /// of this object.
    const ClientIdentity& brokerIdentity() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const BrokerResponse& lhs, const BrokerResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const BrokerResponse& lhs, const BrokerResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                const BrokerResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `BrokerResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::BrokerResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::BrokerResponse)

namespace bmqp_ctrlmsg {

// ================
// class CloseQueue
// ================

/// This request contains parameters advertised by the downstream node when
/// it wants to close a queue on an upstream node.
/// handleParameters.: Queue handle parameters as advertised by the
/// downstream node isFinal..........: Flag advertising if downstream node
/// has no more clients for this queue, and upstream node is free to delete
/// the queue handle representing the downstream node
class CloseQueue {
    // INSTANCE DATA
    QueueHandleParameters d_handleParameters;
    bool                  d_isFinal;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_HANDLE_PARAMETERS = 0, ATTRIBUTE_ID_IS_FINAL = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_HANDLE_PARAMETERS = 0,
        ATTRIBUTE_INDEX_IS_FINAL          = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bool DEFAULT_INITIALIZER_IS_FINAL;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `CloseQueue` having the default value.  Use
    /// the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit CloseQueue(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `CloseQueue` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    CloseQueue(const CloseQueue& original,
               bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `CloseQueue` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    CloseQueue(CloseQueue&& original) noexcept;

    /// Create an object of type `CloseQueue` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    CloseQueue(CloseQueue&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~CloseQueue();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    CloseQueue& operator=(const CloseQueue& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    CloseQueue& operator=(CloseQueue&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "HandleParameters" attribute of
    /// this object.
    QueueHandleParameters& handleParameters();

    /// Return a reference to the modifiable "IsFinal" attribute of this
    /// object.
    bool& isFinal();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "HandleParameters"
    /// attribute of this object.
    const QueueHandleParameters& handleParameters() const;

    /// Return a reference to the non-modifiable "IsFinal" attribute of this
    /// object.
    bool isFinal() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const CloseQueue& lhs, const CloseQueue& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const CloseQueue& lhs, const CloseQueue& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const CloseQueue& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `CloseQueue`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                 hashAlg,
                const bmqp_ctrlmsg::CloseQueue& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::CloseQueue)

namespace bmqp_ctrlmsg {

// ==========================
// class ConfigureQueueStream
// ==========================

/// This request contains parameters advertised by the downstream node so
/// that upstream node can configure the stream associated with the
/// downstream node.
/// qId..............: Id identifying the queue streamParameters.:
/// Parameters for configuring the stream
class ConfigureQueueStream {
    // INSTANCE DATA
    QueueStreamParameters d_streamParameters;
    unsigned int          d_qId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_Q_ID = 0, ATTRIBUTE_ID_STREAM_PARAMETERS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_Q_ID = 0, ATTRIBUTE_INDEX_STREAM_PARAMETERS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ConfigureQueueStream` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit ConfigureQueueStream(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ConfigureQueueStream` having the value of
    /// the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ConfigureQueueStream(const ConfigureQueueStream& original,
                         bslma::Allocator*           basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ConfigureQueueStream` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ConfigureQueueStream(ConfigureQueueStream&& original) noexcept;

    /// Create an object of type `ConfigureQueueStream` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    ConfigureQueueStream(ConfigureQueueStream&& original,
                         bslma::Allocator*      basicAllocator);
#endif

    /// Destroy this object.
    ~ConfigureQueueStream();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ConfigureQueueStream& operator=(const ConfigureQueueStream& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ConfigureQueueStream& operator=(ConfigureQueueStream&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "QId" attribute of this object.
    unsigned int& qId();

    /// Return a reference to the modifiable "StreamParameters" attribute of
    /// this object.
    QueueStreamParameters& streamParameters();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "QId" attribute of this
    /// object.
    unsigned int qId() const;

    /// Return a reference to the non-modifiable "StreamParameters"
    /// attribute of this object.
    const QueueStreamParameters& streamParameters() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ConfigureQueueStream& lhs,
                       const ConfigureQueueStream& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ConfigureQueueStream& lhs,
                       const ConfigureQueueStream& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const ConfigureQueueStream& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ConfigureQueueStream`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ConfigureQueueStream& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ConfigureQueueStream)

namespace bmqp_ctrlmsg {

// ====================
// class ElectorMessage
// ====================

/// This type is the top level type for any message being sent by elector
/// component in the cluster.
/// term....: Term being proposed in the election choice..: Enumerates all
/// the different types of elector messages
class ElectorMessage {
    // INSTANCE DATA
    bsls::Types::Uint64  d_term;
    ElectorMessageChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_TERM = 0, ATTRIBUTE_ID_CHOICE = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_TERM = 0, ATTRIBUTE_INDEX_CHOICE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ElectorMessage` having the default value.
    ElectorMessage();

    /// Create an object of type `ElectorMessage` having the value of the
    /// specified `original` object.
    ElectorMessage(const ElectorMessage& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ElectorMessage` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ElectorMessage(ElectorMessage&& original) = default;
#endif

    /// Destroy this object.
    ~ElectorMessage();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ElectorMessage& operator=(const ElectorMessage& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ElectorMessage& operator=(ElectorMessage&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Term" attribute of this
    /// object.
    bsls::Types::Uint64& term();

    /// Return a reference to the modifiable "Choice" attribute of this
    /// object.
    ElectorMessageChoice& choice();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Term" attribute of this
    /// object.
    bsls::Types::Uint64 term() const;

    /// Return a reference to the non-modifiable "Choice" attribute of this
    /// object.
    const ElectorMessageChoice& choice() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ElectorMessage& lhs, const ElectorMessage& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ElectorMessage& lhs, const ElectorMessage& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                const ElectorMessage& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ElectorMessage`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::ElectorMessage& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::ElectorMessage)

namespace bmqp_ctrlmsg {

// ====================
// class LeaderAdvisory
// ====================

/// This type represents a one way message sent by the leader to all
/// followers about partition/primary and queue info mappings.
class LeaderAdvisory {
    // INSTANCE DATA
    bsl::vector<QueueInfo>            d_queues;
    bsl::vector<PartitionPrimaryInfo> d_partitions;
    LeaderMessageSequence             d_sequenceNumber;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SEQUENCE_NUMBER = 0,
        ATTRIBUTE_ID_PARTITIONS      = 1,
        ATTRIBUTE_ID_QUEUES          = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0,
        ATTRIBUTE_INDEX_PARTITIONS      = 1,
        ATTRIBUTE_INDEX_QUEUES          = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderAdvisory` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit LeaderAdvisory(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `LeaderAdvisory` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    LeaderAdvisory(const LeaderAdvisory& original,
                   bslma::Allocator*     basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderAdvisory` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    LeaderAdvisory(LeaderAdvisory&& original) noexcept;

    /// Create an object of type `LeaderAdvisory` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    LeaderAdvisory(LeaderAdvisory&&  original,
                   bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~LeaderAdvisory();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderAdvisory& operator=(const LeaderAdvisory& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderAdvisory& operator=(LeaderAdvisory&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    LeaderMessageSequence& sequenceNumber();

    /// Return a reference to the modifiable "Partitions" attribute of this
    /// object.
    bsl::vector<PartitionPrimaryInfo>& partitions();

    /// Return a reference to the modifiable "Queues" attribute of this
    /// object.
    bsl::vector<QueueInfo>& queues();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const LeaderMessageSequence& sequenceNumber() const;

    /// Return a reference to the non-modifiable "Partitions" attribute of
    /// this object.
    const bsl::vector<PartitionPrimaryInfo>& partitions() const;

    /// Return a reference to the non-modifiable "Queues" attribute of this
    /// object.
    const bsl::vector<QueueInfo>& queues() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderAdvisory& lhs, const LeaderAdvisory& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderAdvisory& lhs, const LeaderAdvisory& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                const LeaderAdvisory& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderAdvisory`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::LeaderAdvisory& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderAdvisory)

namespace bmqp_ctrlmsg {

// ===============
// class OpenQueue
// ===============

/// This request is an indication that the client wants to open a queue, and
/// the upstream node should create a queue handle for the requester.
/// handleParameters.: Parameters for the queue handle to be created
class OpenQueue {
    // INSTANCE DATA
    QueueHandleParameters d_handleParameters;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_HANDLE_PARAMETERS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_HANDLE_PARAMETERS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `OpenQueue` having the default value.  Use
    /// the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit OpenQueue(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `OpenQueue` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    OpenQueue(const OpenQueue& original, bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `OpenQueue` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    OpenQueue(OpenQueue&& original) noexcept;

    /// Create an object of type `OpenQueue` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    OpenQueue(OpenQueue&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~OpenQueue();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    OpenQueue& operator=(const OpenQueue& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    OpenQueue& operator=(OpenQueue&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "HandleParameters" attribute of
    /// this object.
    QueueHandleParameters& handleParameters();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "HandleParameters"
    /// attribute of this object.
    const QueueHandleParameters& handleParameters() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const OpenQueue& lhs, const OpenQueue& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const OpenQueue& lhs, const OpenQueue& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const OpenQueue& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `OpenQueue`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                hashAlg,
                const bmqp_ctrlmsg::OpenQueue& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::OpenQueue)

namespace bmqp_ctrlmsg {

// ============================
// class PartitionMessageChoice
// ============================

class PartitionMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ReplicaStateRequest>  d_replicaStateRequest;
        bsls::ObjectBuffer<ReplicaStateResponse> d_replicaStateResponse;
        bsls::ObjectBuffer<PrimaryStateRequest>  d_primaryStateRequest;
        bsls::ObjectBuffer<PrimaryStateResponse> d_primaryStateResponse;
        bsls::ObjectBuffer<ReplicaDataRequest>   d_replicaDataRequest;
        bsls::ObjectBuffer<ReplicaDataResponse>  d_replicaDataResponse;
    };

    int d_selectionId;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED              = -1,
        SELECTION_ID_REPLICA_STATE_REQUEST  = 0,
        SELECTION_ID_REPLICA_STATE_RESPONSE = 1,
        SELECTION_ID_PRIMARY_STATE_REQUEST  = 2,
        SELECTION_ID_PRIMARY_STATE_RESPONSE = 3,
        SELECTION_ID_REPLICA_DATA_REQUEST   = 4,
        SELECTION_ID_REPLICA_DATA_RESPONSE  = 5
    };

    enum { NUM_SELECTIONS = 6 };

    enum {
        SELECTION_INDEX_REPLICA_STATE_REQUEST  = 0,
        SELECTION_INDEX_REPLICA_STATE_RESPONSE = 1,
        SELECTION_INDEX_PRIMARY_STATE_REQUEST  = 2,
        SELECTION_INDEX_PRIMARY_STATE_RESPONSE = 3,
        SELECTION_INDEX_REPLICA_DATA_REQUEST   = 4,
        SELECTION_INDEX_REPLICA_DATA_RESPONSE  = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS

    /// Return selection information for the selection indicated by the
    /// specified `id` if the selection exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);

    /// Return selection information for the selection indicated by the
    /// specified `name` of the specified `nameLength` if the selection
    /// exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionMessageChoice` having the default
    /// value.
    PartitionMessageChoice();

    /// Create an object of type `PartitionMessageChoice` having the value
    /// of the specified `original` object.
    PartitionMessageChoice(const PartitionMessageChoice& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionMessageChoice` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    PartitionMessageChoice(PartitionMessageChoice&& original) noexcept;
#endif

    /// Destroy this object.
    ~PartitionMessageChoice();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionMessageChoice& operator=(const PartitionMessageChoice& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionMessageChoice& operator=(PartitionMessageChoice&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon default
    /// construction).
    void reset();

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `selectionId`.  Return 0 on success, and
    /// non-zero value otherwise (i.e., the selection is not found).
    int makeSelection(int selectionId);

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `name` of the specified `nameLength`.
    /// Return 0 on success, and non-zero value otherwise (i.e., the
    /// selection is not found).
    int makeSelection(const char* name, int nameLength);

    ReplicaStateRequest& makeReplicaStateRequest();
    ReplicaStateRequest&
    makeReplicaStateRequest(const ReplicaStateRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicaStateRequest& makeReplicaStateRequest(ReplicaStateRequest&& value);
#endif
    // Set the value of this object to be a "ReplicaStateRequest" value.
    // Optionally specify the 'value' of the "ReplicaStateRequest".  If
    // 'value' is not specified, the default "ReplicaStateRequest" value is
    // used.

    ReplicaStateResponse& makeReplicaStateResponse();
    ReplicaStateResponse&
    makeReplicaStateResponse(const ReplicaStateResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicaStateResponse&
    makeReplicaStateResponse(ReplicaStateResponse&& value);
#endif
    // Set the value of this object to be a "ReplicaStateResponse" value.
    // Optionally specify the 'value' of the "ReplicaStateResponse".  If
    // 'value' is not specified, the default "ReplicaStateResponse" value
    // is used.

    PrimaryStateRequest& makePrimaryStateRequest();
    PrimaryStateRequest&
    makePrimaryStateRequest(const PrimaryStateRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PrimaryStateRequest& makePrimaryStateRequest(PrimaryStateRequest&& value);
#endif
    // Set the value of this object to be a "PrimaryStateRequest" value.
    // Optionally specify the 'value' of the "PrimaryStateRequest".  If
    // 'value' is not specified, the default "PrimaryStateRequest" value is
    // used.

    PrimaryStateResponse& makePrimaryStateResponse();
    PrimaryStateResponse&
    makePrimaryStateResponse(const PrimaryStateResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PrimaryStateResponse&
    makePrimaryStateResponse(PrimaryStateResponse&& value);
#endif
    // Set the value of this object to be a "PrimaryStateResponse" value.
    // Optionally specify the 'value' of the "PrimaryStateResponse".  If
    // 'value' is not specified, the default "PrimaryStateResponse" value
    // is used.

    ReplicaDataRequest& makeReplicaDataRequest();
    ReplicaDataRequest&
    makeReplicaDataRequest(const ReplicaDataRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicaDataRequest& makeReplicaDataRequest(ReplicaDataRequest&& value);
#endif
    // Set the value of this object to be a "ReplicaDataRequest" value.
    // Optionally specify the 'value' of the "ReplicaDataRequest".  If
    // 'value' is not specified, the default "ReplicaDataRequest" value is
    // used.

    ReplicaDataResponse& makeReplicaDataResponse();
    ReplicaDataResponse&
    makeReplicaDataResponse(const ReplicaDataResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicaDataResponse& makeReplicaDataResponse(ReplicaDataResponse&& value);
#endif
    // Set the value of this object to be a "ReplicaDataResponse" value.
    // Optionally specify the 'value' of the "ReplicaDataResponse".  If
    // 'value' is not specified, the default "ReplicaDataResponse" value is
    // used.

    /// Invoke the specified `manipulator` on the address of the modifiable
    /// selection, supplying `manipulator` with the corresponding selection
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if this object has a defined selection,
    /// and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateSelection(MANIPULATOR& manipulator);

    /// Return a reference to the modifiable "ReplicaStateRequest" selection
    /// of this object if "ReplicaStateRequest" is the current selection.
    /// The behavior is undefined unless "ReplicaStateRequest" is the
    /// selection of this object.
    ReplicaStateRequest& replicaStateRequest();

    /// Return a reference to the modifiable "ReplicaStateResponse"
    /// selection of this object if "ReplicaStateResponse" is the current
    /// selection.  The behavior is undefined unless "ReplicaStateResponse"
    /// is the selection of this object.
    ReplicaStateResponse& replicaStateResponse();

    /// Return a reference to the modifiable "PrimaryStateRequest" selection
    /// of this object if "PrimaryStateRequest" is the current selection.
    /// The behavior is undefined unless "PrimaryStateRequest" is the
    /// selection of this object.
    PrimaryStateRequest& primaryStateRequest();

    /// Return a reference to the modifiable "PrimaryStateResponse"
    /// selection of this object if "PrimaryStateResponse" is the current
    /// selection.  The behavior is undefined unless "PrimaryStateResponse"
    /// is the selection of this object.
    PrimaryStateResponse& primaryStateResponse();

    /// Return a reference to the modifiable "ReplicaDataRequest" selection
    /// of this object if "ReplicaDataRequest" is the current selection.
    /// The behavior is undefined unless "ReplicaDataRequest" is the
    /// selection of this object.
    ReplicaDataRequest& replicaDataRequest();

    /// Return a reference to the modifiable "ReplicaDataResponse" selection
    /// of this object if "ReplicaDataResponse" is the current selection.
    /// The behavior is undefined unless "ReplicaDataResponse" is the
    /// selection of this object.
    ReplicaDataResponse& replicaDataResponse();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Return the id of the current selection if the selection is defined,
    /// and -1 otherwise.
    int selectionId() const;

    /// Invoke the specified `accessor` on the non-modifiable selection,
    /// supplying `accessor` with the corresponding selection information
    /// structure.  Return the value returned from the invocation of
    /// `accessor` if this object has a defined selection, and -1 otherwise.
    template <class ACCESSOR>
    int accessSelection(ACCESSOR& accessor) const;

    /// Return a reference to the non-modifiable "ReplicaStateRequest"
    /// selection of this object if "ReplicaStateRequest" is the current
    /// selection.  The behavior is undefined unless "ReplicaStateRequest"
    /// is the selection of this object.
    const ReplicaStateRequest& replicaStateRequest() const;

    /// Return a reference to the non-modifiable "ReplicaStateResponse"
    /// selection of this object if "ReplicaStateResponse" is the current
    /// selection.  The behavior is undefined unless "ReplicaStateResponse"
    /// is the selection of this object.
    const ReplicaStateResponse& replicaStateResponse() const;

    /// Return a reference to the non-modifiable "PrimaryStateRequest"
    /// selection of this object if "PrimaryStateRequest" is the current
    /// selection.  The behavior is undefined unless "PrimaryStateRequest"
    /// is the selection of this object.
    const PrimaryStateRequest& primaryStateRequest() const;

    /// Return a reference to the non-modifiable "PrimaryStateResponse"
    /// selection of this object if "PrimaryStateResponse" is the current
    /// selection.  The behavior is undefined unless "PrimaryStateResponse"
    /// is the selection of this object.
    const PrimaryStateResponse& primaryStateResponse() const;

    /// Return a reference to the non-modifiable "ReplicaDataRequest"
    /// selection of this object if "ReplicaDataRequest" is the current
    /// selection.  The behavior is undefined unless "ReplicaDataRequest" is
    /// the selection of this object.
    const ReplicaDataRequest& replicaDataRequest() const;

    /// Return a reference to the non-modifiable "ReplicaDataResponse"
    /// selection of this object if "ReplicaDataResponse" is the current
    /// selection.  The behavior is undefined unless "ReplicaDataResponse"
    /// is the selection of this object.
    const ReplicaDataResponse& replicaDataResponse() const;

    /// Return `true` if the value of this object is a "ReplicaStateRequest"
    /// value, and return `false` otherwise.
    bool isReplicaStateRequestValue() const;

    /// Return `true` if the value of this object is a
    /// "ReplicaStateResponse" value, and return `false` otherwise.
    bool isReplicaStateResponseValue() const;

    /// Return `true` if the value of this object is a "PrimaryStateRequest"
    /// value, and return `false` otherwise.
    bool isPrimaryStateRequestValue() const;

    /// Return `true` if the value of this object is a
    /// "PrimaryStateResponse" value, and return `false` otherwise.
    bool isPrimaryStateResponseValue() const;

    /// Return `true` if the value of this object is a "ReplicaDataRequest"
    /// value, and return `false` otherwise.
    bool isReplicaDataRequestValue() const;

    /// Return `true` if the value of this object is a "ReplicaDataResponse"
    /// value, and return `false` otherwise.
    bool isReplicaDataResponseValue() const;

    /// Return `true` if the value of this object is undefined, and `false`
    /// otherwise.
    bool isUndefinedValue() const;

    /// Return the symbolic name of the current selection of this object.
    const char* selectionName() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` objects have the same
/// value, and `false` otherwise.  Two `PartitionMessageChoice` objects have
/// the same value if either the selections in both objects have the same ids
/// and the same values, or both selections are undefined.
inline bool operator==(const PartitionMessageChoice& lhs,
                       const PartitionMessageChoice& rhs);

/// Return `true` if the specified `lhs` and `rhs` objects do not have the
/// same values, as determined by `operator==`, and `false` otherwise.
inline bool operator!=(const PartitionMessageChoice& lhs,
                       const PartitionMessageChoice& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                 stream,
                                const PartitionMessageChoice& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionMessageChoice`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                             hashAlg,
                const bmqp_ctrlmsg::PartitionMessageChoice& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionMessageChoice)

namespace bmqp_ctrlmsg {

// ============================
// class PartitionSyncDataQuery
// ============================

/// This type represents a request sent by a new primary node to one of the
/// AVAILABLE peers to asking for syncing the partition.
/// partitionId....: The corresponding partitionId lastSyncPoint..: Last
/// sync point of the requester for this partition.
class PartitionSyncDataQuery {
    // INSTANCE DATA
    bsls::Types::Uint64 d_lastSequenceNum;
    bsls::Types::Uint64 d_uptoSequenceNum;
    SyncPointOffsetPair d_lastSyncPointOffsetPair;
    unsigned int        d_lastPrimaryLeaseId;
    unsigned int        d_uptoPrimaryLeaseId;
    int                 d_partitionId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID                = 0,
        ATTRIBUTE_ID_LAST_PRIMARY_LEASE_ID       = 1,
        ATTRIBUTE_ID_LAST_SEQUENCE_NUM           = 2,
        ATTRIBUTE_ID_UPTO_PRIMARY_LEASE_ID       = 3,
        ATTRIBUTE_ID_UPTO_SEQUENCE_NUM           = 4,
        ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR = 5
    };

    enum { NUM_ATTRIBUTES = 6 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID                = 0,
        ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID       = 1,
        ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM           = 2,
        ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID       = 3,
        ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM           = 4,
        ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionSyncDataQuery` having the default
    /// value.
    PartitionSyncDataQuery();

    /// Create an object of type `PartitionSyncDataQuery` having the value
    /// of the specified `original` object.
    PartitionSyncDataQuery(const PartitionSyncDataQuery& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionSyncDataQuery` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    PartitionSyncDataQuery(PartitionSyncDataQuery&& original) = default;
#endif

    /// Destroy this object.
    ~PartitionSyncDataQuery();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionSyncDataQuery& operator=(const PartitionSyncDataQuery& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionSyncDataQuery& operator=(PartitionSyncDataQuery&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "LastPrimaryLeaseId" attribute
    /// of this object.
    unsigned int& lastPrimaryLeaseId();

    /// Return a reference to the modifiable "LastSequenceNum" attribute of
    /// this object.
    bsls::Types::Uint64& lastSequenceNum();

    /// Return a reference to the modifiable "UptoPrimaryLeaseId" attribute
    /// of this object.
    unsigned int& uptoPrimaryLeaseId();

    /// Return a reference to the modifiable "UptoSequenceNum" attribute of
    /// this object.
    bsls::Types::Uint64& uptoSequenceNum();

    /// Return a reference to the modifiable "LastSyncPointOffsetPair"
    /// attribute of this object.
    SyncPointOffsetPair& lastSyncPointOffsetPair();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "LastPrimaryLeaseId"
    /// attribute of this object.
    unsigned int lastPrimaryLeaseId() const;

    /// Return a reference to the non-modifiable "LastSequenceNum" attribute
    /// of this object.
    bsls::Types::Uint64 lastSequenceNum() const;

    /// Return a reference to the non-modifiable "UptoPrimaryLeaseId"
    /// attribute of this object.
    unsigned int uptoPrimaryLeaseId() const;

    /// Return a reference to the non-modifiable "UptoSequenceNum" attribute
    /// of this object.
    bsls::Types::Uint64 uptoSequenceNum() const;

    /// Return a reference to the non-modifiable "LastSyncPointOffsetPair"
    /// attribute of this object.
    const SyncPointOffsetPair& lastSyncPointOffsetPair() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionSyncDataQuery& lhs,
                       const PartitionSyncDataQuery& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionSyncDataQuery& lhs,
                       const PartitionSyncDataQuery& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                 stream,
                                const PartitionSyncDataQuery& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionSyncDataQuery`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                             hashAlg,
                const bmqp_ctrlmsg::PartitionSyncDataQuery& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncDataQuery)

namespace bmqp_ctrlmsg {

// ==================================
// class PartitionSyncDataQueryStatus
// ==================================

/// This type represents a message sent by a peer node to the new primary
/// after it is finished sending partition sync data.  This message
/// indicates to the new primary node that partition sync from peer is
/// complete (with appropriate success/failure status indicated in this
/// message).
/// partitionId..: The corresponding partitionId status.......: Status of
/// the query
class PartitionSyncDataQueryStatus {
    // INSTANCE DATA
    Status d_status;
    int    d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_STATUS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_PARTITION_ID = 0, ATTRIBUTE_INDEX_STATUS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionSyncDataQueryStatus` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit PartitionSyncDataQueryStatus(
        bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `PartitionSyncDataQueryStatus` having the
    /// value of the specified `original` object.  Use the optionally
    /// specified `basicAllocator` to supply memory.  If `basicAllocator` is
    /// 0, the currently installed default allocator is used.
    PartitionSyncDataQueryStatus(const PartitionSyncDataQueryStatus& original,
                                 bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionSyncDataQueryStatus` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    PartitionSyncDataQueryStatus(
        PartitionSyncDataQueryStatus&& original) noexcept;

    /// Create an object of type `PartitionSyncDataQueryStatus` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    PartitionSyncDataQueryStatus(PartitionSyncDataQueryStatus&& original,
                                 bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~PartitionSyncDataQueryStatus();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionSyncDataQueryStatus&
    operator=(const PartitionSyncDataQueryStatus& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionSyncDataQueryStatus&
    operator=(PartitionSyncDataQueryStatus&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "Status" attribute of this
    /// object.
    Status& status();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "Status" attribute of this
    /// object.
    const Status& status() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionSyncDataQueryStatus& lhs,
                       const PartitionSyncDataQueryStatus& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionSyncDataQueryStatus& lhs,
                       const PartitionSyncDataQueryStatus& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                       stream,
                                const PartitionSyncDataQueryStatus& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionSyncDataQueryStatus`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::PartitionSyncDataQueryStatus& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncDataQueryStatus)

namespace bmqp_ctrlmsg {

// =====================================
// class PartitionSyncStateQueryResponse
// =====================================

/// This type represents a message sent by a peer node in response to
/// PartitionSyncStateQueryQuery.
/// partitionId....: The corresponding partitionId primaryLeaseId.: Peer's
/// partition's primary leaseId sequenceNum....: Peer's partition's sequence
/// number lastSyncPoint..: Last sync point for this partition
class PartitionSyncStateQueryResponse {
    // INSTANCE DATA
    bsls::Types::Uint64 d_sequenceNum;
    SyncPointOffsetPair d_lastSyncPointOffsetPair;
    unsigned int        d_primaryLeaseId;
    int                 d_partitionId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID                = 0,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID            = 1,
        ATTRIBUTE_ID_SEQUENCE_NUM                = 2,
        ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID                = 0,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID            = 1,
        ATTRIBUTE_INDEX_SEQUENCE_NUM                = 2,
        ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionSyncStateQueryResponse` having
    /// the default value.
    PartitionSyncStateQueryResponse();

    /// Create an object of type `PartitionSyncStateQueryResponse` having
    /// the value of the specified `original` object.
    PartitionSyncStateQueryResponse(
        const PartitionSyncStateQueryResponse& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionSyncStateQueryResponse` having
    /// the value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    PartitionSyncStateQueryResponse(
        PartitionSyncStateQueryResponse&& original) = default;
#endif

    /// Destroy this object.
    ~PartitionSyncStateQueryResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionSyncStateQueryResponse&
    operator=(const PartitionSyncStateQueryResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionSyncStateQueryResponse&
    operator=(PartitionSyncStateQueryResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "PrimaryLeaseId" attribute of
    /// this object.
    unsigned int& primaryLeaseId();

    /// Return a reference to the modifiable "SequenceNum" attribute of this
    /// object.
    bsls::Types::Uint64& sequenceNum();

    /// Return a reference to the modifiable "LastSyncPointOffsetPair"
    /// attribute of this object.
    SyncPointOffsetPair& lastSyncPointOffsetPair();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "PrimaryLeaseId" attribute
    /// of this object.
    unsigned int primaryLeaseId() const;

    /// Return a reference to the non-modifiable "SequenceNum" attribute of
    /// this object.
    bsls::Types::Uint64 sequenceNum() const;

    /// Return a reference to the non-modifiable "LastSyncPointOffsetPair"
    /// attribute of this object.
    const SyncPointOffsetPair& lastSyncPointOffsetPair() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionSyncStateQueryResponse& lhs,
                       const PartitionSyncStateQueryResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionSyncStateQueryResponse& lhs,
                       const PartitionSyncStateQueryResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                          stream,
                                const PartitionSyncStateQueryResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for
/// `PartitionSyncStateQueryResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                      hashAlg,
                const bmqp_ctrlmsg::PartitionSyncStateQueryResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::PartitionSyncStateQueryResponse)

namespace bmqp_ctrlmsg {

// =============================
// class QueueAssignmentAdvisory
// =============================

/// This type represents a one way message sent by the leader to all
/// followers when a queue is assigned a partition.
class QueueAssignmentAdvisory {
    // INSTANCE DATA
    bsl::vector<QueueInfo> d_queues;
    LeaderMessageSequence  d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0, ATTRIBUTE_ID_QUEUES = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0, ATTRIBUTE_INDEX_QUEUES = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueAssignmentAdvisory` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit QueueAssignmentAdvisory(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueAssignmentAdvisory` having the value
    /// of the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueAssignmentAdvisory(const QueueAssignmentAdvisory& original,
                            bslma::Allocator*              basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueAssignmentAdvisory` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    QueueAssignmentAdvisory(QueueAssignmentAdvisory&& original) noexcept;

    /// Create an object of type `QueueAssignmentAdvisory` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    QueueAssignmentAdvisory(QueueAssignmentAdvisory&& original,
                            bslma::Allocator*         basicAllocator);
#endif

    /// Destroy this object.
    ~QueueAssignmentAdvisory();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueAssignmentAdvisory& operator=(const QueueAssignmentAdvisory& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueAssignmentAdvisory& operator=(QueueAssignmentAdvisory&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    LeaderMessageSequence& sequenceNumber();

    /// Return a reference to the modifiable "Queues" attribute of this
    /// object.
    bsl::vector<QueueInfo>& queues();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const LeaderMessageSequence& sequenceNumber() const;

    /// Return a reference to the non-modifiable "Queues" attribute of this
    /// object.
    const bsl::vector<QueueInfo>& queues() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueAssignmentAdvisory& lhs,
                       const QueueAssignmentAdvisory& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueAssignmentAdvisory& lhs,
                       const QueueAssignmentAdvisory& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                  stream,
                                const QueueAssignmentAdvisory& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueAssignmentAdvisory`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::QueueAssignmentAdvisory& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueAssignmentAdvisory)

namespace bmqp_ctrlmsg {

// ===============================
// class QueueUnAssignmentAdvisory
// ===============================

/// This type represents a one way message sent by the primary of a
/// partition to all peers when queues are unmapped from that partition.
/// NOTE: The `partitionId` member of `QueueInfo` is unused (superseeded by
/// the `partitionId` at this level of the data structure).
class QueueUnAssignmentAdvisory {
    // INSTANCE DATA
    bsl::vector<QueueInfo> d_queues;
    unsigned int           d_primaryLeaseId;
    int                    d_primaryNodeId;
    int                    d_partitionId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PRIMARY_NODE_ID  = 0,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_ID_PARTITION_ID     = 2,
        ATTRIBUTE_ID_QUEUES           = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PRIMARY_NODE_ID  = 0,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 1,
        ATTRIBUTE_INDEX_PARTITION_ID     = 2,
        ATTRIBUTE_INDEX_QUEUES           = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueUnAssignmentAdvisory` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit QueueUnAssignmentAdvisory(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueUnAssignmentAdvisory` having the
    /// value of the specified `original` object.  Use the optionally
    /// specified `basicAllocator` to supply memory.  If `basicAllocator` is
    /// 0, the currently installed default allocator is used.
    QueueUnAssignmentAdvisory(const QueueUnAssignmentAdvisory& original,
                              bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueUnAssignmentAdvisory` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    QueueUnAssignmentAdvisory(QueueUnAssignmentAdvisory&& original) noexcept;

    /// Create an object of type `QueueUnAssignmentAdvisory` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    QueueUnAssignmentAdvisory(QueueUnAssignmentAdvisory&& original,
                              bslma::Allocator*           basicAllocator);
#endif

    /// Destroy this object.
    ~QueueUnAssignmentAdvisory();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueUnAssignmentAdvisory& operator=(const QueueUnAssignmentAdvisory& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueUnAssignmentAdvisory& operator=(QueueUnAssignmentAdvisory&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PrimaryNodeId" attribute of
    /// this object.
    int& primaryNodeId();

    /// Return a reference to the modifiable "PrimaryLeaseId" attribute of
    /// this object.
    unsigned int& primaryLeaseId();

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "Queues" attribute of this
    /// object.
    bsl::vector<QueueInfo>& queues();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PrimaryNodeId" attribute
    /// of this object.
    int primaryNodeId() const;

    /// Return a reference to the non-modifiable "PrimaryLeaseId" attribute
    /// of this object.
    unsigned int primaryLeaseId() const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "Queues" attribute of this
    /// object.
    const bsl::vector<QueueInfo>& queues() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueUnAssignmentAdvisory& lhs,
                       const QueueUnAssignmentAdvisory& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueUnAssignmentAdvisory& lhs,
                       const QueueUnAssignmentAdvisory& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                    stream,
                                const QueueUnAssignmentAdvisory& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueUnAssignmentAdvisory`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                hashAlg,
                const bmqp_ctrlmsg::QueueUnAssignmentAdvisory& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueUnAssignmentAdvisory)

namespace bmqp_ctrlmsg {

// =============================
// class QueueUnassignedAdvisory
// =============================

/// This type represents a one way message sent by the leader to all peers
/// when queues are unmapped from that partition.  Once the logic is updated
/// such that leader broadcasts queue unassigned advisories, primary node
/// will no longer broadcastthem, and the other similar type
/// `QueueUnAssignmentAdvisory` will be removed.
class QueueUnassignedAdvisory {
    // INSTANCE DATA
    bsl::vector<QueueInfo> d_queues;
    LeaderMessageSequence  d_sequenceNumber;
    unsigned int           d_primaryLeaseId;
    int                    d_partitionId;
    int                    d_primaryNodeId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SEQUENCE_NUMBER  = 0,
        ATTRIBUTE_ID_PARTITION_ID     = 1,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID = 2,
        ATTRIBUTE_ID_PRIMARY_NODE_ID  = 3,
        ATTRIBUTE_ID_QUEUES           = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER  = 0,
        ATTRIBUTE_INDEX_PARTITION_ID     = 1,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID = 2,
        ATTRIBUTE_INDEX_PRIMARY_NODE_ID  = 3,
        ATTRIBUTE_INDEX_QUEUES           = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueUnassignedAdvisory` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit QueueUnassignedAdvisory(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueUnassignedAdvisory` having the value
    /// of the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueUnassignedAdvisory(const QueueUnassignedAdvisory& original,
                            bslma::Allocator*              basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueUnassignedAdvisory` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    QueueUnassignedAdvisory(QueueUnassignedAdvisory&& original) noexcept;

    /// Create an object of type `QueueUnassignedAdvisory` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    QueueUnassignedAdvisory(QueueUnassignedAdvisory&& original,
                            bslma::Allocator*         basicAllocator);
#endif

    /// Destroy this object.
    ~QueueUnassignedAdvisory();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueUnassignedAdvisory& operator=(const QueueUnassignedAdvisory& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueUnassignedAdvisory& operator=(QueueUnassignedAdvisory&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    LeaderMessageSequence& sequenceNumber();

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "PrimaryLeaseId" attribute of
    /// this object.
    unsigned int& primaryLeaseId();

    /// Return a reference to the modifiable "PrimaryNodeId" attribute of
    /// this object.
    int& primaryNodeId();

    /// Return a reference to the modifiable "Queues" attribute of this
    /// object.
    bsl::vector<QueueInfo>& queues();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const LeaderMessageSequence& sequenceNumber() const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "PrimaryLeaseId" attribute
    /// of this object.
    unsigned int primaryLeaseId() const;

    /// Return a reference to the non-modifiable "PrimaryNodeId" attribute
    /// of this object.
    int primaryNodeId() const;

    /// Return a reference to the non-modifiable "Queues" attribute of this
    /// object.
    const bsl::vector<QueueInfo>& queues() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueUnassignedAdvisory& lhs,
                       const QueueUnassignedAdvisory& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueUnassignedAdvisory& lhs,
                       const QueueUnassignedAdvisory& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                  stream,
                                const QueueUnassignedAdvisory& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueUnassignedAdvisory`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::QueueUnassignedAdvisory& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueUnassignedAdvisory)

namespace bmqp_ctrlmsg {

// =========================
// class QueueUpdateAdvisory
// =========================

/// This type represents a one way message sent by the leader to all
/// followers when appIds are added to, or removed from, a queue.
class QueueUpdateAdvisory {
    // INSTANCE DATA
    bsl::vector<QueueInfoUpdate> d_queueUpdates;
    LeaderMessageSequence        d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SEQUENCE_NUMBER = 0, ATTRIBUTE_ID_QUEUE_UPDATES = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 0,
        ATTRIBUTE_INDEX_QUEUE_UPDATES   = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `QueueUpdateAdvisory` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit QueueUpdateAdvisory(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `QueueUpdateAdvisory` having the value of
    /// the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    QueueUpdateAdvisory(const QueueUpdateAdvisory& original,
                        bslma::Allocator*          basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `QueueUpdateAdvisory` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    QueueUpdateAdvisory(QueueUpdateAdvisory&& original) noexcept;

    /// Create an object of type `QueueUpdateAdvisory` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    QueueUpdateAdvisory(QueueUpdateAdvisory&& original,
                        bslma::Allocator*     basicAllocator);
#endif

    /// Destroy this object.
    ~QueueUpdateAdvisory();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    QueueUpdateAdvisory& operator=(const QueueUpdateAdvisory& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    QueueUpdateAdvisory& operator=(QueueUpdateAdvisory&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SequenceNumber" attribute of
    /// this object.
    LeaderMessageSequence& sequenceNumber();

    /// Return a reference to the modifiable "QueueUpdates" attribute of
    /// this object.
    bsl::vector<QueueInfoUpdate>& queueUpdates();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SequenceNumber" attribute
    /// of this object.
    const LeaderMessageSequence& sequenceNumber() const;

    /// Return a reference to the non-modifiable "QueueUpdates" attribute of
    /// this object.
    const bsl::vector<QueueInfoUpdate>& queueUpdates() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const QueueUpdateAdvisory& lhs,
                       const QueueUpdateAdvisory& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const QueueUpdateAdvisory& lhs,
                       const QueueUpdateAdvisory& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&              stream,
                                const QueueUpdateAdvisory& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `QueueUpdateAdvisory`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::QueueUpdateAdvisory& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::QueueUpdateAdvisory)

namespace bmqp_ctrlmsg {

// =======================
// class StateNotification
// =======================

/// Choice of all the various cluster state notifications sent from a node
/// in the cluster to a peer node with the capacity to take action upon the
/// notification.
/// leaderPassive..: Leader is passive
class StateNotification {
    // INSTANCE DATA
    StateNotificationChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `StateNotification` having the default
    /// value.
    StateNotification();

    /// Create an object of type `StateNotification` having the value of the
    /// specified `original` object.
    StateNotification(const StateNotification& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `StateNotification` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    StateNotification(StateNotification&& original) = default;
#endif

    /// Destroy this object.
    ~StateNotification();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    StateNotification& operator=(const StateNotification& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    StateNotification& operator=(StateNotification&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Choice" attribute of this
    /// object.
    StateNotificationChoice& choice();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Choice" attribute of this
    /// object.
    const StateNotificationChoice& choice() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const StateNotification& lhs,
                       const StateNotification& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const StateNotification& lhs,
                       const StateNotification& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&            stream,
                                const StateNotification& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `StateNotification`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::StateNotification& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StateNotification)

namespace bmqp_ctrlmsg {

// ========================
// class StorageSyncRequest
// ========================

/// This type represents a request sent by a cluster node to a peer node in
/// the cluster requesting to initiate storage sync.
/// partitionId.....: The corresponding partitionId beginSyncPoint..:
/// Optional starting sync point of the missing storage endSyncPoint....:
/// Optional ending sync point of the missing storage
class StorageSyncRequest {
    // INSTANCE DATA
    bdlb::NullableValue<SyncPointOffsetPair> d_beginSyncPointOffsetPair;
    bdlb::NullableValue<SyncPointOffsetPair> d_endSyncPointOffsetPair;
    int                                      d_partitionId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID                 = 0,
        ATTRIBUTE_ID_BEGIN_SYNC_POINT_OFFSET_PAIR = 1,
        ATTRIBUTE_ID_END_SYNC_POINT_OFFSET_PAIR   = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID                 = 0,
        ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR = 1,
        ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR   = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `StorageSyncRequest` having the default
    /// value.
    StorageSyncRequest();

    /// Create an object of type `StorageSyncRequest` having the value of
    /// the specified `original` object.
    StorageSyncRequest(const StorageSyncRequest& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `StorageSyncRequest` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    StorageSyncRequest(StorageSyncRequest&& original) = default;
#endif

    /// Destroy this object.
    ~StorageSyncRequest();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    StorageSyncRequest& operator=(const StorageSyncRequest& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    StorageSyncRequest& operator=(StorageSyncRequest&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "PartitionId" attribute of this
    /// object.
    int& partitionId();

    /// Return a reference to the modifiable "BeginSyncPointOffsetPair"
    /// attribute of this object.
    bdlb::NullableValue<SyncPointOffsetPair>& beginSyncPointOffsetPair();

    /// Return a reference to the modifiable "EndSyncPointOffsetPair"
    /// attribute of this object.
    bdlb::NullableValue<SyncPointOffsetPair>& endSyncPointOffsetPair();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "PartitionId" attribute of
    /// this object.
    int partitionId() const;

    /// Return a reference to the non-modifiable "BeginSyncPointOffsetPair"
    /// attribute of this object.
    const bdlb::NullableValue<SyncPointOffsetPair>&
    beginSyncPointOffsetPair() const;

    /// Return a reference to the non-modifiable "EndSyncPointOffsetPair"
    /// attribute of this object.
    const bdlb::NullableValue<SyncPointOffsetPair>&
    endSyncPointOffsetPair() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const StorageSyncRequest& lhs,
                       const StorageSyncRequest& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const StorageSyncRequest& lhs,
                       const StorageSyncRequest& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&             stream,
                                const StorageSyncRequest& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `StorageSyncRequest`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::StorageSyncRequest& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StorageSyncRequest)

namespace bmqp_ctrlmsg {

// ==================
// class Subscription
// ==================

/// This complex type contains various parameters required by an upstream
/// node to configure subscription for a queue handle that has already been
/// created.
/// sId....................: subscription identifier
/// consumers..............: consumer parameters
class Subscription {
    // INSTANCE DATA
    bsl::vector<ConsumerInfo> d_consumers;
    Expression                d_expression;
    unsigned int              d_sId;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_S_ID       = 0,
        ATTRIBUTE_ID_EXPRESSION = 1,
        ATTRIBUTE_ID_CONSUMERS  = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_S_ID       = 0,
        ATTRIBUTE_INDEX_EXPRESSION = 1,
        ATTRIBUTE_INDEX_CONSUMERS  = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `Subscription` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit Subscription(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `Subscription` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    Subscription(const Subscription& original,
                 bslma::Allocator*   basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `Subscription` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    Subscription(Subscription&& original) noexcept;

    /// Create an object of type `Subscription` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    Subscription(Subscription&& original, bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~Subscription();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    Subscription& operator=(const Subscription& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    Subscription& operator=(Subscription&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "SId" attribute of this object.
    unsigned int& sId();

    /// Return a reference to the modifiable "Expression" attribute of this
    /// object.
    Expression& expression();

    /// Return a reference to the modifiable "Consumers" attribute of this
    /// object.
    bsl::vector<ConsumerInfo>& consumers();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "SId" attribute of this
    /// object.
    unsigned int sId() const;

    /// Return a reference to the non-modifiable "Expression" attribute of
    /// this object.
    const Expression& expression() const;

    /// Return a reference to the non-modifiable "Consumers" attribute of
    /// this object.
    const bsl::vector<ConsumerInfo>& consumers() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const Subscription& lhs, const Subscription& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const Subscription& lhs, const Subscription& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream& stream, const Subscription& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `Subscription`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::Subscription& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::Subscription)

namespace bmqp_ctrlmsg {

// ==================================
// class ConfigureQueueStreamResponse
// ==================================

/// Response of a `ConfigureQueueStream` request, indicating success of the
/// operation.
class ConfigureQueueStreamResponse {
    // INSTANCE DATA
    ConfigureQueueStream d_request;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_REQUEST = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_REQUEST = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ConfigureQueueStreamResponse` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit ConfigureQueueStreamResponse(
        bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ConfigureQueueStreamResponse` having the
    /// value of the specified `original` object.  Use the optionally
    /// specified `basicAllocator` to supply memory.  If `basicAllocator` is
    /// 0, the currently installed default allocator is used.
    ConfigureQueueStreamResponse(const ConfigureQueueStreamResponse& original,
                                 bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ConfigureQueueStreamResponse` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    ConfigureQueueStreamResponse(
        ConfigureQueueStreamResponse&& original) noexcept;

    /// Create an object of type `ConfigureQueueStreamResponse` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    ConfigureQueueStreamResponse(ConfigureQueueStreamResponse&& original,
                                 bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~ConfigureQueueStreamResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ConfigureQueueStreamResponse&
    operator=(const ConfigureQueueStreamResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ConfigureQueueStreamResponse&
    operator=(ConfigureQueueStreamResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Request" attribute of this
    /// object.
    ConfigureQueueStream& request();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Request" attribute of this
    /// object.
    const ConfigureQueueStream& request() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ConfigureQueueStreamResponse& lhs,
                       const ConfigureQueueStreamResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ConfigureQueueStreamResponse& lhs,
                       const ConfigureQueueStreamResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                       stream,
                                const ConfigureQueueStreamResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ConfigureQueueStreamResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::ConfigureQueueStreamResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ConfigureQueueStreamResponse)

namespace bmqp_ctrlmsg {

// ==================================
// class FollowerClusterStateResponse
// ==================================

/// This type represents a response to the `FollowerClusterStateRequest`
/// sent by the highest LSN follower to the leader, containing its cluster
/// state snapshot.
/// clusterStateSnapshot..: Encoded cluster state snapshot, in the form of a
/// leader advisory.
class FollowerClusterStateResponse {
    // INSTANCE DATA
    LeaderAdvisory d_clusterStateSnapshot;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CLUSTER_STATE_SNAPSHOT = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `FollowerClusterStateResponse` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit FollowerClusterStateResponse(
        bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `FollowerClusterStateResponse` having the
    /// value of the specified `original` object.  Use the optionally
    /// specified `basicAllocator` to supply memory.  If `basicAllocator` is
    /// 0, the currently installed default allocator is used.
    FollowerClusterStateResponse(const FollowerClusterStateResponse& original,
                                 bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `FollowerClusterStateResponse` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    FollowerClusterStateResponse(
        FollowerClusterStateResponse&& original) noexcept;

    /// Create an object of type `FollowerClusterStateResponse` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    FollowerClusterStateResponse(FollowerClusterStateResponse&& original,
                                 bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~FollowerClusterStateResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    FollowerClusterStateResponse&
    operator=(const FollowerClusterStateResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    FollowerClusterStateResponse&
    operator=(FollowerClusterStateResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "ClusterStateSnapshot"
    /// attribute of this object.
    LeaderAdvisory& clusterStateSnapshot();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "ClusterStateSnapshot"
    /// attribute of this object.
    const LeaderAdvisory& clusterStateSnapshot() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const FollowerClusterStateResponse& lhs,
                       const FollowerClusterStateResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const FollowerClusterStateResponse& lhs,
                       const FollowerClusterStateResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                       stream,
                                const FollowerClusterStateResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `FollowerClusterStateResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::FollowerClusterStateResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::FollowerClusterStateResponse)

namespace bmqp_ctrlmsg {

// =================================
// class LeaderSyncDataQueryResponse
// =================================

/// This type represents a response to the `LeaderSyncDataQuery` sent by the
/// follower to the leader.
class LeaderSyncDataQueryResponse {
    // INSTANCE DATA
    LeaderAdvisory d_leaderSyncData;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_LEADER_SYNC_DATA = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_LEADER_SYNC_DATA = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `LeaderSyncDataQueryResponse` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit LeaderSyncDataQueryResponse(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `LeaderSyncDataQueryResponse` having the
    /// value of the specified `original` object.  Use the optionally
    /// specified `basicAllocator` to supply memory.  If `basicAllocator` is
    /// 0, the currently installed default allocator is used.
    LeaderSyncDataQueryResponse(const LeaderSyncDataQueryResponse& original,
                                bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `LeaderSyncDataQueryResponse` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    LeaderSyncDataQueryResponse(
        LeaderSyncDataQueryResponse&& original) noexcept;

    /// Create an object of type `LeaderSyncDataQueryResponse` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    LeaderSyncDataQueryResponse(LeaderSyncDataQueryResponse&& original,
                                bslma::Allocator*             basicAllocator);
#endif

    /// Destroy this object.
    ~LeaderSyncDataQueryResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    LeaderSyncDataQueryResponse&
    operator=(const LeaderSyncDataQueryResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    LeaderSyncDataQueryResponse& operator=(LeaderSyncDataQueryResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "LeaderSyncData" attribute of
    /// this object.
    LeaderAdvisory& leaderSyncData();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "LeaderSyncData" attribute
    /// of this object.
    const LeaderAdvisory& leaderSyncData() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const LeaderSyncDataQueryResponse& lhs,
                       const LeaderSyncDataQueryResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const LeaderSyncDataQueryResponse& lhs,
                       const LeaderSyncDataQueryResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                      stream,
                                const LeaderSyncDataQueryResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `LeaderSyncDataQueryResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                  hashAlg,
                const bmqp_ctrlmsg::LeaderSyncDataQueryResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::LeaderSyncDataQueryResponse)

namespace bmqp_ctrlmsg {

// ========================
// class NegotiationMessage
// ========================

/// This type is the top level type for any message being exchanged during
/// negotiation of a connection with the broker, whether by a bmq client or
/// another broker.
/// choice.: enumerates all the different type of negotiation packets
/// During negotiation, the process (whether a client using the libbmq SDK,
/// or a bmqbrkr) sends a `clientIdentity` message; to which the remote peer
/// will reply with a `brokerResponse` message, embedding a `clientIdentity`
/// representing its own identity.  In order to support reverse connection,
/// the negotiation will be 3 steps: first, a `reverseConnectionRequest`
/// will be sent, which will trigger the `normal` 2-steps negotiation to be
/// initiated by the remote peer.
class NegotiationMessage {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ClientIdentity> d_clientIdentity;
        bsls::ObjectBuffer<BrokerResponse> d_brokerResponse;
        bsls::ObjectBuffer<ReverseConnectionRequest>
            d_reverseConnectionRequest;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                  = -1,
        SELECTION_ID_CLIENT_IDENTITY            = 0,
        SELECTION_ID_BROKER_RESPONSE            = 1,
        SELECTION_ID_REVERSE_CONNECTION_REQUEST = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_CLIENT_IDENTITY            = 0,
        SELECTION_INDEX_BROKER_RESPONSE            = 1,
        SELECTION_INDEX_REVERSE_CONNECTION_REQUEST = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS

    /// Return selection information for the selection indicated by the
    /// specified `id` if the selection exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);

    /// Return selection information for the selection indicated by the
    /// specified `name` of the specified `nameLength` if the selection
    /// exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `NegotiationMessage` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit NegotiationMessage(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `NegotiationMessage` having the value of
    /// the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    NegotiationMessage(const NegotiationMessage& original,
                       bslma::Allocator*         basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `NegotiationMessage` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    NegotiationMessage(NegotiationMessage&& original) noexcept;

    /// Create an object of type `NegotiationMessage` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    NegotiationMessage(NegotiationMessage&& original,
                       bslma::Allocator*    basicAllocator);
#endif

    /// Destroy this object.
    ~NegotiationMessage();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    NegotiationMessage& operator=(const NegotiationMessage& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    NegotiationMessage& operator=(NegotiationMessage&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon default
    /// construction).
    void reset();

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `selectionId`.  Return 0 on success, and
    /// non-zero value otherwise (i.e., the selection is not found).
    int makeSelection(int selectionId);

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `name` of the specified `nameLength`.
    /// Return 0 on success, and non-zero value otherwise (i.e., the
    /// selection is not found).
    int makeSelection(const char* name, int nameLength);

    ClientIdentity& makeClientIdentity();
    ClientIdentity& makeClientIdentity(const ClientIdentity& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClientIdentity& makeClientIdentity(ClientIdentity&& value);
#endif
    // Set the value of this object to be a "ClientIdentity" value.
    // Optionally specify the 'value' of the "ClientIdentity".  If 'value'
    // is not specified, the default "ClientIdentity" value is used.

    BrokerResponse& makeBrokerResponse();
    BrokerResponse& makeBrokerResponse(const BrokerResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerResponse& makeBrokerResponse(BrokerResponse&& value);
#endif
    // Set the value of this object to be a "BrokerResponse" value.
    // Optionally specify the 'value' of the "BrokerResponse".  If 'value'
    // is not specified, the default "BrokerResponse" value is used.

    ReverseConnectionRequest& makeReverseConnectionRequest();
    ReverseConnectionRequest&
    makeReverseConnectionRequest(const ReverseConnectionRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReverseConnectionRequest&
    makeReverseConnectionRequest(ReverseConnectionRequest&& value);
#endif
    // Set the value of this object to be a "ReverseConnectionRequest"
    // value.  Optionally specify the 'value' of the
    // "ReverseConnectionRequest".  If 'value' is not specified, the
    // default "ReverseConnectionRequest" value is used.

    /// Invoke the specified `manipulator` on the address of the modifiable
    /// selection, supplying `manipulator` with the corresponding selection
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if this object has a defined selection,
    /// and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateSelection(MANIPULATOR& manipulator);

    /// Return a reference to the modifiable "ClientIdentity" selection of
    /// this object if "ClientIdentity" is the current selection.  The
    /// behavior is undefined unless "ClientIdentity" is the selection of
    /// this object.
    ClientIdentity& clientIdentity();

    /// Return a reference to the modifiable "BrokerResponse" selection of
    /// this object if "BrokerResponse" is the current selection.  The
    /// behavior is undefined unless "BrokerResponse" is the selection of
    /// this object.
    BrokerResponse& brokerResponse();

    /// Return a reference to the modifiable "ReverseConnectionRequest"
    /// selection of this object if "ReverseConnectionRequest" is the
    /// current selection.  The behavior is undefined unless
    /// "ReverseConnectionRequest" is the selection of this object.
    ReverseConnectionRequest& reverseConnectionRequest();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Return the id of the current selection if the selection is defined,
    /// and -1 otherwise.
    int selectionId() const;

    /// Invoke the specified `accessor` on the non-modifiable selection,
    /// supplying `accessor` with the corresponding selection information
    /// structure.  Return the value returned from the invocation of
    /// `accessor` if this object has a defined selection, and -1 otherwise.
    template <class ACCESSOR>
    int accessSelection(ACCESSOR& accessor) const;

    /// Return a reference to the non-modifiable "ClientIdentity" selection
    /// of this object if "ClientIdentity" is the current selection.  The
    /// behavior is undefined unless "ClientIdentity" is the selection of
    /// this object.
    const ClientIdentity& clientIdentity() const;

    /// Return a reference to the non-modifiable "BrokerResponse" selection
    /// of this object if "BrokerResponse" is the current selection.  The
    /// behavior is undefined unless "BrokerResponse" is the selection of
    /// this object.
    const BrokerResponse& brokerResponse() const;

    /// Return a reference to the non-modifiable "ReverseConnectionRequest"
    /// selection of this object if "ReverseConnectionRequest" is the
    /// current selection.  The behavior is undefined unless
    /// "ReverseConnectionRequest" is the selection of this object.
    const ReverseConnectionRequest& reverseConnectionRequest() const;

    /// Return `true` if the value of this object is a "ClientIdentity"
    /// value, and return `false` otherwise.
    bool isClientIdentityValue() const;

    /// Return `true` if the value of this object is a "BrokerResponse"
    /// value, and return `false` otherwise.
    bool isBrokerResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "ReverseConnectionRequest" value, and return `false` otherwise.
    bool isReverseConnectionRequestValue() const;

    /// Return `true` if the value of this object is undefined, and `false`
    /// otherwise.
    bool isUndefinedValue() const;

    /// Return the symbolic name of the current selection of this object.
    const char* selectionName() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` objects have the same
/// value, and `false` otherwise.  Two `NegotiationMessage` objects have the
/// same value if either the selections in both objects have the same ids and
/// the same values, or both selections are undefined.
inline bool operator==(const NegotiationMessage& lhs,
                       const NegotiationMessage& rhs);

/// Return `true` if the specified `lhs` and `rhs` objects do not have the
/// same values, as determined by `operator==`, and `false` otherwise.
inline bool operator!=(const NegotiationMessage& lhs,
                       const NegotiationMessage& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&             stream,
                                const NegotiationMessage& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `NegotiationMessage`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::NegotiationMessage& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::NegotiationMessage)

namespace bmqp_ctrlmsg {

// =======================
// class OpenQueueResponse
// =======================

/// Response of an `OpenQueue` request indicating success of the operation.
///
/// originalRequest......: original request this `OpenQueueResponse` is the
/// response of routingConfiguration.: routing info to be used by the
/// downstream node to distribute messages to consumers attached to it
/// deduplicationTimeMs........: timeout, in milliseconds, to keep GUID of
/// PUT message for the purpose of detecting duplicate PUTs.
class OpenQueueResponse {
    // INSTANCE DATA
    RoutingConfiguration d_routingConfiguration;
    OpenQueue            d_originalRequest;
    int                  d_deduplicationTimeMs;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_ORIGINAL_REQUEST      = 0,
        ATTRIBUTE_ID_ROUTING_CONFIGURATION = 1,
        ATTRIBUTE_ID_DEDUPLICATION_TIME_MS = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_ORIGINAL_REQUEST      = 0,
        ATTRIBUTE_INDEX_ROUTING_CONFIGURATION = 1,
        ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const int DEFAULT_INITIALIZER_DEDUPLICATION_TIME_MS;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `OpenQueueResponse` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit OpenQueueResponse(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `OpenQueueResponse` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    OpenQueueResponse(const OpenQueueResponse& original,
                      bslma::Allocator*        basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `OpenQueueResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    OpenQueueResponse(OpenQueueResponse&& original) noexcept;

    /// Create an object of type `OpenQueueResponse` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    OpenQueueResponse(OpenQueueResponse&& original,
                      bslma::Allocator*   basicAllocator);
#endif

    /// Destroy this object.
    ~OpenQueueResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    OpenQueueResponse& operator=(const OpenQueueResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    OpenQueueResponse& operator=(OpenQueueResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "OriginalRequest" attribute of
    /// this object.
    OpenQueue& originalRequest();

    /// Return a reference to the modifiable "RoutingConfiguration"
    /// attribute of this object.
    RoutingConfiguration& routingConfiguration();

    /// Return a reference to the modifiable "DeduplicationTimeMs" attribute
    /// of this object.
    int& deduplicationTimeMs();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "OriginalRequest" attribute
    /// of this object.
    const OpenQueue& originalRequest() const;

    /// Return a reference to the non-modifiable "RoutingConfiguration"
    /// attribute of this object.
    const RoutingConfiguration& routingConfiguration() const;

    /// Return a reference to the non-modifiable "DeduplicationTimeMs"
    /// attribute of this object.
    int deduplicationTimeMs() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const OpenQueueResponse& lhs,
                       const OpenQueueResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const OpenQueueResponse& lhs,
                       const OpenQueueResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&            stream,
                                const OpenQueueResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `OpenQueueResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::OpenQueueResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::OpenQueueResponse)

namespace bmqp_ctrlmsg {

// ======================
// class PartitionMessage
// ======================

/// This type is the top level type for any message being sent by a node
/// inside the cluster to one or more peer nodes to exchange partition
/// state.  Note that this type of message is not sent outside the cluster.
///
/// choice.: enumerates all the different types of partition messages
class PartitionMessage {
    // INSTANCE DATA
    PartitionMessageChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `PartitionMessage` having the default
    /// value.
    PartitionMessage();

    /// Create an object of type `PartitionMessage` having the value of the
    /// specified `original` object.
    PartitionMessage(const PartitionMessage& original);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `PartitionMessage` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    PartitionMessage(PartitionMessage&& original) = default;
#endif

    /// Destroy this object.
    ~PartitionMessage();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    PartitionMessage& operator=(const PartitionMessage& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    PartitionMessage& operator=(PartitionMessage&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Choice" attribute of this
    /// object.
    PartitionMessageChoice& choice();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Choice" attribute of this
    /// object.
    const PartitionMessageChoice& choice() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const PartitionMessage& lhs,
                       const PartitionMessage& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const PartitionMessage& lhs,
                       const PartitionMessage& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&           stream,
                                const PartitionMessage& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `PartitionMessage`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::PartitionMessage& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(bmqp_ctrlmsg::PartitionMessage)

namespace bmqp_ctrlmsg {

// ======================
// class StreamParameters
// ======================

/// This request contains parameters advertised by the downstream node so
/// that upstream node can configure subscriptions associated with the given
/// queue on the downstream node.
/// appId..................: Application-provided unique string identifier
/// for a given fanout consumer subscriptions..........: Parameters for
/// configuring subscriptions
class StreamParameters {
    // INSTANCE DATA
    bsl::vector<Subscription> d_subscriptions;
    bsl::string               d_appId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_APP_ID = 0, ATTRIBUTE_ID_SUBSCRIPTIONS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_APP_ID = 0, ATTRIBUTE_INDEX_SUBSCRIPTIONS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const char DEFAULT_INITIALIZER_APP_ID[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `StreamParameters` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit StreamParameters(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `StreamParameters` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    StreamParameters(const StreamParameters& original,
                     bslma::Allocator*       basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `StreamParameters` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    StreamParameters(StreamParameters&& original) noexcept;

    /// Create an object of type `StreamParameters` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    StreamParameters(StreamParameters&& original,
                     bslma::Allocator*  basicAllocator);
#endif

    /// Destroy this object.
    ~StreamParameters();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    StreamParameters& operator=(const StreamParameters& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    StreamParameters& operator=(StreamParameters&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "AppId" attribute of this
    /// object.
    bsl::string& appId();

    /// Return a reference to the modifiable "Subscriptions" attribute of
    /// this object.
    bsl::vector<Subscription>& subscriptions();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "AppId" attribute of this
    /// object.
    const bsl::string& appId() const;

    /// Return a reference to the non-modifiable "Subscriptions" attribute
    /// of this object.
    const bsl::vector<Subscription>& subscriptions() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const StreamParameters& lhs,
                       const StreamParameters& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const StreamParameters& lhs,
                       const StreamParameters& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&           stream,
                                const StreamParameters& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `StreamParameters`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::StreamParameters& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::StreamParameters)

namespace bmqp_ctrlmsg {

// ==================================
// class ClusterStateFSMMessageChoice
// ==================================

class ClusterStateFSMMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<FollowerLSNRequest>   d_followerLSNRequest;
        bsls::ObjectBuffer<FollowerLSNResponse>  d_followerLSNResponse;
        bsls::ObjectBuffer<RegistrationRequest>  d_registrationRequest;
        bsls::ObjectBuffer<RegistrationResponse> d_registrationResponse;
        bsls::ObjectBuffer<FollowerClusterStateRequest>
            d_followerClusterStateRequest;
        bsls::ObjectBuffer<FollowerClusterStateResponse>
            d_followerClusterStateResponse;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                       = -1,
        SELECTION_ID_FOLLOWER_L_S_N_REQUEST          = 0,
        SELECTION_ID_FOLLOWER_L_S_N_RESPONSE         = 1,
        SELECTION_ID_REGISTRATION_REQUEST            = 2,
        SELECTION_ID_REGISTRATION_RESPONSE           = 3,
        SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST  = 4,
        SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE = 5
    };

    enum { NUM_SELECTIONS = 6 };

    enum {
        SELECTION_INDEX_FOLLOWER_L_S_N_REQUEST          = 0,
        SELECTION_INDEX_FOLLOWER_L_S_N_RESPONSE         = 1,
        SELECTION_INDEX_REGISTRATION_REQUEST            = 2,
        SELECTION_INDEX_REGISTRATION_RESPONSE           = 3,
        SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_REQUEST  = 4,
        SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_RESPONSE = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS

    /// Return selection information for the selection indicated by the
    /// specified `id` if the selection exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);

    /// Return selection information for the selection indicated by the
    /// specified `name` of the specified `nameLength` if the selection
    /// exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ClusterStateFSMMessageChoice` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit ClusterStateFSMMessageChoice(
        bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ClusterStateFSMMessageChoice` having the
    /// value of the specified `original` object.  Use the optionally
    /// specified `basicAllocator` to supply memory.  If `basicAllocator` is
    /// 0, the currently installed default allocator is used.
    ClusterStateFSMMessageChoice(const ClusterStateFSMMessageChoice& original,
                                 bslma::Allocator* basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ClusterStateFSMMessageChoice` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.
    ClusterStateFSMMessageChoice(
        ClusterStateFSMMessageChoice&& original) noexcept;

    /// Create an object of type `ClusterStateFSMMessageChoice` having the
    /// value of the specified `original` object.  After performing this
    /// action, the `original` object will be left in a valid, but
    /// unspecified state.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    ClusterStateFSMMessageChoice(ClusterStateFSMMessageChoice&& original,
                                 bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~ClusterStateFSMMessageChoice();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ClusterStateFSMMessageChoice&
    operator=(const ClusterStateFSMMessageChoice& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ClusterStateFSMMessageChoice&
    operator=(ClusterStateFSMMessageChoice&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon default
    /// construction).
    void reset();

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `selectionId`.  Return 0 on success, and
    /// non-zero value otherwise (i.e., the selection is not found).
    int makeSelection(int selectionId);

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `name` of the specified `nameLength`.
    /// Return 0 on success, and non-zero value otherwise (i.e., the
    /// selection is not found).
    int makeSelection(const char* name, int nameLength);

    FollowerLSNRequest& makeFollowerLSNRequest();
    FollowerLSNRequest&
    makeFollowerLSNRequest(const FollowerLSNRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerLSNRequest& makeFollowerLSNRequest(FollowerLSNRequest&& value);
#endif
    // Set the value of this object to be a "FollowerLSNRequest" value.
    // Optionally specify the 'value' of the "FollowerLSNRequest".  If
    // 'value' is not specified, the default "FollowerLSNRequest" value is
    // used.

    FollowerLSNResponse& makeFollowerLSNResponse();
    FollowerLSNResponse&
    makeFollowerLSNResponse(const FollowerLSNResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerLSNResponse& makeFollowerLSNResponse(FollowerLSNResponse&& value);
#endif
    // Set the value of this object to be a "FollowerLSNResponse" value.
    // Optionally specify the 'value' of the "FollowerLSNResponse".  If
    // 'value' is not specified, the default "FollowerLSNResponse" value is
    // used.

    RegistrationRequest& makeRegistrationRequest();
    RegistrationRequest&
    makeRegistrationRequest(const RegistrationRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RegistrationRequest& makeRegistrationRequest(RegistrationRequest&& value);
#endif
    // Set the value of this object to be a "RegistrationRequest" value.
    // Optionally specify the 'value' of the "RegistrationRequest".  If
    // 'value' is not specified, the default "RegistrationRequest" value is
    // used.

    RegistrationResponse& makeRegistrationResponse();
    RegistrationResponse&
    makeRegistrationResponse(const RegistrationResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RegistrationResponse&
    makeRegistrationResponse(RegistrationResponse&& value);
#endif
    // Set the value of this object to be a "RegistrationResponse" value.
    // Optionally specify the 'value' of the "RegistrationResponse".  If
    // 'value' is not specified, the default "RegistrationResponse" value
    // is used.

    FollowerClusterStateRequest& makeFollowerClusterStateRequest();
    FollowerClusterStateRequest&
    makeFollowerClusterStateRequest(const FollowerClusterStateRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerClusterStateRequest&
    makeFollowerClusterStateRequest(FollowerClusterStateRequest&& value);
#endif
    // Set the value of this object to be a "FollowerClusterStateRequest"
    // value.  Optionally specify the 'value' of the
    // "FollowerClusterStateRequest".  If 'value' is not specified, the
    // default "FollowerClusterStateRequest" value is used.

    FollowerClusterStateResponse& makeFollowerClusterStateResponse();
    FollowerClusterStateResponse& makeFollowerClusterStateResponse(
        const FollowerClusterStateResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FollowerClusterStateResponse&
    makeFollowerClusterStateResponse(FollowerClusterStateResponse&& value);
#endif
    // Set the value of this object to be a "FollowerClusterStateResponse"
    // value.  Optionally specify the 'value' of the
    // "FollowerClusterStateResponse".  If 'value' is not specified, the
    // default "FollowerClusterStateResponse" value is used.

    /// Invoke the specified `manipulator` on the address of the modifiable
    /// selection, supplying `manipulator` with the corresponding selection
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if this object has a defined selection,
    /// and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateSelection(MANIPULATOR& manipulator);

    /// Return a reference to the modifiable "FollowerLSNRequest" selection
    /// of this object if "FollowerLSNRequest" is the current selection.
    /// The behavior is undefined unless "FollowerLSNRequest" is the
    /// selection of this object.
    FollowerLSNRequest& followerLSNRequest();

    /// Return a reference to the modifiable "FollowerLSNResponse" selection
    /// of this object if "FollowerLSNResponse" is the current selection.
    /// The behavior is undefined unless "FollowerLSNResponse" is the
    /// selection of this object.
    FollowerLSNResponse& followerLSNResponse();

    /// Return a reference to the modifiable "RegistrationRequest" selection
    /// of this object if "RegistrationRequest" is the current selection.
    /// The behavior is undefined unless "RegistrationRequest" is the
    /// selection of this object.
    RegistrationRequest& registrationRequest();

    /// Return a reference to the modifiable "RegistrationResponse"
    /// selection of this object if "RegistrationResponse" is the current
    /// selection.  The behavior is undefined unless "RegistrationResponse"
    /// is the selection of this object.
    RegistrationResponse& registrationResponse();

    /// Return a reference to the modifiable "FollowerClusterStateRequest"
    /// selection of this object if "FollowerClusterStateRequest" is the
    /// current selection.  The behavior is undefined unless
    /// "FollowerClusterStateRequest" is the selection of this object.
    FollowerClusterStateRequest& followerClusterStateRequest();

    /// Return a reference to the modifiable "FollowerClusterStateResponse"
    /// selection of this object if "FollowerClusterStateResponse" is the
    /// current selection.  The behavior is undefined unless
    /// "FollowerClusterStateResponse" is the selection of this object.
    FollowerClusterStateResponse& followerClusterStateResponse();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Return the id of the current selection if the selection is defined,
    /// and -1 otherwise.
    int selectionId() const;

    /// Invoke the specified `accessor` on the non-modifiable selection,
    /// supplying `accessor` with the corresponding selection information
    /// structure.  Return the value returned from the invocation of
    /// `accessor` if this object has a defined selection, and -1 otherwise.
    template <class ACCESSOR>
    int accessSelection(ACCESSOR& accessor) const;

    /// Return a reference to the non-modifiable "FollowerLSNRequest"
    /// selection of this object if "FollowerLSNRequest" is the current
    /// selection.  The behavior is undefined unless "FollowerLSNRequest" is
    /// the selection of this object.
    const FollowerLSNRequest& followerLSNRequest() const;

    /// Return a reference to the non-modifiable "FollowerLSNResponse"
    /// selection of this object if "FollowerLSNResponse" is the current
    /// selection.  The behavior is undefined unless "FollowerLSNResponse"
    /// is the selection of this object.
    const FollowerLSNResponse& followerLSNResponse() const;

    /// Return a reference to the non-modifiable "RegistrationRequest"
    /// selection of this object if "RegistrationRequest" is the current
    /// selection.  The behavior is undefined unless "RegistrationRequest"
    /// is the selection of this object.
    const RegistrationRequest& registrationRequest() const;

    /// Return a reference to the non-modifiable "RegistrationResponse"
    /// selection of this object if "RegistrationResponse" is the current
    /// selection.  The behavior is undefined unless "RegistrationResponse"
    /// is the selection of this object.
    const RegistrationResponse& registrationResponse() const;

    /// Return a reference to the non-modifiable
    /// "FollowerClusterStateRequest" selection of this object if
    /// "FollowerClusterStateRequest" is the current selection.  The
    /// behavior is undefined unless "FollowerClusterStateRequest" is the
    /// selection of this object.
    const FollowerClusterStateRequest& followerClusterStateRequest() const;

    /// Return a reference to the non-modifiable
    /// "FollowerClusterStateResponse" selection of this object if
    /// "FollowerClusterStateResponse" is the current selection.  The
    /// behavior is undefined unless "FollowerClusterStateResponse" is the
    /// selection of this object.
    const FollowerClusterStateResponse& followerClusterStateResponse() const;

    /// Return `true` if the value of this object is a "FollowerLSNRequest"
    /// value, and return `false` otherwise.
    bool isFollowerLSNRequestValue() const;

    /// Return `true` if the value of this object is a "FollowerLSNResponse"
    /// value, and return `false` otherwise.
    bool isFollowerLSNResponseValue() const;

    /// Return `true` if the value of this object is a "RegistrationRequest"
    /// value, and return `false` otherwise.
    bool isRegistrationRequestValue() const;

    /// Return `true` if the value of this object is a
    /// "RegistrationResponse" value, and return `false` otherwise.
    bool isRegistrationResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "FollowerClusterStateRequest" value, and return `false` otherwise.
    bool isFollowerClusterStateRequestValue() const;

    /// Return `true` if the value of this object is a
    /// "FollowerClusterStateResponse" value, and return `false` otherwise.
    bool isFollowerClusterStateResponseValue() const;

    /// Return `true` if the value of this object is undefined, and `false`
    /// otherwise.
    bool isUndefinedValue() const;

    /// Return the symbolic name of the current selection of this object.
    const char* selectionName() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` objects have the same
/// value, and `false` otherwise.  Two `ClusterStateFSMMessageChoice` objects
/// have the same value if either the selections in both objects have the same
/// ids and the same values, or both selections are undefined.
inline bool operator==(const ClusterStateFSMMessageChoice& lhs,
                       const ClusterStateFSMMessageChoice& rhs);

/// Return `true` if the specified `lhs` and `rhs` objects do not have the
/// same values, as determined by `operator==`, and `false` otherwise.
inline bool operator!=(const ClusterStateFSMMessageChoice& lhs,
                       const ClusterStateFSMMessageChoice& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                       stream,
                                const ClusterStateFSMMessageChoice& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ClusterStateFSMMessageChoice`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::ClusterStateFSMMessageChoice& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterStateFSMMessageChoice)

namespace bmqp_ctrlmsg {

// =====================
// class ConfigureStream
// =====================

/// This request contains parameters advertised by the downstream node so
/// that upstream node can configure subscriptions associated with the given
/// queue on the downstream node.
/// qId....................: Id identifying the queue
/// subscriptionParameters.: Parameters for configuring subscriptions
class ConfigureStream {
    // INSTANCE DATA
    StreamParameters d_streamParameters;
    unsigned int     d_qId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_Q_ID = 0, ATTRIBUTE_ID_STREAM_PARAMETERS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_Q_ID = 0, ATTRIBUTE_INDEX_STREAM_PARAMETERS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ConfigureStream` having the default value.
    ///  Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit ConfigureStream(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ConfigureStream` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ConfigureStream(const ConfigureStream& original,
                    bslma::Allocator*      basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ConfigureStream` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ConfigureStream(ConfigureStream&& original) noexcept;

    /// Create an object of type `ConfigureStream` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    ConfigureStream(ConfigureStream&& original,
                    bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~ConfigureStream();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ConfigureStream& operator=(const ConfigureStream& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ConfigureStream& operator=(ConfigureStream&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "QId" attribute of this object.
    unsigned int& qId();

    /// Return a reference to the modifiable "StreamParameters" attribute of
    /// this object.
    StreamParameters& streamParameters();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "QId" attribute of this
    /// object.
    unsigned int qId() const;

    /// Return a reference to the non-modifiable "StreamParameters"
    /// attribute of this object.
    const StreamParameters& streamParameters() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ConfigureStream& lhs, const ConfigureStream& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ConfigureStream& lhs, const ConfigureStream& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&          stream,
                                const ConfigureStream& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ConfigureStream`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                      hashAlg,
                const bmqp_ctrlmsg::ConfigureStream& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ConfigureStream)

namespace bmqp_ctrlmsg {

// ============================
// class ClusterStateFSMMessage
// ============================

/// This type is the top level type for any message being sent by a node
/// inside the cluster to one or more peer nodes that triggers an event in
/// the Cluster State FSM.  Note that this type of message is not sent
/// outside the cluster.
/// choice.: enumerates all the different types of cluster state messages
class ClusterStateFSMMessage {
    // INSTANCE DATA
    ClusterStateFSMMessageChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ClusterStateFSMMessage` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit ClusterStateFSMMessage(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ClusterStateFSMMessage` having the value
    /// of the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ClusterStateFSMMessage(const ClusterStateFSMMessage& original,
                           bslma::Allocator*             basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ClusterStateFSMMessage` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    ClusterStateFSMMessage(ClusterStateFSMMessage&& original) noexcept;

    /// Create an object of type `ClusterStateFSMMessage` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    ClusterStateFSMMessage(ClusterStateFSMMessage&& original,
                           bslma::Allocator*        basicAllocator);
#endif

    /// Destroy this object.
    ~ClusterStateFSMMessage();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ClusterStateFSMMessage& operator=(const ClusterStateFSMMessage& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ClusterStateFSMMessage& operator=(ClusterStateFSMMessage&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Choice" attribute of this
    /// object.
    ClusterStateFSMMessageChoice& choice();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Choice" attribute of this
    /// object.
    const ClusterStateFSMMessageChoice& choice() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ClusterStateFSMMessage& lhs,
                       const ClusterStateFSMMessage& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ClusterStateFSMMessage& lhs,
                       const ClusterStateFSMMessage& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                 stream,
                                const ClusterStateFSMMessage& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ClusterStateFSMMessage`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                             hashAlg,
                const bmqp_ctrlmsg::ClusterStateFSMMessage& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterStateFSMMessage)

namespace bmqp_ctrlmsg {

// =============================
// class ConfigureStreamResponse
// =============================

/// Response of a `ConfigureStream` request, indicating success of the
/// operation.
class ConfigureStreamResponse {
    // INSTANCE DATA
    ConfigureStream d_request;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_REQUEST = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_REQUEST = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ConfigureStreamResponse` having the
    /// default value.  Use the optionally specified `basicAllocator` to
    /// supply memory.  If `basicAllocator` is 0, the currently installed
    /// default allocator is used.
    explicit ConfigureStreamResponse(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ConfigureStreamResponse` having the value
    /// of the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ConfigureStreamResponse(const ConfigureStreamResponse& original,
                            bslma::Allocator*              basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ConfigureStreamResponse` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.
    ConfigureStreamResponse(ConfigureStreamResponse&& original) noexcept;

    /// Create an object of type `ConfigureStreamResponse` having the value
    /// of the specified `original` object.  After performing this action,
    /// the `original` object will be left in a valid, but unspecified
    /// state.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    ConfigureStreamResponse(ConfigureStreamResponse&& original,
                            bslma::Allocator*         basicAllocator);
#endif

    /// Destroy this object.
    ~ConfigureStreamResponse();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ConfigureStreamResponse& operator=(const ConfigureStreamResponse& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ConfigureStreamResponse& operator=(ConfigureStreamResponse&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Request" attribute of this
    /// object.
    ConfigureStream& request();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Request" attribute of this
    /// object.
    const ConfigureStream& request() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ConfigureStreamResponse& lhs,
                       const ConfigureStreamResponse& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ConfigureStreamResponse& lhs,
                       const ConfigureStreamResponse& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&                  stream,
                                const ConfigureStreamResponse& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ConfigureStreamResponse`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::ConfigureStreamResponse& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ConfigureStreamResponse)

namespace bmqp_ctrlmsg {

// ==========================
// class ClusterMessageChoice
// ==========================

class ClusterMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<PartitionPrimaryAdvisory>
                                                    d_partitionPrimaryAdvisory;
        bsls::ObjectBuffer<LeaderAdvisory>          d_leaderAdvisory;
        bsls::ObjectBuffer<QueueAssignmentAdvisory> d_queueAssignmentAdvisory;
        bsls::ObjectBuffer<NodeStatusAdvisory>      d_nodeStatusAdvisory;
        bsls::ObjectBuffer<LeaderSyncStateQuery>    d_leaderSyncStateQuery;
        bsls::ObjectBuffer<LeaderSyncStateQueryResponse>
                                                d_leaderSyncStateQueryResponse;
        bsls::ObjectBuffer<LeaderSyncDataQuery> d_leaderSyncDataQuery;
        bsls::ObjectBuffer<LeaderSyncDataQueryResponse>
            d_leaderSyncDataQueryResponse;
        bsls::ObjectBuffer<QueueAssignmentRequest>  d_queueAssignmentRequest;
        bsls::ObjectBuffer<StorageSyncRequest>      d_storageSyncRequest;
        bsls::ObjectBuffer<StorageSyncResponse>     d_storageSyncResponse;
        bsls::ObjectBuffer<PartitionSyncStateQuery> d_partitionSyncStateQuery;
        bsls::ObjectBuffer<PartitionSyncStateQueryResponse>
            d_partitionSyncStateQueryResponse;
        bsls::ObjectBuffer<PartitionSyncDataQuery> d_partitionSyncDataQuery;
        bsls::ObjectBuffer<PartitionSyncDataQueryResponse>
            d_partitionSyncDataQueryResponse;
        bsls::ObjectBuffer<PartitionSyncDataQueryStatus>
            d_partitionSyncDataQueryStatus;
        bsls::ObjectBuffer<PrimaryStatusAdvisory> d_primaryStatusAdvisory;
        bsls::ObjectBuffer<ClusterSyncRequest>    d_clusterSyncRequest;
        bsls::ObjectBuffer<ClusterSyncResponse>   d_clusterSyncResponse;
        bsls::ObjectBuffer<QueueUnAssignmentAdvisory>
            d_queueUnAssignmentAdvisory;
        bsls::ObjectBuffer<QueueUnassignedAdvisory> d_queueUnassignedAdvisory;
        bsls::ObjectBuffer<LeaderAdvisoryAck>       d_leaderAdvisoryAck;
        bsls::ObjectBuffer<LeaderAdvisoryCommit>    d_leaderAdvisoryCommit;
        bsls::ObjectBuffer<StateNotification>       d_stateNotification;
        bsls::ObjectBuffer<StopRequest>             d_stopRequest;
        bsls::ObjectBuffer<StopResponse>            d_stopResponse;
        bsls::ObjectBuffer<QueueUnassignmentRequest>
                                                   d_queueUnassignmentRequest;
        bsls::ObjectBuffer<QueueUpdateAdvisory>    d_queueUpdateAdvisory;
        bsls::ObjectBuffer<ClusterStateFSMMessage> d_clusterStateFSMMessage;
        bsls::ObjectBuffer<PartitionMessage>       d_partitionMessage;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                           = -1,
        SELECTION_ID_PARTITION_PRIMARY_ADVISORY          = 0,
        SELECTION_ID_LEADER_ADVISORY                     = 1,
        SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY           = 2,
        SELECTION_ID_NODE_STATUS_ADVISORY                = 3,
        SELECTION_ID_LEADER_SYNC_STATE_QUERY             = 4,
        SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE    = 5,
        SELECTION_ID_LEADER_SYNC_DATA_QUERY              = 6,
        SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE     = 7,
        SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST            = 8,
        SELECTION_ID_STORAGE_SYNC_REQUEST                = 9,
        SELECTION_ID_STORAGE_SYNC_RESPONSE               = 10,
        SELECTION_ID_PARTITION_SYNC_STATE_QUERY          = 11,
        SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE = 12,
        SELECTION_ID_PARTITION_SYNC_DATA_QUERY           = 13,
        SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE  = 14,
        SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS    = 15,
        SELECTION_ID_PRIMARY_STATUS_ADVISORY             = 16,
        SELECTION_ID_CLUSTER_SYNC_REQUEST                = 17,
        SELECTION_ID_CLUSTER_SYNC_RESPONSE               = 18,
        SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY        = 19,
        SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY           = 20,
        SELECTION_ID_LEADER_ADVISORY_ACK                 = 21,
        SELECTION_ID_LEADER_ADVISORY_COMMIT              = 22,
        SELECTION_ID_STATE_NOTIFICATION                  = 23,
        SELECTION_ID_STOP_REQUEST                        = 24,
        SELECTION_ID_STOP_RESPONSE                       = 25,
        SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST          = 26,
        SELECTION_ID_QUEUE_UPDATE_ADVISORY               = 27,
        SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE         = 28,
        SELECTION_ID_PARTITION_MESSAGE                   = 29
    };

    enum { NUM_SELECTIONS = 30 };

    enum {
        SELECTION_INDEX_PARTITION_PRIMARY_ADVISORY          = 0,
        SELECTION_INDEX_LEADER_ADVISORY                     = 1,
        SELECTION_INDEX_QUEUE_ASSIGNMENT_ADVISORY           = 2,
        SELECTION_INDEX_NODE_STATUS_ADVISORY                = 3,
        SELECTION_INDEX_LEADER_SYNC_STATE_QUERY             = 4,
        SELECTION_INDEX_LEADER_SYNC_STATE_QUERY_RESPONSE    = 5,
        SELECTION_INDEX_LEADER_SYNC_DATA_QUERY              = 6,
        SELECTION_INDEX_LEADER_SYNC_DATA_QUERY_RESPONSE     = 7,
        SELECTION_INDEX_QUEUE_ASSIGNMENT_REQUEST            = 8,
        SELECTION_INDEX_STORAGE_SYNC_REQUEST                = 9,
        SELECTION_INDEX_STORAGE_SYNC_RESPONSE               = 10,
        SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY          = 11,
        SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY_RESPONSE = 12,
        SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY           = 13,
        SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_RESPONSE  = 14,
        SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_STATUS    = 15,
        SELECTION_INDEX_PRIMARY_STATUS_ADVISORY             = 16,
        SELECTION_INDEX_CLUSTER_SYNC_REQUEST                = 17,
        SELECTION_INDEX_CLUSTER_SYNC_RESPONSE               = 18,
        SELECTION_INDEX_QUEUE_UN_ASSIGNMENT_ADVISORY        = 19,
        SELECTION_INDEX_QUEUE_UNASSIGNED_ADVISORY           = 20,
        SELECTION_INDEX_LEADER_ADVISORY_ACK                 = 21,
        SELECTION_INDEX_LEADER_ADVISORY_COMMIT              = 22,
        SELECTION_INDEX_STATE_NOTIFICATION                  = 23,
        SELECTION_INDEX_STOP_REQUEST                        = 24,
        SELECTION_INDEX_STOP_RESPONSE                       = 25,
        SELECTION_INDEX_QUEUE_UNASSIGNMENT_REQUEST          = 26,
        SELECTION_INDEX_QUEUE_UPDATE_ADVISORY               = 27,
        SELECTION_INDEX_CLUSTER_STATE_F_S_M_MESSAGE         = 28,
        SELECTION_INDEX_PARTITION_MESSAGE                   = 29
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS

    /// Return selection information for the selection indicated by the
    /// specified `id` if the selection exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);

    /// Return selection information for the selection indicated by the
    /// specified `name` of the specified `nameLength` if the selection
    /// exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ClusterMessageChoice` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit ClusterMessageChoice(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ClusterMessageChoice` having the value of
    /// the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ClusterMessageChoice(const ClusterMessageChoice& original,
                         bslma::Allocator*           basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ClusterMessageChoice` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ClusterMessageChoice(ClusterMessageChoice&& original) noexcept;

    /// Create an object of type `ClusterMessageChoice` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    ClusterMessageChoice(ClusterMessageChoice&& original,
                         bslma::Allocator*      basicAllocator);
#endif

    /// Destroy this object.
    ~ClusterMessageChoice();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ClusterMessageChoice& operator=(const ClusterMessageChoice& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ClusterMessageChoice& operator=(ClusterMessageChoice&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon default
    /// construction).
    void reset();

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `selectionId`.  Return 0 on success, and
    /// non-zero value otherwise (i.e., the selection is not found).
    int makeSelection(int selectionId);

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `name` of the specified `nameLength`.
    /// Return 0 on success, and non-zero value otherwise (i.e., the
    /// selection is not found).
    int makeSelection(const char* name, int nameLength);

    PartitionPrimaryAdvisory& makePartitionPrimaryAdvisory();
    PartitionPrimaryAdvisory&
    makePartitionPrimaryAdvisory(const PartitionPrimaryAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionPrimaryAdvisory&
    makePartitionPrimaryAdvisory(PartitionPrimaryAdvisory&& value);
#endif
    // Set the value of this object to be a "PartitionPrimaryAdvisory"
    // value.  Optionally specify the 'value' of the
    // "PartitionPrimaryAdvisory".  If 'value' is not specified, the
    // default "PartitionPrimaryAdvisory" value is used.

    LeaderAdvisory& makeLeaderAdvisory();
    LeaderAdvisory& makeLeaderAdvisory(const LeaderAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderAdvisory& makeLeaderAdvisory(LeaderAdvisory&& value);
#endif
    // Set the value of this object to be a "LeaderAdvisory" value.
    // Optionally specify the 'value' of the "LeaderAdvisory".  If 'value'
    // is not specified, the default "LeaderAdvisory" value is used.

    QueueAssignmentAdvisory& makeQueueAssignmentAdvisory();
    QueueAssignmentAdvisory&
    makeQueueAssignmentAdvisory(const QueueAssignmentAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueAssignmentAdvisory&
    makeQueueAssignmentAdvisory(QueueAssignmentAdvisory&& value);
#endif
    // Set the value of this object to be a "QueueAssignmentAdvisory"
    // value.  Optionally specify the 'value' of the
    // "QueueAssignmentAdvisory".  If 'value' is not specified, the default
    // "QueueAssignmentAdvisory" value is used.

    NodeStatusAdvisory& makeNodeStatusAdvisory();
    NodeStatusAdvisory&
    makeNodeStatusAdvisory(const NodeStatusAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    NodeStatusAdvisory& makeNodeStatusAdvisory(NodeStatusAdvisory&& value);
#endif
    // Set the value of this object to be a "NodeStatusAdvisory" value.
    // Optionally specify the 'value' of the "NodeStatusAdvisory".  If
    // 'value' is not specified, the default "NodeStatusAdvisory" value is
    // used.

    LeaderSyncStateQuery& makeLeaderSyncStateQuery();
    LeaderSyncStateQuery&
    makeLeaderSyncStateQuery(const LeaderSyncStateQuery& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncStateQuery&
    makeLeaderSyncStateQuery(LeaderSyncStateQuery&& value);
#endif
    // Set the value of this object to be a "LeaderSyncStateQuery" value.
    // Optionally specify the 'value' of the "LeaderSyncStateQuery".  If
    // 'value' is not specified, the default "LeaderSyncStateQuery" value
    // is used.

    LeaderSyncStateQueryResponse& makeLeaderSyncStateQueryResponse();
    LeaderSyncStateQueryResponse& makeLeaderSyncStateQueryResponse(
        const LeaderSyncStateQueryResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncStateQueryResponse&
    makeLeaderSyncStateQueryResponse(LeaderSyncStateQueryResponse&& value);
#endif
    // Set the value of this object to be a "LeaderSyncStateQueryResponse"
    // value.  Optionally specify the 'value' of the
    // "LeaderSyncStateQueryResponse".  If 'value' is not specified, the
    // default "LeaderSyncStateQueryResponse" value is used.

    LeaderSyncDataQuery& makeLeaderSyncDataQuery();
    LeaderSyncDataQuery&
    makeLeaderSyncDataQuery(const LeaderSyncDataQuery& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncDataQuery& makeLeaderSyncDataQuery(LeaderSyncDataQuery&& value);
#endif
    // Set the value of this object to be a "LeaderSyncDataQuery" value.
    // Optionally specify the 'value' of the "LeaderSyncDataQuery".  If
    // 'value' is not specified, the default "LeaderSyncDataQuery" value is
    // used.

    LeaderSyncDataQueryResponse& makeLeaderSyncDataQueryResponse();
    LeaderSyncDataQueryResponse&
    makeLeaderSyncDataQueryResponse(const LeaderSyncDataQueryResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderSyncDataQueryResponse&
    makeLeaderSyncDataQueryResponse(LeaderSyncDataQueryResponse&& value);
#endif
    // Set the value of this object to be a "LeaderSyncDataQueryResponse"
    // value.  Optionally specify the 'value' of the
    // "LeaderSyncDataQueryResponse".  If 'value' is not specified, the
    // default "LeaderSyncDataQueryResponse" value is used.

    QueueAssignmentRequest& makeQueueAssignmentRequest();
    QueueAssignmentRequest&
    makeQueueAssignmentRequest(const QueueAssignmentRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueAssignmentRequest&
    makeQueueAssignmentRequest(QueueAssignmentRequest&& value);
#endif
    // Set the value of this object to be a "QueueAssignmentRequest" value.
    //  Optionally specify the 'value' of the "QueueAssignmentRequest".  If
    // 'value' is not specified, the default "QueueAssignmentRequest" value
    // is used.

    StorageSyncRequest& makeStorageSyncRequest();
    StorageSyncRequest&
    makeStorageSyncRequest(const StorageSyncRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageSyncRequest& makeStorageSyncRequest(StorageSyncRequest&& value);
#endif
    // Set the value of this object to be a "StorageSyncRequest" value.
    // Optionally specify the 'value' of the "StorageSyncRequest".  If
    // 'value' is not specified, the default "StorageSyncRequest" value is
    // used.

    StorageSyncResponse& makeStorageSyncResponse();
    StorageSyncResponse&
    makeStorageSyncResponse(const StorageSyncResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageSyncResponse& makeStorageSyncResponse(StorageSyncResponse&& value);
#endif
    // Set the value of this object to be a "StorageSyncResponse" value.
    // Optionally specify the 'value' of the "StorageSyncResponse".  If
    // 'value' is not specified, the default "StorageSyncResponse" value is
    // used.

    PartitionSyncStateQuery& makePartitionSyncStateQuery();
    PartitionSyncStateQuery&
    makePartitionSyncStateQuery(const PartitionSyncStateQuery& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncStateQuery&
    makePartitionSyncStateQuery(PartitionSyncStateQuery&& value);
#endif
    // Set the value of this object to be a "PartitionSyncStateQuery"
    // value.  Optionally specify the 'value' of the
    // "PartitionSyncStateQuery".  If 'value' is not specified, the default
    // "PartitionSyncStateQuery" value is used.

    PartitionSyncStateQueryResponse& makePartitionSyncStateQueryResponse();
    PartitionSyncStateQueryResponse& makePartitionSyncStateQueryResponse(
        const PartitionSyncStateQueryResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncStateQueryResponse& makePartitionSyncStateQueryResponse(
        PartitionSyncStateQueryResponse&& value);
#endif
    // Set the value of this object to be a
    // "PartitionSyncStateQueryResponse" value.  Optionally specify the
    // 'value' of the "PartitionSyncStateQueryResponse".  If 'value' is not
    // specified, the default "PartitionSyncStateQueryResponse" value is
    // used.

    PartitionSyncDataQuery& makePartitionSyncDataQuery();
    PartitionSyncDataQuery&
    makePartitionSyncDataQuery(const PartitionSyncDataQuery& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncDataQuery&
    makePartitionSyncDataQuery(PartitionSyncDataQuery&& value);
#endif
    // Set the value of this object to be a "PartitionSyncDataQuery" value.
    //  Optionally specify the 'value' of the "PartitionSyncDataQuery".  If
    // 'value' is not specified, the default "PartitionSyncDataQuery" value
    // is used.

    PartitionSyncDataQueryResponse& makePartitionSyncDataQueryResponse();
    PartitionSyncDataQueryResponse& makePartitionSyncDataQueryResponse(
        const PartitionSyncDataQueryResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncDataQueryResponse&
    makePartitionSyncDataQueryResponse(PartitionSyncDataQueryResponse&& value);
#endif
    // Set the value of this object to be a
    // "PartitionSyncDataQueryResponse" value.  Optionally specify the
    // 'value' of the "PartitionSyncDataQueryResponse".  If 'value' is not
    // specified, the default "PartitionSyncDataQueryResponse" value is
    // used.

    PartitionSyncDataQueryStatus& makePartitionSyncDataQueryStatus();
    PartitionSyncDataQueryStatus& makePartitionSyncDataQueryStatus(
        const PartitionSyncDataQueryStatus& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionSyncDataQueryStatus&
    makePartitionSyncDataQueryStatus(PartitionSyncDataQueryStatus&& value);
#endif
    // Set the value of this object to be a "PartitionSyncDataQueryStatus"
    // value.  Optionally specify the 'value' of the
    // "PartitionSyncDataQueryStatus".  If 'value' is not specified, the
    // default "PartitionSyncDataQueryStatus" value is used.

    PrimaryStatusAdvisory& makePrimaryStatusAdvisory();
    PrimaryStatusAdvisory&
    makePrimaryStatusAdvisory(const PrimaryStatusAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PrimaryStatusAdvisory&
    makePrimaryStatusAdvisory(PrimaryStatusAdvisory&& value);
#endif
    // Set the value of this object to be a "PrimaryStatusAdvisory" value.
    // Optionally specify the 'value' of the "PrimaryStatusAdvisory".  If
    // 'value' is not specified, the default "PrimaryStatusAdvisory" value
    // is used.

    ClusterSyncRequest& makeClusterSyncRequest();
    ClusterSyncRequest&
    makeClusterSyncRequest(const ClusterSyncRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterSyncRequest& makeClusterSyncRequest(ClusterSyncRequest&& value);
#endif
    // Set the value of this object to be a "ClusterSyncRequest" value.
    // Optionally specify the 'value' of the "ClusterSyncRequest".  If
    // 'value' is not specified, the default "ClusterSyncRequest" value is
    // used.

    ClusterSyncResponse& makeClusterSyncResponse();
    ClusterSyncResponse&
    makeClusterSyncResponse(const ClusterSyncResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterSyncResponse& makeClusterSyncResponse(ClusterSyncResponse&& value);
#endif
    // Set the value of this object to be a "ClusterSyncResponse" value.
    // Optionally specify the 'value' of the "ClusterSyncResponse".  If
    // 'value' is not specified, the default "ClusterSyncResponse" value is
    // used.

    QueueUnAssignmentAdvisory& makeQueueUnAssignmentAdvisory();
    QueueUnAssignmentAdvisory&
    makeQueueUnAssignmentAdvisory(const QueueUnAssignmentAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnAssignmentAdvisory&
    makeQueueUnAssignmentAdvisory(QueueUnAssignmentAdvisory&& value);
#endif
    // Set the value of this object to be a "QueueUnAssignmentAdvisory"
    // value.  Optionally specify the 'value' of the
    // "QueueUnAssignmentAdvisory".  If 'value' is not specified, the
    // default "QueueUnAssignmentAdvisory" value is used.

    QueueUnassignedAdvisory& makeQueueUnassignedAdvisory();
    QueueUnassignedAdvisory&
    makeQueueUnassignedAdvisory(const QueueUnassignedAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnassignedAdvisory&
    makeQueueUnassignedAdvisory(QueueUnassignedAdvisory&& value);
#endif
    // Set the value of this object to be a "QueueUnassignedAdvisory"
    // value.  Optionally specify the 'value' of the
    // "QueueUnassignedAdvisory".  If 'value' is not specified, the default
    // "QueueUnassignedAdvisory" value is used.

    LeaderAdvisoryAck& makeLeaderAdvisoryAck();
    LeaderAdvisoryAck& makeLeaderAdvisoryAck(const LeaderAdvisoryAck& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderAdvisoryAck& makeLeaderAdvisoryAck(LeaderAdvisoryAck&& value);
#endif
    // Set the value of this object to be a "LeaderAdvisoryAck" value.
    // Optionally specify the 'value' of the "LeaderAdvisoryAck".  If
    // 'value' is not specified, the default "LeaderAdvisoryAck" value is
    // used.

    LeaderAdvisoryCommit& makeLeaderAdvisoryCommit();
    LeaderAdvisoryCommit&
    makeLeaderAdvisoryCommit(const LeaderAdvisoryCommit& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeaderAdvisoryCommit&
    makeLeaderAdvisoryCommit(LeaderAdvisoryCommit&& value);
#endif
    // Set the value of this object to be a "LeaderAdvisoryCommit" value.
    // Optionally specify the 'value' of the "LeaderAdvisoryCommit".  If
    // 'value' is not specified, the default "LeaderAdvisoryCommit" value
    // is used.

    StateNotification& makeStateNotification();
    StateNotification& makeStateNotification(const StateNotification& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StateNotification& makeStateNotification(StateNotification&& value);
#endif
    // Set the value of this object to be a "StateNotification" value.
    // Optionally specify the 'value' of the "StateNotification".  If
    // 'value' is not specified, the default "StateNotification" value is
    // used.

    StopRequest& makeStopRequest();
    StopRequest& makeStopRequest(const StopRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StopRequest& makeStopRequest(StopRequest&& value);
#endif
    // Set the value of this object to be a "StopRequest" value.
    // Optionally specify the 'value' of the "StopRequest".  If 'value' is
    // not specified, the default "StopRequest" value is used.

    StopResponse& makeStopResponse();
    StopResponse& makeStopResponse(const StopResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StopResponse& makeStopResponse(StopResponse&& value);
#endif
    // Set the value of this object to be a "StopResponse" value.
    // Optionally specify the 'value' of the "StopResponse".  If 'value' is
    // not specified, the default "StopResponse" value is used.

    QueueUnassignmentRequest& makeQueueUnassignmentRequest();
    QueueUnassignmentRequest&
    makeQueueUnassignmentRequest(const QueueUnassignmentRequest& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUnassignmentRequest&
    makeQueueUnassignmentRequest(QueueUnassignmentRequest&& value);
#endif
    // Set the value of this object to be a "QueueUnassignmentRequest"
    // value.  Optionally specify the 'value' of the
    // "QueueUnassignmentRequest".  If 'value' is not specified, the
    // default "QueueUnassignmentRequest" value is used.

    QueueUpdateAdvisory& makeQueueUpdateAdvisory();
    QueueUpdateAdvisory&
    makeQueueUpdateAdvisory(const QueueUpdateAdvisory& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueUpdateAdvisory& makeQueueUpdateAdvisory(QueueUpdateAdvisory&& value);
#endif
    // Set the value of this object to be a "QueueUpdateAdvisory" value.
    // Optionally specify the 'value' of the "QueueUpdateAdvisory".  If
    // 'value' is not specified, the default "QueueUpdateAdvisory" value is
    // used.

    ClusterStateFSMMessage& makeClusterStateFSMMessage();
    ClusterStateFSMMessage&
    makeClusterStateFSMMessage(const ClusterStateFSMMessage& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateFSMMessage&
    makeClusterStateFSMMessage(ClusterStateFSMMessage&& value);
#endif
    // Set the value of this object to be a "ClusterStateFSMMessage" value.
    //  Optionally specify the 'value' of the "ClusterStateFSMMessage".  If
    // 'value' is not specified, the default "ClusterStateFSMMessage" value
    // is used.

    PartitionMessage& makePartitionMessage();
    PartitionMessage& makePartitionMessage(const PartitionMessage& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionMessage& makePartitionMessage(PartitionMessage&& value);
#endif
    // Set the value of this object to be a "PartitionMessage" value.
    // Optionally specify the 'value' of the "PartitionMessage".  If
    // 'value' is not specified, the default "PartitionMessage" value is
    // used.

    /// Invoke the specified `manipulator` on the address of the modifiable
    /// selection, supplying `manipulator` with the corresponding selection
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if this object has a defined selection,
    /// and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateSelection(MANIPULATOR& manipulator);

    /// Return a reference to the modifiable "PartitionPrimaryAdvisory"
    /// selection of this object if "PartitionPrimaryAdvisory" is the
    /// current selection.  The behavior is undefined unless
    /// "PartitionPrimaryAdvisory" is the selection of this object.
    PartitionPrimaryAdvisory& partitionPrimaryAdvisory();

    /// Return a reference to the modifiable "LeaderAdvisory" selection of
    /// this object if "LeaderAdvisory" is the current selection.  The
    /// behavior is undefined unless "LeaderAdvisory" is the selection of
    /// this object.
    LeaderAdvisory& leaderAdvisory();

    /// Return a reference to the modifiable "QueueAssignmentAdvisory"
    /// selection of this object if "QueueAssignmentAdvisory" is the current
    /// selection.  The behavior is undefined unless
    /// "QueueAssignmentAdvisory" is the selection of this object.
    QueueAssignmentAdvisory& queueAssignmentAdvisory();

    /// Return a reference to the modifiable "NodeStatusAdvisory" selection
    /// of this object if "NodeStatusAdvisory" is the current selection.
    /// The behavior is undefined unless "NodeStatusAdvisory" is the
    /// selection of this object.
    NodeStatusAdvisory& nodeStatusAdvisory();

    /// Return a reference to the modifiable "LeaderSyncStateQuery"
    /// selection of this object if "LeaderSyncStateQuery" is the current
    /// selection.  The behavior is undefined unless "LeaderSyncStateQuery"
    /// is the selection of this object.
    LeaderSyncStateQuery& leaderSyncStateQuery();

    /// Return a reference to the modifiable "LeaderSyncStateQueryResponse"
    /// selection of this object if "LeaderSyncStateQueryResponse" is the
    /// current selection.  The behavior is undefined unless
    /// "LeaderSyncStateQueryResponse" is the selection of this object.
    LeaderSyncStateQueryResponse& leaderSyncStateQueryResponse();

    /// Return a reference to the modifiable "LeaderSyncDataQuery" selection
    /// of this object if "LeaderSyncDataQuery" is the current selection.
    /// The behavior is undefined unless "LeaderSyncDataQuery" is the
    /// selection of this object.
    LeaderSyncDataQuery& leaderSyncDataQuery();

    /// Return a reference to the modifiable "LeaderSyncDataQueryResponse"
    /// selection of this object if "LeaderSyncDataQueryResponse" is the
    /// current selection.  The behavior is undefined unless
    /// "LeaderSyncDataQueryResponse" is the selection of this object.
    LeaderSyncDataQueryResponse& leaderSyncDataQueryResponse();

    /// Return a reference to the modifiable "QueueAssignmentRequest"
    /// selection of this object if "QueueAssignmentRequest" is the current
    /// selection.  The behavior is undefined unless
    /// "QueueAssignmentRequest" is the selection of this object.
    QueueAssignmentRequest& queueAssignmentRequest();

    /// Return a reference to the modifiable "StorageSyncRequest" selection
    /// of this object if "StorageSyncRequest" is the current selection.
    /// The behavior is undefined unless "StorageSyncRequest" is the
    /// selection of this object.
    StorageSyncRequest& storageSyncRequest();

    /// Return a reference to the modifiable "StorageSyncResponse" selection
    /// of this object if "StorageSyncResponse" is the current selection.
    /// The behavior is undefined unless "StorageSyncResponse" is the
    /// selection of this object.
    StorageSyncResponse& storageSyncResponse();

    /// Return a reference to the modifiable "PartitionSyncStateQuery"
    /// selection of this object if "PartitionSyncStateQuery" is the current
    /// selection.  The behavior is undefined unless
    /// "PartitionSyncStateQuery" is the selection of this object.
    PartitionSyncStateQuery& partitionSyncStateQuery();

    /// Return a reference to the modifiable
    /// "PartitionSyncStateQueryResponse" selection of this object if
    /// "PartitionSyncStateQueryResponse" is the current selection.  The
    /// behavior is undefined unless "PartitionSyncStateQueryResponse" is
    /// the selection of this object.
    PartitionSyncStateQueryResponse& partitionSyncStateQueryResponse();

    /// Return a reference to the modifiable "PartitionSyncDataQuery"
    /// selection of this object if "PartitionSyncDataQuery" is the current
    /// selection.  The behavior is undefined unless
    /// "PartitionSyncDataQuery" is the selection of this object.
    PartitionSyncDataQuery& partitionSyncDataQuery();

    /// Return a reference to the modifiable
    /// "PartitionSyncDataQueryResponse" selection of this object if
    /// "PartitionSyncDataQueryResponse" is the current selection.  The
    /// behavior is undefined unless "PartitionSyncDataQueryResponse" is the
    /// selection of this object.
    PartitionSyncDataQueryResponse& partitionSyncDataQueryResponse();

    /// Return a reference to the modifiable "PartitionSyncDataQueryStatus"
    /// selection of this object if "PartitionSyncDataQueryStatus" is the
    /// current selection.  The behavior is undefined unless
    /// "PartitionSyncDataQueryStatus" is the selection of this object.
    PartitionSyncDataQueryStatus& partitionSyncDataQueryStatus();

    /// Return a reference to the modifiable "PrimaryStatusAdvisory"
    /// selection of this object if "PrimaryStatusAdvisory" is the current
    /// selection.  The behavior is undefined unless "PrimaryStatusAdvisory"
    /// is the selection of this object.
    PrimaryStatusAdvisory& primaryStatusAdvisory();

    /// Return a reference to the modifiable "ClusterSyncRequest" selection
    /// of this object if "ClusterSyncRequest" is the current selection.
    /// The behavior is undefined unless "ClusterSyncRequest" is the
    /// selection of this object.
    ClusterSyncRequest& clusterSyncRequest();

    /// Return a reference to the modifiable "ClusterSyncResponse" selection
    /// of this object if "ClusterSyncResponse" is the current selection.
    /// The behavior is undefined unless "ClusterSyncResponse" is the
    /// selection of this object.
    ClusterSyncResponse& clusterSyncResponse();

    /// Return a reference to the modifiable "QueueUnAssignmentAdvisory"
    /// selection of this object if "QueueUnAssignmentAdvisory" is the
    /// current selection.  The behavior is undefined unless
    /// "QueueUnAssignmentAdvisory" is the selection of this object.
    QueueUnAssignmentAdvisory& queueUnAssignmentAdvisory();

    /// Return a reference to the modifiable "QueueUnassignedAdvisory"
    /// selection of this object if "QueueUnassignedAdvisory" is the current
    /// selection.  The behavior is undefined unless
    /// "QueueUnassignedAdvisory" is the selection of this object.
    QueueUnassignedAdvisory& queueUnassignedAdvisory();

    /// Return a reference to the modifiable "LeaderAdvisoryAck" selection
    /// of this object if "LeaderAdvisoryAck" is the current selection.  The
    /// behavior is undefined unless "LeaderAdvisoryAck" is the selection of
    /// this object.
    LeaderAdvisoryAck& leaderAdvisoryAck();

    /// Return a reference to the modifiable "LeaderAdvisoryCommit"
    /// selection of this object if "LeaderAdvisoryCommit" is the current
    /// selection.  The behavior is undefined unless "LeaderAdvisoryCommit"
    /// is the selection of this object.
    LeaderAdvisoryCommit& leaderAdvisoryCommit();

    /// Return a reference to the modifiable "StateNotification" selection
    /// of this object if "StateNotification" is the current selection.  The
    /// behavior is undefined unless "StateNotification" is the selection of
    /// this object.
    StateNotification& stateNotification();

    /// Return a reference to the modifiable "StopRequest" selection of this
    /// object if "StopRequest" is the current selection.  The behavior is
    /// undefined unless "StopRequest" is the selection of this object.
    StopRequest& stopRequest();

    /// Return a reference to the modifiable "StopResponse" selection of
    /// this object if "StopResponse" is the current selection.  The
    /// behavior is undefined unless "StopResponse" is the selection of this
    /// object.
    StopResponse& stopResponse();

    /// Return a reference to the modifiable "QueueUnassignmentRequest"
    /// selection of this object if "QueueUnassignmentRequest" is the
    /// current selection.  The behavior is undefined unless
    /// "QueueUnassignmentRequest" is the selection of this object.
    QueueUnassignmentRequest& queueUnassignmentRequest();

    /// Return a reference to the modifiable "QueueUpdateAdvisory" selection
    /// of this object if "QueueUpdateAdvisory" is the current selection.
    /// The behavior is undefined unless "QueueUpdateAdvisory" is the
    /// selection of this object.
    QueueUpdateAdvisory& queueUpdateAdvisory();

    /// Return a reference to the modifiable "ClusterStateFSMMessage"
    /// selection of this object if "ClusterStateFSMMessage" is the current
    /// selection.  The behavior is undefined unless
    /// "ClusterStateFSMMessage" is the selection of this object.
    ClusterStateFSMMessage& clusterStateFSMMessage();

    /// Return a reference to the modifiable "PartitionMessage" selection of
    /// this object if "PartitionMessage" is the current selection.  The
    /// behavior is undefined unless "PartitionMessage" is the selection of
    /// this object.
    PartitionMessage& partitionMessage();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Return the id of the current selection if the selection is defined,
    /// and -1 otherwise.
    int selectionId() const;

    /// Invoke the specified `accessor` on the non-modifiable selection,
    /// supplying `accessor` with the corresponding selection information
    /// structure.  Return the value returned from the invocation of
    /// `accessor` if this object has a defined selection, and -1 otherwise.
    template <class ACCESSOR>
    int accessSelection(ACCESSOR& accessor) const;

    /// Return a reference to the non-modifiable "PartitionPrimaryAdvisory"
    /// selection of this object if "PartitionPrimaryAdvisory" is the
    /// current selection.  The behavior is undefined unless
    /// "PartitionPrimaryAdvisory" is the selection of this object.
    const PartitionPrimaryAdvisory& partitionPrimaryAdvisory() const;

    /// Return a reference to the non-modifiable "LeaderAdvisory" selection
    /// of this object if "LeaderAdvisory" is the current selection.  The
    /// behavior is undefined unless "LeaderAdvisory" is the selection of
    /// this object.
    const LeaderAdvisory& leaderAdvisory() const;

    /// Return a reference to the non-modifiable "QueueAssignmentAdvisory"
    /// selection of this object if "QueueAssignmentAdvisory" is the current
    /// selection.  The behavior is undefined unless
    /// "QueueAssignmentAdvisory" is the selection of this object.
    const QueueAssignmentAdvisory& queueAssignmentAdvisory() const;

    /// Return a reference to the non-modifiable "NodeStatusAdvisory"
    /// selection of this object if "NodeStatusAdvisory" is the current
    /// selection.  The behavior is undefined unless "NodeStatusAdvisory" is
    /// the selection of this object.
    const NodeStatusAdvisory& nodeStatusAdvisory() const;

    /// Return a reference to the non-modifiable "LeaderSyncStateQuery"
    /// selection of this object if "LeaderSyncStateQuery" is the current
    /// selection.  The behavior is undefined unless "LeaderSyncStateQuery"
    /// is the selection of this object.
    const LeaderSyncStateQuery& leaderSyncStateQuery() const;

    /// Return a reference to the non-modifiable
    /// "LeaderSyncStateQueryResponse" selection of this object if
    /// "LeaderSyncStateQueryResponse" is the current selection.  The
    /// behavior is undefined unless "LeaderSyncStateQueryResponse" is the
    /// selection of this object.
    const LeaderSyncStateQueryResponse& leaderSyncStateQueryResponse() const;

    /// Return a reference to the non-modifiable "LeaderSyncDataQuery"
    /// selection of this object if "LeaderSyncDataQuery" is the current
    /// selection.  The behavior is undefined unless "LeaderSyncDataQuery"
    /// is the selection of this object.
    const LeaderSyncDataQuery& leaderSyncDataQuery() const;

    /// Return a reference to the non-modifiable
    /// "LeaderSyncDataQueryResponse" selection of this object if
    /// "LeaderSyncDataQueryResponse" is the current selection.  The
    /// behavior is undefined unless "LeaderSyncDataQueryResponse" is the
    /// selection of this object.
    const LeaderSyncDataQueryResponse& leaderSyncDataQueryResponse() const;

    /// Return a reference to the non-modifiable "QueueAssignmentRequest"
    /// selection of this object if "QueueAssignmentRequest" is the current
    /// selection.  The behavior is undefined unless
    /// "QueueAssignmentRequest" is the selection of this object.
    const QueueAssignmentRequest& queueAssignmentRequest() const;

    /// Return a reference to the non-modifiable "StorageSyncRequest"
    /// selection of this object if "StorageSyncRequest" is the current
    /// selection.  The behavior is undefined unless "StorageSyncRequest" is
    /// the selection of this object.
    const StorageSyncRequest& storageSyncRequest() const;

    /// Return a reference to the non-modifiable "StorageSyncResponse"
    /// selection of this object if "StorageSyncResponse" is the current
    /// selection.  The behavior is undefined unless "StorageSyncResponse"
    /// is the selection of this object.
    const StorageSyncResponse& storageSyncResponse() const;

    /// Return a reference to the non-modifiable "PartitionSyncStateQuery"
    /// selection of this object if "PartitionSyncStateQuery" is the current
    /// selection.  The behavior is undefined unless
    /// "PartitionSyncStateQuery" is the selection of this object.
    const PartitionSyncStateQuery& partitionSyncStateQuery() const;

    /// Return a reference to the non-modifiable
    /// "PartitionSyncStateQueryResponse" selection of this object if
    /// "PartitionSyncStateQueryResponse" is the current selection.  The
    /// behavior is undefined unless "PartitionSyncStateQueryResponse" is
    /// the selection of this object.
    const PartitionSyncStateQueryResponse&
    partitionSyncStateQueryResponse() const;

    /// Return a reference to the non-modifiable "PartitionSyncDataQuery"
    /// selection of this object if "PartitionSyncDataQuery" is the current
    /// selection.  The behavior is undefined unless
    /// "PartitionSyncDataQuery" is the selection of this object.
    const PartitionSyncDataQuery& partitionSyncDataQuery() const;

    /// Return a reference to the non-modifiable
    /// "PartitionSyncDataQueryResponse" selection of this object if
    /// "PartitionSyncDataQueryResponse" is the current selection.  The
    /// behavior is undefined unless "PartitionSyncDataQueryResponse" is the
    /// selection of this object.
    const PartitionSyncDataQueryResponse&
    partitionSyncDataQueryResponse() const;

    /// Return a reference to the non-modifiable
    /// "PartitionSyncDataQueryStatus" selection of this object if
    /// "PartitionSyncDataQueryStatus" is the current selection.  The
    /// behavior is undefined unless "PartitionSyncDataQueryStatus" is the
    /// selection of this object.
    const PartitionSyncDataQueryStatus& partitionSyncDataQueryStatus() const;

    /// Return a reference to the non-modifiable "PrimaryStatusAdvisory"
    /// selection of this object if "PrimaryStatusAdvisory" is the current
    /// selection.  The behavior is undefined unless "PrimaryStatusAdvisory"
    /// is the selection of this object.
    const PrimaryStatusAdvisory& primaryStatusAdvisory() const;

    /// Return a reference to the non-modifiable "ClusterSyncRequest"
    /// selection of this object if "ClusterSyncRequest" is the current
    /// selection.  The behavior is undefined unless "ClusterSyncRequest" is
    /// the selection of this object.
    const ClusterSyncRequest& clusterSyncRequest() const;

    /// Return a reference to the non-modifiable "ClusterSyncResponse"
    /// selection of this object if "ClusterSyncResponse" is the current
    /// selection.  The behavior is undefined unless "ClusterSyncResponse"
    /// is the selection of this object.
    const ClusterSyncResponse& clusterSyncResponse() const;

    /// Return a reference to the non-modifiable "QueueUnAssignmentAdvisory"
    /// selection of this object if "QueueUnAssignmentAdvisory" is the
    /// current selection.  The behavior is undefined unless
    /// "QueueUnAssignmentAdvisory" is the selection of this object.
    const QueueUnAssignmentAdvisory& queueUnAssignmentAdvisory() const;

    /// Return a reference to the non-modifiable "QueueUnassignedAdvisory"
    /// selection of this object if "QueueUnassignedAdvisory" is the current
    /// selection.  The behavior is undefined unless
    /// "QueueUnassignedAdvisory" is the selection of this object.
    const QueueUnassignedAdvisory& queueUnassignedAdvisory() const;

    /// Return a reference to the non-modifiable "LeaderAdvisoryAck"
    /// selection of this object if "LeaderAdvisoryAck" is the current
    /// selection.  The behavior is undefined unless "LeaderAdvisoryAck" is
    /// the selection of this object.
    const LeaderAdvisoryAck& leaderAdvisoryAck() const;

    /// Return a reference to the non-modifiable "LeaderAdvisoryCommit"
    /// selection of this object if "LeaderAdvisoryCommit" is the current
    /// selection.  The behavior is undefined unless "LeaderAdvisoryCommit"
    /// is the selection of this object.
    const LeaderAdvisoryCommit& leaderAdvisoryCommit() const;

    /// Return a reference to the non-modifiable "StateNotification"
    /// selection of this object if "StateNotification" is the current
    /// selection.  The behavior is undefined unless "StateNotification" is
    /// the selection of this object.
    const StateNotification& stateNotification() const;

    /// Return a reference to the non-modifiable "StopRequest" selection of
    /// this object if "StopRequest" is the current selection.  The behavior
    /// is undefined unless "StopRequest" is the selection of this object.
    const StopRequest& stopRequest() const;

    /// Return a reference to the non-modifiable "StopResponse" selection of
    /// this object if "StopResponse" is the current selection.  The
    /// behavior is undefined unless "StopResponse" is the selection of this
    /// object.
    const StopResponse& stopResponse() const;

    /// Return a reference to the non-modifiable "QueueUnassignmentRequest"
    /// selection of this object if "QueueUnassignmentRequest" is the
    /// current selection.  The behavior is undefined unless
    /// "QueueUnassignmentRequest" is the selection of this object.
    const QueueUnassignmentRequest& queueUnassignmentRequest() const;

    /// Return a reference to the non-modifiable "QueueUpdateAdvisory"
    /// selection of this object if "QueueUpdateAdvisory" is the current
    /// selection.  The behavior is undefined unless "QueueUpdateAdvisory"
    /// is the selection of this object.
    const QueueUpdateAdvisory& queueUpdateAdvisory() const;

    /// Return a reference to the non-modifiable "ClusterStateFSMMessage"
    /// selection of this object if "ClusterStateFSMMessage" is the current
    /// selection.  The behavior is undefined unless
    /// "ClusterStateFSMMessage" is the selection of this object.
    const ClusterStateFSMMessage& clusterStateFSMMessage() const;

    /// Return a reference to the non-modifiable "PartitionMessage"
    /// selection of this object if "PartitionMessage" is the current
    /// selection.  The behavior is undefined unless "PartitionMessage" is
    /// the selection of this object.
    const PartitionMessage& partitionMessage() const;

    /// Return `true` if the value of this object is a
    /// "PartitionPrimaryAdvisory" value, and return `false` otherwise.
    bool isPartitionPrimaryAdvisoryValue() const;

    /// Return `true` if the value of this object is a "LeaderAdvisory"
    /// value, and return `false` otherwise.
    bool isLeaderAdvisoryValue() const;

    /// Return `true` if the value of this object is a
    /// "QueueAssignmentAdvisory" value, and return `false` otherwise.
    bool isQueueAssignmentAdvisoryValue() const;

    /// Return `true` if the value of this object is a "NodeStatusAdvisory"
    /// value, and return `false` otherwise.
    bool isNodeStatusAdvisoryValue() const;

    /// Return `true` if the value of this object is a
    /// "LeaderSyncStateQuery" value, and return `false` otherwise.
    bool isLeaderSyncStateQueryValue() const;

    /// Return `true` if the value of this object is a
    /// "LeaderSyncStateQueryResponse" value, and return `false` otherwise.
    bool isLeaderSyncStateQueryResponseValue() const;

    /// Return `true` if the value of this object is a "LeaderSyncDataQuery"
    /// value, and return `false` otherwise.
    bool isLeaderSyncDataQueryValue() const;

    /// Return `true` if the value of this object is a
    /// "LeaderSyncDataQueryResponse" value, and return `false` otherwise.
    bool isLeaderSyncDataQueryResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "QueueAssignmentRequest" value, and return `false` otherwise.
    bool isQueueAssignmentRequestValue() const;

    /// Return `true` if the value of this object is a "StorageSyncRequest"
    /// value, and return `false` otherwise.
    bool isStorageSyncRequestValue() const;

    /// Return `true` if the value of this object is a "StorageSyncResponse"
    /// value, and return `false` otherwise.
    bool isStorageSyncResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "PartitionSyncStateQuery" value, and return `false` otherwise.
    bool isPartitionSyncStateQueryValue() const;

    /// Return `true` if the value of this object is a
    /// "PartitionSyncStateQueryResponse" value, and return `false`
    /// otherwise.
    bool isPartitionSyncStateQueryResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "PartitionSyncDataQuery" value, and return `false` otherwise.
    bool isPartitionSyncDataQueryValue() const;

    /// Return `true` if the value of this object is a
    /// "PartitionSyncDataQueryResponse" value, and return `false`
    /// otherwise.
    bool isPartitionSyncDataQueryResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "PartitionSyncDataQueryStatus" value, and return `false` otherwise.
    bool isPartitionSyncDataQueryStatusValue() const;

    /// Return `true` if the value of this object is a
    /// "PrimaryStatusAdvisory" value, and return `false` otherwise.
    bool isPrimaryStatusAdvisoryValue() const;

    /// Return `true` if the value of this object is a "ClusterSyncRequest"
    /// value, and return `false` otherwise.
    bool isClusterSyncRequestValue() const;

    /// Return `true` if the value of this object is a "ClusterSyncResponse"
    /// value, and return `false` otherwise.
    bool isClusterSyncResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "QueueUnAssignmentAdvisory" value, and return `false` otherwise.
    bool isQueueUnAssignmentAdvisoryValue() const;

    /// Return `true` if the value of this object is a
    /// "QueueUnassignedAdvisory" value, and return `false` otherwise.
    bool isQueueUnassignedAdvisoryValue() const;

    /// Return `true` if the value of this object is a "LeaderAdvisoryAck"
    /// value, and return `false` otherwise.
    bool isLeaderAdvisoryAckValue() const;

    /// Return `true` if the value of this object is a
    /// "LeaderAdvisoryCommit" value, and return `false` otherwise.
    bool isLeaderAdvisoryCommitValue() const;

    /// Return `true` if the value of this object is a "StateNotification"
    /// value, and return `false` otherwise.
    bool isStateNotificationValue() const;

    /// Return `true` if the value of this object is a "StopRequest" value,
    /// and return `false` otherwise.
    bool isStopRequestValue() const;

    /// Return `true` if the value of this object is a "StopResponse" value,
    /// and return `false` otherwise.
    bool isStopResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "QueueUnassignmentRequest" value, and return `false` otherwise.
    bool isQueueUnassignmentRequestValue() const;

    /// Return `true` if the value of this object is a "QueueUpdateAdvisory"
    /// value, and return `false` otherwise.
    bool isQueueUpdateAdvisoryValue() const;

    /// Return `true` if the value of this object is a
    /// "ClusterStateFSMMessage" value, and return `false` otherwise.
    bool isClusterStateFSMMessageValue() const;

    /// Return `true` if the value of this object is a "PartitionMessage"
    /// value, and return `false` otherwise.
    bool isPartitionMessageValue() const;

    /// Return `true` if the value of this object is undefined, and `false`
    /// otherwise.
    bool isUndefinedValue() const;

    /// Return the symbolic name of the current selection of this object.
    const char* selectionName() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` objects have the same
/// value, and `false` otherwise.  Two `ClusterMessageChoice` objects have the
/// same value if either the selections in both objects have the same ids and
/// the same values, or both selections are undefined.
inline bool operator==(const ClusterMessageChoice& lhs,
                       const ClusterMessageChoice& rhs);

/// Return `true` if the specified `lhs` and `rhs` objects do not have the
/// same values, as determined by `operator==`, and `false` otherwise.
inline bool operator!=(const ClusterMessageChoice& lhs,
                       const ClusterMessageChoice& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const ClusterMessageChoice& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ClusterMessageChoice`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ClusterMessageChoice& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterMessageChoice)

namespace bmqp_ctrlmsg {

// ====================
// class ClusterMessage
// ====================

/// This type is the top level type for any message being sent by a node
/// inside the cluster to one or more peer nodes.  Note that this type of
/// message is not sent outside the cluster.
/// choice.: enumerates all the different types of cluster messages
class ClusterMessage {
    // INSTANCE DATA
    ClusterMessageChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ClusterMessage` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit ClusterMessage(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ClusterMessage` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ClusterMessage(const ClusterMessage& original,
                   bslma::Allocator*     basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ClusterMessage` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ClusterMessage(ClusterMessage&& original) noexcept;

    /// Create an object of type `ClusterMessage` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    ClusterMessage(ClusterMessage&&  original,
                   bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~ClusterMessage();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ClusterMessage& operator=(const ClusterMessage& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ClusterMessage& operator=(ClusterMessage&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "Choice" attribute of this
    /// object.
    ClusterMessageChoice& choice();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "Choice" attribute of this
    /// object.
    const ClusterMessageChoice& choice() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ClusterMessage& lhs, const ClusterMessage& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ClusterMessage& lhs, const ClusterMessage& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                const ClusterMessage& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ClusterMessage`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::ClusterMessage& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ClusterMessage)

namespace bmqp_ctrlmsg {

// ==========================
// class ControlMessageChoice
// ==========================

class ControlMessageChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Status>               d_status;
        bsls::ObjectBuffer<Disconnect>           d_disconnect;
        bsls::ObjectBuffer<DisconnectResponse>   d_disconnectResponse;
        bsls::ObjectBuffer<AdminCommand>         d_adminCommand;
        bsls::ObjectBuffer<AdminCommandResponse> d_adminCommandResponse;
        bsls::ObjectBuffer<ClusterMessage>       d_clusterMessage;
        bsls::ObjectBuffer<OpenQueue>            d_openQueue;
        bsls::ObjectBuffer<OpenQueueResponse>    d_openQueueResponse;
        bsls::ObjectBuffer<CloseQueue>           d_closeQueue;
        bsls::ObjectBuffer<CloseQueueResponse>   d_closeQueueResponse;
        bsls::ObjectBuffer<ConfigureQueueStream> d_configureQueueStream;
        bsls::ObjectBuffer<ConfigureQueueStreamResponse>
                                            d_configureQueueStreamResponse;
        bsls::ObjectBuffer<ConfigureStream> d_configureStream;
        bsls::ObjectBuffer<ConfigureStreamResponse> d_configureStreamResponse;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                       = -1,
        SELECTION_ID_STATUS                          = 0,
        SELECTION_ID_DISCONNECT                      = 1,
        SELECTION_ID_DISCONNECT_RESPONSE             = 2,
        SELECTION_ID_ADMIN_COMMAND                   = 7,
        SELECTION_ID_ADMIN_COMMAND_RESPONSE          = 8,
        SELECTION_ID_CLUSTER_MESSAGE                 = 9,
        SELECTION_ID_OPEN_QUEUE                      = 10,
        SELECTION_ID_OPEN_QUEUE_RESPONSE             = 11,
        SELECTION_ID_CLOSE_QUEUE                     = 12,
        SELECTION_ID_CLOSE_QUEUE_RESPONSE            = 13,
        SELECTION_ID_CONFIGURE_QUEUE_STREAM          = 14,
        SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE = 15,
        SELECTION_ID_CONFIGURE_STREAM                = 16,
        SELECTION_ID_CONFIGURE_STREAM_RESPONSE       = 17
    };

    enum { NUM_SELECTIONS = 14 };

    enum {
        SELECTION_INDEX_STATUS                          = 0,
        SELECTION_INDEX_DISCONNECT                      = 1,
        SELECTION_INDEX_DISCONNECT_RESPONSE             = 2,
        SELECTION_INDEX_ADMIN_COMMAND                   = 3,
        SELECTION_INDEX_ADMIN_COMMAND_RESPONSE          = 4,
        SELECTION_INDEX_CLUSTER_MESSAGE                 = 5,
        SELECTION_INDEX_OPEN_QUEUE                      = 6,
        SELECTION_INDEX_OPEN_QUEUE_RESPONSE             = 7,
        SELECTION_INDEX_CLOSE_QUEUE                     = 8,
        SELECTION_INDEX_CLOSE_QUEUE_RESPONSE            = 9,
        SELECTION_INDEX_CONFIGURE_QUEUE_STREAM          = 10,
        SELECTION_INDEX_CONFIGURE_QUEUE_STREAM_RESPONSE = 11,
        SELECTION_INDEX_CONFIGURE_STREAM                = 12,
        SELECTION_INDEX_CONFIGURE_STREAM_RESPONSE       = 13
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS

    /// Return selection information for the selection indicated by the
    /// specified `id` if the selection exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);

    /// Return selection information for the selection indicated by the
    /// specified `name` of the specified `nameLength` if the selection
    /// exists, and 0 otherwise.
    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ControlMessageChoice` having the default
    /// value.  Use the optionally specified `basicAllocator` to supply
    /// memory.  If `basicAllocator` is 0, the currently installed default
    /// allocator is used.
    explicit ControlMessageChoice(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ControlMessageChoice` having the value of
    /// the specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ControlMessageChoice(const ControlMessageChoice& original,
                         bslma::Allocator*           basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ControlMessageChoice` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ControlMessageChoice(ControlMessageChoice&& original) noexcept;

    /// Create an object of type `ControlMessageChoice` having the value of
    /// the specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    ControlMessageChoice(ControlMessageChoice&& original,
                         bslma::Allocator*      basicAllocator);
#endif

    /// Destroy this object.
    ~ControlMessageChoice();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ControlMessageChoice& operator=(const ControlMessageChoice& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ControlMessageChoice& operator=(ControlMessageChoice&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon default
    /// construction).
    void reset();

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `selectionId`.  Return 0 on success, and
    /// non-zero value otherwise (i.e., the selection is not found).
    int makeSelection(int selectionId);

    /// Set the value of this object to be the default for the selection
    /// indicated by the specified `name` of the specified `nameLength`.
    /// Return 0 on success, and non-zero value otherwise (i.e., the
    /// selection is not found).
    int makeSelection(const char* name, int nameLength);

    Status& makeStatus();
    Status& makeStatus(const Status& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Status& makeStatus(Status&& value);
#endif
    // Set the value of this object to be a "Status" value.  Optionally
    // specify the 'value' of the "Status".  If 'value' is not specified,
    // the default "Status" value is used.

    Disconnect& makeDisconnect();
    Disconnect& makeDisconnect(const Disconnect& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Disconnect& makeDisconnect(Disconnect&& value);
#endif
    // Set the value of this object to be a "Disconnect" value.  Optionally
    // specify the 'value' of the "Disconnect".  If 'value' is not
    // specified, the default "Disconnect" value is used.

    DisconnectResponse& makeDisconnectResponse();
    DisconnectResponse&
    makeDisconnectResponse(const DisconnectResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DisconnectResponse& makeDisconnectResponse(DisconnectResponse&& value);
#endif
    // Set the value of this object to be a "DisconnectResponse" value.
    // Optionally specify the 'value' of the "DisconnectResponse".  If
    // 'value' is not specified, the default "DisconnectResponse" value is
    // used.

    AdminCommand& makeAdminCommand();
    AdminCommand& makeAdminCommand(const AdminCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AdminCommand& makeAdminCommand(AdminCommand&& value);
#endif
    // Set the value of this object to be a "AdminCommand" value.
    // Optionally specify the 'value' of the "AdminCommand".  If 'value' is
    // not specified, the default "AdminCommand" value is used.

    AdminCommandResponse& makeAdminCommandResponse();
    AdminCommandResponse&
    makeAdminCommandResponse(const AdminCommandResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AdminCommandResponse&
    makeAdminCommandResponse(AdminCommandResponse&& value);
#endif
    // Set the value of this object to be a "AdminCommandResponse" value.
    // Optionally specify the 'value' of the "AdminCommandResponse".  If
    // 'value' is not specified, the default "AdminCommandResponse" value
    // is used.

    ClusterMessage& makeClusterMessage();
    ClusterMessage& makeClusterMessage(const ClusterMessage& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterMessage& makeClusterMessage(ClusterMessage&& value);
#endif
    // Set the value of this object to be a "ClusterMessage" value.
    // Optionally specify the 'value' of the "ClusterMessage".  If 'value'
    // is not specified, the default "ClusterMessage" value is used.

    OpenQueue& makeOpenQueue();
    OpenQueue& makeOpenQueue(const OpenQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    OpenQueue& makeOpenQueue(OpenQueue&& value);
#endif
    // Set the value of this object to be a "OpenQueue" value.  Optionally
    // specify the 'value' of the "OpenQueue".  If 'value' is not
    // specified, the default "OpenQueue" value is used.

    OpenQueueResponse& makeOpenQueueResponse();
    OpenQueueResponse& makeOpenQueueResponse(const OpenQueueResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    OpenQueueResponse& makeOpenQueueResponse(OpenQueueResponse&& value);
#endif
    // Set the value of this object to be a "OpenQueueResponse" value.
    // Optionally specify the 'value' of the "OpenQueueResponse".  If
    // 'value' is not specified, the default "OpenQueueResponse" value is
    // used.

    CloseQueue& makeCloseQueue();
    CloseQueue& makeCloseQueue(const CloseQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CloseQueue& makeCloseQueue(CloseQueue&& value);
#endif
    // Set the value of this object to be a "CloseQueue" value.  Optionally
    // specify the 'value' of the "CloseQueue".  If 'value' is not
    // specified, the default "CloseQueue" value is used.

    CloseQueueResponse& makeCloseQueueResponse();
    CloseQueueResponse&
    makeCloseQueueResponse(const CloseQueueResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CloseQueueResponse& makeCloseQueueResponse(CloseQueueResponse&& value);
#endif
    // Set the value of this object to be a "CloseQueueResponse" value.
    // Optionally specify the 'value' of the "CloseQueueResponse".  If
    // 'value' is not specified, the default "CloseQueueResponse" value is
    // used.

    ConfigureQueueStream& makeConfigureQueueStream();
    ConfigureQueueStream&
    makeConfigureQueueStream(const ConfigureQueueStream& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureQueueStream&
    makeConfigureQueueStream(ConfigureQueueStream&& value);
#endif
    // Set the value of this object to be a "ConfigureQueueStream" value.
    // Optionally specify the 'value' of the "ConfigureQueueStream".  If
    // 'value' is not specified, the default "ConfigureQueueStream" value
    // is used.

    ConfigureQueueStreamResponse& makeConfigureQueueStreamResponse();
    ConfigureQueueStreamResponse& makeConfigureQueueStreamResponse(
        const ConfigureQueueStreamResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureQueueStreamResponse&
    makeConfigureQueueStreamResponse(ConfigureQueueStreamResponse&& value);
#endif
    // Set the value of this object to be a "ConfigureQueueStreamResponse"
    // value.  Optionally specify the 'value' of the
    // "ConfigureQueueStreamResponse".  If 'value' is not specified, the
    // default "ConfigureQueueStreamResponse" value is used.

    ConfigureStream& makeConfigureStream();
    ConfigureStream& makeConfigureStream(const ConfigureStream& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureStream& makeConfigureStream(ConfigureStream&& value);
#endif
    // Set the value of this object to be a "ConfigureStream" value.
    // Optionally specify the 'value' of the "ConfigureStream".  If 'value'
    // is not specified, the default "ConfigureStream" value is used.

    ConfigureStreamResponse& makeConfigureStreamResponse();
    ConfigureStreamResponse&
    makeConfigureStreamResponse(const ConfigureStreamResponse& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigureStreamResponse&
    makeConfigureStreamResponse(ConfigureStreamResponse&& value);
#endif
    // Set the value of this object to be a "ConfigureStreamResponse"
    // value.  Optionally specify the 'value' of the
    // "ConfigureStreamResponse".  If 'value' is not specified, the default
    // "ConfigureStreamResponse" value is used.

    /// Invoke the specified `manipulator` on the address of the modifiable
    /// selection, supplying `manipulator` with the corresponding selection
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if this object has a defined selection,
    /// and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateSelection(MANIPULATOR& manipulator);

    /// Return a reference to the modifiable "Status" selection of this
    /// object if "Status" is the current selection.  The behavior is
    /// undefined unless "Status" is the selection of this object.
    Status& status();

    /// Return a reference to the modifiable "Disconnect" selection of this
    /// object if "Disconnect" is the current selection.  The behavior is
    /// undefined unless "Disconnect" is the selection of this object.
    Disconnect& disconnect();

    /// Return a reference to the modifiable "DisconnectResponse" selection
    /// of this object if "DisconnectResponse" is the current selection.
    /// The behavior is undefined unless "DisconnectResponse" is the
    /// selection of this object.
    DisconnectResponse& disconnectResponse();

    /// Return a reference to the modifiable "AdminCommand" selection of
    /// this object if "AdminCommand" is the current selection.  The
    /// behavior is undefined unless "AdminCommand" is the selection of this
    /// object.
    AdminCommand& adminCommand();

    /// Return a reference to the modifiable "AdminCommandResponse"
    /// selection of this object if "AdminCommandResponse" is the current
    /// selection.  The behavior is undefined unless "AdminCommandResponse"
    /// is the selection of this object.
    AdminCommandResponse& adminCommandResponse();

    /// Return a reference to the modifiable "ClusterMessage" selection of
    /// this object if "ClusterMessage" is the current selection.  The
    /// behavior is undefined unless "ClusterMessage" is the selection of
    /// this object.
    ClusterMessage& clusterMessage();

    /// Return a reference to the modifiable "OpenQueue" selection of this
    /// object if "OpenQueue" is the current selection.  The behavior is
    /// undefined unless "OpenQueue" is the selection of this object.
    OpenQueue& openQueue();

    /// Return a reference to the modifiable "OpenQueueResponse" selection
    /// of this object if "OpenQueueResponse" is the current selection.  The
    /// behavior is undefined unless "OpenQueueResponse" is the selection of
    /// this object.
    OpenQueueResponse& openQueueResponse();

    /// Return a reference to the modifiable "CloseQueue" selection of this
    /// object if "CloseQueue" is the current selection.  The behavior is
    /// undefined unless "CloseQueue" is the selection of this object.
    CloseQueue& closeQueue();

    /// Return a reference to the modifiable "CloseQueueResponse" selection
    /// of this object if "CloseQueueResponse" is the current selection.
    /// The behavior is undefined unless "CloseQueueResponse" is the
    /// selection of this object.
    CloseQueueResponse& closeQueueResponse();

    /// Return a reference to the modifiable "ConfigureQueueStream"
    /// selection of this object if "ConfigureQueueStream" is the current
    /// selection.  The behavior is undefined unless "ConfigureQueueStream"
    /// is the selection of this object.
    ConfigureQueueStream& configureQueueStream();

    /// Return a reference to the modifiable "ConfigureQueueStreamResponse"
    /// selection of this object if "ConfigureQueueStreamResponse" is the
    /// current selection.  The behavior is undefined unless
    /// "ConfigureQueueStreamResponse" is the selection of this object.
    ConfigureQueueStreamResponse& configureQueueStreamResponse();

    /// Return a reference to the modifiable "ConfigureStream" selection of
    /// this object if "ConfigureStream" is the current selection.  The
    /// behavior is undefined unless "ConfigureStream" is the selection of
    /// this object.
    ConfigureStream& configureStream();

    /// Return a reference to the modifiable "ConfigureStreamResponse"
    /// selection of this object if "ConfigureStreamResponse" is the current
    /// selection.  The behavior is undefined unless
    /// "ConfigureStreamResponse" is the selection of this object.
    ConfigureStreamResponse& configureStreamResponse();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Return the id of the current selection if the selection is defined,
    /// and -1 otherwise.
    int selectionId() const;

    /// Invoke the specified `accessor` on the non-modifiable selection,
    /// supplying `accessor` with the corresponding selection information
    /// structure.  Return the value returned from the invocation of
    /// `accessor` if this object has a defined selection, and -1 otherwise.
    template <class ACCESSOR>
    int accessSelection(ACCESSOR& accessor) const;

    /// Return a reference to the non-modifiable "Status" selection of this
    /// object if "Status" is the current selection.  The behavior is
    /// undefined unless "Status" is the selection of this object.
    const Status& status() const;

    /// Return a reference to the non-modifiable "Disconnect" selection of
    /// this object if "Disconnect" is the current selection.  The behavior
    /// is undefined unless "Disconnect" is the selection of this object.
    const Disconnect& disconnect() const;

    /// Return a reference to the non-modifiable "DisconnectResponse"
    /// selection of this object if "DisconnectResponse" is the current
    /// selection.  The behavior is undefined unless "DisconnectResponse" is
    /// the selection of this object.
    const DisconnectResponse& disconnectResponse() const;

    /// Return a reference to the non-modifiable "AdminCommand" selection of
    /// this object if "AdminCommand" is the current selection.  The
    /// behavior is undefined unless "AdminCommand" is the selection of this
    /// object.
    const AdminCommand& adminCommand() const;

    /// Return a reference to the non-modifiable "AdminCommandResponse"
    /// selection of this object if "AdminCommandResponse" is the current
    /// selection.  The behavior is undefined unless "AdminCommandResponse"
    /// is the selection of this object.
    const AdminCommandResponse& adminCommandResponse() const;

    /// Return a reference to the non-modifiable "ClusterMessage" selection
    /// of this object if "ClusterMessage" is the current selection.  The
    /// behavior is undefined unless "ClusterMessage" is the selection of
    /// this object.
    const ClusterMessage& clusterMessage() const;

    /// Return a reference to the non-modifiable "OpenQueue" selection of
    /// this object if "OpenQueue" is the current selection.  The behavior
    /// is undefined unless "OpenQueue" is the selection of this object.
    const OpenQueue& openQueue() const;

    /// Return a reference to the non-modifiable "OpenQueueResponse"
    /// selection of this object if "OpenQueueResponse" is the current
    /// selection.  The behavior is undefined unless "OpenQueueResponse" is
    /// the selection of this object.
    const OpenQueueResponse& openQueueResponse() const;

    /// Return a reference to the non-modifiable "CloseQueue" selection of
    /// this object if "CloseQueue" is the current selection.  The behavior
    /// is undefined unless "CloseQueue" is the selection of this object.
    const CloseQueue& closeQueue() const;

    /// Return a reference to the non-modifiable "CloseQueueResponse"
    /// selection of this object if "CloseQueueResponse" is the current
    /// selection.  The behavior is undefined unless "CloseQueueResponse" is
    /// the selection of this object.
    const CloseQueueResponse& closeQueueResponse() const;

    /// Return a reference to the non-modifiable "ConfigureQueueStream"
    /// selection of this object if "ConfigureQueueStream" is the current
    /// selection.  The behavior is undefined unless "ConfigureQueueStream"
    /// is the selection of this object.
    const ConfigureQueueStream& configureQueueStream() const;

    /// Return a reference to the non-modifiable
    /// "ConfigureQueueStreamResponse" selection of this object if
    /// "ConfigureQueueStreamResponse" is the current selection.  The
    /// behavior is undefined unless "ConfigureQueueStreamResponse" is the
    /// selection of this object.
    const ConfigureQueueStreamResponse& configureQueueStreamResponse() const;

    /// Return a reference to the non-modifiable "ConfigureStream" selection
    /// of this object if "ConfigureStream" is the current selection.  The
    /// behavior is undefined unless "ConfigureStream" is the selection of
    /// this object.
    const ConfigureStream& configureStream() const;

    /// Return a reference to the non-modifiable "ConfigureStreamResponse"
    /// selection of this object if "ConfigureStreamResponse" is the current
    /// selection.  The behavior is undefined unless
    /// "ConfigureStreamResponse" is the selection of this object.
    const ConfigureStreamResponse& configureStreamResponse() const;

    /// Return `true` if the value of this object is a "Status" value, and
    /// return `false` otherwise.
    bool isStatusValue() const;

    /// Return `true` if the value of this object is a "Disconnect" value,
    /// and return `false` otherwise.
    bool isDisconnectValue() const;

    /// Return `true` if the value of this object is a "DisconnectResponse"
    /// value, and return `false` otherwise.
    bool isDisconnectResponseValue() const;

    /// Return `true` if the value of this object is a "AdminCommand" value,
    /// and return `false` otherwise.
    bool isAdminCommandValue() const;

    /// Return `true` if the value of this object is a
    /// "AdminCommandResponse" value, and return `false` otherwise.
    bool isAdminCommandResponseValue() const;

    /// Return `true` if the value of this object is a "ClusterMessage"
    /// value, and return `false` otherwise.
    bool isClusterMessageValue() const;

    /// Return `true` if the value of this object is a "OpenQueue" value,
    /// and return `false` otherwise.
    bool isOpenQueueValue() const;

    /// Return `true` if the value of this object is a "OpenQueueResponse"
    /// value, and return `false` otherwise.
    bool isOpenQueueResponseValue() const;

    /// Return `true` if the value of this object is a "CloseQueue" value,
    /// and return `false` otherwise.
    bool isCloseQueueValue() const;

    /// Return `true` if the value of this object is a "CloseQueueResponse"
    /// value, and return `false` otherwise.
    bool isCloseQueueResponseValue() const;

    /// Return `true` if the value of this object is a
    /// "ConfigureQueueStream" value, and return `false` otherwise.
    bool isConfigureQueueStreamValue() const;

    /// Return `true` if the value of this object is a
    /// "ConfigureQueueStreamResponse" value, and return `false` otherwise.
    bool isConfigureQueueStreamResponseValue() const;

    /// Return `true` if the value of this object is a "ConfigureStream"
    /// value, and return `false` otherwise.
    bool isConfigureStreamValue() const;

    /// Return `true` if the value of this object is a
    /// "ConfigureStreamResponse" value, and return `false` otherwise.
    bool isConfigureStreamResponseValue() const;

    /// Return `true` if the value of this object is undefined, and `false`
    /// otherwise.
    bool isUndefinedValue() const;

    /// Return the symbolic name of the current selection of this object.
    const char* selectionName() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` objects have the same
/// value, and `false` otherwise.  Two `ControlMessageChoice` objects have the
/// same value if either the selections in both objects have the same ids and
/// the same values, or both selections are undefined.
inline bool operator==(const ControlMessageChoice& lhs,
                       const ControlMessageChoice& rhs);

/// Return `true` if the specified `lhs` and `rhs` objects do not have the
/// same values, as determined by `operator==`, and `false` otherwise.
inline bool operator!=(const ControlMessageChoice& lhs,
                       const ControlMessageChoice& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&               stream,
                                const ControlMessageChoice& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ControlMessageChoice`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ControlMessageChoice& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ControlMessageChoice)

namespace bmqp_ctrlmsg {

// ====================
// class ControlMessage
// ====================

/// This type is the top level type for any message being sent by a client
/// to the broker or a broker to another broker.  Each message can be
/// associated with an optional `rId` (requestId) that, if specified, will
/// be set to the same value as part of the response to correlate the
/// request and the response together.
/// rId....: optional id of this specific request choice.: enumerates all
/// the different types of control messages
class ControlMessage {
    // INSTANCE DATA
    ControlMessageChoice     d_choice;
    bdlb::NullableValue<int> d_rId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_R_ID = 0, ATTRIBUTE_ID_CHOICE = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_R_ID = 0, ATTRIBUTE_INDEX_CHOICE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS

    /// Return attribute information for the attribute indicated by the
    /// specified `id` if the attribute exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);

    /// Return attribute information for the attribute indicated by the
    /// specified `name` of the specified `nameLength` if the attribute
    /// exists, and 0 otherwise.
    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);

    // CREATORS

    /// Create an object of type `ControlMessage` having the default value.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    explicit ControlMessage(bslma::Allocator* basicAllocator = 0);

    /// Create an object of type `ControlMessage` having the value of the
    /// specified `original` object.  Use the optionally specified
    /// `basicAllocator` to supply memory.  If `basicAllocator` is 0, the
    /// currently installed default allocator is used.
    ControlMessage(const ControlMessage& original,
                   bslma::Allocator*     basicAllocator = 0);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Create an object of type `ControlMessage` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    ControlMessage(ControlMessage&& original) noexcept;

    /// Create an object of type `ControlMessage` having the value of the
    /// specified `original` object.  After performing this action, the
    /// `original` object will be left in a valid, but unspecified state.
    /// Use the optionally specified `basicAllocator` to supply memory.  If
    /// `basicAllocator` is 0, the currently installed default allocator is
    /// used.
    ControlMessage(ControlMessage&&  original,
                   bslma::Allocator* basicAllocator);
#endif

    /// Destroy this object.
    ~ControlMessage();

    // MANIPULATORS

    /// Assign to this object the value of the specified `rhs` object.
    ControlMessage& operator=(const ControlMessage& rhs);

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    /// Assign to this object the value of the specified `rhs` object.
    /// After performing this action, the `rhs` object will be left in a
    /// valid, but unspecified state.
    ControlMessage& operator=(ControlMessage&& rhs);
#endif

    /// Reset this object to the default value (i.e., its value upon
    /// default construction).
    void reset();

    /// Invoke the specified `manipulator` sequentially on the address of
    /// each (modifiable) attribute of this object, supplying `manipulator`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `manipulator` (i.e., the invocation that
    /// terminated the sequence).
    template <class MANIPULATOR>
    int manipulateAttributes(MANIPULATOR& manipulator);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `id`,
    /// supplying `manipulator` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `manipulator` if `id` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator, int id);

    /// Invoke the specified `manipulator` on the address of
    /// the (modifiable) attribute indicated by the specified `name` of the
    /// specified `nameLength`, supplying `manipulator` with the
    /// corresponding attribute information structure.  Return the value
    /// returned from the invocation of `manipulator` if `name` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class MANIPULATOR>
    int manipulateAttribute(MANIPULATOR& manipulator,
                            const char*  name,
                            int          nameLength);

    /// Return a reference to the modifiable "RId" attribute of this object.
    bdlb::NullableValue<int>& rId();

    /// Return a reference to the modifiable "Choice" attribute of this
    /// object.
    ControlMessageChoice& choice();

    // ACCESSORS

    /// Format this object to the specified output `stream` at the
    /// optionally specified indentation `level` and return a reference to
    /// the modifiable `stream`.  If `level` is specified, optionally
    /// specify `spacesPerLevel`, the number of spaces per indentation level
    /// for this and all of its nested objects.  Each line is indented by
    /// the absolute value of `level * spacesPerLevel`.  If `level` is
    /// negative, suppress indentation of the first line.  If
    /// `spacesPerLevel` is negative, suppress line breaks and format the
    /// entire output on one line.  If `stream` is initially invalid, this
    /// operation has no effect.  Note that a trailing newline is provided
    /// in multiline mode only.
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;

    /// Invoke the specified `accessor` sequentially on each
    /// (non-modifiable) attribute of this object, supplying `accessor`
    /// with the corresponding attribute information structure until such
    /// invocation returns a non-zero value.  Return the value from the
    /// last invocation of `accessor` (i.e., the invocation that terminated
    /// the sequence).
    template <class ACCESSOR>
    int accessAttributes(ACCESSOR& accessor) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `id`, supplying `accessor`
    /// with the corresponding attribute information structure.  Return the
    /// value returned from the invocation of `accessor` if `id` identifies
    /// an attribute of this class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR& accessor, int id) const;

    /// Invoke the specified `accessor` on the (non-modifiable) attribute
    /// of this object indicated by the specified `name` of the specified
    /// `nameLength`, supplying `accessor` with the corresponding attribute
    /// information structure.  Return the value returned from the
    /// invocation of `accessor` if `name` identifies an attribute of this
    /// class, and -1 otherwise.
    template <class ACCESSOR>
    int accessAttribute(ACCESSOR&   accessor,
                        const char* name,
                        int         nameLength) const;

    /// Return a reference to the non-modifiable "RId" attribute of this
    /// object.
    const bdlb::NullableValue<int>& rId() const;

    /// Return a reference to the non-modifiable "Choice" attribute of this
    /// object.
    const ControlMessageChoice& choice() const;
};

// FREE OPERATORS

/// Return `true` if the specified `lhs` and `rhs` attribute objects have
/// the same value, and `false` otherwise.  Two attribute objects have the
/// same value if each respective attribute has the same value.
inline bool operator==(const ControlMessage& lhs, const ControlMessage& rhs);

/// Return `true` if the specified `lhs` and `rhs` attribute objects do not
/// have the same value, and `false` otherwise.  Two attribute objects do
/// not have the same value if one or more respective attributes differ in
/// values.
inline bool operator!=(const ControlMessage& lhs, const ControlMessage& rhs);

/// Format the specified `rhs` to the specified output `stream` and
/// return a reference to the modifiable `stream`.
inline bsl::ostream& operator<<(bsl::ostream&         stream,
                                const ControlMessage& rhs);

/// Pass the specified `object` to the specified `hashAlg`.  This function
/// integrates with the `bslh` modular hashing system and effectively
/// provides a `bsl::hash` specialization for `ControlMessage`.
template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::ControlMessage& object);

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    bmqp_ctrlmsg::ControlMessage)

// ============================================================================
//                         INLINE FUNCTION DEFINITIONS
// ============================================================================

namespace bmqp_ctrlmsg {

// ------------------
// class AdminCommand
// ------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int AdminCommand::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int AdminCommand::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int AdminCommand::manipulateAttribute(MANIPULATOR& manipulator,
                                      const char*  name,
                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& AdminCommand::command()
{
    return d_command;
}

// ACCESSORS
template <class ACCESSOR>
int AdminCommand::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int AdminCommand::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int AdminCommand::accessAttribute(ACCESSOR&   accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& AdminCommand::command() const
{
    return d_command;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::AdminCommand& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.command());
}

// --------------------------
// class AdminCommandResponse
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int AdminCommandResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int AdminCommandResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TEXT: {
        return manipulator(&d_text,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int AdminCommandResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& AdminCommandResponse::text()
{
    return d_text;
}

// ACCESSORS
template <class ACCESSOR>
int AdminCommandResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int AdminCommandResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TEXT: {
        return accessor(d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int AdminCommandResponse::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& AdminCommandResponse::text() const
{
    return d_text;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::AdminCommandResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.text());
}

// ---------------
// class AppIdInfo
// ---------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int AppIdInfo::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appKey,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int AppIdInfo::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return manipulator(&d_appKey,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int AppIdInfo::manipulateAttribute(MANIPULATOR& manipulator,
                                   const char*  name,
                                   int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& AppIdInfo::appId()
{
    return d_appId;
}

inline bsl::vector<char>& AppIdInfo::appKey()
{
    return d_appKey;
}

// ACCESSORS
template <class ACCESSOR>
int AppIdInfo::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appKey, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int AppIdInfo::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return accessor(d_appKey,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int AppIdInfo::accessAttribute(ACCESSOR&   accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& AppIdInfo::appId() const
{
    return d_appId;
}

inline const bsl::vector<char>& AppIdInfo::appKey() const
{
    return d_appKey;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM& hashAlg, const bmqp_ctrlmsg::AppIdInfo& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.appId());
    hashAppend(hashAlg, object.appKey());
}

// --------------------
// class ClientLanguage
// --------------------

// CLASS METHODS
inline int ClientLanguage::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ClientLanguage::print(bsl::ostream&         stream,
                                           ClientLanguage::Value value)
{
    return stream << toString(value);
}

// ----------------
// class ClientType
// ----------------

// CLASS METHODS
inline int ClientType::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ClientType::print(bsl::ostream&     stream,
                                       ClientType::Value value)
{
    return stream << toString(value);
}

// ------------------------
// class CloseQueueResponse
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int CloseQueueResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int CloseQueueResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int CloseQueueResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                            const char*  name,
                                            int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int CloseQueueResponse::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int CloseQueueResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int CloseQueueResponse::accessAttribute(ACCESSOR&   accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::CloseQueueResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ------------------------
// class ClusterSyncRequest
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ClusterSyncRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int ClusterSyncRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ClusterSyncRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                            const char*  name,
                                            int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int ClusterSyncRequest::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int ClusterSyncRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ClusterSyncRequest::accessAttribute(ACCESSOR&   accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::ClusterSyncRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// -------------------------
// class ClusterSyncResponse
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ClusterSyncResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int ClusterSyncResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ClusterSyncResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int ClusterSyncResponse::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int ClusterSyncResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ClusterSyncResponse::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::ClusterSyncResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ------------------
// class ConsumerInfo
// ------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ConsumerInfo::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumerPriority,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ConsumerInfo::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return manipulator(
            &d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return manipulator(
            &d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return manipulator(
            &d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return manipulator(
            &d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ConsumerInfo::manipulateAttribute(MANIPULATOR& manipulator,
                                      const char*  name,
                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Int64& ConsumerInfo::maxUnconfirmedMessages()
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64& ConsumerInfo::maxUnconfirmedBytes()
{
    return d_maxUnconfirmedBytes;
}

inline int& ConsumerInfo::consumerPriority()
{
    return d_consumerPriority;
}

inline int& ConsumerInfo::consumerPriorityCount()
{
    return d_consumerPriorityCount;
}

// ACCESSORS
template <class ACCESSOR>
int ConsumerInfo::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumerPriority,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ConsumerInfo::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return accessor(
            d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return accessor(
            d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return accessor(
            d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return accessor(
            d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ConsumerInfo::accessAttribute(ACCESSOR&   accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Int64 ConsumerInfo::maxUnconfirmedMessages() const
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64 ConsumerInfo::maxUnconfirmedBytes() const
{
    return d_maxUnconfirmedBytes;
}

inline int ConsumerInfo::consumerPriority() const
{
    return d_consumerPriority;
}

inline int ConsumerInfo::consumerPriorityCount() const
{
    return d_consumerPriorityCount;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::ConsumerInfo& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.maxUnconfirmedMessages());
    hashAppend(hashAlg, object.maxUnconfirmedBytes());
    hashAppend(hashAlg, object.consumerPriority());
    hashAppend(hashAlg, object.consumerPriorityCount());
}

// ----------------
// class Disconnect
// ----------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int Disconnect::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int Disconnect::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int Disconnect::manipulateAttribute(MANIPULATOR& manipulator,
                                    const char*  name,
                                    int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int Disconnect::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int Disconnect::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int Disconnect::accessAttribute(ACCESSOR&   accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                 hashAlg,
                const bmqp_ctrlmsg::Disconnect& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ------------------------
// class DisconnectResponse
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int DisconnectResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int DisconnectResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int DisconnectResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                            const char*  name,
                                            int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int DisconnectResponse::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int DisconnectResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int DisconnectResponse::accessAttribute(ACCESSOR&   accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::DisconnectResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// --------------------
// class DumpActionType
// --------------------

// CLASS METHODS
inline int DumpActionType::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& DumpActionType::print(bsl::ostream&         stream,
                                           DumpActionType::Value value)
{
    return stream << toString(value);
}

// -----------------
// class DumpMsgType
// -----------------

// CLASS METHODS
inline int DumpMsgType::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& DumpMsgType::print(bsl::ostream&      stream,
                                        DumpMsgType::Value value)
{
    return stream << toString(value);
}

// ----------------------
// class ElectionProposal
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ElectionProposal::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int ElectionProposal::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ElectionProposal::manipulateAttribute(MANIPULATOR& manipulator,
                                          const char*  name,
                                          int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int ElectionProposal::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int ElectionProposal::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ElectionProposal::accessAttribute(ACCESSOR&   accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::ElectionProposal& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ----------------------
// class ElectionResponse
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ElectionResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int ElectionResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ElectionResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                          const char*  name,
                                          int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int ElectionResponse::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int ElectionResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ElectionResponse::accessAttribute(ACCESSOR&   accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::ElectionResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// -----------------------
// class ElectorNodeStatus
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ElectorNodeStatus::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_isAvailable,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ElectorNodeStatus::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_IS_AVAILABLE: {
        return manipulator(&d_isAvailable,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ElectorNodeStatus::manipulateAttribute(MANIPULATOR& manipulator,
                                           const char*  name,
                                           int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bool& ElectorNodeStatus::isAvailable()
{
    return d_isAvailable;
}

// ACCESSORS
template <class ACCESSOR>
int ElectorNodeStatus::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_isAvailable,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ElectorNodeStatus::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_IS_AVAILABLE: {
        return accessor(d_isAvailable,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ElectorNodeStatus::accessAttribute(ACCESSOR&   accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bool ElectorNodeStatus::isAvailable() const
{
    return d_isAvailable;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::ElectorNodeStatus& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.isAvailable());
}

// -----------------------
// class ExpressionVersion
// -----------------------

// CLASS METHODS
inline int ExpressionVersion::fromString(Value*             result,
                                         const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ExpressionVersion::print(bsl::ostream&            stream,
                                              ExpressionVersion::Value value)
{
    return stream << toString(value);
}

// ---------------------------------
// class FollowerClusterStateRequest
// ---------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int FollowerClusterStateRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int FollowerClusterStateRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                                     int          id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int FollowerClusterStateRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                                     const char*  name,
                                                     int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int FollowerClusterStateRequest::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int FollowerClusterStateRequest::accessAttribute(ACCESSOR& accessor,
                                                 int       id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int FollowerClusterStateRequest::accessAttribute(ACCESSOR&   accessor,
                                                 const char* name,
                                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                  hashAlg,
                const bmqp_ctrlmsg::FollowerClusterStateRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ------------------------
// class FollowerLSNRequest
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int FollowerLSNRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int FollowerLSNRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int FollowerLSNRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                            const char*  name,
                                            int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int FollowerLSNRequest::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int FollowerLSNRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int FollowerLSNRequest::accessAttribute(ACCESSOR&   accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::FollowerLSNRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// --------------
// class GuidInfo
// --------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int GuidInfo::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clientId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_nanoSecondsFromEpoch,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int GuidInfo::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_ID: {
        return manipulator(&d_clientId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_ID]);
    }
    case ATTRIBUTE_ID_NANO_SECONDS_FROM_EPOCH: {
        return manipulator(
            &d_nanoSecondsFromEpoch,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int GuidInfo::manipulateAttribute(MANIPULATOR& manipulator,
                                  const char*  name,
                                  int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& GuidInfo::clientId()
{
    return d_clientId;
}

inline bsls::Types::Int64& GuidInfo::nanoSecondsFromEpoch()
{
    return d_nanoSecondsFromEpoch;
}

// ACCESSORS
template <class ACCESSOR>
int GuidInfo::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clientId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_nanoSecondsFromEpoch,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int GuidInfo::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_ID: {
        return accessor(d_clientId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_ID]);
    }
    case ATTRIBUTE_ID_NANO_SECONDS_FROM_EPOCH: {
        return accessor(
            d_nanoSecondsFromEpoch,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NANO_SECONDS_FROM_EPOCH]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int GuidInfo::accessAttribute(ACCESSOR&   accessor,
                              const char* name,
                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& GuidInfo::clientId() const
{
    return d_clientId;
}

inline bsls::Types::Int64 GuidInfo::nanoSecondsFromEpoch() const
{
    return d_nanoSecondsFromEpoch;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM& hashAlg, const bmqp_ctrlmsg::GuidInfo& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.clientId());
    hashAppend(hashAlg, object.nanoSecondsFromEpoch());
}

// -----------------------
// class HeartbeatResponse
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int HeartbeatResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int HeartbeatResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int HeartbeatResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                           const char*  name,
                                           int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int HeartbeatResponse::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int HeartbeatResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int HeartbeatResponse::accessAttribute(ACCESSOR&   accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::HeartbeatResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ---------------------
// class LeaderHeartbeat
// ---------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderHeartbeat::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int LeaderHeartbeat::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderHeartbeat::manipulateAttribute(MANIPULATOR& manipulator,
                                         const char*  name,
                                         int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int LeaderHeartbeat::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int LeaderHeartbeat::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderHeartbeat::accessAttribute(ACCESSOR&   accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                      hashAlg,
                const bmqp_ctrlmsg::LeaderHeartbeat& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ---------------------------
// class LeaderMessageSequence
// ---------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderMessageSequence::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_electorTerm,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int LeaderMessageSequence::manipulateAttribute(MANIPULATOR& manipulator,
                                               int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ELECTOR_TERM: {
        return manipulator(&d_electorTerm,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderMessageSequence::manipulateAttribute(MANIPULATOR& manipulator,
                                               const char*  name,
                                               int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Uint64& LeaderMessageSequence::electorTerm()
{
    return d_electorTerm;
}

inline bsls::Types::Uint64& LeaderMessageSequence::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int LeaderMessageSequence::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_electorTerm,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int LeaderMessageSequence::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ELECTOR_TERM: {
        return accessor(d_electorTerm,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderMessageSequence::accessAttribute(ACCESSOR&   accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Uint64 LeaderMessageSequence::electorTerm() const
{
    return d_electorTerm;
}

inline bsls::Types::Uint64 LeaderMessageSequence::sequenceNumber() const
{
    return d_sequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                            hashAlg,
                const bmqp_ctrlmsg::LeaderMessageSequence& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.electorTerm());
    hashAppend(hashAlg, object.sequenceNumber());
}

// -------------------
// class LeaderPassive
// -------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderPassive::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int LeaderPassive::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderPassive::manipulateAttribute(MANIPULATOR& manipulator,
                                       const char*  name,
                                       int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int LeaderPassive::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int LeaderPassive::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderPassive::accessAttribute(ACCESSOR&   accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                    hashAlg,
                const bmqp_ctrlmsg::LeaderPassive& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// -------------------------
// class LeaderSyncDataQuery
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderSyncDataQuery::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int LeaderSyncDataQuery::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderSyncDataQuery::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int LeaderSyncDataQuery::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int LeaderSyncDataQuery::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderSyncDataQuery::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::LeaderSyncDataQuery& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// --------------------------
// class LeaderSyncStateQuery
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderSyncStateQuery::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int LeaderSyncStateQuery::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderSyncStateQuery::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int LeaderSyncStateQuery::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int LeaderSyncStateQuery::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderSyncStateQuery::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::LeaderSyncStateQuery& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// -----------------------------------
// class LeadershipCessionNotification
// -----------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeadershipCessionNotification::manipulateAttributes(
    MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int LeadershipCessionNotification::manipulateAttribute(
    MANIPULATOR& manipulator,
    int          id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeadershipCessionNotification::manipulateAttribute(
    MANIPULATOR& manipulator,
    const char*  name,
    int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int LeadershipCessionNotification::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int LeadershipCessionNotification::accessAttribute(ACCESSOR& accessor,
                                                   int       id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeadershipCessionNotification::accessAttribute(ACCESSOR&   accessor,
                                                   const char* name,
                                                   int nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                    hashAlg,
                const bmqp_ctrlmsg::LeadershipCessionNotification& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ----------------
// class NodeStatus
// ----------------

// CLASS METHODS
inline int NodeStatus::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& NodeStatus::print(bsl::ostream&     stream,
                                       NodeStatus::Value value)
{
    return stream << toString(value);
}

// --------------------------
// class PartitionPrimaryInfo
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionPrimaryInfo::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionPrimaryInfo::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return manipulator(
            &d_primaryNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionPrimaryInfo::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionPrimaryInfo::partitionId()
{
    return d_partitionId;
}

inline int& PartitionPrimaryInfo::primaryNodeId()
{
    return d_primaryNodeId;
}

inline unsigned int& PartitionPrimaryInfo::primaryLeaseId()
{
    return d_primaryLeaseId;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionPrimaryInfo::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionPrimaryInfo::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return accessor(d_primaryNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionPrimaryInfo::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionPrimaryInfo::partitionId() const
{
    return d_partitionId;
}

inline int PartitionPrimaryInfo::primaryNodeId() const
{
    return d_primaryNodeId;
}

inline unsigned int PartitionPrimaryInfo::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::PartitionPrimaryInfo& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.primaryNodeId());
    hashAppend(hashAlg, object.primaryLeaseId());
}

// -----------------------------
// class PartitionSequenceNumber
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionSequenceNumber::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionSequenceNumber::manipulateAttribute(MANIPULATOR& manipulator,
                                                 int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionSequenceNumber::manipulateAttribute(MANIPULATOR& manipulator,
                                                 const char*  name,
                                                 int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& PartitionSequenceNumber::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSequenceNumber::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionSequenceNumber::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionSequenceNumber::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionSequenceNumber::accessAttribute(ACCESSOR&   accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int PartitionSequenceNumber::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64 PartitionSequenceNumber::sequenceNumber() const
{
    return d_sequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::PartitionSequenceNumber& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.primaryLeaseId());
    hashAppend(hashAlg, object.sequenceNumber());
}

// ------------------------------------
// class PartitionSyncDataQueryResponse
// ------------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionSyncDataQueryResponse::manipulateAttributes(
    MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_endPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_endSequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionSyncDataQueryResponse::manipulateAttribute(
    MANIPULATOR& manipulator,
    int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_END_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_endPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUM: {
        return manipulator(
            &d_endSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUM]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionSyncDataQueryResponse::manipulateAttribute(
    MANIPULATOR& manipulator,
    const char*  name,
    int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncDataQueryResponse::partitionId()
{
    return d_partitionId;
}

inline unsigned int& PartitionSyncDataQueryResponse::endPrimaryLeaseId()
{
    return d_endPrimaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSyncDataQueryResponse::endSequenceNum()
{
    return d_endSequenceNum;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionSyncDataQueryResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endPrimaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endSequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionSyncDataQueryResponse::accessAttribute(ACCESSOR& accessor,
                                                    int       id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_END_PRIMARY_LEASE_ID: {
        return accessor(
            d_endPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUM: {
        return accessor(
            d_endSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUM]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionSyncDataQueryResponse::accessAttribute(ACCESSOR&   accessor,
                                                    const char* name,
                                                    int nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncDataQueryResponse::partitionId() const
{
    return d_partitionId;
}

inline unsigned int PartitionSyncDataQueryResponse::endPrimaryLeaseId() const
{
    return d_endPrimaryLeaseId;
}

inline bsls::Types::Uint64
PartitionSyncDataQueryResponse::endSequenceNum() const
{
    return d_endSequenceNum;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                     hashAlg,
                const bmqp_ctrlmsg::PartitionSyncDataQueryResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.endPrimaryLeaseId());
    hashAppend(hashAlg, object.endSequenceNum());
}

// -----------------------------
// class PartitionSyncStateQuery
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionSyncStateQuery::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionSyncStateQuery::manipulateAttribute(MANIPULATOR& manipulator,
                                                 int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionSyncStateQuery::manipulateAttribute(MANIPULATOR& manipulator,
                                                 const char*  name,
                                                 int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncStateQuery::partitionId()
{
    return d_partitionId;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionSyncStateQuery::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionSyncStateQuery::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionSyncStateQuery::accessAttribute(ACCESSOR&   accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncStateQuery::partitionId() const
{
    return d_partitionId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::PartitionSyncStateQuery& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
}

// -------------------
// class PrimaryStatus
// -------------------

// CLASS METHODS
inline int PrimaryStatus::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& PrimaryStatus::print(bsl::ostream&        stream,
                                          PrimaryStatus::Value value)
{
    return stream << toString(value);
}

// ----------------------------
// class QueueAssignmentRequest
// ----------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueAssignmentRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queueUri,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueAssignmentRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                                int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return manipulator(&d_queueUri,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueAssignmentRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                                const char*  name,
                                                int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueAssignmentRequest::queueUri()
{
    return d_queueUri;
}

// ACCESSORS
template <class ACCESSOR>
int QueueAssignmentRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queueUri,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueAssignmentRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return accessor(d_queueUri,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueAssignmentRequest::accessAttribute(ACCESSOR&   accessor,
                                            const char* name,
                                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueAssignmentRequest::queueUri() const
{
    return d_queueUri;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                             hashAlg,
                const bmqp_ctrlmsg::QueueAssignmentRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.queueUri());
}

// ------------------------------
// class QueueUnassignmentRequest
// ------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueUnassignmentRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queueUri,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queueKey,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueUnassignmentRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                                  int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return manipulator(&d_queueUri,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_QUEUE_KEY: {
        return manipulator(&d_queueKey,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueUnassignmentRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                                  const char*  name,
                                                  int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueUnassignmentRequest::queueUri()
{
    return d_queueUri;
}

inline int& QueueUnassignmentRequest::partitionId()
{
    return d_partitionId;
}

inline bsl::vector<char>& QueueUnassignmentRequest::queueKey()
{
    return d_queueKey;
}

// ACCESSORS
template <class ACCESSOR>
int QueueUnassignmentRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queueUri,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queueKey,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueUnassignmentRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return accessor(d_queueUri,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_QUEUE_KEY: {
        return accessor(d_queueKey,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueUnassignmentRequest::accessAttribute(ACCESSOR&   accessor,
                                              const char* name,
                                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueUnassignmentRequest::queueUri() const
{
    return d_queueUri;
}

inline int QueueUnassignmentRequest::partitionId() const
{
    return d_partitionId;
}

inline const bsl::vector<char>& QueueUnassignmentRequest::queueKey() const
{
    return d_queueKey;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                               hashAlg,
                const bmqp_ctrlmsg::QueueUnassignmentRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.queueUri());
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.queueKey());
}

// --------------------------
// class RegistrationResponse
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int RegistrationResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int RegistrationResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int RegistrationResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int RegistrationResponse::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int RegistrationResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int RegistrationResponse::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::RegistrationResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ---------------------
// class ReplicaDataType
// ---------------------

// CLASS METHODS
inline int ReplicaDataType::fromString(Value*             result,
                                       const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ReplicaDataType::print(bsl::ostream&          stream,
                                            ReplicaDataType::Value value)
{
    return stream << toString(value);
}

// ------------------------------
// class ReverseConnectionRequest
// ------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ReverseConnectionRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_protocolVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ReverseConnectionRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                                  int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return manipulator(
            &d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CLUSTER_NODE_ID: {
        return manipulator(
            &d_clusterNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ReverseConnectionRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                                  const char*  name,
                                                  int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& ReverseConnectionRequest::protocolVersion()
{
    return d_protocolVersion;
}

inline bsl::string& ReverseConnectionRequest::clusterName()
{
    return d_clusterName;
}

inline int& ReverseConnectionRequest::clusterNodeId()
{
    return d_clusterNodeId;
}

// ACCESSORS
template <class ACCESSOR>
int ReverseConnectionRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_protocolVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ReverseConnectionRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return accessor(
            d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CLUSTER_NODE_ID: {
        return accessor(d_clusterNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ReverseConnectionRequest::accessAttribute(ACCESSOR&   accessor,
                                              const char* name,
                                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int ReverseConnectionRequest::protocolVersion() const
{
    return d_protocolVersion;
}

inline const bsl::string& ReverseConnectionRequest::clusterName() const
{
    return d_clusterName;
}

inline int ReverseConnectionRequest::clusterNodeId() const
{
    return d_clusterNodeId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                               hashAlg,
                const bmqp_ctrlmsg::ReverseConnectionRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.protocolVersion());
    hashAppend(hashAlg, object.clusterName());
    hashAppend(hashAlg, object.clusterNodeId());
}

// --------------------------
// class RoutingConfiguration
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int RoutingConfiguration::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int RoutingConfiguration::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_FLAGS: {
        return manipulator(&d_flags,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int RoutingConfiguration::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Uint64& RoutingConfiguration::flags()
{
    return d_flags;
}

// ACCESSORS
template <class ACCESSOR>
int RoutingConfiguration::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int RoutingConfiguration::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_FLAGS: {
        return accessor(d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int RoutingConfiguration::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Uint64 RoutingConfiguration::flags() const
{
    return d_flags;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::RoutingConfiguration& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.flags());
}

// -------------------------------
// class RoutingConfigurationFlags
// -------------------------------

// CLASS METHODS
inline int RoutingConfigurationFlags::fromString(Value*             result,
                                                 const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream&
RoutingConfigurationFlags::print(bsl::ostream&                    stream,
                                 RoutingConfigurationFlags::Value value)
{
    return stream << toString(value);
}

// ---------------------
// class ScoutingRequest
// ---------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ScoutingRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    (void)manipulator;
    int ret = 0;

    return ret;
}

template <class MANIPULATOR>
int ScoutingRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ScoutingRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                         const char*  name,
                                         int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <class ACCESSOR>
int ScoutingRequest::accessAttributes(ACCESSOR& accessor) const
{
    (void)accessor;
    int ret = 0;

    return ret;
}

template <class ACCESSOR>
int ScoutingRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ScoutingRequest::accessAttribute(ACCESSOR&   accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                      hashAlg,
                const bmqp_ctrlmsg::ScoutingRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
}

// ----------------------
// class ScoutingResponse
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ScoutingResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_willVote,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WILL_VOTE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ScoutingResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_WILL_VOTE: {
        return manipulator(&d_willVote,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WILL_VOTE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ScoutingResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                          const char*  name,
                                          int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bool& ScoutingResponse::willVote()
{
    return d_willVote;
}

// ACCESSORS
template <class ACCESSOR>
int ScoutingResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_willVote,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WILL_VOTE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ScoutingResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_WILL_VOTE: {
        return accessor(d_willVote,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WILL_VOTE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ScoutingResponse::accessAttribute(ACCESSOR&   accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bool ScoutingResponse::willVote() const
{
    return d_willVote;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::ScoutingResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.willVote());
}

// --------------------
// class StatusCategory
// --------------------

// CLASS METHODS
inline int StatusCategory::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& StatusCategory::print(bsl::ostream&         stream,
                                           StatusCategory::Value value)
{
    return stream << toString(value);
}

// -----------------
// class StopRequest
// -----------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int StopRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_version,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int StopRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_VERSION: {
        return manipulator(&d_version,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int StopRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                     const char*  name,
                                     int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StopRequest::clusterName()
{
    return d_clusterName;
}

inline int& StopRequest::version()
{
    return d_version;
}

// ACCESSORS
template <class ACCESSOR>
int StopRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_version, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    if (ret) {
        return ret;
    }
    return ret;
}

template <class ACCESSOR>
int StopRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_VERSION: {
        return accessor(d_version,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int StopRequest::accessAttribute(ACCESSOR&   accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StopRequest::clusterName() const
{
    return d_clusterName;
}

inline int StopRequest::version() const
{
    return d_version;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                  hashAlg,
                const bmqp_ctrlmsg::StopRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.clusterName());
}

// ------------------
// class StopResponse
// ------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int StopResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int StopResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int StopResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                      const char*  name,
                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StopResponse::clusterName()
{
    return d_clusterName;
}

// ACCESSORS
template <class ACCESSOR>
int StopResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int StopResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int StopResponse::accessAttribute(ACCESSOR&   accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StopResponse::clusterName() const
{
    return d_clusterName;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::StopResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.clusterName());
}

// -----------------------------
// class StorageSyncResponseType
// -----------------------------

// CLASS METHODS
inline int StorageSyncResponseType::fromString(Value*             result,
                                               const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream&
StorageSyncResponseType::print(bsl::ostream&                  stream,
                               StorageSyncResponseType::Value value)
{
    return stream << toString(value);
}

// --------------------
// class SubQueueIdInfo
// --------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int SubQueueIdInfo::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int SubQueueIdInfo::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID: {
        return manipulator(&d_subId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int SubQueueIdInfo::manipulateAttribute(MANIPULATOR& manipulator,
                                        const char*  name,
                                        int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& SubQueueIdInfo::subId()
{
    return d_subId;
}

inline bsl::string& SubQueueIdInfo::appId()
{
    return d_appId;
}

// ACCESSORS
template <class ACCESSOR>
int SubQueueIdInfo::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int SubQueueIdInfo::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID: {
        return accessor(d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int SubQueueIdInfo::accessAttribute(ACCESSOR&   accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int SubQueueIdInfo::subId() const
{
    return d_subId;
}

inline const bsl::string& SubQueueIdInfo::appId() const
{
    return d_appId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::SubQueueIdInfo& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.subId());
    hashAppend(hashAlg, object.appId());
}

// ---------------
// class SyncPoint
// ---------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int SyncPoint::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_dataFileOffsetDwords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_qlistFileOffsetWords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int SyncPoint::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return manipulator(&d_sequenceNum,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_DATA_FILE_OFFSET_DWORDS: {
        return manipulator(
            &d_dataFileOffsetDwords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS]);
    }
    case ATTRIBUTE_ID_QLIST_FILE_OFFSET_WORDS: {
        return manipulator(
            &d_qlistFileOffsetWords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int SyncPoint::manipulateAttribute(MANIPULATOR& manipulator,
                                   const char*  name,
                                   int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& SyncPoint::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64& SyncPoint::sequenceNum()
{
    return d_sequenceNum;
}

inline unsigned int& SyncPoint::dataFileOffsetDwords()
{
    return d_dataFileOffsetDwords;
}

inline unsigned int& SyncPoint::qlistFileOffsetWords()
{
    return d_qlistFileOffsetWords;
}

// ACCESSORS
template <class ACCESSOR>
int SyncPoint::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_dataFileOffsetDwords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_qlistFileOffsetWords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int SyncPoint::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return accessor(d_sequenceNum,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_DATA_FILE_OFFSET_DWORDS: {
        return accessor(
            d_dataFileOffsetDwords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_OFFSET_DWORDS]);
    }
    case ATTRIBUTE_ID_QLIST_FILE_OFFSET_WORDS: {
        return accessor(
            d_qlistFileOffsetWords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE_OFFSET_WORDS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int SyncPoint::accessAttribute(ACCESSOR&   accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int SyncPoint::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64 SyncPoint::sequenceNum() const
{
    return d_sequenceNum;
}

inline unsigned int SyncPoint::dataFileOffsetDwords() const
{
    return d_dataFileOffsetDwords;
}

inline unsigned int SyncPoint::qlistFileOffsetWords() const
{
    return d_qlistFileOffsetWords;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM& hashAlg, const bmqp_ctrlmsg::SyncPoint& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.primaryLeaseId());
    hashAppend(hashAlg, object.sequenceNum());
    hashAppend(hashAlg, object.dataFileOffsetDwords());
    hashAppend(hashAlg, object.qlistFileOffsetWords());
}

// --------------------
// class ClientIdentity
// --------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ClientIdentity::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_protocolVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sdkVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clientType,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_processName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROCESS_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_pid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sessionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SESSION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_hostName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_features,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FEATURES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sdkLanguage,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_LANGUAGE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_guidInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID_INFO]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ClientIdentity::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return manipulator(
            &d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_SDK_VERSION: {
        return manipulator(&d_sdkVersion,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_VERSION]);
    }
    case ATTRIBUTE_ID_CLIENT_TYPE: {
        return manipulator(&d_clientType,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_TYPE]);
    }
    case ATTRIBUTE_ID_PROCESS_NAME: {
        return manipulator(&d_processName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROCESS_NAME]);
    }
    case ATTRIBUTE_ID_PID: {
        return manipulator(&d_pid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PID]);
    }
    case ATTRIBUTE_ID_SESSION_ID: {
        return manipulator(&d_sessionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SESSION_ID]);
    }
    case ATTRIBUTE_ID_HOST_NAME: {
        return manipulator(&d_hostName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    }
    case ATTRIBUTE_ID_FEATURES: {
        return manipulator(&d_features,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FEATURES]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CLUSTER_NODE_ID: {
        return manipulator(
            &d_clusterNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    }
    case ATTRIBUTE_ID_SDK_LANGUAGE: {
        return manipulator(&d_sdkLanguage,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_LANGUAGE]);
    }
    case ATTRIBUTE_ID_GUID_INFO: {
        return manipulator(&d_guidInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID_INFO]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ClientIdentity::manipulateAttribute(MANIPULATOR& manipulator,
                                        const char*  name,
                                        int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& ClientIdentity::protocolVersion()
{
    return d_protocolVersion;
}

inline int& ClientIdentity::sdkVersion()
{
    return d_sdkVersion;
}

inline ClientType::Value& ClientIdentity::clientType()
{
    return d_clientType;
}

inline bsl::string& ClientIdentity::processName()
{
    return d_processName;
}

inline int& ClientIdentity::pid()
{
    return d_pid;
}

inline int& ClientIdentity::sessionId()
{
    return d_sessionId;
}

inline bsl::string& ClientIdentity::hostName()
{
    return d_hostName;
}

inline bsl::string& ClientIdentity::features()
{
    return d_features;
}

inline bsl::string& ClientIdentity::clusterName()
{
    return d_clusterName;
}

inline int& ClientIdentity::clusterNodeId()
{
    return d_clusterNodeId;
}

inline ClientLanguage::Value& ClientIdentity::sdkLanguage()
{
    return d_sdkLanguage;
}

inline GuidInfo& ClientIdentity::guidInfo()
{
    return d_guidInfo;
}

// ACCESSORS
template <class ACCESSOR>
int ClientIdentity::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_protocolVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sdkVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clientType,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_processName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROCESS_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_pid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sessionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SESSION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_hostName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_features, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FEATURES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sdkLanguage,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_LANGUAGE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_guidInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID_INFO]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ClientIdentity::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return accessor(
            d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_SDK_VERSION: {
        return accessor(d_sdkVersion,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_VERSION]);
    }
    case ATTRIBUTE_ID_CLIENT_TYPE: {
        return accessor(d_clientType,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_TYPE]);
    }
    case ATTRIBUTE_ID_PROCESS_NAME: {
        return accessor(d_processName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROCESS_NAME]);
    }
    case ATTRIBUTE_ID_PID: {
        return accessor(d_pid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PID]);
    }
    case ATTRIBUTE_ID_SESSION_ID: {
        return accessor(d_sessionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SESSION_ID]);
    }
    case ATTRIBUTE_ID_HOST_NAME: {
        return accessor(d_hostName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    }
    case ATTRIBUTE_ID_FEATURES: {
        return accessor(d_features,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FEATURES]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CLUSTER_NODE_ID: {
        return accessor(d_clusterNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NODE_ID]);
    }
    case ATTRIBUTE_ID_SDK_LANGUAGE: {
        return accessor(d_sdkLanguage,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SDK_LANGUAGE]);
    }
    case ATTRIBUTE_ID_GUID_INFO: {
        return accessor(d_guidInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID_INFO]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ClientIdentity::accessAttribute(ACCESSOR&   accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int ClientIdentity::protocolVersion() const
{
    return d_protocolVersion;
}

inline int ClientIdentity::sdkVersion() const
{
    return d_sdkVersion;
}

inline ClientType::Value ClientIdentity::clientType() const
{
    return d_clientType;
}

inline const bsl::string& ClientIdentity::processName() const
{
    return d_processName;
}

inline int ClientIdentity::pid() const
{
    return d_pid;
}

inline int ClientIdentity::sessionId() const
{
    return d_sessionId;
}

inline const bsl::string& ClientIdentity::hostName() const
{
    return d_hostName;
}

inline const bsl::string& ClientIdentity::features() const
{
    return d_features;
}

inline const bsl::string& ClientIdentity::clusterName() const
{
    return d_clusterName;
}

inline int ClientIdentity::clusterNodeId() const
{
    return d_clusterNodeId;
}

inline ClientLanguage::Value ClientIdentity::sdkLanguage() const
{
    return d_sdkLanguage;
}

inline const GuidInfo& ClientIdentity::guidInfo() const
{
    return d_guidInfo;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::ClientIdentity& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.protocolVersion());
    hashAppend(hashAlg, object.sdkVersion());
    hashAppend(hashAlg, object.clientType());
    hashAppend(hashAlg, object.processName());
    hashAppend(hashAlg, object.pid());
    hashAppend(hashAlg, object.sessionId());
    hashAppend(hashAlg, object.hostName());
    hashAppend(hashAlg, object.features());
    hashAppend(hashAlg, object.clusterName());
    hashAppend(hashAlg, object.clusterNodeId());
    hashAppend(hashAlg, object.sdkLanguage());
    hashAppend(hashAlg, object.guidInfo());
}

// ------------------
// class DumpMessages
// ------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int DumpMessages::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_msgTypeToDump,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_dumpActionType,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_dumpActionValue,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_VALUE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int DumpMessages::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MSG_TYPE_TO_DUMP: {
        return manipulator(
            &d_msgTypeToDump,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP]);
    }
    case ATTRIBUTE_ID_DUMP_ACTION_TYPE: {
        return manipulator(
            &d_dumpActionType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_TYPE]);
    }
    case ATTRIBUTE_ID_DUMP_ACTION_VALUE: {
        return manipulator(
            &d_dumpActionValue,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_VALUE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int DumpMessages::manipulateAttribute(MANIPULATOR& manipulator,
                                      const char*  name,
                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline DumpMsgType::Value& DumpMessages::msgTypeToDump()
{
    return d_msgTypeToDump;
}

inline DumpActionType::Value& DumpMessages::dumpActionType()
{
    return d_dumpActionType;
}

inline int& DumpMessages::dumpActionValue()
{
    return d_dumpActionValue;
}

// ACCESSORS
template <class ACCESSOR>
int DumpMessages::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_msgTypeToDump,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_dumpActionType,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_dumpActionValue,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_VALUE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int DumpMessages::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MSG_TYPE_TO_DUMP: {
        return accessor(
            d_msgTypeToDump,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_TYPE_TO_DUMP]);
    }
    case ATTRIBUTE_ID_DUMP_ACTION_TYPE: {
        return accessor(
            d_dumpActionType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_TYPE]);
    }
    case ATTRIBUTE_ID_DUMP_ACTION_VALUE: {
        return accessor(
            d_dumpActionValue,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DUMP_ACTION_VALUE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int DumpMessages::accessAttribute(ACCESSOR&   accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline DumpMsgType::Value DumpMessages::msgTypeToDump() const
{
    return d_msgTypeToDump;
}

inline DumpActionType::Value DumpMessages::dumpActionType() const
{
    return d_dumpActionType;
}

inline int DumpMessages::dumpActionValue() const
{
    return d_dumpActionValue;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::DumpMessages& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.msgTypeToDump());
    hashAppend(hashAlg, object.dumpActionType());
    hashAppend(hashAlg, object.dumpActionValue());
}

// --------------------------
// class ElectorMessageChoice
// --------------------------

// CLASS METHODS
// CREATORS
inline ElectorMessageChoice::ElectorMessageChoice()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline ElectorMessageChoice::~ElectorMessageChoice()
{
    reset();
}

// MANIPULATORS
template <class MANIPULATOR>
int ElectorMessageChoice::manipulateSelection(MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ElectorMessageChoice::SELECTION_ID_ELECTION_PROPOSAL:
        return manipulator(
            &d_electionProposal.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTION_PROPOSAL]);
    case ElectorMessageChoice::SELECTION_ID_ELECTION_RESPONSE:
        return manipulator(
            &d_electionResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTION_RESPONSE]);
    case ElectorMessageChoice::SELECTION_ID_LEADER_HEARTBEAT:
        return manipulator(
            &d_leaderHeartbeat.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_HEARTBEAT]);
    case ElectorMessageChoice::SELECTION_ID_ELECTOR_NODE_STATUS:
        return manipulator(
            &d_electorNodeStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR_NODE_STATUS]);
    case ElectorMessageChoice::SELECTION_ID_HEARTBEAT_RESPONSE:
        return manipulator(
            &d_heartbeatResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_HEARTBEAT_RESPONSE]);
    case ElectorMessageChoice::SELECTION_ID_SCOUTING_REQUEST:
        return manipulator(
            &d_scoutingRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_SCOUTING_REQUEST]);
    case ElectorMessageChoice::SELECTION_ID_SCOUTING_RESPONSE:
        return manipulator(
            &d_scoutingResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_SCOUTING_RESPONSE]);
    case ElectorMessageChoice::SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION:
        return manipulator(
            &d_leadershipCessionNotification.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_LEADERSHIP_CESSION_NOTIFICATION]);
    default:
        BSLS_ASSERT(ElectorMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ElectionProposal& ElectorMessageChoice::electionProposal()
{
    BSLS_ASSERT(SELECTION_ID_ELECTION_PROPOSAL == d_selectionId);
    return d_electionProposal.object();
}

inline ElectionResponse& ElectorMessageChoice::electionResponse()
{
    BSLS_ASSERT(SELECTION_ID_ELECTION_RESPONSE == d_selectionId);
    return d_electionResponse.object();
}

inline LeaderHeartbeat& ElectorMessageChoice::leaderHeartbeat()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_HEARTBEAT == d_selectionId);
    return d_leaderHeartbeat.object();
}

inline ElectorNodeStatus& ElectorMessageChoice::electorNodeStatus()
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR_NODE_STATUS == d_selectionId);
    return d_electorNodeStatus.object();
}

inline HeartbeatResponse& ElectorMessageChoice::heartbeatResponse()
{
    BSLS_ASSERT(SELECTION_ID_HEARTBEAT_RESPONSE == d_selectionId);
    return d_heartbeatResponse.object();
}

inline ScoutingRequest& ElectorMessageChoice::scoutingRequest()
{
    BSLS_ASSERT(SELECTION_ID_SCOUTING_REQUEST == d_selectionId);
    return d_scoutingRequest.object();
}

inline ScoutingResponse& ElectorMessageChoice::scoutingResponse()
{
    BSLS_ASSERT(SELECTION_ID_SCOUTING_RESPONSE == d_selectionId);
    return d_scoutingResponse.object();
}

inline LeadershipCessionNotification&
ElectorMessageChoice::leadershipCessionNotification()
{
    BSLS_ASSERT(SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION == d_selectionId);
    return d_leadershipCessionNotification.object();
}

// ACCESSORS
inline int ElectorMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <class ACCESSOR>
int ElectorMessageChoice::accessSelection(ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ELECTION_PROPOSAL:
        return accessor(
            d_electionProposal.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTION_PROPOSAL]);
    case SELECTION_ID_ELECTION_RESPONSE:
        return accessor(
            d_electionResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTION_RESPONSE]);
    case SELECTION_ID_LEADER_HEARTBEAT:
        return accessor(
            d_leaderHeartbeat.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_HEARTBEAT]);
    case SELECTION_ID_ELECTOR_NODE_STATUS:
        return accessor(
            d_electorNodeStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR_NODE_STATUS]);
    case SELECTION_ID_HEARTBEAT_RESPONSE:
        return accessor(
            d_heartbeatResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_HEARTBEAT_RESPONSE]);
    case SELECTION_ID_SCOUTING_REQUEST:
        return accessor(
            d_scoutingRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_SCOUTING_REQUEST]);
    case SELECTION_ID_SCOUTING_RESPONSE:
        return accessor(
            d_scoutingResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_SCOUTING_RESPONSE]);
    case SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION:
        return accessor(d_leadershipCessionNotification.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_LEADERSHIP_CESSION_NOTIFICATION]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ElectionProposal& ElectorMessageChoice::electionProposal() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTION_PROPOSAL == d_selectionId);
    return d_electionProposal.object();
}

inline const ElectionResponse& ElectorMessageChoice::electionResponse() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTION_RESPONSE == d_selectionId);
    return d_electionResponse.object();
}

inline const LeaderHeartbeat& ElectorMessageChoice::leaderHeartbeat() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_HEARTBEAT == d_selectionId);
    return d_leaderHeartbeat.object();
}

inline const ElectorNodeStatus& ElectorMessageChoice::electorNodeStatus() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR_NODE_STATUS == d_selectionId);
    return d_electorNodeStatus.object();
}

inline const HeartbeatResponse& ElectorMessageChoice::heartbeatResponse() const
{
    BSLS_ASSERT(SELECTION_ID_HEARTBEAT_RESPONSE == d_selectionId);
    return d_heartbeatResponse.object();
}

inline const ScoutingRequest& ElectorMessageChoice::scoutingRequest() const
{
    BSLS_ASSERT(SELECTION_ID_SCOUTING_REQUEST == d_selectionId);
    return d_scoutingRequest.object();
}

inline const ScoutingResponse& ElectorMessageChoice::scoutingResponse() const
{
    BSLS_ASSERT(SELECTION_ID_SCOUTING_RESPONSE == d_selectionId);
    return d_scoutingResponse.object();
}

inline const LeadershipCessionNotification&
ElectorMessageChoice::leadershipCessionNotification() const
{
    BSLS_ASSERT(SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION == d_selectionId);
    return d_leadershipCessionNotification.object();
}

inline bool ElectorMessageChoice::isElectionProposalValue() const
{
    return SELECTION_ID_ELECTION_PROPOSAL == d_selectionId;
}

inline bool ElectorMessageChoice::isElectionResponseValue() const
{
    return SELECTION_ID_ELECTION_RESPONSE == d_selectionId;
}

inline bool ElectorMessageChoice::isLeaderHeartbeatValue() const
{
    return SELECTION_ID_LEADER_HEARTBEAT == d_selectionId;
}

inline bool ElectorMessageChoice::isElectorNodeStatusValue() const
{
    return SELECTION_ID_ELECTOR_NODE_STATUS == d_selectionId;
}

inline bool ElectorMessageChoice::isHeartbeatResponseValue() const
{
    return SELECTION_ID_HEARTBEAT_RESPONSE == d_selectionId;
}

inline bool ElectorMessageChoice::isScoutingRequestValue() const
{
    return SELECTION_ID_SCOUTING_REQUEST == d_selectionId;
}

inline bool ElectorMessageChoice::isScoutingResponseValue() const
{
    return SELECTION_ID_SCOUTING_RESPONSE == d_selectionId;
}

inline bool ElectorMessageChoice::isLeadershipCessionNotificationValue() const
{
    return SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION == d_selectionId;
}

inline bool ElectorMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ElectorMessageChoice& object)
{
    typedef bmqp_ctrlmsg::ElectorMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.selectionId());
    switch (object.selectionId()) {
    case Class::SELECTION_ID_ELECTION_PROPOSAL:
        hashAppend(hashAlg, object.electionProposal());
        break;
    case Class::SELECTION_ID_ELECTION_RESPONSE:
        hashAppend(hashAlg, object.electionResponse());
        break;
    case Class::SELECTION_ID_LEADER_HEARTBEAT:
        hashAppend(hashAlg, object.leaderHeartbeat());
        break;
    case Class::SELECTION_ID_ELECTOR_NODE_STATUS:
        hashAppend(hashAlg, object.electorNodeStatus());
        break;
    case Class::SELECTION_ID_HEARTBEAT_RESPONSE:
        hashAppend(hashAlg, object.heartbeatResponse());
        break;
    case Class::SELECTION_ID_SCOUTING_REQUEST:
        hashAppend(hashAlg, object.scoutingRequest());
        break;
    case Class::SELECTION_ID_SCOUTING_RESPONSE:
        hashAppend(hashAlg, object.scoutingResponse());
        break;
    case Class::SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION:
        hashAppend(hashAlg, object.leadershipCessionNotification());
        break;
    default:
        BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == object.selectionId());
    }
}

// ----------------
// class Expression
// ----------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int Expression::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_version,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int Expression::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_VERSION: {
        return manipulator(&d_version,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    }
    case ATTRIBUTE_ID_TEXT: {
        return manipulator(&d_text,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int Expression::manipulateAttribute(MANIPULATOR& manipulator,
                                    const char*  name,
                                    int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ExpressionVersion::Value& Expression::version()
{
    return d_version;
}

inline bsl::string& Expression::text()
{
    return d_text;
}

// ACCESSORS
template <class ACCESSOR>
int Expression::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_version, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int Expression::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_VERSION: {
        return accessor(d_version,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VERSION]);
    }
    case ATTRIBUTE_ID_TEXT: {
        return accessor(d_text, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TEXT]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int Expression::accessAttribute(ACCESSOR&   accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline ExpressionVersion::Value Expression::version() const
{
    return d_version;
}

inline const bsl::string& Expression::text() const
{
    return d_text;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                 hashAlg,
                const bmqp_ctrlmsg::Expression& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.version());
    hashAppend(hashAlg, object.text());
}

// -------------------------
// class FollowerLSNResponse
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int FollowerLSNResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int FollowerLSNResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int FollowerLSNResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& FollowerLSNResponse::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int FollowerLSNResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int FollowerLSNResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int FollowerLSNResponse::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence& FollowerLSNResponse::sequenceNumber() const
{
    return d_sequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::FollowerLSNResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumber());
}

// -----------------------
// class LeaderAdvisoryAck
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderAdvisoryAck::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_sequenceNumberAcked,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int LeaderAdvisoryAck::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER_ACKED: {
        return manipulator(
            &d_sequenceNumberAcked,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderAdvisoryAck::manipulateAttribute(MANIPULATOR& manipulator,
                                           const char*  name,
                                           int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& LeaderAdvisoryAck::sequenceNumberAcked()
{
    return d_sequenceNumberAcked;
}

// ACCESSORS
template <class ACCESSOR>
int LeaderAdvisoryAck::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_sequenceNumberAcked,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int LeaderAdvisoryAck::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER_ACKED: {
        return accessor(
            d_sequenceNumberAcked,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_ACKED]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderAdvisoryAck::accessAttribute(ACCESSOR&   accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
LeaderAdvisoryAck::sequenceNumberAcked() const
{
    return d_sequenceNumberAcked;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::LeaderAdvisoryAck& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumberAcked());
}

// --------------------------
// class LeaderAdvisoryCommit
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderAdvisoryCommit::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_sequenceNumberCommitted,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int LeaderAdvisoryCommit::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER_COMMITTED: {
        return manipulator(
            &d_sequenceNumberCommitted,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderAdvisoryCommit::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& LeaderAdvisoryCommit::sequenceNumber()
{
    return d_sequenceNumber;
}

inline LeaderMessageSequence& LeaderAdvisoryCommit::sequenceNumberCommitted()
{
    return d_sequenceNumberCommitted;
}

// ACCESSORS
template <class ACCESSOR>
int LeaderAdvisoryCommit::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_sequenceNumberCommitted,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int LeaderAdvisoryCommit::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER_COMMITTED: {
        return accessor(
            d_sequenceNumberCommitted,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER_COMMITTED]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderAdvisoryCommit::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
LeaderAdvisoryCommit::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const LeaderMessageSequence&
LeaderAdvisoryCommit::sequenceNumberCommitted() const
{
    return d_sequenceNumberCommitted;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::LeaderAdvisoryCommit& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumber());
    hashAppend(hashAlg, object.sequenceNumberCommitted());
}

// ----------------------------------
// class LeaderSyncStateQueryResponse
// ----------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderSyncStateQueryResponse::manipulateAttributes(
    MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_leaderMessageSequence,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int LeaderSyncStateQueryResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                      int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE: {
        return manipulator(
            &d_leaderMessageSequence,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderSyncStateQueryResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                      const char*  name,
                                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence&
LeaderSyncStateQueryResponse::leaderMessageSequence()
{
    return d_leaderMessageSequence;
}

// ACCESSORS
template <class ACCESSOR>
int LeaderSyncStateQueryResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_leaderMessageSequence,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int LeaderSyncStateQueryResponse::accessAttribute(ACCESSOR& accessor,
                                                  int       id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE: {
        return accessor(
            d_leaderMessageSequence,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderSyncStateQueryResponse::accessAttribute(ACCESSOR&   accessor,
                                                  const char* name,
                                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
LeaderSyncStateQueryResponse::leaderMessageSequence() const
{
    return d_leaderMessageSequence;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::LeaderSyncStateQueryResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.leaderMessageSequence());
}

// ------------------------
// class NodeStatusAdvisory
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int NodeStatusAdvisory::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int NodeStatusAdvisory::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int NodeStatusAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                            const char*  name,
                                            int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline NodeStatus::Value& NodeStatusAdvisory::status()
{
    return d_status;
}

// ACCESSORS
template <class ACCESSOR>
int NodeStatusAdvisory::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int NodeStatusAdvisory::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int NodeStatusAdvisory::accessAttribute(ACCESSOR&   accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline NodeStatus::Value NodeStatusAdvisory::status() const
{
    return d_status;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::NodeStatusAdvisory& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.status());
}

// ------------------------------
// class PartitionPrimaryAdvisory
// ------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionPrimaryAdvisory::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitions,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionPrimaryAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                                  int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITIONS: {
        return manipulator(&d_partitions,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionPrimaryAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                                  const char*  name,
                                                  int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& PartitionPrimaryAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline bsl::vector<PartitionPrimaryInfo>&
PartitionPrimaryAdvisory::partitions()
{
    return d_partitions;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionPrimaryAdvisory::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitions,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionPrimaryAdvisory::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITIONS: {
        return accessor(d_partitions,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionPrimaryAdvisory::accessAttribute(ACCESSOR&   accessor,
                                              const char* name,
                                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
PartitionPrimaryAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const bsl::vector<PartitionPrimaryInfo>&
PartitionPrimaryAdvisory::partitions() const
{
    return d_partitions;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                               hashAlg,
                const bmqp_ctrlmsg::PartitionPrimaryAdvisory& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumber());
    hashAppend(hashAlg, object.partitions());
}

// -------------------------
// class PrimaryStateRequest
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PrimaryStateRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PrimaryStateRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PrimaryStateRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PrimaryStateRequest::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& PrimaryStateRequest::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int PrimaryStateRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PrimaryStateRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PrimaryStateRequest::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PrimaryStateRequest::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
PrimaryStateRequest::sequenceNumber() const
{
    return d_sequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::PrimaryStateRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.sequenceNumber());
}

// --------------------------
// class PrimaryStateResponse
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PrimaryStateResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PrimaryStateResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PrimaryStateResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PrimaryStateResponse::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& PrimaryStateResponse::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int PrimaryStateResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PrimaryStateResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PrimaryStateResponse::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PrimaryStateResponse::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
PrimaryStateResponse::sequenceNumber() const
{
    return d_sequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::PrimaryStateResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.sequenceNumber());
}

// ---------------------------
// class PrimaryStatusAdvisory
// ---------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PrimaryStatusAdvisory::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PrimaryStatusAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                               int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PrimaryStatusAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                               const char*  name,
                                               int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PrimaryStatusAdvisory::partitionId()
{
    return d_partitionId;
}

inline unsigned int& PrimaryStatusAdvisory::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline PrimaryStatus::Value& PrimaryStatusAdvisory::status()
{
    return d_status;
}

// ACCESSORS
template <class ACCESSOR>
int PrimaryStatusAdvisory::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PrimaryStatusAdvisory::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PrimaryStatusAdvisory::accessAttribute(ACCESSOR&   accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PrimaryStatusAdvisory::partitionId() const
{
    return d_partitionId;
}

inline unsigned int PrimaryStatusAdvisory::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline PrimaryStatus::Value PrimaryStatusAdvisory::status() const
{
    return d_status;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                            hashAlg,
                const bmqp_ctrlmsg::PrimaryStatusAdvisory& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.primaryLeaseId());
    hashAppend(hashAlg, object.status());
}

// ---------------------------
// class QueueHandleParameters
// ---------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueHandleParameters::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_subIdInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_readCount,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_READ_COUNT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_writeCount,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WRITE_COUNT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_adminCount,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADMIN_COUNT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueHandleParameters::manipulateAttribute(MANIPULATOR& manipulator,
                                               int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_Q_ID: {
        return manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_SUB_ID_INFO: {
        return manipulator(&d_subIdInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    }
    case ATTRIBUTE_ID_FLAGS: {
        return manipulator(&d_flags,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    }
    case ATTRIBUTE_ID_READ_COUNT: {
        return manipulator(&d_readCount,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_READ_COUNT]);
    }
    case ATTRIBUTE_ID_WRITE_COUNT: {
        return manipulator(&d_writeCount,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WRITE_COUNT]);
    }
    case ATTRIBUTE_ID_ADMIN_COUNT: {
        return manipulator(&d_adminCount,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADMIN_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueHandleParameters::manipulateAttribute(MANIPULATOR& manipulator,
                                               const char*  name,
                                               int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueHandleParameters::uri()
{
    return d_uri;
}

inline unsigned int& QueueHandleParameters::qId()
{
    return d_qId;
}

inline bdlb::NullableValue<SubQueueIdInfo>& QueueHandleParameters::subIdInfo()
{
    return d_subIdInfo;
}

inline bsls::Types::Uint64& QueueHandleParameters::flags()
{
    return d_flags;
}

inline int& QueueHandleParameters::readCount()
{
    return d_readCount;
}

inline int& QueueHandleParameters::writeCount()
{
    return d_writeCount;
}

inline int& QueueHandleParameters::adminCount()
{
    return d_adminCount;
}

// ACCESSORS
template <class ACCESSOR>
int QueueHandleParameters::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_subIdInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_readCount,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_READ_COUNT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_writeCount,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WRITE_COUNT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_adminCount,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADMIN_COUNT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueHandleParameters::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_Q_ID: {
        return accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_SUB_ID_INFO: {
        return accessor(d_subIdInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    }
    case ATTRIBUTE_ID_FLAGS: {
        return accessor(d_flags, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FLAGS]);
    }
    case ATTRIBUTE_ID_READ_COUNT: {
        return accessor(d_readCount,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_READ_COUNT]);
    }
    case ATTRIBUTE_ID_WRITE_COUNT: {
        return accessor(d_writeCount,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_WRITE_COUNT]);
    }
    case ATTRIBUTE_ID_ADMIN_COUNT: {
        return accessor(d_adminCount,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADMIN_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueHandleParameters::accessAttribute(ACCESSOR&   accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueHandleParameters::uri() const
{
    return d_uri;
}

inline unsigned int QueueHandleParameters::qId() const
{
    return d_qId;
}

inline const bdlb::NullableValue<SubQueueIdInfo>&
QueueHandleParameters::subIdInfo() const
{
    return d_subIdInfo;
}

inline bsls::Types::Uint64 QueueHandleParameters::flags() const
{
    return d_flags;
}

inline int QueueHandleParameters::readCount() const
{
    return d_readCount;
}

inline int QueueHandleParameters::writeCount() const
{
    return d_writeCount;
}

inline int QueueHandleParameters::adminCount() const
{
    return d_adminCount;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                            hashAlg,
                const bmqp_ctrlmsg::QueueHandleParameters& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.uri());
    hashAppend(hashAlg, object.qId());
    hashAppend(hashAlg, object.subIdInfo());
    hashAppend(hashAlg, object.flags());
    hashAppend(hashAlg, object.readCount());
    hashAppend(hashAlg, object.writeCount());
    hashAppend(hashAlg, object.adminCount());
}

// ---------------
// class QueueInfo
// ---------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueInfo::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_IDS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueInfo::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_KEY: {
        return manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_APP_IDS: {
        return manipulator(&d_appIds,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_IDS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueInfo::manipulateAttribute(MANIPULATOR& manipulator,
                                   const char*  name,
                                   int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueInfo::uri()
{
    return d_uri;
}

inline bsl::vector<char>& QueueInfo::key()
{
    return d_key;
}

inline int& QueueInfo::partitionId()
{
    return d_partitionId;
}

inline bsl::vector<AppIdInfo>& QueueInfo::appIds()
{
    return d_appIds;
}

// ACCESSORS
template <class ACCESSOR>
int QueueInfo::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appIds, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_IDS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueInfo::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_KEY: {
        return accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_APP_IDS: {
        return accessor(d_appIds,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_IDS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueInfo::accessAttribute(ACCESSOR&   accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueInfo::uri() const
{
    return d_uri;
}

inline const bsl::vector<char>& QueueInfo::key() const
{
    return d_key;
}

inline int QueueInfo::partitionId() const
{
    return d_partitionId;
}

inline const bsl::vector<AppIdInfo>& QueueInfo::appIds() const
{
    return d_appIds;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM& hashAlg, const bmqp_ctrlmsg::QueueInfo& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.uri());
    hashAppend(hashAlg, object.key());
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.appIds());
}

// ---------------------
// class QueueInfoUpdate
// ---------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueInfoUpdate::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_addedAppIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADDED_APP_IDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_removedAppIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOVED_APP_IDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_domain, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAIN]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueInfoUpdate::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_KEY: {
        return manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_ADDED_APP_IDS: {
        return manipulator(
            &d_addedAppIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADDED_APP_IDS]);
    }
    case ATTRIBUTE_ID_REMOVED_APP_IDS: {
        return manipulator(
            &d_removedAppIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOVED_APP_IDS]);
    }
    case ATTRIBUTE_ID_DOMAIN: {
        return manipulator(&d_domain,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAIN]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueInfoUpdate::manipulateAttribute(MANIPULATOR& manipulator,
                                         const char*  name,
                                         int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueInfoUpdate::uri()
{
    return d_uri;
}

inline bsl::vector<char>& QueueInfoUpdate::key()
{
    return d_key;
}

inline int& QueueInfoUpdate::partitionId()
{
    return d_partitionId;
}

inline bsl::vector<AppIdInfo>& QueueInfoUpdate::addedAppIds()
{
    return d_addedAppIds;
}

inline bsl::vector<AppIdInfo>& QueueInfoUpdate::removedAppIds()
{
    return d_removedAppIds;
}

inline bsl::string& QueueInfoUpdate::domain()
{
    return d_domain;
}

// ACCESSORS
template <class ACCESSOR>
int QueueInfoUpdate::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_addedAppIds,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADDED_APP_IDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_removedAppIds,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOVED_APP_IDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_domain, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAIN]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueInfoUpdate::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_KEY: {
        return accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_ADDED_APP_IDS: {
        return accessor(d_addedAppIds,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ADDED_APP_IDS]);
    }
    case ATTRIBUTE_ID_REMOVED_APP_IDS: {
        return accessor(d_removedAppIds,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOVED_APP_IDS]);
    }
    case ATTRIBUTE_ID_DOMAIN: {
        return accessor(d_domain,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAIN]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueInfoUpdate::accessAttribute(ACCESSOR&   accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueInfoUpdate::uri() const
{
    return d_uri;
}

inline const bsl::vector<char>& QueueInfoUpdate::key() const
{
    return d_key;
}

inline int QueueInfoUpdate::partitionId() const
{
    return d_partitionId;
}

inline const bsl::vector<AppIdInfo>& QueueInfoUpdate::addedAppIds() const
{
    return d_addedAppIds;
}

inline const bsl::vector<AppIdInfo>& QueueInfoUpdate::removedAppIds() const
{
    return d_removedAppIds;
}

inline const bsl::string& QueueInfoUpdate::domain() const
{
    return d_domain;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                      hashAlg,
                const bmqp_ctrlmsg::QueueInfoUpdate& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.uri());
    hashAppend(hashAlg, object.key());
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.addedAppIds());
    hashAppend(hashAlg, object.removedAppIds());
    hashAppend(hashAlg, object.domain());
}

// ---------------------------
// class QueueStreamParameters
// ---------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueStreamParameters::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_subIdInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumerPriority,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueStreamParameters::manipulateAttribute(MANIPULATOR& manipulator,
                                               int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID_INFO: {
        return manipulator(&d_subIdInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return manipulator(
            &d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return manipulator(
            &d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return manipulator(
            &d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return manipulator(
            &d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueStreamParameters::manipulateAttribute(MANIPULATOR& manipulator,
                                               const char*  name,
                                               int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bdlb::NullableValue<SubQueueIdInfo>& QueueStreamParameters::subIdInfo()
{
    return d_subIdInfo;
}

inline bsls::Types::Int64& QueueStreamParameters::maxUnconfirmedMessages()
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64& QueueStreamParameters::maxUnconfirmedBytes()
{
    return d_maxUnconfirmedBytes;
}

inline int& QueueStreamParameters::consumerPriority()
{
    return d_consumerPriority;
}

inline int& QueueStreamParameters::consumerPriorityCount()
{
    return d_consumerPriorityCount;
}

// ACCESSORS
template <class ACCESSOR>
int QueueStreamParameters::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_subIdInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumerPriority,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueStreamParameters::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID_INFO: {
        return accessor(d_subIdInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID_INFO]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return accessor(
            d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return accessor(
            d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return accessor(
            d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return accessor(
            d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueStreamParameters::accessAttribute(ACCESSOR&   accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bdlb::NullableValue<SubQueueIdInfo>&
QueueStreamParameters::subIdInfo() const
{
    return d_subIdInfo;
}

inline bsls::Types::Int64 QueueStreamParameters::maxUnconfirmedMessages() const
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64 QueueStreamParameters::maxUnconfirmedBytes() const
{
    return d_maxUnconfirmedBytes;
}

inline int QueueStreamParameters::consumerPriority() const
{
    return d_consumerPriority;
}

inline int QueueStreamParameters::consumerPriorityCount() const
{
    return d_consumerPriorityCount;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                            hashAlg,
                const bmqp_ctrlmsg::QueueStreamParameters& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.subIdInfo());
    hashAppend(hashAlg, object.maxUnconfirmedMessages());
    hashAppend(hashAlg, object.maxUnconfirmedBytes());
    hashAppend(hashAlg, object.consumerPriority());
    hashAppend(hashAlg, object.consumerPriorityCount());
}

// -------------------------
// class RegistrationRequest
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int RegistrationRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int RegistrationRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int RegistrationRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& RegistrationRequest::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int RegistrationRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int RegistrationRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int RegistrationRequest::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence& RegistrationRequest::sequenceNumber() const
{
    return d_sequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::RegistrationRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumber());
}

// ------------------------
// class ReplicaDataRequest
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ReplicaDataRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_replicaDataType,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_beginSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_endSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ReplicaDataRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REPLICA_DATA_TYPE: {
        return manipulator(
            &d_replicaDataType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER: {
        return manipulator(
            &d_beginSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUMBER: {
        return manipulator(
            &d_endSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ReplicaDataRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                            const char*  name,
                                            int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ReplicaDataType::Value& ReplicaDataRequest::replicaDataType()
{
    return d_replicaDataType;
}

inline int& ReplicaDataRequest::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& ReplicaDataRequest::beginSequenceNumber()
{
    return d_beginSequenceNumber;
}

inline PartitionSequenceNumber& ReplicaDataRequest::endSequenceNumber()
{
    return d_endSequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int ReplicaDataRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_replicaDataType,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_beginSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endSequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ReplicaDataRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REPLICA_DATA_TYPE: {
        return accessor(
            d_replicaDataType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER: {
        return accessor(
            d_beginSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUMBER: {
        return accessor(
            d_endSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ReplicaDataRequest::accessAttribute(ACCESSOR&   accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline ReplicaDataType::Value ReplicaDataRequest::replicaDataType() const
{
    return d_replicaDataType;
}

inline int ReplicaDataRequest::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
ReplicaDataRequest::beginSequenceNumber() const
{
    return d_beginSequenceNumber;
}

inline const PartitionSequenceNumber&
ReplicaDataRequest::endSequenceNumber() const
{
    return d_endSequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::ReplicaDataRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.replicaDataType());
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.beginSequenceNumber());
    hashAppend(hashAlg, object.endSequenceNumber());
}

// -------------------------
// class ReplicaDataResponse
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ReplicaDataResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_replicaDataType,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_beginSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_endSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ReplicaDataResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REPLICA_DATA_TYPE: {
        return manipulator(
            &d_replicaDataType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER: {
        return manipulator(
            &d_beginSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUMBER: {
        return manipulator(
            &d_endSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ReplicaDataResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ReplicaDataType::Value& ReplicaDataResponse::replicaDataType()
{
    return d_replicaDataType;
}

inline int& ReplicaDataResponse::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& ReplicaDataResponse::beginSequenceNumber()
{
    return d_beginSequenceNumber;
}

inline PartitionSequenceNumber& ReplicaDataResponse::endSequenceNumber()
{
    return d_endSequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int ReplicaDataResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_replicaDataType,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_beginSequenceNumber,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endSequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ReplicaDataResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REPLICA_DATA_TYPE: {
        return accessor(
            d_replicaDataType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REPLICA_DATA_TYPE]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SEQUENCE_NUMBER: {
        return accessor(
            d_beginSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_END_SEQUENCE_NUMBER: {
        return accessor(
            d_endSequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ReplicaDataResponse::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline ReplicaDataType::Value ReplicaDataResponse::replicaDataType() const
{
    return d_replicaDataType;
}

inline int ReplicaDataResponse::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
ReplicaDataResponse::beginSequenceNumber() const
{
    return d_beginSequenceNumber;
}

inline const PartitionSequenceNumber&
ReplicaDataResponse::endSequenceNumber() const
{
    return d_endSequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::ReplicaDataResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.replicaDataType());
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.beginSequenceNumber());
    hashAppend(hashAlg, object.endSequenceNumber());
}

// -------------------------
// class ReplicaStateRequest
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ReplicaStateRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ReplicaStateRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ReplicaStateRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& ReplicaStateRequest::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& ReplicaStateRequest::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int ReplicaStateRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ReplicaStateRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ReplicaStateRequest::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int ReplicaStateRequest::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
ReplicaStateRequest::sequenceNumber() const
{
    return d_sequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::ReplicaStateRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.sequenceNumber());
}

// --------------------------
// class ReplicaStateResponse
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ReplicaStateResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ReplicaStateResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ReplicaStateResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& ReplicaStateResponse::partitionId()
{
    return d_partitionId;
}

inline PartitionSequenceNumber& ReplicaStateResponse::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <class ACCESSOR>
int ReplicaStateResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ReplicaStateResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ReplicaStateResponse::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int ReplicaStateResponse::partitionId() const
{
    return d_partitionId;
}

inline const PartitionSequenceNumber&
ReplicaStateResponse::sequenceNumber() const
{
    return d_sequenceNumber;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ReplicaStateResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.sequenceNumber());
}

// -----------------------------
// class StateNotificationChoice
// -----------------------------

// CLASS METHODS
// CREATORS
inline StateNotificationChoice::StateNotificationChoice()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline StateNotificationChoice::~StateNotificationChoice()
{
    reset();
}

// MANIPULATORS
template <class MANIPULATOR>
int StateNotificationChoice::manipulateSelection(MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StateNotificationChoice::SELECTION_ID_LEADER_PASSIVE:
        return manipulator(
            &d_leaderPassive.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_PASSIVE]);
    default:
        BSLS_ASSERT(StateNotificationChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline LeaderPassive& StateNotificationChoice::leaderPassive()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_PASSIVE == d_selectionId);
    return d_leaderPassive.object();
}

// ACCESSORS
inline int StateNotificationChoice::selectionId() const
{
    return d_selectionId;
}

template <class ACCESSOR>
int StateNotificationChoice::accessSelection(ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_LEADER_PASSIVE:
        return accessor(d_leaderPassive.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_PASSIVE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const LeaderPassive& StateNotificationChoice::leaderPassive() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_PASSIVE == d_selectionId);
    return d_leaderPassive.object();
}

inline bool StateNotificationChoice::isLeaderPassiveValue() const
{
    return SELECTION_ID_LEADER_PASSIVE == d_selectionId;
}

inline bool StateNotificationChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::StateNotificationChoice& object)
{
    typedef bmqp_ctrlmsg::StateNotificationChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.selectionId());
    switch (object.selectionId()) {
    case Class::SELECTION_ID_LEADER_PASSIVE:
        hashAppend(hashAlg, object.leaderPassive());
        break;
    default:
        BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == object.selectionId());
    }
}

// ------------
// class Status
// ------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int Status::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_category,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CATEGORY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_code, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CODE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_message,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int Status::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CATEGORY: {
        return manipulator(&d_category,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CATEGORY]);
    }
    case ATTRIBUTE_ID_CODE: {
        return manipulator(&d_code,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CODE]);
    }
    case ATTRIBUTE_ID_MESSAGE: {
        return manipulator(&d_message,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int Status::manipulateAttribute(MANIPULATOR& manipulator,
                                const char*  name,
                                int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline StatusCategory::Value& Status::category()
{
    return d_category;
}

inline int& Status::code()
{
    return d_code;
}

inline bsl::string& Status::message()
{
    return d_message;
}

// ACCESSORS
template <class ACCESSOR>
int Status::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_category, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CATEGORY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_code, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CODE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_message, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int Status::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CATEGORY: {
        return accessor(d_category,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CATEGORY]);
    }
    case ATTRIBUTE_ID_CODE: {
        return accessor(d_code, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CODE]);
    }
    case ATTRIBUTE_ID_MESSAGE: {
        return accessor(d_message,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int Status::accessAttribute(ACCESSOR&   accessor,
                            const char* name,
                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline StatusCategory::Value Status::category() const
{
    return d_category;
}

inline int Status::code() const
{
    return d_code;
}

inline const bsl::string& Status::message() const
{
    return d_message;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM& hashAlg, const bmqp_ctrlmsg::Status& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.category());
    hashAppend(hashAlg, object.code());
    hashAppend(hashAlg, object.message());
}

// -------------------------
// class StorageSyncResponse
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int StorageSyncResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_storageSyncResponseType,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_beginSyncPoint,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_endSyncPoint,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int StorageSyncResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STORAGE_SYNC_RESPONSE_TYPE: {
        return manipulator(
            &d_storageSyncResponseType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE]);
    }
    case ATTRIBUTE_ID_BEGIN_SYNC_POINT: {
        return manipulator(
            &d_beginSyncPoint,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT]);
    }
    case ATTRIBUTE_ID_END_SYNC_POINT: {
        return manipulator(
            &d_endSyncPoint,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int StorageSyncResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& StorageSyncResponse::partitionId()
{
    return d_partitionId;
}

inline StorageSyncResponseType::Value&
StorageSyncResponse::storageSyncResponseType()
{
    return d_storageSyncResponseType;
}

inline SyncPoint& StorageSyncResponse::beginSyncPoint()
{
    return d_beginSyncPoint;
}

inline SyncPoint& StorageSyncResponse::endSyncPoint()
{
    return d_endSyncPoint;
}

// ACCESSORS
template <class ACCESSOR>
int StorageSyncResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_storageSyncResponseType,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_beginSyncPoint,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_endSyncPoint,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int StorageSyncResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STORAGE_SYNC_RESPONSE_TYPE: {
        return accessor(
            d_storageSyncResponseType,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_SYNC_RESPONSE_TYPE]);
    }
    case ATTRIBUTE_ID_BEGIN_SYNC_POINT: {
        return accessor(
            d_beginSyncPoint,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT]);
    }
    case ATTRIBUTE_ID_END_SYNC_POINT: {
        return accessor(d_endSyncPoint,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int StorageSyncResponse::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int StorageSyncResponse::partitionId() const
{
    return d_partitionId;
}

inline StorageSyncResponseType::Value
StorageSyncResponse::storageSyncResponseType() const
{
    return d_storageSyncResponseType;
}

inline const SyncPoint& StorageSyncResponse::beginSyncPoint() const
{
    return d_beginSyncPoint;
}

inline const SyncPoint& StorageSyncResponse::endSyncPoint() const
{
    return d_endSyncPoint;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::StorageSyncResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.storageSyncResponseType());
    hashAppend(hashAlg, object.beginSyncPoint());
    hashAppend(hashAlg, object.endSyncPoint());
}

// -------------------------
// class SyncPointOffsetPair
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int SyncPointOffsetPair::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_syncPoint,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_offset, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int SyncPointOffsetPair::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SYNC_POINT: {
        return manipulator(&d_syncPoint,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SYNC_POINT]);
    }
    case ATTRIBUTE_ID_OFFSET: {
        return manipulator(&d_offset,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int SyncPointOffsetPair::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline SyncPoint& SyncPointOffsetPair::syncPoint()
{
    return d_syncPoint;
}

inline bsls::Types::Uint64& SyncPointOffsetPair::offset()
{
    return d_offset;
}

// ACCESSORS
template <class ACCESSOR>
int SyncPointOffsetPair::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_syncPoint,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SYNC_POINT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_offset, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int SyncPointOffsetPair::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SYNC_POINT: {
        return accessor(d_syncPoint,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SYNC_POINT]);
    }
    case ATTRIBUTE_ID_OFFSET: {
        return accessor(d_offset,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int SyncPointOffsetPair::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const SyncPoint& SyncPointOffsetPair::syncPoint() const
{
    return d_syncPoint;
}

inline bsls::Types::Uint64 SyncPointOffsetPair::offset() const
{
    return d_offset;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::SyncPointOffsetPair& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.syncPoint());
    hashAppend(hashAlg, object.offset());
}

// --------------------
// class BrokerResponse
// --------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int BrokerResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_result, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_protocolVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_brokerVersion,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_VERSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isDeprecatedSdk,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DEPRECATED_SDK]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_brokerIdentity,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_IDENTITY]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int BrokerResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_RESULT: {
        return manipulator(&d_result,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    }
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return manipulator(
            &d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_BROKER_VERSION: {
        return manipulator(
            &d_brokerVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_VERSION]);
    }
    case ATTRIBUTE_ID_IS_DEPRECATED_SDK: {
        return manipulator(
            &d_isDeprecatedSdk,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DEPRECATED_SDK]);
    }
    case ATTRIBUTE_ID_BROKER_IDENTITY: {
        return manipulator(
            &d_brokerIdentity,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_IDENTITY]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int BrokerResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                        const char*  name,
                                        int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline Status& BrokerResponse::result()
{
    return d_result;
}

inline int& BrokerResponse::protocolVersion()
{
    return d_protocolVersion;
}

inline int& BrokerResponse::brokerVersion()
{
    return d_brokerVersion;
}

inline bool& BrokerResponse::isDeprecatedSdk()
{
    return d_isDeprecatedSdk;
}

inline ClientIdentity& BrokerResponse::brokerIdentity()
{
    return d_brokerIdentity;
}

// ACCESSORS
template <class ACCESSOR>
int BrokerResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_result, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_protocolVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_brokerVersion,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_VERSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isDeprecatedSdk,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DEPRECATED_SDK]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_brokerIdentity,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_IDENTITY]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int BrokerResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_RESULT: {
        return accessor(d_result,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    }
    case ATTRIBUTE_ID_PROTOCOL_VERSION: {
        return accessor(
            d_protocolVersion,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PROTOCOL_VERSION]);
    }
    case ATTRIBUTE_ID_BROKER_VERSION: {
        return accessor(d_brokerVersion,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_VERSION]);
    }
    case ATTRIBUTE_ID_IS_DEPRECATED_SDK: {
        return accessor(
            d_isDeprecatedSdk,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DEPRECATED_SDK]);
    }
    case ATTRIBUTE_ID_BROKER_IDENTITY: {
        return accessor(d_brokerIdentity,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BROKER_IDENTITY]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int BrokerResponse::accessAttribute(ACCESSOR&   accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const Status& BrokerResponse::result() const
{
    return d_result;
}

inline int BrokerResponse::protocolVersion() const
{
    return d_protocolVersion;
}

inline int BrokerResponse::brokerVersion() const
{
    return d_brokerVersion;
}

inline bool BrokerResponse::isDeprecatedSdk() const
{
    return d_isDeprecatedSdk;
}

inline const ClientIdentity& BrokerResponse::brokerIdentity() const
{
    return d_brokerIdentity;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::BrokerResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.result());
    hashAppend(hashAlg, object.protocolVersion());
    hashAppend(hashAlg, object.brokerVersion());
    hashAppend(hashAlg, object.isDeprecatedSdk());
    hashAppend(hashAlg, object.brokerIdentity());
}

// ----------------
// class CloseQueue
// ----------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int CloseQueue::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_handleParameters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isFinal,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_FINAL]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int CloseQueue::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HANDLE_PARAMETERS: {
        return manipulator(
            &d_handleParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    }
    case ATTRIBUTE_ID_IS_FINAL: {
        return manipulator(&d_isFinal,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_FINAL]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int CloseQueue::manipulateAttribute(MANIPULATOR& manipulator,
                                    const char*  name,
                                    int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline QueueHandleParameters& CloseQueue::handleParameters()
{
    return d_handleParameters;
}

inline bool& CloseQueue::isFinal()
{
    return d_isFinal;
}

// ACCESSORS
template <class ACCESSOR>
int CloseQueue::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_handleParameters,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isFinal, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_FINAL]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int CloseQueue::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HANDLE_PARAMETERS: {
        return accessor(
            d_handleParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    }
    case ATTRIBUTE_ID_IS_FINAL: {
        return accessor(d_isFinal,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_FINAL]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int CloseQueue::accessAttribute(ACCESSOR&   accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const QueueHandleParameters& CloseQueue::handleParameters() const
{
    return d_handleParameters;
}

inline bool CloseQueue::isFinal() const
{
    return d_isFinal;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                 hashAlg,
                const bmqp_ctrlmsg::CloseQueue& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.handleParameters());
    hashAppend(hashAlg, object.isFinal());
}

// --------------------------
// class ConfigureQueueStream
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ConfigureQueueStream::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_streamParameters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ConfigureQueueStream::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_Q_ID: {
        return manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS: {
        return manipulator(
            &d_streamParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ConfigureQueueStream::manipulateAttribute(MANIPULATOR& manipulator,
                                              const char*  name,
                                              int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& ConfigureQueueStream::qId()
{
    return d_qId;
}

inline QueueStreamParameters& ConfigureQueueStream::streamParameters()
{
    return d_streamParameters;
}

// ACCESSORS
template <class ACCESSOR>
int ConfigureQueueStream::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_streamParameters,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ConfigureQueueStream::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_Q_ID: {
        return accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS: {
        return accessor(
            d_streamParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ConfigureQueueStream::accessAttribute(ACCESSOR&   accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int ConfigureQueueStream::qId() const
{
    return d_qId;
}

inline const QueueStreamParameters&
ConfigureQueueStream::streamParameters() const
{
    return d_streamParameters;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ConfigureQueueStream& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.qId());
    hashAppend(hashAlg, object.streamParameters());
}

// --------------------
// class ElectorMessage
// --------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ElectorMessage::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_term, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TERM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ElectorMessage::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TERM: {
        return manipulator(&d_term,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TERM]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ElectorMessage::manipulateAttribute(MANIPULATOR& manipulator,
                                        const char*  name,
                                        int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Uint64& ElectorMessage::term()
{
    return d_term;
}

inline ElectorMessageChoice& ElectorMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <class ACCESSOR>
int ElectorMessage::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_term, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TERM]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ElectorMessage::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TERM: {
        return accessor(d_term, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TERM]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ElectorMessage::accessAttribute(ACCESSOR&   accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Uint64 ElectorMessage::term() const
{
    return d_term;
}

inline const ElectorMessageChoice& ElectorMessage::choice() const
{
    return d_choice;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::ElectorMessage& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.term());
    hashAppend(hashAlg, object.choice());
}

// --------------------
// class LeaderAdvisory
// --------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderAdvisory::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitions,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int LeaderAdvisory::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITIONS: {
        return manipulator(&d_partitions,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                        const char*  name,
                                        int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& LeaderAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline bsl::vector<PartitionPrimaryInfo>& LeaderAdvisory::partitions()
{
    return d_partitions;
}

inline bsl::vector<QueueInfo>& LeaderAdvisory::queues()
{
    return d_queues;
}

// ACCESSORS
template <class ACCESSOR>
int LeaderAdvisory::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitions,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int LeaderAdvisory::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITIONS: {
        return accessor(d_partitions,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderAdvisory::accessAttribute(ACCESSOR&   accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence& LeaderAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const bsl::vector<PartitionPrimaryInfo>&
LeaderAdvisory::partitions() const
{
    return d_partitions;
}

inline const bsl::vector<QueueInfo>& LeaderAdvisory::queues() const
{
    return d_queues;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::LeaderAdvisory& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumber());
    hashAppend(hashAlg, object.partitions());
    hashAppend(hashAlg, object.queues());
}

// ---------------
// class OpenQueue
// ---------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int OpenQueue::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_handleParameters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int OpenQueue::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HANDLE_PARAMETERS: {
        return manipulator(
            &d_handleParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int OpenQueue::manipulateAttribute(MANIPULATOR& manipulator,
                                   const char*  name,
                                   int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline QueueHandleParameters& OpenQueue::handleParameters()
{
    return d_handleParameters;
}

// ACCESSORS
template <class ACCESSOR>
int OpenQueue::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_handleParameters,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int OpenQueue::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HANDLE_PARAMETERS: {
        return accessor(
            d_handleParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int OpenQueue::accessAttribute(ACCESSOR&   accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const QueueHandleParameters& OpenQueue::handleParameters() const
{
    return d_handleParameters;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM& hashAlg, const bmqp_ctrlmsg::OpenQueue& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.handleParameters());
}

// ----------------------------
// class PartitionMessageChoice
// ----------------------------

// CLASS METHODS
// CREATORS
inline PartitionMessageChoice::PartitionMessageChoice()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline PartitionMessageChoice::~PartitionMessageChoice()
{
    reset();
}

// MANIPULATORS
template <class MANIPULATOR>
int PartitionMessageChoice::manipulateSelection(MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case PartitionMessageChoice::SELECTION_ID_REPLICA_STATE_REQUEST:
        return manipulator(
            &d_replicaStateRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_STATE_REQUEST]);
    case PartitionMessageChoice::SELECTION_ID_REPLICA_STATE_RESPONSE:
        return manipulator(
            &d_replicaStateResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_STATE_RESPONSE]);
    case PartitionMessageChoice::SELECTION_ID_PRIMARY_STATE_REQUEST:
        return manipulator(
            &d_primaryStateRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATE_REQUEST]);
    case PartitionMessageChoice::SELECTION_ID_PRIMARY_STATE_RESPONSE:
        return manipulator(
            &d_primaryStateResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATE_RESPONSE]);
    case PartitionMessageChoice::SELECTION_ID_REPLICA_DATA_REQUEST:
        return manipulator(
            &d_replicaDataRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_DATA_REQUEST]);
    case PartitionMessageChoice::SELECTION_ID_REPLICA_DATA_RESPONSE:
        return manipulator(
            &d_replicaDataResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_DATA_RESPONSE]);
    default:
        BSLS_ASSERT(PartitionMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ReplicaStateRequest& PartitionMessageChoice::replicaStateRequest()
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_STATE_REQUEST == d_selectionId);
    return d_replicaStateRequest.object();
}

inline ReplicaStateResponse& PartitionMessageChoice::replicaStateResponse()
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_STATE_RESPONSE == d_selectionId);
    return d_replicaStateResponse.object();
}

inline PrimaryStateRequest& PartitionMessageChoice::primaryStateRequest()
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATE_REQUEST == d_selectionId);
    return d_primaryStateRequest.object();
}

inline PrimaryStateResponse& PartitionMessageChoice::primaryStateResponse()
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATE_RESPONSE == d_selectionId);
    return d_primaryStateResponse.object();
}

inline ReplicaDataRequest& PartitionMessageChoice::replicaDataRequest()
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_DATA_REQUEST == d_selectionId);
    return d_replicaDataRequest.object();
}

inline ReplicaDataResponse& PartitionMessageChoice::replicaDataResponse()
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_DATA_RESPONSE == d_selectionId);
    return d_replicaDataResponse.object();
}

// ACCESSORS
inline int PartitionMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <class ACCESSOR>
int PartitionMessageChoice::accessSelection(ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_REPLICA_STATE_REQUEST:
        return accessor(
            d_replicaStateRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_STATE_REQUEST]);
    case SELECTION_ID_REPLICA_STATE_RESPONSE:
        return accessor(
            d_replicaStateResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_STATE_RESPONSE]);
    case SELECTION_ID_PRIMARY_STATE_REQUEST:
        return accessor(
            d_primaryStateRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATE_REQUEST]);
    case SELECTION_ID_PRIMARY_STATE_RESPONSE:
        return accessor(
            d_primaryStateResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATE_RESPONSE]);
    case SELECTION_ID_REPLICA_DATA_REQUEST:
        return accessor(
            d_replicaDataRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_DATA_REQUEST]);
    case SELECTION_ID_REPLICA_DATA_RESPONSE:
        return accessor(
            d_replicaDataResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICA_DATA_RESPONSE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ReplicaStateRequest&
PartitionMessageChoice::replicaStateRequest() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_STATE_REQUEST == d_selectionId);
    return d_replicaStateRequest.object();
}

inline const ReplicaStateResponse&
PartitionMessageChoice::replicaStateResponse() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_STATE_RESPONSE == d_selectionId);
    return d_replicaStateResponse.object();
}

inline const PrimaryStateRequest&
PartitionMessageChoice::primaryStateRequest() const
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATE_REQUEST == d_selectionId);
    return d_primaryStateRequest.object();
}

inline const PrimaryStateResponse&
PartitionMessageChoice::primaryStateResponse() const
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATE_RESPONSE == d_selectionId);
    return d_primaryStateResponse.object();
}

inline const ReplicaDataRequest&
PartitionMessageChoice::replicaDataRequest() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_DATA_REQUEST == d_selectionId);
    return d_replicaDataRequest.object();
}

inline const ReplicaDataResponse&
PartitionMessageChoice::replicaDataResponse() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICA_DATA_RESPONSE == d_selectionId);
    return d_replicaDataResponse.object();
}

inline bool PartitionMessageChoice::isReplicaStateRequestValue() const
{
    return SELECTION_ID_REPLICA_STATE_REQUEST == d_selectionId;
}

inline bool PartitionMessageChoice::isReplicaStateResponseValue() const
{
    return SELECTION_ID_REPLICA_STATE_RESPONSE == d_selectionId;
}

inline bool PartitionMessageChoice::isPrimaryStateRequestValue() const
{
    return SELECTION_ID_PRIMARY_STATE_REQUEST == d_selectionId;
}

inline bool PartitionMessageChoice::isPrimaryStateResponseValue() const
{
    return SELECTION_ID_PRIMARY_STATE_RESPONSE == d_selectionId;
}

inline bool PartitionMessageChoice::isReplicaDataRequestValue() const
{
    return SELECTION_ID_REPLICA_DATA_REQUEST == d_selectionId;
}

inline bool PartitionMessageChoice::isReplicaDataResponseValue() const
{
    return SELECTION_ID_REPLICA_DATA_RESPONSE == d_selectionId;
}

inline bool PartitionMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                             hashAlg,
                const bmqp_ctrlmsg::PartitionMessageChoice& object)
{
    typedef bmqp_ctrlmsg::PartitionMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.selectionId());
    switch (object.selectionId()) {
    case Class::SELECTION_ID_REPLICA_STATE_REQUEST:
        hashAppend(hashAlg, object.replicaStateRequest());
        break;
    case Class::SELECTION_ID_REPLICA_STATE_RESPONSE:
        hashAppend(hashAlg, object.replicaStateResponse());
        break;
    case Class::SELECTION_ID_PRIMARY_STATE_REQUEST:
        hashAppend(hashAlg, object.primaryStateRequest());
        break;
    case Class::SELECTION_ID_PRIMARY_STATE_RESPONSE:
        hashAppend(hashAlg, object.primaryStateResponse());
        break;
    case Class::SELECTION_ID_REPLICA_DATA_REQUEST:
        hashAppend(hashAlg, object.replicaDataRequest());
        break;
    case Class::SELECTION_ID_REPLICA_DATA_RESPONSE:
        hashAppend(hashAlg, object.replicaDataResponse());
        break;
    default:
        BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == object.selectionId());
    }
}

// ----------------------------
// class PartitionSyncDataQuery
// ----------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionSyncDataQuery::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_lastPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_lastSequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_uptoPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_uptoSequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_lastSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionSyncDataQuery::manipulateAttribute(MANIPULATOR& manipulator,
                                                int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_LAST_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_lastPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_LAST_SEQUENCE_NUM: {
        return manipulator(
            &d_lastSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_UPTO_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_uptoPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_UPTO_SEQUENCE_NUM: {
        return manipulator(
            &d_uptoSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR: {
        return manipulator(
            &d_lastSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionSyncDataQuery::manipulateAttribute(MANIPULATOR& manipulator,
                                                const char*  name,
                                                int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncDataQuery::partitionId()
{
    return d_partitionId;
}

inline unsigned int& PartitionSyncDataQuery::lastPrimaryLeaseId()
{
    return d_lastPrimaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSyncDataQuery::lastSequenceNum()
{
    return d_lastSequenceNum;
}

inline unsigned int& PartitionSyncDataQuery::uptoPrimaryLeaseId()
{
    return d_uptoPrimaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSyncDataQuery::uptoSequenceNum()
{
    return d_uptoSequenceNum;
}

inline SyncPointOffsetPair& PartitionSyncDataQuery::lastSyncPointOffsetPair()
{
    return d_lastSyncPointOffsetPair;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionSyncDataQuery::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_lastPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_lastSequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_uptoPrimaryLeaseId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_uptoSequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_lastSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionSyncDataQuery::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_LAST_PRIMARY_LEASE_ID: {
        return accessor(
            d_lastPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_LAST_SEQUENCE_NUM: {
        return accessor(
            d_lastSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_UPTO_PRIMARY_LEASE_ID: {
        return accessor(
            d_uptoPrimaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_UPTO_SEQUENCE_NUM: {
        return accessor(
            d_uptoSequenceNum,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPTO_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR: {
        return accessor(
            d_lastSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionSyncDataQuery::accessAttribute(ACCESSOR&   accessor,
                                            const char* name,
                                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncDataQuery::partitionId() const
{
    return d_partitionId;
}

inline unsigned int PartitionSyncDataQuery::lastPrimaryLeaseId() const
{
    return d_lastPrimaryLeaseId;
}

inline bsls::Types::Uint64 PartitionSyncDataQuery::lastSequenceNum() const
{
    return d_lastSequenceNum;
}

inline unsigned int PartitionSyncDataQuery::uptoPrimaryLeaseId() const
{
    return d_uptoPrimaryLeaseId;
}

inline bsls::Types::Uint64 PartitionSyncDataQuery::uptoSequenceNum() const
{
    return d_uptoSequenceNum;
}

inline const SyncPointOffsetPair&
PartitionSyncDataQuery::lastSyncPointOffsetPair() const
{
    return d_lastSyncPointOffsetPair;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                             hashAlg,
                const bmqp_ctrlmsg::PartitionSyncDataQuery& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.lastPrimaryLeaseId());
    hashAppend(hashAlg, object.lastSequenceNum());
    hashAppend(hashAlg, object.uptoPrimaryLeaseId());
    hashAppend(hashAlg, object.uptoSequenceNum());
    hashAppend(hashAlg, object.lastSyncPointOffsetPair());
}

// ----------------------------------
// class PartitionSyncDataQueryStatus
// ----------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionSyncDataQueryStatus::manipulateAttributes(
    MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionSyncDataQueryStatus::manipulateAttribute(MANIPULATOR& manipulator,
                                                      int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionSyncDataQueryStatus::manipulateAttribute(MANIPULATOR& manipulator,
                                                      const char*  name,
                                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncDataQueryStatus::partitionId()
{
    return d_partitionId;
}

inline Status& PartitionSyncDataQueryStatus::status()
{
    return d_status;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionSyncDataQueryStatus::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionSyncDataQueryStatus::accessAttribute(ACCESSOR& accessor,
                                                  int       id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionSyncDataQueryStatus::accessAttribute(ACCESSOR&   accessor,
                                                  const char* name,
                                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncDataQueryStatus::partitionId() const
{
    return d_partitionId;
}

inline const Status& PartitionSyncDataQueryStatus::status() const
{
    return d_status;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::PartitionSyncDataQueryStatus& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.status());
}

// -------------------------------------
// class PartitionSyncStateQueryResponse
// -------------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionSyncStateQueryResponse::manipulateAttributes(
    MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_lastSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionSyncStateQueryResponse::manipulateAttribute(
    MANIPULATOR& manipulator,
    int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return manipulator(&d_sequenceNum,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR: {
        return manipulator(
            &d_lastSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionSyncStateQueryResponse::manipulateAttribute(
    MANIPULATOR& manipulator,
    const char*  name,
    int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionSyncStateQueryResponse::partitionId()
{
    return d_partitionId;
}

inline unsigned int& PartitionSyncStateQueryResponse::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64& PartitionSyncStateQueryResponse::sequenceNum()
{
    return d_sequenceNum;
}

inline SyncPointOffsetPair&
PartitionSyncStateQueryResponse::lastSyncPointOffsetPair()
{
    return d_lastSyncPointOffsetPair;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionSyncStateQueryResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_lastSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionSyncStateQueryResponse::accessAttribute(ACCESSOR& accessor,
                                                     int       id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return accessor(d_sequenceNum,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_LAST_SYNC_POINT_OFFSET_PAIR: {
        return accessor(
            d_lastSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionSyncStateQueryResponse::accessAttribute(ACCESSOR&   accessor,
                                                     const char* name,
                                                     int nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionSyncStateQueryResponse::partitionId() const
{
    return d_partitionId;
}

inline unsigned int PartitionSyncStateQueryResponse::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64 PartitionSyncStateQueryResponse::sequenceNum() const
{
    return d_sequenceNum;
}

inline const SyncPointOffsetPair&
PartitionSyncStateQueryResponse::lastSyncPointOffsetPair() const
{
    return d_lastSyncPointOffsetPair;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                      hashAlg,
                const bmqp_ctrlmsg::PartitionSyncStateQueryResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.primaryLeaseId());
    hashAppend(hashAlg, object.sequenceNum());
    hashAppend(hashAlg, object.lastSyncPointOffsetPair());
}

// -----------------------------
// class QueueAssignmentAdvisory
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueAssignmentAdvisory::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueAssignmentAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                                 int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueAssignmentAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                                 const char*  name,
                                                 int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& QueueAssignmentAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline bsl::vector<QueueInfo>& QueueAssignmentAdvisory::queues()
{
    return d_queues;
}

// ACCESSORS
template <class ACCESSOR>
int QueueAssignmentAdvisory::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueAssignmentAdvisory::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueAssignmentAdvisory::accessAttribute(ACCESSOR&   accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
QueueAssignmentAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const bsl::vector<QueueInfo>& QueueAssignmentAdvisory::queues() const
{
    return d_queues;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::QueueAssignmentAdvisory& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumber());
    hashAppend(hashAlg, object.queues());
}

// -------------------------------
// class QueueUnAssignmentAdvisory
// -------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueUnAssignmentAdvisory::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_primaryNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueUnAssignmentAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                                   int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return manipulator(
            &d_primaryNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueUnAssignmentAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                                   const char*  name,
                                                   int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& QueueUnAssignmentAdvisory::primaryNodeId()
{
    return d_primaryNodeId;
}

inline unsigned int& QueueUnAssignmentAdvisory::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline int& QueueUnAssignmentAdvisory::partitionId()
{
    return d_partitionId;
}

inline bsl::vector<QueueInfo>& QueueUnAssignmentAdvisory::queues()
{
    return d_queues;
}

// ACCESSORS
template <class ACCESSOR>
int QueueUnAssignmentAdvisory::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_primaryNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueUnAssignmentAdvisory::accessAttribute(ACCESSOR& accessor,
                                               int       id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return accessor(d_primaryNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueUnAssignmentAdvisory::accessAttribute(ACCESSOR&   accessor,
                                               const char* name,
                                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int QueueUnAssignmentAdvisory::primaryNodeId() const
{
    return d_primaryNodeId;
}

inline unsigned int QueueUnAssignmentAdvisory::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline int QueueUnAssignmentAdvisory::partitionId() const
{
    return d_partitionId;
}

inline const bsl::vector<QueueInfo>& QueueUnAssignmentAdvisory::queues() const
{
    return d_queues;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                hashAlg,
                const bmqp_ctrlmsg::QueueUnAssignmentAdvisory& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.primaryNodeId());
    hashAppend(hashAlg, object.primaryLeaseId());
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.queues());
}

// -----------------------------
// class QueueUnassignedAdvisory
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueUnassignedAdvisory::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryNodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueUnassignedAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                                 int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return manipulator(
            &d_primaryNodeId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueUnassignedAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                                 const char*  name,
                                                 int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& QueueUnassignedAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline int& QueueUnassignedAdvisory::partitionId()
{
    return d_partitionId;
}

inline unsigned int& QueueUnassignedAdvisory::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline int& QueueUnassignedAdvisory::primaryNodeId()
{
    return d_primaryNodeId;
}

inline bsl::vector<QueueInfo>& QueueUnassignedAdvisory::queues()
{
    return d_queues;
}

// ACCESSORS
template <class ACCESSOR>
int QueueUnassignedAdvisory::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryNodeId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueUnassignedAdvisory::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_ID: {
        return accessor(d_primaryNodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_ID]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueUnassignedAdvisory::accessAttribute(ACCESSOR&   accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence&
QueueUnassignedAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline int QueueUnassignedAdvisory::partitionId() const
{
    return d_partitionId;
}

inline unsigned int QueueUnassignedAdvisory::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline int QueueUnassignedAdvisory::primaryNodeId() const
{
    return d_primaryNodeId;
}

inline const bsl::vector<QueueInfo>& QueueUnassignedAdvisory::queues() const
{
    return d_queues;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::QueueUnassignedAdvisory& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumber());
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.primaryLeaseId());
    hashAppend(hashAlg, object.primaryNodeId());
    hashAppend(hashAlg, object.queues());
}

// -------------------------
// class QueueUpdateAdvisory
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int QueueUpdateAdvisory::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queueUpdates,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_UPDATES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int QueueUpdateAdvisory::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_QUEUE_UPDATES: {
        return manipulator(
            &d_queueUpdates,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_UPDATES]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int QueueUpdateAdvisory::manipulateAttribute(MANIPULATOR& manipulator,
                                             const char*  name,
                                             int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderMessageSequence& QueueUpdateAdvisory::sequenceNumber()
{
    return d_sequenceNumber;
}

inline bsl::vector<QueueInfoUpdate>& QueueUpdateAdvisory::queueUpdates()
{
    return d_queueUpdates;
}

// ACCESSORS
template <class ACCESSOR>
int QueueUpdateAdvisory::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queueUpdates,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_UPDATES]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int QueueUpdateAdvisory::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    case ATTRIBUTE_ID_QUEUE_UPDATES: {
        return accessor(d_queueUpdates,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_UPDATES]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int QueueUpdateAdvisory::accessAttribute(ACCESSOR&   accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderMessageSequence& QueueUpdateAdvisory::sequenceNumber() const
{
    return d_sequenceNumber;
}

inline const bsl::vector<QueueInfoUpdate>&
QueueUpdateAdvisory::queueUpdates() const
{
    return d_queueUpdates;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                          hashAlg,
                const bmqp_ctrlmsg::QueueUpdateAdvisory& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sequenceNumber());
    hashAppend(hashAlg, object.queueUpdates());
}

// -----------------------
// class StateNotification
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int StateNotification::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int StateNotification::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int StateNotification::manipulateAttribute(MANIPULATOR& manipulator,
                                           const char*  name,
                                           int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline StateNotificationChoice& StateNotification::choice()
{
    return d_choice;
}

// ACCESSORS
template <class ACCESSOR>
int StateNotification::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int StateNotification::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int StateNotification::accessAttribute(ACCESSOR&   accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const StateNotificationChoice& StateNotification::choice() const
{
    return d_choice;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::StateNotification& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.choice());
}

// ------------------------
// class StorageSyncRequest
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int StorageSyncRequest::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_beginSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_endSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int StorageSyncRequest::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SYNC_POINT_OFFSET_PAIR: {
        return manipulator(&d_beginSyncPointOffsetPair,
                           ATTRIBUTE_INFO_ARRAY
                               [ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR]);
    }
    case ATTRIBUTE_ID_END_SYNC_POINT_OFFSET_PAIR: {
        return manipulator(
            &d_endSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int StorageSyncRequest::manipulateAttribute(MANIPULATOR& manipulator,
                                            const char*  name,
                                            int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& StorageSyncRequest::partitionId()
{
    return d_partitionId;
}

inline bdlb::NullableValue<SyncPointOffsetPair>&
StorageSyncRequest::beginSyncPointOffsetPair()
{
    return d_beginSyncPointOffsetPair;
}

inline bdlb::NullableValue<SyncPointOffsetPair>&
StorageSyncRequest::endSyncPointOffsetPair()
{
    return d_endSyncPointOffsetPair;
}

// ACCESSORS
template <class ACCESSOR>
int StorageSyncRequest::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_beginSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_endSyncPointOffsetPair,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int StorageSyncRequest::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_BEGIN_SYNC_POINT_OFFSET_PAIR: {
        return accessor(d_beginSyncPointOffsetPair,
                        ATTRIBUTE_INFO_ARRAY
                            [ATTRIBUTE_INDEX_BEGIN_SYNC_POINT_OFFSET_PAIR]);
    }
    case ATTRIBUTE_ID_END_SYNC_POINT_OFFSET_PAIR: {
        return accessor(
            d_endSyncPointOffsetPair,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_END_SYNC_POINT_OFFSET_PAIR]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int StorageSyncRequest::accessAttribute(ACCESSOR&   accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int StorageSyncRequest::partitionId() const
{
    return d_partitionId;
}

inline const bdlb::NullableValue<SyncPointOffsetPair>&
StorageSyncRequest::beginSyncPointOffsetPair() const
{
    return d_beginSyncPointOffsetPair;
}

inline const bdlb::NullableValue<SyncPointOffsetPair>&
StorageSyncRequest::endSyncPointOffsetPair() const
{
    return d_endSyncPointOffsetPair;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::StorageSyncRequest& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.partitionId());
    hashAppend(hashAlg, object.beginSyncPointOffsetPair());
    hashAppend(hashAlg, object.endSyncPointOffsetPair());
}

// ------------------
// class Subscription
// ------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int Subscription::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_sId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_S_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_expression,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumers,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int Subscription::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_S_ID: {
        return manipulator(&d_sId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_S_ID]);
    }
    case ATTRIBUTE_ID_EXPRESSION: {
        return manipulator(&d_expression,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    }
    case ATTRIBUTE_ID_CONSUMERS: {
        return manipulator(&d_consumers,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int Subscription::manipulateAttribute(MANIPULATOR& manipulator,
                                      const char*  name,
                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& Subscription::sId()
{
    return d_sId;
}

inline Expression& Subscription::expression()
{
    return d_expression;
}

inline bsl::vector<ConsumerInfo>& Subscription::consumers()
{
    return d_consumers;
}

// ACCESSORS
template <class ACCESSOR>
int Subscription::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_sId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_S_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_expression,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumers,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int Subscription::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_S_ID: {
        return accessor(d_sId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_S_ID]);
    }
    case ATTRIBUTE_ID_EXPRESSION: {
        return accessor(d_expression,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    }
    case ATTRIBUTE_ID_CONSUMERS: {
        return accessor(d_consumers,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int Subscription::accessAttribute(ACCESSOR&   accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int Subscription::sId() const
{
    return d_sId;
}

inline const Expression& Subscription::expression() const
{
    return d_expression;
}

inline const bsl::vector<ConsumerInfo>& Subscription::consumers() const
{
    return d_consumers;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                   hashAlg,
                const bmqp_ctrlmsg::Subscription& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.sId());
    hashAppend(hashAlg, object.expression());
    hashAppend(hashAlg, object.consumers());
}

// ----------------------------------
// class ConfigureQueueStreamResponse
// ----------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ConfigureQueueStreamResponse::manipulateAttributes(
    MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_request,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ConfigureQueueStreamResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                      int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REQUEST: {
        return manipulator(&d_request,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ConfigureQueueStreamResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                      const char*  name,
                                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ConfigureQueueStream& ConfigureQueueStreamResponse::request()
{
    return d_request;
}

// ACCESSORS
template <class ACCESSOR>
int ConfigureQueueStreamResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_request, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ConfigureQueueStreamResponse::accessAttribute(ACCESSOR& accessor,
                                                  int       id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REQUEST: {
        return accessor(d_request,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ConfigureQueueStreamResponse::accessAttribute(ACCESSOR&   accessor,
                                                  const char* name,
                                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const ConfigureQueueStream&
ConfigureQueueStreamResponse::request() const
{
    return d_request;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::ConfigureQueueStreamResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.request());
}

// ----------------------------------
// class FollowerClusterStateResponse
// ----------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int FollowerClusterStateResponse::manipulateAttributes(
    MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_clusterStateSnapshot,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int FollowerClusterStateResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                      int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_STATE_SNAPSHOT: {
        return manipulator(
            &d_clusterStateSnapshot,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int FollowerClusterStateResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                      const char*  name,
                                                      int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderAdvisory& FollowerClusterStateResponse::clusterStateSnapshot()
{
    return d_clusterStateSnapshot;
}

// ACCESSORS
template <class ACCESSOR>
int FollowerClusterStateResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_clusterStateSnapshot,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int FollowerClusterStateResponse::accessAttribute(ACCESSOR& accessor,
                                                  int       id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_STATE_SNAPSHOT: {
        return accessor(
            d_clusterStateSnapshot,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STATE_SNAPSHOT]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int FollowerClusterStateResponse::accessAttribute(ACCESSOR&   accessor,
                                                  const char* name,
                                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderAdvisory&
FollowerClusterStateResponse::clusterStateSnapshot() const
{
    return d_clusterStateSnapshot;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::FollowerClusterStateResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.clusterStateSnapshot());
}

// ---------------------------------
// class LeaderSyncDataQueryResponse
// ---------------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int LeaderSyncDataQueryResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_leaderSyncData,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_SYNC_DATA]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int LeaderSyncDataQueryResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                     int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEADER_SYNC_DATA: {
        return manipulator(
            &d_leaderSyncData,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_SYNC_DATA]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int LeaderSyncDataQueryResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                     const char*  name,
                                                     int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline LeaderAdvisory& LeaderSyncDataQueryResponse::leaderSyncData()
{
    return d_leaderSyncData;
}

// ACCESSORS
template <class ACCESSOR>
int LeaderSyncDataQueryResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_leaderSyncData,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_SYNC_DATA]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int LeaderSyncDataQueryResponse::accessAttribute(ACCESSOR& accessor,
                                                 int       id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEADER_SYNC_DATA: {
        return accessor(
            d_leaderSyncData,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_SYNC_DATA]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int LeaderSyncDataQueryResponse::accessAttribute(ACCESSOR&   accessor,
                                                 const char* name,
                                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const LeaderAdvisory&
LeaderSyncDataQueryResponse::leaderSyncData() const
{
    return d_leaderSyncData;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                  hashAlg,
                const bmqp_ctrlmsg::LeaderSyncDataQueryResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.leaderSyncData());
}

// ------------------------
// class NegotiationMessage
// ------------------------

// CLASS METHODS
// CREATORS
inline NegotiationMessage::NegotiationMessage(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline NegotiationMessage::~NegotiationMessage()
{
    reset();
}

// MANIPULATORS
template <class MANIPULATOR>
int NegotiationMessage::manipulateSelection(MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case NegotiationMessage::SELECTION_ID_CLIENT_IDENTITY:
        return manipulator(
            &d_clientIdentity.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLIENT_IDENTITY]);
    case NegotiationMessage::SELECTION_ID_BROKER_RESPONSE:
        return manipulator(
            &d_brokerResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_RESPONSE]);
    case NegotiationMessage::SELECTION_ID_REVERSE_CONNECTION_REQUEST:
        return manipulator(
            &d_reverseConnectionRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REVERSE_CONNECTION_REQUEST]);
    default:
        BSLS_ASSERT(NegotiationMessage::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ClientIdentity& NegotiationMessage::clientIdentity()
{
    BSLS_ASSERT(SELECTION_ID_CLIENT_IDENTITY == d_selectionId);
    return d_clientIdentity.object();
}

inline BrokerResponse& NegotiationMessage::brokerResponse()
{
    BSLS_ASSERT(SELECTION_ID_BROKER_RESPONSE == d_selectionId);
    return d_brokerResponse.object();
}

inline ReverseConnectionRequest& NegotiationMessage::reverseConnectionRequest()
{
    BSLS_ASSERT(SELECTION_ID_REVERSE_CONNECTION_REQUEST == d_selectionId);
    return d_reverseConnectionRequest.object();
}

// ACCESSORS
inline int NegotiationMessage::selectionId() const
{
    return d_selectionId;
}

template <class ACCESSOR>
int NegotiationMessage::accessSelection(ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_CLIENT_IDENTITY:
        return accessor(d_clientIdentity.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLIENT_IDENTITY]);
    case SELECTION_ID_BROKER_RESPONSE:
        return accessor(d_brokerResponse.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_RESPONSE]);
    case SELECTION_ID_REVERSE_CONNECTION_REQUEST:
        return accessor(
            d_reverseConnectionRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REVERSE_CONNECTION_REQUEST]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ClientIdentity& NegotiationMessage::clientIdentity() const
{
    BSLS_ASSERT(SELECTION_ID_CLIENT_IDENTITY == d_selectionId);
    return d_clientIdentity.object();
}

inline const BrokerResponse& NegotiationMessage::brokerResponse() const
{
    BSLS_ASSERT(SELECTION_ID_BROKER_RESPONSE == d_selectionId);
    return d_brokerResponse.object();
}

inline const ReverseConnectionRequest&
NegotiationMessage::reverseConnectionRequest() const
{
    BSLS_ASSERT(SELECTION_ID_REVERSE_CONNECTION_REQUEST == d_selectionId);
    return d_reverseConnectionRequest.object();
}

inline bool NegotiationMessage::isClientIdentityValue() const
{
    return SELECTION_ID_CLIENT_IDENTITY == d_selectionId;
}

inline bool NegotiationMessage::isBrokerResponseValue() const
{
    return SELECTION_ID_BROKER_RESPONSE == d_selectionId;
}

inline bool NegotiationMessage::isReverseConnectionRequestValue() const
{
    return SELECTION_ID_REVERSE_CONNECTION_REQUEST == d_selectionId;
}

inline bool NegotiationMessage::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                         hashAlg,
                const bmqp_ctrlmsg::NegotiationMessage& object)
{
    typedef bmqp_ctrlmsg::NegotiationMessage Class;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.selectionId());
    switch (object.selectionId()) {
    case Class::SELECTION_ID_CLIENT_IDENTITY:
        hashAppend(hashAlg, object.clientIdentity());
        break;
    case Class::SELECTION_ID_BROKER_RESPONSE:
        hashAppend(hashAlg, object.brokerResponse());
        break;
    case Class::SELECTION_ID_REVERSE_CONNECTION_REQUEST:
        hashAppend(hashAlg, object.reverseConnectionRequest());
        break;
    default:
        BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == object.selectionId());
    }
}

// -----------------------
// class OpenQueueResponse
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int OpenQueueResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_originalRequest,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ORIGINAL_REQUEST]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_routingConfiguration,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING_CONFIGURATION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_deduplicationTimeMs,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int OpenQueueResponse::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ORIGINAL_REQUEST: {
        return manipulator(
            &d_originalRequest,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ORIGINAL_REQUEST]);
    }
    case ATTRIBUTE_ID_ROUTING_CONFIGURATION: {
        return manipulator(
            &d_routingConfiguration,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING_CONFIGURATION]);
    }
    case ATTRIBUTE_ID_DEDUPLICATION_TIME_MS: {
        return manipulator(
            &d_deduplicationTimeMs,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int OpenQueueResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                           const char*  name,
                                           int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline OpenQueue& OpenQueueResponse::originalRequest()
{
    return d_originalRequest;
}

inline RoutingConfiguration& OpenQueueResponse::routingConfiguration()
{
    return d_routingConfiguration;
}

inline int& OpenQueueResponse::deduplicationTimeMs()
{
    return d_deduplicationTimeMs;
}

// ACCESSORS
template <class ACCESSOR>
int OpenQueueResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_originalRequest,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ORIGINAL_REQUEST]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_routingConfiguration,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING_CONFIGURATION]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_deduplicationTimeMs,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int OpenQueueResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ORIGINAL_REQUEST: {
        return accessor(
            d_originalRequest,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ORIGINAL_REQUEST]);
    }
    case ATTRIBUTE_ID_ROUTING_CONFIGURATION: {
        return accessor(
            d_routingConfiguration,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING_CONFIGURATION]);
    }
    case ATTRIBUTE_ID_DEDUPLICATION_TIME_MS: {
        return accessor(
            d_deduplicationTimeMs,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DEDUPLICATION_TIME_MS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int OpenQueueResponse::accessAttribute(ACCESSOR&   accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const OpenQueue& OpenQueueResponse::originalRequest() const
{
    return d_originalRequest;
}

inline const RoutingConfiguration&
OpenQueueResponse::routingConfiguration() const
{
    return d_routingConfiguration;
}

inline int OpenQueueResponse::deduplicationTimeMs() const
{
    return d_deduplicationTimeMs;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                        hashAlg,
                const bmqp_ctrlmsg::OpenQueueResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.originalRequest());
    hashAppend(hashAlg, object.routingConfiguration());
    hashAppend(hashAlg, object.deduplicationTimeMs());
}

// ----------------------
// class PartitionMessage
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int PartitionMessage::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int PartitionMessage::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int PartitionMessage::manipulateAttribute(MANIPULATOR& manipulator,
                                          const char*  name,
                                          int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline PartitionMessageChoice& PartitionMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <class ACCESSOR>
int PartitionMessage::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int PartitionMessage::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int PartitionMessage::accessAttribute(ACCESSOR&   accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const PartitionMessageChoice& PartitionMessage::choice() const
{
    return d_choice;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::PartitionMessage& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.choice());
}

// ----------------------
// class StreamParameters
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int StreamParameters::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_subscriptions,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTIONS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int StreamParameters::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_SUBSCRIPTIONS: {
        return manipulator(
            &d_subscriptions,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int StreamParameters::manipulateAttribute(MANIPULATOR& manipulator,
                                          const char*  name,
                                          int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StreamParameters::appId()
{
    return d_appId;
}

inline bsl::vector<Subscription>& StreamParameters::subscriptions()
{
    return d_subscriptions;
}

// ACCESSORS
template <class ACCESSOR>
int StreamParameters::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_subscriptions,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTIONS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int StreamParameters::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_SUBSCRIPTIONS: {
        return accessor(d_subscriptions,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int StreamParameters::accessAttribute(ACCESSOR&   accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StreamParameters::appId() const
{
    return d_appId;
}

inline const bsl::vector<Subscription>& StreamParameters::subscriptions() const
{
    return d_subscriptions;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                       hashAlg,
                const bmqp_ctrlmsg::StreamParameters& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.appId());
    hashAppend(hashAlg, object.subscriptions());
}

// ----------------------------------
// class ClusterStateFSMMessageChoice
// ----------------------------------

// CLASS METHODS
// CREATORS
inline ClusterStateFSMMessageChoice::ClusterStateFSMMessageChoice(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClusterStateFSMMessageChoice::~ClusterStateFSMMessageChoice()
{
    reset();
}

// MANIPULATORS
template <class MANIPULATOR>
int ClusterStateFSMMessageChoice::manipulateSelection(MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClusterStateFSMMessageChoice::SELECTION_ID_FOLLOWER_L_S_N_REQUEST:
        return manipulator(
            &d_followerLSNRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FOLLOWER_L_S_N_REQUEST]);
    case ClusterStateFSMMessageChoice::SELECTION_ID_FOLLOWER_L_S_N_RESPONSE:
        return manipulator(
            &d_followerLSNResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FOLLOWER_L_S_N_RESPONSE]);
    case ClusterStateFSMMessageChoice::SELECTION_ID_REGISTRATION_REQUEST:
        return manipulator(
            &d_registrationRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REGISTRATION_REQUEST]);
    case ClusterStateFSMMessageChoice::SELECTION_ID_REGISTRATION_RESPONSE:
        return manipulator(
            &d_registrationResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REGISTRATION_RESPONSE]);
    case ClusterStateFSMMessageChoice::
        SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST:
        return manipulator(
            &d_followerClusterStateRequest.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_REQUEST]);
    case ClusterStateFSMMessageChoice::
        SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE:
        return manipulator(
            &d_followerClusterStateResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_RESPONSE]);
    default:
        BSLS_ASSERT(ClusterStateFSMMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline FollowerLSNRequest& ClusterStateFSMMessageChoice::followerLSNRequest()
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_L_S_N_REQUEST == d_selectionId);
    return d_followerLSNRequest.object();
}

inline FollowerLSNResponse& ClusterStateFSMMessageChoice::followerLSNResponse()
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_L_S_N_RESPONSE == d_selectionId);
    return d_followerLSNResponse.object();
}

inline RegistrationRequest& ClusterStateFSMMessageChoice::registrationRequest()
{
    BSLS_ASSERT(SELECTION_ID_REGISTRATION_REQUEST == d_selectionId);
    return d_registrationRequest.object();
}

inline RegistrationResponse&
ClusterStateFSMMessageChoice::registrationResponse()
{
    BSLS_ASSERT(SELECTION_ID_REGISTRATION_RESPONSE == d_selectionId);
    return d_registrationResponse.object();
}

inline FollowerClusterStateRequest&
ClusterStateFSMMessageChoice::followerClusterStateRequest()
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST == d_selectionId);
    return d_followerClusterStateRequest.object();
}

inline FollowerClusterStateResponse&
ClusterStateFSMMessageChoice::followerClusterStateResponse()
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE == d_selectionId);
    return d_followerClusterStateResponse.object();
}

// ACCESSORS
inline int ClusterStateFSMMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <class ACCESSOR>
int ClusterStateFSMMessageChoice::accessSelection(ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_FOLLOWER_L_S_N_REQUEST:
        return accessor(
            d_followerLSNRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FOLLOWER_L_S_N_REQUEST]);
    case SELECTION_ID_FOLLOWER_L_S_N_RESPONSE:
        return accessor(
            d_followerLSNResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FOLLOWER_L_S_N_RESPONSE]);
    case SELECTION_ID_REGISTRATION_REQUEST:
        return accessor(
            d_registrationRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REGISTRATION_REQUEST]);
    case SELECTION_ID_REGISTRATION_RESPONSE:
        return accessor(
            d_registrationResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REGISTRATION_RESPONSE]);
    case SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST:
        return accessor(d_followerClusterStateRequest.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_REQUEST]);
    case SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE:
        return accessor(d_followerClusterStateResponse.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_FOLLOWER_CLUSTER_STATE_RESPONSE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const FollowerLSNRequest&
ClusterStateFSMMessageChoice::followerLSNRequest() const
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_L_S_N_REQUEST == d_selectionId);
    return d_followerLSNRequest.object();
}

inline const FollowerLSNResponse&
ClusterStateFSMMessageChoice::followerLSNResponse() const
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_L_S_N_RESPONSE == d_selectionId);
    return d_followerLSNResponse.object();
}

inline const RegistrationRequest&
ClusterStateFSMMessageChoice::registrationRequest() const
{
    BSLS_ASSERT(SELECTION_ID_REGISTRATION_REQUEST == d_selectionId);
    return d_registrationRequest.object();
}

inline const RegistrationResponse&
ClusterStateFSMMessageChoice::registrationResponse() const
{
    BSLS_ASSERT(SELECTION_ID_REGISTRATION_RESPONSE == d_selectionId);
    return d_registrationResponse.object();
}

inline const FollowerClusterStateRequest&
ClusterStateFSMMessageChoice::followerClusterStateRequest() const
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST == d_selectionId);
    return d_followerClusterStateRequest.object();
}

inline const FollowerClusterStateResponse&
ClusterStateFSMMessageChoice::followerClusterStateResponse() const
{
    BSLS_ASSERT(SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE == d_selectionId);
    return d_followerClusterStateResponse.object();
}

inline bool ClusterStateFSMMessageChoice::isFollowerLSNRequestValue() const
{
    return SELECTION_ID_FOLLOWER_L_S_N_REQUEST == d_selectionId;
}

inline bool ClusterStateFSMMessageChoice::isFollowerLSNResponseValue() const
{
    return SELECTION_ID_FOLLOWER_L_S_N_RESPONSE == d_selectionId;
}

inline bool ClusterStateFSMMessageChoice::isRegistrationRequestValue() const
{
    return SELECTION_ID_REGISTRATION_REQUEST == d_selectionId;
}

inline bool ClusterStateFSMMessageChoice::isRegistrationResponseValue() const
{
    return SELECTION_ID_REGISTRATION_RESPONSE == d_selectionId;
}

inline bool
ClusterStateFSMMessageChoice::isFollowerClusterStateRequestValue() const
{
    return SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST == d_selectionId;
}

inline bool
ClusterStateFSMMessageChoice::isFollowerClusterStateResponseValue() const
{
    return SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE == d_selectionId;
}

inline bool ClusterStateFSMMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                                   hashAlg,
                const bmqp_ctrlmsg::ClusterStateFSMMessageChoice& object)
{
    typedef bmqp_ctrlmsg::ClusterStateFSMMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.selectionId());
    switch (object.selectionId()) {
    case Class::SELECTION_ID_FOLLOWER_L_S_N_REQUEST:
        hashAppend(hashAlg, object.followerLSNRequest());
        break;
    case Class::SELECTION_ID_FOLLOWER_L_S_N_RESPONSE:
        hashAppend(hashAlg, object.followerLSNResponse());
        break;
    case Class::SELECTION_ID_REGISTRATION_REQUEST:
        hashAppend(hashAlg, object.registrationRequest());
        break;
    case Class::SELECTION_ID_REGISTRATION_RESPONSE:
        hashAppend(hashAlg, object.registrationResponse());
        break;
    case Class::SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST:
        hashAppend(hashAlg, object.followerClusterStateRequest());
        break;
    case Class::SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE:
        hashAppend(hashAlg, object.followerClusterStateResponse());
        break;
    default:
        BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == object.selectionId());
    }
}

// ---------------------
// class ConfigureStream
// ---------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ConfigureStream::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_streamParameters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ConfigureStream::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_Q_ID: {
        return manipulator(&d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS: {
        return manipulator(
            &d_streamParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ConfigureStream::manipulateAttribute(MANIPULATOR& manipulator,
                                         const char*  name,
                                         int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& ConfigureStream::qId()
{
    return d_qId;
}

inline StreamParameters& ConfigureStream::streamParameters()
{
    return d_streamParameters;
}

// ACCESSORS
template <class ACCESSOR>
int ConfigureStream::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_streamParameters,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ConfigureStream::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_Q_ID: {
        return accessor(d_qId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_Q_ID]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS: {
        return accessor(
            d_streamParameters,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ConfigureStream::accessAttribute(ACCESSOR&   accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int ConfigureStream::qId() const
{
    return d_qId;
}

inline const StreamParameters& ConfigureStream::streamParameters() const
{
    return d_streamParameters;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                      hashAlg,
                const bmqp_ctrlmsg::ConfigureStream& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.qId());
    hashAppend(hashAlg, object.streamParameters());
}

// ----------------------------
// class ClusterStateFSMMessage
// ----------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ClusterStateFSMMessage::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ClusterStateFSMMessage::manipulateAttribute(MANIPULATOR& manipulator,
                                                int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ClusterStateFSMMessage::manipulateAttribute(MANIPULATOR& manipulator,
                                                const char*  name,
                                                int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ClusterStateFSMMessageChoice& ClusterStateFSMMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <class ACCESSOR>
int ClusterStateFSMMessage::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ClusterStateFSMMessage::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ClusterStateFSMMessage::accessAttribute(ACCESSOR&   accessor,
                                            const char* name,
                                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const ClusterStateFSMMessageChoice&
ClusterStateFSMMessage::choice() const
{
    return d_choice;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                             hashAlg,
                const bmqp_ctrlmsg::ClusterStateFSMMessage& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.choice());
}

// -----------------------------
// class ConfigureStreamResponse
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ConfigureStreamResponse::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_request,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ConfigureStreamResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                 int          id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REQUEST: {
        return manipulator(&d_request,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ConfigureStreamResponse::manipulateAttribute(MANIPULATOR& manipulator,
                                                 const char*  name,
                                                 int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ConfigureStream& ConfigureStreamResponse::request()
{
    return d_request;
}

// ACCESSORS
template <class ACCESSOR>
int ConfigureStreamResponse::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_request, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ConfigureStreamResponse::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_REQUEST: {
        return accessor(d_request,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REQUEST]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ConfigureStreamResponse::accessAttribute(ACCESSOR&   accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const ConfigureStream& ConfigureStreamResponse::request() const
{
    return d_request;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                              hashAlg,
                const bmqp_ctrlmsg::ConfigureStreamResponse& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.request());
}

// --------------------------
// class ClusterMessageChoice
// --------------------------

// CLASS METHODS
// CREATORS
inline ClusterMessageChoice::ClusterMessageChoice(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClusterMessageChoice::~ClusterMessageChoice()
{
    reset();
}

// MANIPULATORS
template <class MANIPULATOR>
int ClusterMessageChoice::manipulateSelection(MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClusterMessageChoice::SELECTION_ID_PARTITION_PRIMARY_ADVISORY:
        return manipulator(
            &d_partitionPrimaryAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_PRIMARY_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_ADVISORY:
        return manipulator(
            &d_leaderAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY:
        return manipulator(
            &d_queueAssignmentAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_ASSIGNMENT_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_NODE_STATUS_ADVISORY:
        return manipulator(
            &d_nodeStatusAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_NODE_STATUS_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_SYNC_STATE_QUERY:
        return manipulator(
            &d_leaderSyncStateQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_SYNC_STATE_QUERY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE:
        return manipulator(
            &d_leaderSyncStateQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_LEADER_SYNC_STATE_QUERY_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_SYNC_DATA_QUERY:
        return manipulator(
            &d_leaderSyncDataQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_SYNC_DATA_QUERY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE:
        return manipulator(
            &d_leaderSyncDataQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_LEADER_SYNC_DATA_QUERY_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST:
        return manipulator(
            &d_queueAssignmentRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_ASSIGNMENT_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_STORAGE_SYNC_REQUEST:
        return manipulator(
            &d_storageSyncRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_SYNC_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_STORAGE_SYNC_RESPONSE:
        return manipulator(
            &d_storageSyncResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_SYNC_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_SYNC_STATE_QUERY:
        return manipulator(
            &d_partitionSyncStateQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY]);
    case ClusterMessageChoice::
        SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE:
        return manipulator(
            &d_partitionSyncStateQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_SYNC_DATA_QUERY:
        return manipulator(
            &d_partitionSyncDataQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE:
        return manipulator(
            &d_partitionSyncDataQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS:
        return manipulator(
            &d_partitionSyncDataQueryStatus.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_STATUS]);
    case ClusterMessageChoice::SELECTION_ID_PRIMARY_STATUS_ADVISORY:
        return manipulator(
            &d_primaryStatusAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATUS_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_CLUSTER_SYNC_REQUEST:
        return manipulator(
            &d_clusterSyncRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_SYNC_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_CLUSTER_SYNC_RESPONSE:
        return manipulator(
            &d_clusterSyncResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_SYNC_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY:
        return manipulator(&d_queueUnAssignmentAdvisory.object(),
                           SELECTION_INFO_ARRAY
                               [SELECTION_INDEX_QUEUE_UN_ASSIGNMENT_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY:
        return manipulator(
            &d_queueUnassignedAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UNASSIGNED_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_ADVISORY_ACK:
        return manipulator(
            &d_leaderAdvisoryAck.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY_ACK]);
    case ClusterMessageChoice::SELECTION_ID_LEADER_ADVISORY_COMMIT:
        return manipulator(
            &d_leaderAdvisoryCommit.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY_COMMIT]);
    case ClusterMessageChoice::SELECTION_ID_STATE_NOTIFICATION:
        return manipulator(
            &d_stateNotification.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STATE_NOTIFICATION]);
    case ClusterMessageChoice::SELECTION_ID_STOP_REQUEST:
        return manipulator(&d_stopRequest.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STOP_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_STOP_RESPONSE:
        return manipulator(
            &d_stopResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STOP_RESPONSE]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST:
        return manipulator(
            &d_queueUnassignmentRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UNASSIGNMENT_REQUEST]);
    case ClusterMessageChoice::SELECTION_ID_QUEUE_UPDATE_ADVISORY:
        return manipulator(
            &d_queueUpdateAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UPDATE_ADVISORY]);
    case ClusterMessageChoice::SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE:
        return manipulator(
            &d_clusterStateFSMMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STATE_F_S_M_MESSAGE]);
    case ClusterMessageChoice::SELECTION_ID_PARTITION_MESSAGE:
        return manipulator(
            &d_partitionMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_MESSAGE]);
    default:
        BSLS_ASSERT(ClusterMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline PartitionPrimaryAdvisory&
ClusterMessageChoice::partitionPrimaryAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_PRIMARY_ADVISORY == d_selectionId);
    return d_partitionPrimaryAdvisory.object();
}

inline LeaderAdvisory& ClusterMessageChoice::leaderAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY == d_selectionId);
    return d_leaderAdvisory.object();
}

inline QueueAssignmentAdvisory& ClusterMessageChoice::queueAssignmentAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY == d_selectionId);
    return d_queueAssignmentAdvisory.object();
}

inline NodeStatusAdvisory& ClusterMessageChoice::nodeStatusAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_NODE_STATUS_ADVISORY == d_selectionId);
    return d_nodeStatusAdvisory.object();
}

inline LeaderSyncStateQuery& ClusterMessageChoice::leaderSyncStateQuery()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_STATE_QUERY == d_selectionId);
    return d_leaderSyncStateQuery.object();
}

inline LeaderSyncStateQueryResponse&
ClusterMessageChoice::leaderSyncStateQueryResponse()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE ==
                d_selectionId);
    return d_leaderSyncStateQueryResponse.object();
}

inline LeaderSyncDataQuery& ClusterMessageChoice::leaderSyncDataQuery()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_DATA_QUERY == d_selectionId);
    return d_leaderSyncDataQuery.object();
}

inline LeaderSyncDataQueryResponse&
ClusterMessageChoice::leaderSyncDataQueryResponse()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE == d_selectionId);
    return d_leaderSyncDataQueryResponse.object();
}

inline QueueAssignmentRequest& ClusterMessageChoice::queueAssignmentRequest()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST == d_selectionId);
    return d_queueAssignmentRequest.object();
}

inline StorageSyncRequest& ClusterMessageChoice::storageSyncRequest()
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_SYNC_REQUEST == d_selectionId);
    return d_storageSyncRequest.object();
}

inline StorageSyncResponse& ClusterMessageChoice::storageSyncResponse()
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_SYNC_RESPONSE == d_selectionId);
    return d_storageSyncResponse.object();
}

inline PartitionSyncStateQuery& ClusterMessageChoice::partitionSyncStateQuery()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_STATE_QUERY == d_selectionId);
    return d_partitionSyncStateQuery.object();
}

inline PartitionSyncStateQueryResponse&
ClusterMessageChoice::partitionSyncStateQueryResponse()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE ==
                d_selectionId);
    return d_partitionSyncStateQueryResponse.object();
}

inline PartitionSyncDataQuery& ClusterMessageChoice::partitionSyncDataQuery()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY == d_selectionId);
    return d_partitionSyncDataQuery.object();
}

inline PartitionSyncDataQueryResponse&
ClusterMessageChoice::partitionSyncDataQueryResponse()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE ==
                d_selectionId);
    return d_partitionSyncDataQueryResponse.object();
}

inline PartitionSyncDataQueryStatus&
ClusterMessageChoice::partitionSyncDataQueryStatus()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS ==
                d_selectionId);
    return d_partitionSyncDataQueryStatus.object();
}

inline PrimaryStatusAdvisory& ClusterMessageChoice::primaryStatusAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATUS_ADVISORY == d_selectionId);
    return d_primaryStatusAdvisory.object();
}

inline ClusterSyncRequest& ClusterMessageChoice::clusterSyncRequest()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_SYNC_REQUEST == d_selectionId);
    return d_clusterSyncRequest.object();
}

inline ClusterSyncResponse& ClusterMessageChoice::clusterSyncResponse()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_SYNC_RESPONSE == d_selectionId);
    return d_clusterSyncResponse.object();
}

inline QueueUnAssignmentAdvisory&
ClusterMessageChoice::queueUnAssignmentAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY == d_selectionId);
    return d_queueUnAssignmentAdvisory.object();
}

inline QueueUnassignedAdvisory& ClusterMessageChoice::queueUnassignedAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY == d_selectionId);
    return d_queueUnassignedAdvisory.object();
}

inline LeaderAdvisoryAck& ClusterMessageChoice::leaderAdvisoryAck()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY_ACK == d_selectionId);
    return d_leaderAdvisoryAck.object();
}

inline LeaderAdvisoryCommit& ClusterMessageChoice::leaderAdvisoryCommit()
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY_COMMIT == d_selectionId);
    return d_leaderAdvisoryCommit.object();
}

inline StateNotification& ClusterMessageChoice::stateNotification()
{
    BSLS_ASSERT(SELECTION_ID_STATE_NOTIFICATION == d_selectionId);
    return d_stateNotification.object();
}

inline StopRequest& ClusterMessageChoice::stopRequest()
{
    BSLS_ASSERT(SELECTION_ID_STOP_REQUEST == d_selectionId);
    return d_stopRequest.object();
}

inline StopResponse& ClusterMessageChoice::stopResponse()
{
    BSLS_ASSERT(SELECTION_ID_STOP_RESPONSE == d_selectionId);
    return d_stopResponse.object();
}

inline QueueUnassignmentRequest&
ClusterMessageChoice::queueUnassignmentRequest()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST == d_selectionId);
    return d_queueUnassignmentRequest.object();
}

inline QueueUpdateAdvisory& ClusterMessageChoice::queueUpdateAdvisory()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UPDATE_ADVISORY == d_selectionId);
    return d_queueUpdateAdvisory.object();
}

inline ClusterStateFSMMessage& ClusterMessageChoice::clusterStateFSMMessage()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE == d_selectionId);
    return d_clusterStateFSMMessage.object();
}

inline PartitionMessage& ClusterMessageChoice::partitionMessage()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_MESSAGE == d_selectionId);
    return d_partitionMessage.object();
}

// ACCESSORS
inline int ClusterMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <class ACCESSOR>
int ClusterMessageChoice::accessSelection(ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_PARTITION_PRIMARY_ADVISORY:
        return accessor(
            d_partitionPrimaryAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_PRIMARY_ADVISORY]);
    case SELECTION_ID_LEADER_ADVISORY:
        return accessor(d_leaderAdvisory.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY]);
    case SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY:
        return accessor(
            d_queueAssignmentAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_ASSIGNMENT_ADVISORY]);
    case SELECTION_ID_NODE_STATUS_ADVISORY:
        return accessor(
            d_nodeStatusAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_NODE_STATUS_ADVISORY]);
    case SELECTION_ID_LEADER_SYNC_STATE_QUERY:
        return accessor(
            d_leaderSyncStateQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_SYNC_STATE_QUERY]);
    case SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE:
        return accessor(
            d_leaderSyncStateQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_LEADER_SYNC_STATE_QUERY_RESPONSE]);
    case SELECTION_ID_LEADER_SYNC_DATA_QUERY:
        return accessor(
            d_leaderSyncDataQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_SYNC_DATA_QUERY]);
    case SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE:
        return accessor(d_leaderSyncDataQueryResponse.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_LEADER_SYNC_DATA_QUERY_RESPONSE]);
    case SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST:
        return accessor(
            d_queueAssignmentRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_ASSIGNMENT_REQUEST]);
    case SELECTION_ID_STORAGE_SYNC_REQUEST:
        return accessor(
            d_storageSyncRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_SYNC_REQUEST]);
    case SELECTION_ID_STORAGE_SYNC_RESPONSE:
        return accessor(
            d_storageSyncResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_SYNC_RESPONSE]);
    case SELECTION_ID_PARTITION_SYNC_STATE_QUERY:
        return accessor(
            d_partitionSyncStateQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY]);
    case SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE:
        return accessor(
            d_partitionSyncStateQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_STATE_QUERY_RESPONSE]);
    case SELECTION_ID_PARTITION_SYNC_DATA_QUERY:
        return accessor(
            d_partitionSyncDataQuery.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY]);
    case SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE:
        return accessor(
            d_partitionSyncDataQueryResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_RESPONSE]);
    case SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS:
        return accessor(
            d_partitionSyncDataQueryStatus.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_PARTITION_SYNC_DATA_QUERY_STATUS]);
    case SELECTION_ID_PRIMARY_STATUS_ADVISORY:
        return accessor(
            d_primaryStatusAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PRIMARY_STATUS_ADVISORY]);
    case SELECTION_ID_CLUSTER_SYNC_REQUEST:
        return accessor(
            d_clusterSyncRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_SYNC_REQUEST]);
    case SELECTION_ID_CLUSTER_SYNC_RESPONSE:
        return accessor(
            d_clusterSyncResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_SYNC_RESPONSE]);
    case SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY:
        return accessor(d_queueUnAssignmentAdvisory.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_QUEUE_UN_ASSIGNMENT_ADVISORY]);
    case SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY:
        return accessor(
            d_queueUnassignedAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UNASSIGNED_ADVISORY]);
    case SELECTION_ID_LEADER_ADVISORY_ACK:
        return accessor(
            d_leaderAdvisoryAck.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY_ACK]);
    case SELECTION_ID_LEADER_ADVISORY_COMMIT:
        return accessor(
            d_leaderAdvisoryCommit.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LEADER_ADVISORY_COMMIT]);
    case SELECTION_ID_STATE_NOTIFICATION:
        return accessor(
            d_stateNotification.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STATE_NOTIFICATION]);
    case SELECTION_ID_STOP_REQUEST:
        return accessor(d_stopRequest.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STOP_REQUEST]);
    case SELECTION_ID_STOP_RESPONSE:
        return accessor(d_stopResponse.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STOP_RESPONSE]);
    case SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST:
        return accessor(
            d_queueUnassignmentRequest.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UNASSIGNMENT_REQUEST]);
    case SELECTION_ID_QUEUE_UPDATE_ADVISORY:
        return accessor(
            d_queueUpdateAdvisory.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_UPDATE_ADVISORY]);
    case SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE:
        return accessor(
            d_clusterStateFSMMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STATE_F_S_M_MESSAGE]);
    case SELECTION_ID_PARTITION_MESSAGE:
        return accessor(
            d_partitionMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION_MESSAGE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const PartitionPrimaryAdvisory&
ClusterMessageChoice::partitionPrimaryAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_PRIMARY_ADVISORY == d_selectionId);
    return d_partitionPrimaryAdvisory.object();
}

inline const LeaderAdvisory& ClusterMessageChoice::leaderAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY == d_selectionId);
    return d_leaderAdvisory.object();
}

inline const QueueAssignmentAdvisory&
ClusterMessageChoice::queueAssignmentAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY == d_selectionId);
    return d_queueAssignmentAdvisory.object();
}

inline const NodeStatusAdvisory&
ClusterMessageChoice::nodeStatusAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_NODE_STATUS_ADVISORY == d_selectionId);
    return d_nodeStatusAdvisory.object();
}

inline const LeaderSyncStateQuery&
ClusterMessageChoice::leaderSyncStateQuery() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_STATE_QUERY == d_selectionId);
    return d_leaderSyncStateQuery.object();
}

inline const LeaderSyncStateQueryResponse&
ClusterMessageChoice::leaderSyncStateQueryResponse() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE ==
                d_selectionId);
    return d_leaderSyncStateQueryResponse.object();
}

inline const LeaderSyncDataQuery&
ClusterMessageChoice::leaderSyncDataQuery() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_DATA_QUERY == d_selectionId);
    return d_leaderSyncDataQuery.object();
}

inline const LeaderSyncDataQueryResponse&
ClusterMessageChoice::leaderSyncDataQueryResponse() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE == d_selectionId);
    return d_leaderSyncDataQueryResponse.object();
}

inline const QueueAssignmentRequest&
ClusterMessageChoice::queueAssignmentRequest() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST == d_selectionId);
    return d_queueAssignmentRequest.object();
}

inline const StorageSyncRequest&
ClusterMessageChoice::storageSyncRequest() const
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_SYNC_REQUEST == d_selectionId);
    return d_storageSyncRequest.object();
}

inline const StorageSyncResponse&
ClusterMessageChoice::storageSyncResponse() const
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_SYNC_RESPONSE == d_selectionId);
    return d_storageSyncResponse.object();
}

inline const PartitionSyncStateQuery&
ClusterMessageChoice::partitionSyncStateQuery() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_STATE_QUERY == d_selectionId);
    return d_partitionSyncStateQuery.object();
}

inline const PartitionSyncStateQueryResponse&
ClusterMessageChoice::partitionSyncStateQueryResponse() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE ==
                d_selectionId);
    return d_partitionSyncStateQueryResponse.object();
}

inline const PartitionSyncDataQuery&
ClusterMessageChoice::partitionSyncDataQuery() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY == d_selectionId);
    return d_partitionSyncDataQuery.object();
}

inline const PartitionSyncDataQueryResponse&
ClusterMessageChoice::partitionSyncDataQueryResponse() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE ==
                d_selectionId);
    return d_partitionSyncDataQueryResponse.object();
}

inline const PartitionSyncDataQueryStatus&
ClusterMessageChoice::partitionSyncDataQueryStatus() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS ==
                d_selectionId);
    return d_partitionSyncDataQueryStatus.object();
}

inline const PrimaryStatusAdvisory&
ClusterMessageChoice::primaryStatusAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_PRIMARY_STATUS_ADVISORY == d_selectionId);
    return d_primaryStatusAdvisory.object();
}

inline const ClusterSyncRequest&
ClusterMessageChoice::clusterSyncRequest() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_SYNC_REQUEST == d_selectionId);
    return d_clusterSyncRequest.object();
}

inline const ClusterSyncResponse&
ClusterMessageChoice::clusterSyncResponse() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_SYNC_RESPONSE == d_selectionId);
    return d_clusterSyncResponse.object();
}

inline const QueueUnAssignmentAdvisory&
ClusterMessageChoice::queueUnAssignmentAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY == d_selectionId);
    return d_queueUnAssignmentAdvisory.object();
}

inline const QueueUnassignedAdvisory&
ClusterMessageChoice::queueUnassignedAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY == d_selectionId);
    return d_queueUnassignedAdvisory.object();
}

inline const LeaderAdvisoryAck& ClusterMessageChoice::leaderAdvisoryAck() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY_ACK == d_selectionId);
    return d_leaderAdvisoryAck.object();
}

inline const LeaderAdvisoryCommit&
ClusterMessageChoice::leaderAdvisoryCommit() const
{
    BSLS_ASSERT(SELECTION_ID_LEADER_ADVISORY_COMMIT == d_selectionId);
    return d_leaderAdvisoryCommit.object();
}

inline const StateNotification& ClusterMessageChoice::stateNotification() const
{
    BSLS_ASSERT(SELECTION_ID_STATE_NOTIFICATION == d_selectionId);
    return d_stateNotification.object();
}

inline const StopRequest& ClusterMessageChoice::stopRequest() const
{
    BSLS_ASSERT(SELECTION_ID_STOP_REQUEST == d_selectionId);
    return d_stopRequest.object();
}

inline const StopResponse& ClusterMessageChoice::stopResponse() const
{
    BSLS_ASSERT(SELECTION_ID_STOP_RESPONSE == d_selectionId);
    return d_stopResponse.object();
}

inline const QueueUnassignmentRequest&
ClusterMessageChoice::queueUnassignmentRequest() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST == d_selectionId);
    return d_queueUnassignmentRequest.object();
}

inline const QueueUpdateAdvisory&
ClusterMessageChoice::queueUpdateAdvisory() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_UPDATE_ADVISORY == d_selectionId);
    return d_queueUpdateAdvisory.object();
}

inline const ClusterStateFSMMessage&
ClusterMessageChoice::clusterStateFSMMessage() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE == d_selectionId);
    return d_clusterStateFSMMessage.object();
}

inline const PartitionMessage& ClusterMessageChoice::partitionMessage() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION_MESSAGE == d_selectionId);
    return d_partitionMessage.object();
}

inline bool ClusterMessageChoice::isPartitionPrimaryAdvisoryValue() const
{
    return SELECTION_ID_PARTITION_PRIMARY_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderAdvisoryValue() const
{
    return SELECTION_ID_LEADER_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueAssignmentAdvisoryValue() const
{
    return SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isNodeStatusAdvisoryValue() const
{
    return SELECTION_ID_NODE_STATUS_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderSyncStateQueryValue() const
{
    return SELECTION_ID_LEADER_SYNC_STATE_QUERY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderSyncStateQueryResponseValue() const
{
    return SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderSyncDataQueryValue() const
{
    return SELECTION_ID_LEADER_SYNC_DATA_QUERY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderSyncDataQueryResponseValue() const
{
    return SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueAssignmentRequestValue() const
{
    return SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isStorageSyncRequestValue() const
{
    return SELECTION_ID_STORAGE_SYNC_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isStorageSyncResponseValue() const
{
    return SELECTION_ID_STORAGE_SYNC_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionSyncStateQueryValue() const
{
    return SELECTION_ID_PARTITION_SYNC_STATE_QUERY == d_selectionId;
}

inline bool
ClusterMessageChoice::isPartitionSyncStateQueryResponseValue() const
{
    return SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionSyncDataQueryValue() const
{
    return SELECTION_ID_PARTITION_SYNC_DATA_QUERY == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionSyncDataQueryResponseValue() const
{
    return SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionSyncDataQueryStatusValue() const
{
    return SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS == d_selectionId;
}

inline bool ClusterMessageChoice::isPrimaryStatusAdvisoryValue() const
{
    return SELECTION_ID_PRIMARY_STATUS_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isClusterSyncRequestValue() const
{
    return SELECTION_ID_CLUSTER_SYNC_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isClusterSyncResponseValue() const
{
    return SELECTION_ID_CLUSTER_SYNC_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueUnAssignmentAdvisoryValue() const
{
    return SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueUnassignedAdvisoryValue() const
{
    return SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderAdvisoryAckValue() const
{
    return SELECTION_ID_LEADER_ADVISORY_ACK == d_selectionId;
}

inline bool ClusterMessageChoice::isLeaderAdvisoryCommitValue() const
{
    return SELECTION_ID_LEADER_ADVISORY_COMMIT == d_selectionId;
}

inline bool ClusterMessageChoice::isStateNotificationValue() const
{
    return SELECTION_ID_STATE_NOTIFICATION == d_selectionId;
}

inline bool ClusterMessageChoice::isStopRequestValue() const
{
    return SELECTION_ID_STOP_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isStopResponseValue() const
{
    return SELECTION_ID_STOP_RESPONSE == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueUnassignmentRequestValue() const
{
    return SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST == d_selectionId;
}

inline bool ClusterMessageChoice::isQueueUpdateAdvisoryValue() const
{
    return SELECTION_ID_QUEUE_UPDATE_ADVISORY == d_selectionId;
}

inline bool ClusterMessageChoice::isClusterStateFSMMessageValue() const
{
    return SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE == d_selectionId;
}

inline bool ClusterMessageChoice::isPartitionMessageValue() const
{
    return SELECTION_ID_PARTITION_MESSAGE == d_selectionId;
}

inline bool ClusterMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ClusterMessageChoice& object)
{
    typedef bmqp_ctrlmsg::ClusterMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.selectionId());
    switch (object.selectionId()) {
    case Class::SELECTION_ID_PARTITION_PRIMARY_ADVISORY:
        hashAppend(hashAlg, object.partitionPrimaryAdvisory());
        break;
    case Class::SELECTION_ID_LEADER_ADVISORY:
        hashAppend(hashAlg, object.leaderAdvisory());
        break;
    case Class::SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY:
        hashAppend(hashAlg, object.queueAssignmentAdvisory());
        break;
    case Class::SELECTION_ID_NODE_STATUS_ADVISORY:
        hashAppend(hashAlg, object.nodeStatusAdvisory());
        break;
    case Class::SELECTION_ID_LEADER_SYNC_STATE_QUERY:
        hashAppend(hashAlg, object.leaderSyncStateQuery());
        break;
    case Class::SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE:
        hashAppend(hashAlg, object.leaderSyncStateQueryResponse());
        break;
    case Class::SELECTION_ID_LEADER_SYNC_DATA_QUERY:
        hashAppend(hashAlg, object.leaderSyncDataQuery());
        break;
    case Class::SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE:
        hashAppend(hashAlg, object.leaderSyncDataQueryResponse());
        break;
    case Class::SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST:
        hashAppend(hashAlg, object.queueAssignmentRequest());
        break;
    case Class::SELECTION_ID_STORAGE_SYNC_REQUEST:
        hashAppend(hashAlg, object.storageSyncRequest());
        break;
    case Class::SELECTION_ID_STORAGE_SYNC_RESPONSE:
        hashAppend(hashAlg, object.storageSyncResponse());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_STATE_QUERY:
        hashAppend(hashAlg, object.partitionSyncStateQuery());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE:
        hashAppend(hashAlg, object.partitionSyncStateQueryResponse());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY:
        hashAppend(hashAlg, object.partitionSyncDataQuery());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE:
        hashAppend(hashAlg, object.partitionSyncDataQueryResponse());
        break;
    case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS:
        hashAppend(hashAlg, object.partitionSyncDataQueryStatus());
        break;
    case Class::SELECTION_ID_PRIMARY_STATUS_ADVISORY:
        hashAppend(hashAlg, object.primaryStatusAdvisory());
        break;
    case Class::SELECTION_ID_CLUSTER_SYNC_REQUEST:
        hashAppend(hashAlg, object.clusterSyncRequest());
        break;
    case Class::SELECTION_ID_CLUSTER_SYNC_RESPONSE:
        hashAppend(hashAlg, object.clusterSyncResponse());
        break;
    case Class::SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY:
        hashAppend(hashAlg, object.queueUnAssignmentAdvisory());
        break;
    case Class::SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY:
        hashAppend(hashAlg, object.queueUnassignedAdvisory());
        break;
    case Class::SELECTION_ID_LEADER_ADVISORY_ACK:
        hashAppend(hashAlg, object.leaderAdvisoryAck());
        break;
    case Class::SELECTION_ID_LEADER_ADVISORY_COMMIT:
        hashAppend(hashAlg, object.leaderAdvisoryCommit());
        break;
    case Class::SELECTION_ID_STATE_NOTIFICATION:
        hashAppend(hashAlg, object.stateNotification());
        break;
    case Class::SELECTION_ID_STOP_REQUEST:
        hashAppend(hashAlg, object.stopRequest());
        break;
    case Class::SELECTION_ID_STOP_RESPONSE:
        hashAppend(hashAlg, object.stopResponse());
        break;
    case Class::SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST:
        hashAppend(hashAlg, object.queueUnassignmentRequest());
        break;
    case Class::SELECTION_ID_QUEUE_UPDATE_ADVISORY:
        hashAppend(hashAlg, object.queueUpdateAdvisory());
        break;
    case Class::SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE:
        hashAppend(hashAlg, object.clusterStateFSMMessage());
        break;
    case Class::SELECTION_ID_PARTITION_MESSAGE:
        hashAppend(hashAlg, object.partitionMessage());
        break;
    default:
        BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == object.selectionId());
    }
}

// --------------------
// class ClusterMessage
// --------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ClusterMessage::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ClusterMessage::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ClusterMessage::manipulateAttribute(MANIPULATOR& manipulator,
                                        const char*  name,
                                        int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ClusterMessageChoice& ClusterMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <class ACCESSOR>
int ClusterMessage::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ClusterMessage::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ClusterMessage::accessAttribute(ACCESSOR&   accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const ClusterMessageChoice& ClusterMessage::choice() const
{
    return d_choice;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::ClusterMessage& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.choice());
}

// --------------------------
// class ControlMessageChoice
// --------------------------

// CLASS METHODS
// CREATORS
inline ControlMessageChoice::ControlMessageChoice(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ControlMessageChoice::~ControlMessageChoice()
{
    reset();
}

// MANIPULATORS
template <class MANIPULATOR>
int ControlMessageChoice::manipulateSelection(MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ControlMessageChoice::SELECTION_ID_STATUS:
        return manipulator(&d_status.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STATUS]);
    case ControlMessageChoice::SELECTION_ID_DISCONNECT:
        return manipulator(&d_disconnect.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DISCONNECT]);
    case ControlMessageChoice::SELECTION_ID_DISCONNECT_RESPONSE:
        return manipulator(
            &d_disconnectResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_DISCONNECT_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_ADMIN_COMMAND:
        return manipulator(
            &d_adminCommand.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ADMIN_COMMAND]);
    case ControlMessageChoice::SELECTION_ID_ADMIN_COMMAND_RESPONSE:
        return manipulator(
            &d_adminCommandResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ADMIN_COMMAND_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_CLUSTER_MESSAGE:
        return manipulator(
            &d_clusterMessage.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_MESSAGE]);
    case ControlMessageChoice::SELECTION_ID_OPEN_QUEUE:
        return manipulator(&d_openQueue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_OPEN_QUEUE]);
    case ControlMessageChoice::SELECTION_ID_OPEN_QUEUE_RESPONSE:
        return manipulator(
            &d_openQueueResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_OPEN_QUEUE_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_CLOSE_QUEUE:
        return manipulator(&d_closeQueue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLOSE_QUEUE]);
    case ControlMessageChoice::SELECTION_ID_CLOSE_QUEUE_RESPONSE:
        return manipulator(
            &d_closeQueueResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLOSE_QUEUE_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_CONFIGURE_QUEUE_STREAM:
        return manipulator(
            &d_configureQueueStream.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_QUEUE_STREAM]);
    case ControlMessageChoice::SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE:
        return manipulator(
            &d_configureQueueStreamResponse.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_CONFIGURE_QUEUE_STREAM_RESPONSE]);
    case ControlMessageChoice::SELECTION_ID_CONFIGURE_STREAM:
        return manipulator(
            &d_configureStream.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_STREAM]);
    case ControlMessageChoice::SELECTION_ID_CONFIGURE_STREAM_RESPONSE:
        return manipulator(
            &d_configureStreamResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_STREAM_RESPONSE]);
    default:
        BSLS_ASSERT(ControlMessageChoice::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline Status& ControlMessageChoice::status()
{
    BSLS_ASSERT(SELECTION_ID_STATUS == d_selectionId);
    return d_status.object();
}

inline Disconnect& ControlMessageChoice::disconnect()
{
    BSLS_ASSERT(SELECTION_ID_DISCONNECT == d_selectionId);
    return d_disconnect.object();
}

inline DisconnectResponse& ControlMessageChoice::disconnectResponse()
{
    BSLS_ASSERT(SELECTION_ID_DISCONNECT_RESPONSE == d_selectionId);
    return d_disconnectResponse.object();
}

inline AdminCommand& ControlMessageChoice::adminCommand()
{
    BSLS_ASSERT(SELECTION_ID_ADMIN_COMMAND == d_selectionId);
    return d_adminCommand.object();
}

inline AdminCommandResponse& ControlMessageChoice::adminCommandResponse()
{
    BSLS_ASSERT(SELECTION_ID_ADMIN_COMMAND_RESPONSE == d_selectionId);
    return d_adminCommandResponse.object();
}

inline ClusterMessage& ControlMessageChoice::clusterMessage()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_MESSAGE == d_selectionId);
    return d_clusterMessage.object();
}

inline OpenQueue& ControlMessageChoice::openQueue()
{
    BSLS_ASSERT(SELECTION_ID_OPEN_QUEUE == d_selectionId);
    return d_openQueue.object();
}

inline OpenQueueResponse& ControlMessageChoice::openQueueResponse()
{
    BSLS_ASSERT(SELECTION_ID_OPEN_QUEUE_RESPONSE == d_selectionId);
    return d_openQueueResponse.object();
}

inline CloseQueue& ControlMessageChoice::closeQueue()
{
    BSLS_ASSERT(SELECTION_ID_CLOSE_QUEUE == d_selectionId);
    return d_closeQueue.object();
}

inline CloseQueueResponse& ControlMessageChoice::closeQueueResponse()
{
    BSLS_ASSERT(SELECTION_ID_CLOSE_QUEUE_RESPONSE == d_selectionId);
    return d_closeQueueResponse.object();
}

inline ConfigureQueueStream& ControlMessageChoice::configureQueueStream()
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_QUEUE_STREAM == d_selectionId);
    return d_configureQueueStream.object();
}

inline ConfigureQueueStreamResponse&
ControlMessageChoice::configureQueueStreamResponse()
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE == d_selectionId);
    return d_configureQueueStreamResponse.object();
}

inline ConfigureStream& ControlMessageChoice::configureStream()
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_STREAM == d_selectionId);
    return d_configureStream.object();
}

inline ConfigureStreamResponse& ControlMessageChoice::configureStreamResponse()
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_STREAM_RESPONSE == d_selectionId);
    return d_configureStreamResponse.object();
}

// ACCESSORS
inline int ControlMessageChoice::selectionId() const
{
    return d_selectionId;
}

template <class ACCESSOR>
int ControlMessageChoice::accessSelection(ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_STATUS:
        return accessor(d_status.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STATUS]);
    case SELECTION_ID_DISCONNECT:
        return accessor(d_disconnect.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DISCONNECT]);
    case SELECTION_ID_DISCONNECT_RESPONSE:
        return accessor(
            d_disconnectResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_DISCONNECT_RESPONSE]);
    case SELECTION_ID_ADMIN_COMMAND:
        return accessor(d_adminCommand.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ADMIN_COMMAND]);
    case SELECTION_ID_ADMIN_COMMAND_RESPONSE:
        return accessor(
            d_adminCommandResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ADMIN_COMMAND_RESPONSE]);
    case SELECTION_ID_CLUSTER_MESSAGE:
        return accessor(d_clusterMessage.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_MESSAGE]);
    case SELECTION_ID_OPEN_QUEUE:
        return accessor(d_openQueue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_OPEN_QUEUE]);
    case SELECTION_ID_OPEN_QUEUE_RESPONSE:
        return accessor(
            d_openQueueResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_OPEN_QUEUE_RESPONSE]);
    case SELECTION_ID_CLOSE_QUEUE:
        return accessor(d_closeQueue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLOSE_QUEUE]);
    case SELECTION_ID_CLOSE_QUEUE_RESPONSE:
        return accessor(
            d_closeQueueResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLOSE_QUEUE_RESPONSE]);
    case SELECTION_ID_CONFIGURE_QUEUE_STREAM:
        return accessor(
            d_configureQueueStream.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_QUEUE_STREAM]);
    case SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE:
        return accessor(d_configureQueueStreamResponse.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_CONFIGURE_QUEUE_STREAM_RESPONSE]);
    case SELECTION_ID_CONFIGURE_STREAM:
        return accessor(
            d_configureStream.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_STREAM]);
    case SELECTION_ID_CONFIGURE_STREAM_RESPONSE:
        return accessor(
            d_configureStreamResponse.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIGURE_STREAM_RESPONSE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Status& ControlMessageChoice::status() const
{
    BSLS_ASSERT(SELECTION_ID_STATUS == d_selectionId);
    return d_status.object();
}

inline const Disconnect& ControlMessageChoice::disconnect() const
{
    BSLS_ASSERT(SELECTION_ID_DISCONNECT == d_selectionId);
    return d_disconnect.object();
}

inline const DisconnectResponse&
ControlMessageChoice::disconnectResponse() const
{
    BSLS_ASSERT(SELECTION_ID_DISCONNECT_RESPONSE == d_selectionId);
    return d_disconnectResponse.object();
}

inline const AdminCommand& ControlMessageChoice::adminCommand() const
{
    BSLS_ASSERT(SELECTION_ID_ADMIN_COMMAND == d_selectionId);
    return d_adminCommand.object();
}

inline const AdminCommandResponse&
ControlMessageChoice::adminCommandResponse() const
{
    BSLS_ASSERT(SELECTION_ID_ADMIN_COMMAND_RESPONSE == d_selectionId);
    return d_adminCommandResponse.object();
}

inline const ClusterMessage& ControlMessageChoice::clusterMessage() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_MESSAGE == d_selectionId);
    return d_clusterMessage.object();
}

inline const OpenQueue& ControlMessageChoice::openQueue() const
{
    BSLS_ASSERT(SELECTION_ID_OPEN_QUEUE == d_selectionId);
    return d_openQueue.object();
}

inline const OpenQueueResponse& ControlMessageChoice::openQueueResponse() const
{
    BSLS_ASSERT(SELECTION_ID_OPEN_QUEUE_RESPONSE == d_selectionId);
    return d_openQueueResponse.object();
}

inline const CloseQueue& ControlMessageChoice::closeQueue() const
{
    BSLS_ASSERT(SELECTION_ID_CLOSE_QUEUE == d_selectionId);
    return d_closeQueue.object();
}

inline const CloseQueueResponse&
ControlMessageChoice::closeQueueResponse() const
{
    BSLS_ASSERT(SELECTION_ID_CLOSE_QUEUE_RESPONSE == d_selectionId);
    return d_closeQueueResponse.object();
}

inline const ConfigureQueueStream&
ControlMessageChoice::configureQueueStream() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_QUEUE_STREAM == d_selectionId);
    return d_configureQueueStream.object();
}

inline const ConfigureQueueStreamResponse&
ControlMessageChoice::configureQueueStreamResponse() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE == d_selectionId);
    return d_configureQueueStreamResponse.object();
}

inline const ConfigureStream& ControlMessageChoice::configureStream() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_STREAM == d_selectionId);
    return d_configureStream.object();
}

inline const ConfigureStreamResponse&
ControlMessageChoice::configureStreamResponse() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIGURE_STREAM_RESPONSE == d_selectionId);
    return d_configureStreamResponse.object();
}

inline bool ControlMessageChoice::isStatusValue() const
{
    return SELECTION_ID_STATUS == d_selectionId;
}

inline bool ControlMessageChoice::isDisconnectValue() const
{
    return SELECTION_ID_DISCONNECT == d_selectionId;
}

inline bool ControlMessageChoice::isDisconnectResponseValue() const
{
    return SELECTION_ID_DISCONNECT_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isAdminCommandValue() const
{
    return SELECTION_ID_ADMIN_COMMAND == d_selectionId;
}

inline bool ControlMessageChoice::isAdminCommandResponseValue() const
{
    return SELECTION_ID_ADMIN_COMMAND_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isClusterMessageValue() const
{
    return SELECTION_ID_CLUSTER_MESSAGE == d_selectionId;
}

inline bool ControlMessageChoice::isOpenQueueValue() const
{
    return SELECTION_ID_OPEN_QUEUE == d_selectionId;
}

inline bool ControlMessageChoice::isOpenQueueResponseValue() const
{
    return SELECTION_ID_OPEN_QUEUE_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isCloseQueueValue() const
{
    return SELECTION_ID_CLOSE_QUEUE == d_selectionId;
}

inline bool ControlMessageChoice::isCloseQueueResponseValue() const
{
    return SELECTION_ID_CLOSE_QUEUE_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isConfigureQueueStreamValue() const
{
    return SELECTION_ID_CONFIGURE_QUEUE_STREAM == d_selectionId;
}

inline bool ControlMessageChoice::isConfigureQueueStreamResponseValue() const
{
    return SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isConfigureStreamValue() const
{
    return SELECTION_ID_CONFIGURE_STREAM == d_selectionId;
}

inline bool ControlMessageChoice::isConfigureStreamResponseValue() const
{
    return SELECTION_ID_CONFIGURE_STREAM_RESPONSE == d_selectionId;
}

inline bool ControlMessageChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                           hashAlg,
                const bmqp_ctrlmsg::ControlMessageChoice& object)
{
    typedef bmqp_ctrlmsg::ControlMessageChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.selectionId());
    switch (object.selectionId()) {
    case Class::SELECTION_ID_STATUS:
        hashAppend(hashAlg, object.status());
        break;
    case Class::SELECTION_ID_DISCONNECT:
        hashAppend(hashAlg, object.disconnect());
        break;
    case Class::SELECTION_ID_DISCONNECT_RESPONSE:
        hashAppend(hashAlg, object.disconnectResponse());
        break;
    case Class::SELECTION_ID_ADMIN_COMMAND:
        hashAppend(hashAlg, object.adminCommand());
        break;
    case Class::SELECTION_ID_ADMIN_COMMAND_RESPONSE:
        hashAppend(hashAlg, object.adminCommandResponse());
        break;
    case Class::SELECTION_ID_CLUSTER_MESSAGE:
        hashAppend(hashAlg, object.clusterMessage());
        break;
    case Class::SELECTION_ID_OPEN_QUEUE:
        hashAppend(hashAlg, object.openQueue());
        break;
    case Class::SELECTION_ID_OPEN_QUEUE_RESPONSE:
        hashAppend(hashAlg, object.openQueueResponse());
        break;
    case Class::SELECTION_ID_CLOSE_QUEUE:
        hashAppend(hashAlg, object.closeQueue());
        break;
    case Class::SELECTION_ID_CLOSE_QUEUE_RESPONSE:
        hashAppend(hashAlg, object.closeQueueResponse());
        break;
    case Class::SELECTION_ID_CONFIGURE_QUEUE_STREAM:
        hashAppend(hashAlg, object.configureQueueStream());
        break;
    case Class::SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE:
        hashAppend(hashAlg, object.configureQueueStreamResponse());
        break;
    case Class::SELECTION_ID_CONFIGURE_STREAM:
        hashAppend(hashAlg, object.configureStream());
        break;
    case Class::SELECTION_ID_CONFIGURE_STREAM_RESPONSE:
        hashAppend(hashAlg, object.configureStreamResponse());
        break;
    default:
        BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == object.selectionId());
    }
}

// --------------------
// class ControlMessage
// --------------------

// CLASS METHODS
// MANIPULATORS
template <class MANIPULATOR>
int ControlMessage::manipulateAttributes(MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_rId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_R_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class MANIPULATOR>
int ControlMessage::manipulateAttribute(MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_R_ID: {
        return manipulator(&d_rId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_R_ID]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class MANIPULATOR>
int ControlMessage::manipulateAttribute(MANIPULATOR& manipulator,
                                        const char*  name,
                                        int          nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bdlb::NullableValue<int>& ControlMessage::rId()
{
    return d_rId;
}

inline ControlMessageChoice& ControlMessage::choice()
{
    return d_choice;
}

// ACCESSORS
template <class ACCESSOR>
int ControlMessage::accessAttributes(ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_rId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_R_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return ret;
}

template <class ACCESSOR>
int ControlMessage::accessAttribute(ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_R_ID: {
        return accessor(d_rId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_R_ID]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <class ACCESSOR>
int ControlMessage::accessAttribute(ACCESSOR&   accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bdlb::NullableValue<int>& ControlMessage::rId() const
{
    return d_rId;
}

inline const ControlMessageChoice& ControlMessage::choice() const
{
    return d_choice;
}

template <typename HASH_ALGORITHM>
void hashAppend(HASH_ALGORITHM&                     hashAlg,
                const bmqp_ctrlmsg::ControlMessage& object)
{
    (void)hashAlg;
    (void)object;
    using bslh::hashAppend;
    hashAppend(hashAlg, object.rId());
    hashAppend(hashAlg, object.choice());
}

}  // close package namespace

// FREE FUNCTIONS

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::AdminCommand& lhs,
                                     const bmqp_ctrlmsg::AdminCommand& rhs)
{
    return lhs.command() == rhs.command();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::AdminCommand& lhs,
                                     const bmqp_ctrlmsg::AdminCommand& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                     stream,
                         const bmqp_ctrlmsg::AdminCommand& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::AdminCommandResponse& lhs,
                         const bmqp_ctrlmsg::AdminCommandResponse& rhs)
{
    return lhs.text() == rhs.text();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::AdminCommandResponse& lhs,
                         const bmqp_ctrlmsg::AdminCommandResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::AdminCommandResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::AppIdInfo& lhs,
                                     const bmqp_ctrlmsg::AppIdInfo& rhs)
{
    return lhs.appId() == rhs.appId() && lhs.appKey() == rhs.appKey();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::AppIdInfo& lhs,
                                     const bmqp_ctrlmsg::AppIdInfo& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                  stream,
                         const bmqp_ctrlmsg::AppIdInfo& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         bmqp_ctrlmsg::ClientLanguage::Value rhs)
{
    return bmqp_ctrlmsg::ClientLanguage::print(stream, rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                   stream,
                         bmqp_ctrlmsg::ClientType::Value rhs)
{
    return bmqp_ctrlmsg::ClientType::print(stream, rhs);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::CloseQueueResponse&,
                                     const bmqp_ctrlmsg::CloseQueueResponse&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::CloseQueueResponse&,
                                     const bmqp_ctrlmsg::CloseQueueResponse&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                           stream,
                         const bmqp_ctrlmsg::CloseQueueResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ClusterSyncRequest&,
                                     const bmqp_ctrlmsg::ClusterSyncRequest&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ClusterSyncRequest&,
                                     const bmqp_ctrlmsg::ClusterSyncRequest&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                           stream,
                         const bmqp_ctrlmsg::ClusterSyncRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ClusterSyncResponse&,
                                     const bmqp_ctrlmsg::ClusterSyncResponse&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ClusterSyncResponse&,
                                     const bmqp_ctrlmsg::ClusterSyncResponse&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::ClusterSyncResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ConsumerInfo& lhs,
                                     const bmqp_ctrlmsg::ConsumerInfo& rhs)
{
    return lhs.maxUnconfirmedMessages() == rhs.maxUnconfirmedMessages() &&
           lhs.maxUnconfirmedBytes() == rhs.maxUnconfirmedBytes() &&
           lhs.consumerPriority() == rhs.consumerPriority() &&
           lhs.consumerPriorityCount() == rhs.consumerPriorityCount();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ConsumerInfo& lhs,
                                     const bmqp_ctrlmsg::ConsumerInfo& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                     stream,
                         const bmqp_ctrlmsg::ConsumerInfo& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::Disconnect&,
                                     const bmqp_ctrlmsg::Disconnect&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::Disconnect&,
                                     const bmqp_ctrlmsg::Disconnect&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                   stream,
                         const bmqp_ctrlmsg::Disconnect& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::DisconnectResponse&,
                                     const bmqp_ctrlmsg::DisconnectResponse&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::DisconnectResponse&,
                                     const bmqp_ctrlmsg::DisconnectResponse&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                           stream,
                         const bmqp_ctrlmsg::DisconnectResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         bmqp_ctrlmsg::DumpActionType::Value rhs)
{
    return bmqp_ctrlmsg::DumpActionType::print(stream, rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                    stream,
                         bmqp_ctrlmsg::DumpMsgType::Value rhs)
{
    return bmqp_ctrlmsg::DumpMsgType::print(stream, rhs);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ElectionProposal&,
                                     const bmqp_ctrlmsg::ElectionProposal&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ElectionProposal&,
                                     const bmqp_ctrlmsg::ElectionProposal&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                         stream,
                         const bmqp_ctrlmsg::ElectionProposal& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ElectionResponse&,
                                     const bmqp_ctrlmsg::ElectionResponse&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ElectionResponse&,
                                     const bmqp_ctrlmsg::ElectionResponse&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                         stream,
                         const bmqp_ctrlmsg::ElectionResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ElectorNodeStatus& lhs,
                         const bmqp_ctrlmsg::ElectorNodeStatus& rhs)
{
    return lhs.isAvailable() == rhs.isAvailable();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ElectorNodeStatus& lhs,
                         const bmqp_ctrlmsg::ElectorNodeStatus& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                          stream,
                         const bmqp_ctrlmsg::ElectorNodeStatus& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                          stream,
                         bmqp_ctrlmsg::ExpressionVersion::Value rhs)
{
    return bmqp_ctrlmsg::ExpressionVersion::print(stream, rhs);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::FollowerClusterStateRequest&,
                         const bmqp_ctrlmsg::FollowerClusterStateRequest&)
{
    return true;
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::FollowerClusterStateRequest&,
                         const bmqp_ctrlmsg::FollowerClusterStateRequest&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream& stream,
                         const bmqp_ctrlmsg::FollowerClusterStateRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::FollowerLSNRequest&,
                                     const bmqp_ctrlmsg::FollowerLSNRequest&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::FollowerLSNRequest&,
                                     const bmqp_ctrlmsg::FollowerLSNRequest&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                           stream,
                         const bmqp_ctrlmsg::FollowerLSNRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::GuidInfo& lhs,
                                     const bmqp_ctrlmsg::GuidInfo& rhs)
{
    return lhs.clientId() == rhs.clientId() &&
           lhs.nanoSecondsFromEpoch() == rhs.nanoSecondsFromEpoch();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::GuidInfo& lhs,
                                     const bmqp_ctrlmsg::GuidInfo& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                 stream,
                         const bmqp_ctrlmsg::GuidInfo& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::HeartbeatResponse&,
                                     const bmqp_ctrlmsg::HeartbeatResponse&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::HeartbeatResponse&,
                                     const bmqp_ctrlmsg::HeartbeatResponse&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                          stream,
                         const bmqp_ctrlmsg::HeartbeatResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderHeartbeat&,
                                     const bmqp_ctrlmsg::LeaderHeartbeat&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderHeartbeat&,
                                     const bmqp_ctrlmsg::LeaderHeartbeat&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                        stream,
                         const bmqp_ctrlmsg::LeaderHeartbeat& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderMessageSequence& lhs,
                         const bmqp_ctrlmsg::LeaderMessageSequence& rhs)
{
    return lhs.electorTerm() == rhs.electorTerm() &&
           lhs.sequenceNumber() == rhs.sequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderMessageSequence& lhs,
                         const bmqp_ctrlmsg::LeaderMessageSequence& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                              stream,
                         const bmqp_ctrlmsg::LeaderMessageSequence& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderPassive&,
                                     const bmqp_ctrlmsg::LeaderPassive&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderPassive&,
                                     const bmqp_ctrlmsg::LeaderPassive&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                      stream,
                         const bmqp_ctrlmsg::LeaderPassive& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderSyncDataQuery&,
                                     const bmqp_ctrlmsg::LeaderSyncDataQuery&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderSyncDataQuery&,
                                     const bmqp_ctrlmsg::LeaderSyncDataQuery&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::LeaderSyncDataQuery& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderSyncStateQuery&,
                                     const bmqp_ctrlmsg::LeaderSyncStateQuery&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderSyncStateQuery&,
                                     const bmqp_ctrlmsg::LeaderSyncStateQuery&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::LeaderSyncStateQuery& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeadershipCessionNotification&,
                         const bmqp_ctrlmsg::LeadershipCessionNotification&)
{
    return true;
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeadershipCessionNotification&,
                         const bmqp_ctrlmsg::LeadershipCessionNotification&)
{
    return false;
}

inline bsl::ostream& bmqp_ctrlmsg::operator<<(
    bsl::ostream&                                      stream,
    const bmqp_ctrlmsg::LeadershipCessionNotification& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                   stream,
                         bmqp_ctrlmsg::NodeStatus::Value rhs)
{
    return bmqp_ctrlmsg::NodeStatus::print(stream, rhs);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PartitionPrimaryInfo& lhs,
                         const bmqp_ctrlmsg::PartitionPrimaryInfo& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.primaryNodeId() == rhs.primaryNodeId() &&
           lhs.primaryLeaseId() == rhs.primaryLeaseId();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PartitionPrimaryInfo& lhs,
                         const bmqp_ctrlmsg::PartitionPrimaryInfo& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::PartitionPrimaryInfo& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PartitionSequenceNumber& lhs,
                         const bmqp_ctrlmsg::PartitionSequenceNumber& rhs)
{
    return lhs.primaryLeaseId() == rhs.primaryLeaseId() &&
           lhs.sequenceNumber() == rhs.sequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PartitionSequenceNumber& lhs,
                         const bmqp_ctrlmsg::PartitionSequenceNumber& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                stream,
                         const bmqp_ctrlmsg::PartitionSequenceNumber& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(
    const bmqp_ctrlmsg::PartitionSyncDataQueryResponse& lhs,
    const bmqp_ctrlmsg::PartitionSyncDataQueryResponse& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.endPrimaryLeaseId() == rhs.endPrimaryLeaseId() &&
           lhs.endSequenceNum() == rhs.endSequenceNum();
}

inline bool bmqp_ctrlmsg::operator!=(
    const bmqp_ctrlmsg::PartitionSyncDataQueryResponse& lhs,
    const bmqp_ctrlmsg::PartitionSyncDataQueryResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream& bmqp_ctrlmsg::operator<<(
    bsl::ostream&                                       stream,
    const bmqp_ctrlmsg::PartitionSyncDataQueryResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PartitionSyncStateQuery& lhs,
                         const bmqp_ctrlmsg::PartitionSyncStateQuery& rhs)
{
    return lhs.partitionId() == rhs.partitionId();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PartitionSyncStateQuery& lhs,
                         const bmqp_ctrlmsg::PartitionSyncStateQuery& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                stream,
                         const bmqp_ctrlmsg::PartitionSyncStateQuery& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                      stream,
                         bmqp_ctrlmsg::PrimaryStatus::Value rhs)
{
    return bmqp_ctrlmsg::PrimaryStatus::print(stream, rhs);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueAssignmentRequest& lhs,
                         const bmqp_ctrlmsg::QueueAssignmentRequest& rhs)
{
    return lhs.queueUri() == rhs.queueUri();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueAssignmentRequest& lhs,
                         const bmqp_ctrlmsg::QueueAssignmentRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                               stream,
                         const bmqp_ctrlmsg::QueueAssignmentRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueUnassignmentRequest& lhs,
                         const bmqp_ctrlmsg::QueueUnassignmentRequest& rhs)
{
    return lhs.queueUri() == rhs.queueUri() &&
           lhs.partitionId() == rhs.partitionId() &&
           lhs.queueKey() == rhs.queueKey();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueUnassignmentRequest& lhs,
                         const bmqp_ctrlmsg::QueueUnassignmentRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                 stream,
                         const bmqp_ctrlmsg::QueueUnassignmentRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::RegistrationResponse&,
                                     const bmqp_ctrlmsg::RegistrationResponse&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::RegistrationResponse&,
                                     const bmqp_ctrlmsg::RegistrationResponse&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::RegistrationResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                        stream,
                         bmqp_ctrlmsg::ReplicaDataType::Value rhs)
{
    return bmqp_ctrlmsg::ReplicaDataType::print(stream, rhs);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ReverseConnectionRequest& lhs,
                         const bmqp_ctrlmsg::ReverseConnectionRequest& rhs)
{
    return lhs.protocolVersion() == rhs.protocolVersion() &&
           lhs.clusterName() == rhs.clusterName() &&
           lhs.clusterNodeId() == rhs.clusterNodeId();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ReverseConnectionRequest& lhs,
                         const bmqp_ctrlmsg::ReverseConnectionRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                 stream,
                         const bmqp_ctrlmsg::ReverseConnectionRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::RoutingConfiguration& lhs,
                         const bmqp_ctrlmsg::RoutingConfiguration& rhs)
{
    return lhs.flags() == rhs.flags();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::RoutingConfiguration& lhs,
                         const bmqp_ctrlmsg::RoutingConfiguration& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::RoutingConfiguration& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                  stream,
                         bmqp_ctrlmsg::RoutingConfigurationFlags::Value rhs)
{
    return bmqp_ctrlmsg::RoutingConfigurationFlags::print(stream, rhs);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ScoutingRequest&,
                                     const bmqp_ctrlmsg::ScoutingRequest&)
{
    return true;
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ScoutingRequest&,
                                     const bmqp_ctrlmsg::ScoutingRequest&)
{
    return false;
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                        stream,
                         const bmqp_ctrlmsg::ScoutingRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ScoutingResponse& lhs,
                                     const bmqp_ctrlmsg::ScoutingResponse& rhs)
{
    return lhs.willVote() == rhs.willVote();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ScoutingResponse& lhs,
                                     const bmqp_ctrlmsg::ScoutingResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                         stream,
                         const bmqp_ctrlmsg::ScoutingResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         bmqp_ctrlmsg::StatusCategory::Value rhs)
{
    return bmqp_ctrlmsg::StatusCategory::print(stream, rhs);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::StopRequest& lhs,
                                     const bmqp_ctrlmsg::StopRequest& rhs)
{
    return lhs.clusterName() == rhs.clusterName();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::StopRequest& lhs,
                                     const bmqp_ctrlmsg::StopRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                    stream,
                         const bmqp_ctrlmsg::StopRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::StopResponse& lhs,
                                     const bmqp_ctrlmsg::StopResponse& rhs)
{
    return lhs.clusterName() == rhs.clusterName();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::StopResponse& lhs,
                                     const bmqp_ctrlmsg::StopResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                     stream,
                         const bmqp_ctrlmsg::StopResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                stream,
                         bmqp_ctrlmsg::StorageSyncResponseType::Value rhs)
{
    return bmqp_ctrlmsg::StorageSyncResponseType::print(stream, rhs);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::SubQueueIdInfo& lhs,
                                     const bmqp_ctrlmsg::SubQueueIdInfo& rhs)
{
    return lhs.subId() == rhs.subId() && lhs.appId() == rhs.appId();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::SubQueueIdInfo& lhs,
                                     const bmqp_ctrlmsg::SubQueueIdInfo& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         const bmqp_ctrlmsg::SubQueueIdInfo& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::SyncPoint& lhs,
                                     const bmqp_ctrlmsg::SyncPoint& rhs)
{
    return lhs.primaryLeaseId() == rhs.primaryLeaseId() &&
           lhs.sequenceNum() == rhs.sequenceNum() &&
           lhs.dataFileOffsetDwords() == rhs.dataFileOffsetDwords() &&
           lhs.qlistFileOffsetWords() == rhs.qlistFileOffsetWords();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::SyncPoint& lhs,
                                     const bmqp_ctrlmsg::SyncPoint& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                  stream,
                         const bmqp_ctrlmsg::SyncPoint& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ClientIdentity& lhs,
                                     const bmqp_ctrlmsg::ClientIdentity& rhs)
{
    return lhs.protocolVersion() == rhs.protocolVersion() &&
           lhs.sdkVersion() == rhs.sdkVersion() &&
           lhs.clientType() == rhs.clientType() &&
           lhs.processName() == rhs.processName() && lhs.pid() == rhs.pid() &&
           lhs.sessionId() == rhs.sessionId() &&
           lhs.hostName() == rhs.hostName() &&
           lhs.features() == rhs.features() &&
           lhs.clusterName() == rhs.clusterName() &&
           lhs.clusterNodeId() == rhs.clusterNodeId() &&
           lhs.sdkLanguage() == rhs.sdkLanguage() &&
           lhs.guidInfo() == rhs.guidInfo();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ClientIdentity& lhs,
                                     const bmqp_ctrlmsg::ClientIdentity& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         const bmqp_ctrlmsg::ClientIdentity& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::DumpMessages& lhs,
                                     const bmqp_ctrlmsg::DumpMessages& rhs)
{
    return lhs.msgTypeToDump() == rhs.msgTypeToDump() &&
           lhs.dumpActionType() == rhs.dumpActionType() &&
           lhs.dumpActionValue() == rhs.dumpActionValue();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::DumpMessages& lhs,
                                     const bmqp_ctrlmsg::DumpMessages& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                     stream,
                         const bmqp_ctrlmsg::DumpMessages& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ElectorMessageChoice& lhs,
                         const bmqp_ctrlmsg::ElectorMessageChoice& rhs)
{
    typedef bmqp_ctrlmsg::ElectorMessageChoice Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ELECTION_PROPOSAL:
            return lhs.electionProposal() == rhs.electionProposal();
        case Class::SELECTION_ID_ELECTION_RESPONSE:
            return lhs.electionResponse() == rhs.electionResponse();
        case Class::SELECTION_ID_LEADER_HEARTBEAT:
            return lhs.leaderHeartbeat() == rhs.leaderHeartbeat();
        case Class::SELECTION_ID_ELECTOR_NODE_STATUS:
            return lhs.electorNodeStatus() == rhs.electorNodeStatus();
        case Class::SELECTION_ID_HEARTBEAT_RESPONSE:
            return lhs.heartbeatResponse() == rhs.heartbeatResponse();
        case Class::SELECTION_ID_SCOUTING_REQUEST:
            return lhs.scoutingRequest() == rhs.scoutingRequest();
        case Class::SELECTION_ID_SCOUTING_RESPONSE:
            return lhs.scoutingResponse() == rhs.scoutingResponse();
        case Class::SELECTION_ID_LEADERSHIP_CESSION_NOTIFICATION:
            return lhs.leadershipCessionNotification() ==
                   rhs.leadershipCessionNotification();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ElectorMessageChoice& lhs,
                         const bmqp_ctrlmsg::ElectorMessageChoice& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::ElectorMessageChoice& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::Expression& lhs,
                                     const bmqp_ctrlmsg::Expression& rhs)
{
    return lhs.version() == rhs.version() && lhs.text() == rhs.text();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::Expression& lhs,
                                     const bmqp_ctrlmsg::Expression& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                   stream,
                         const bmqp_ctrlmsg::Expression& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::FollowerLSNResponse& lhs,
                         const bmqp_ctrlmsg::FollowerLSNResponse& rhs)
{
    return lhs.sequenceNumber() == rhs.sequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::FollowerLSNResponse& lhs,
                         const bmqp_ctrlmsg::FollowerLSNResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::FollowerLSNResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderAdvisoryAck& lhs,
                         const bmqp_ctrlmsg::LeaderAdvisoryAck& rhs)
{
    return lhs.sequenceNumberAcked() == rhs.sequenceNumberAcked();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderAdvisoryAck& lhs,
                         const bmqp_ctrlmsg::LeaderAdvisoryAck& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                          stream,
                         const bmqp_ctrlmsg::LeaderAdvisoryAck& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderAdvisoryCommit& lhs,
                         const bmqp_ctrlmsg::LeaderAdvisoryCommit& rhs)
{
    return lhs.sequenceNumber() == rhs.sequenceNumber() &&
           lhs.sequenceNumberCommitted() == rhs.sequenceNumberCommitted();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderAdvisoryCommit& lhs,
                         const bmqp_ctrlmsg::LeaderAdvisoryCommit& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::LeaderAdvisoryCommit& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderSyncStateQueryResponse& lhs,
                         const bmqp_ctrlmsg::LeaderSyncStateQueryResponse& rhs)
{
    return lhs.leaderMessageSequence() == rhs.leaderMessageSequence();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderSyncStateQueryResponse& lhs,
                         const bmqp_ctrlmsg::LeaderSyncStateQueryResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream& stream,
                         const bmqp_ctrlmsg::LeaderSyncStateQueryResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::NodeStatusAdvisory& lhs,
                         const bmqp_ctrlmsg::NodeStatusAdvisory& rhs)
{
    return lhs.status() == rhs.status();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::NodeStatusAdvisory& lhs,
                         const bmqp_ctrlmsg::NodeStatusAdvisory& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                           stream,
                         const bmqp_ctrlmsg::NodeStatusAdvisory& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PartitionPrimaryAdvisory& lhs,
                         const bmqp_ctrlmsg::PartitionPrimaryAdvisory& rhs)
{
    return lhs.sequenceNumber() == rhs.sequenceNumber() &&
           lhs.partitions() == rhs.partitions();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PartitionPrimaryAdvisory& lhs,
                         const bmqp_ctrlmsg::PartitionPrimaryAdvisory& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                 stream,
                         const bmqp_ctrlmsg::PartitionPrimaryAdvisory& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PrimaryStateRequest& lhs,
                         const bmqp_ctrlmsg::PrimaryStateRequest& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.sequenceNumber() == rhs.sequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PrimaryStateRequest& lhs,
                         const bmqp_ctrlmsg::PrimaryStateRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::PrimaryStateRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PrimaryStateResponse& lhs,
                         const bmqp_ctrlmsg::PrimaryStateResponse& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.sequenceNumber() == rhs.sequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PrimaryStateResponse& lhs,
                         const bmqp_ctrlmsg::PrimaryStateResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::PrimaryStateResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PrimaryStatusAdvisory& lhs,
                         const bmqp_ctrlmsg::PrimaryStatusAdvisory& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.primaryLeaseId() == rhs.primaryLeaseId() &&
           lhs.status() == rhs.status();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PrimaryStatusAdvisory& lhs,
                         const bmqp_ctrlmsg::PrimaryStatusAdvisory& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                              stream,
                         const bmqp_ctrlmsg::PrimaryStatusAdvisory& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueHandleParameters& lhs,
                         const bmqp_ctrlmsg::QueueHandleParameters& rhs)
{
    return lhs.uri() == rhs.uri() && lhs.qId() == rhs.qId() &&
           lhs.subIdInfo() == rhs.subIdInfo() && lhs.flags() == rhs.flags() &&
           lhs.readCount() == rhs.readCount() &&
           lhs.writeCount() == rhs.writeCount() &&
           lhs.adminCount() == rhs.adminCount();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueHandleParameters& lhs,
                         const bmqp_ctrlmsg::QueueHandleParameters& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                              stream,
                         const bmqp_ctrlmsg::QueueHandleParameters& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueInfo& lhs,
                                     const bmqp_ctrlmsg::QueueInfo& rhs)
{
    return lhs.uri() == rhs.uri() && lhs.key() == rhs.key() &&
           lhs.partitionId() == rhs.partitionId() &&
           lhs.appIds() == rhs.appIds();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueInfo& lhs,
                                     const bmqp_ctrlmsg::QueueInfo& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                  stream,
                         const bmqp_ctrlmsg::QueueInfo& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueInfoUpdate& lhs,
                                     const bmqp_ctrlmsg::QueueInfoUpdate& rhs)
{
    return lhs.uri() == rhs.uri() && lhs.key() == rhs.key() &&
           lhs.partitionId() == rhs.partitionId() &&
           lhs.addedAppIds() == rhs.addedAppIds() &&
           lhs.removedAppIds() == rhs.removedAppIds() &&
           lhs.domain() == rhs.domain();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueInfoUpdate& lhs,
                                     const bmqp_ctrlmsg::QueueInfoUpdate& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                        stream,
                         const bmqp_ctrlmsg::QueueInfoUpdate& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueStreamParameters& lhs,
                         const bmqp_ctrlmsg::QueueStreamParameters& rhs)
{
    return lhs.subIdInfo() == rhs.subIdInfo() &&
           lhs.maxUnconfirmedMessages() == rhs.maxUnconfirmedMessages() &&
           lhs.maxUnconfirmedBytes() == rhs.maxUnconfirmedBytes() &&
           lhs.consumerPriority() == rhs.consumerPriority() &&
           lhs.consumerPriorityCount() == rhs.consumerPriorityCount();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueStreamParameters& lhs,
                         const bmqp_ctrlmsg::QueueStreamParameters& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                              stream,
                         const bmqp_ctrlmsg::QueueStreamParameters& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::RegistrationRequest& lhs,
                         const bmqp_ctrlmsg::RegistrationRequest& rhs)
{
    return lhs.sequenceNumber() == rhs.sequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::RegistrationRequest& lhs,
                         const bmqp_ctrlmsg::RegistrationRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::RegistrationRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ReplicaDataRequest& lhs,
                         const bmqp_ctrlmsg::ReplicaDataRequest& rhs)
{
    return lhs.replicaDataType() == rhs.replicaDataType() &&
           lhs.partitionId() == rhs.partitionId() &&
           lhs.beginSequenceNumber() == rhs.beginSequenceNumber() &&
           lhs.endSequenceNumber() == rhs.endSequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ReplicaDataRequest& lhs,
                         const bmqp_ctrlmsg::ReplicaDataRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                           stream,
                         const bmqp_ctrlmsg::ReplicaDataRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ReplicaDataResponse& lhs,
                         const bmqp_ctrlmsg::ReplicaDataResponse& rhs)
{
    return lhs.replicaDataType() == rhs.replicaDataType() &&
           lhs.partitionId() == rhs.partitionId() &&
           lhs.beginSequenceNumber() == rhs.beginSequenceNumber() &&
           lhs.endSequenceNumber() == rhs.endSequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ReplicaDataResponse& lhs,
                         const bmqp_ctrlmsg::ReplicaDataResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::ReplicaDataResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ReplicaStateRequest& lhs,
                         const bmqp_ctrlmsg::ReplicaStateRequest& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.sequenceNumber() == rhs.sequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ReplicaStateRequest& lhs,
                         const bmqp_ctrlmsg::ReplicaStateRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::ReplicaStateRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ReplicaStateResponse& lhs,
                         const bmqp_ctrlmsg::ReplicaStateResponse& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.sequenceNumber() == rhs.sequenceNumber();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ReplicaStateResponse& lhs,
                         const bmqp_ctrlmsg::ReplicaStateResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::ReplicaStateResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::StateNotificationChoice& lhs,
                         const bmqp_ctrlmsg::StateNotificationChoice& rhs)
{
    typedef bmqp_ctrlmsg::StateNotificationChoice Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_LEADER_PASSIVE:
            return lhs.leaderPassive() == rhs.leaderPassive();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::StateNotificationChoice& lhs,
                         const bmqp_ctrlmsg::StateNotificationChoice& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                stream,
                         const bmqp_ctrlmsg::StateNotificationChoice& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::Status& lhs,
                                     const bmqp_ctrlmsg::Status& rhs)
{
    return lhs.category() == rhs.category() && lhs.code() == rhs.code() &&
           lhs.message() == rhs.message();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::Status& lhs,
                                     const bmqp_ctrlmsg::Status& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream& bmqp_ctrlmsg::operator<<(bsl::ostream& stream,
                                              const bmqp_ctrlmsg::Status& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::StorageSyncResponse& lhs,
                         const bmqp_ctrlmsg::StorageSyncResponse& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.storageSyncResponseType() == rhs.storageSyncResponseType() &&
           lhs.beginSyncPoint() == rhs.beginSyncPoint() &&
           lhs.endSyncPoint() == rhs.endSyncPoint();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::StorageSyncResponse& lhs,
                         const bmqp_ctrlmsg::StorageSyncResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::StorageSyncResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::SyncPointOffsetPair& lhs,
                         const bmqp_ctrlmsg::SyncPointOffsetPair& rhs)
{
    return lhs.syncPoint() == rhs.syncPoint() && lhs.offset() == rhs.offset();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::SyncPointOffsetPair& lhs,
                         const bmqp_ctrlmsg::SyncPointOffsetPair& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::SyncPointOffsetPair& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::BrokerResponse& lhs,
                                     const bmqp_ctrlmsg::BrokerResponse& rhs)
{
    return lhs.result() == rhs.result() &&
           lhs.protocolVersion() == rhs.protocolVersion() &&
           lhs.brokerVersion() == rhs.brokerVersion() &&
           lhs.isDeprecatedSdk() == rhs.isDeprecatedSdk() &&
           lhs.brokerIdentity() == rhs.brokerIdentity();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::BrokerResponse& lhs,
                                     const bmqp_ctrlmsg::BrokerResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         const bmqp_ctrlmsg::BrokerResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::CloseQueue& lhs,
                                     const bmqp_ctrlmsg::CloseQueue& rhs)
{
    return lhs.handleParameters() == rhs.handleParameters() &&
           lhs.isFinal() == rhs.isFinal();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::CloseQueue& lhs,
                                     const bmqp_ctrlmsg::CloseQueue& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                   stream,
                         const bmqp_ctrlmsg::CloseQueue& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ConfigureQueueStream& lhs,
                         const bmqp_ctrlmsg::ConfigureQueueStream& rhs)
{
    return lhs.qId() == rhs.qId() &&
           lhs.streamParameters() == rhs.streamParameters();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ConfigureQueueStream& lhs,
                         const bmqp_ctrlmsg::ConfigureQueueStream& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::ConfigureQueueStream& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ElectorMessage& lhs,
                                     const bmqp_ctrlmsg::ElectorMessage& rhs)
{
    return lhs.term() == rhs.term() && lhs.choice() == rhs.choice();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ElectorMessage& lhs,
                                     const bmqp_ctrlmsg::ElectorMessage& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         const bmqp_ctrlmsg::ElectorMessage& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderAdvisory& lhs,
                                     const bmqp_ctrlmsg::LeaderAdvisory& rhs)
{
    return lhs.sequenceNumber() == rhs.sequenceNumber() &&
           lhs.partitions() == rhs.partitions() &&
           lhs.queues() == rhs.queues();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderAdvisory& lhs,
                                     const bmqp_ctrlmsg::LeaderAdvisory& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         const bmqp_ctrlmsg::LeaderAdvisory& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::OpenQueue& lhs,
                                     const bmqp_ctrlmsg::OpenQueue& rhs)
{
    return lhs.handleParameters() == rhs.handleParameters();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::OpenQueue& lhs,
                                     const bmqp_ctrlmsg::OpenQueue& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                  stream,
                         const bmqp_ctrlmsg::OpenQueue& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PartitionMessageChoice& lhs,
                         const bmqp_ctrlmsg::PartitionMessageChoice& rhs)
{
    typedef bmqp_ctrlmsg::PartitionMessageChoice Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_REPLICA_STATE_REQUEST:
            return lhs.replicaStateRequest() == rhs.replicaStateRequest();
        case Class::SELECTION_ID_REPLICA_STATE_RESPONSE:
            return lhs.replicaStateResponse() == rhs.replicaStateResponse();
        case Class::SELECTION_ID_PRIMARY_STATE_REQUEST:
            return lhs.primaryStateRequest() == rhs.primaryStateRequest();
        case Class::SELECTION_ID_PRIMARY_STATE_RESPONSE:
            return lhs.primaryStateResponse() == rhs.primaryStateResponse();
        case Class::SELECTION_ID_REPLICA_DATA_REQUEST:
            return lhs.replicaDataRequest() == rhs.replicaDataRequest();
        case Class::SELECTION_ID_REPLICA_DATA_RESPONSE:
            return lhs.replicaDataResponse() == rhs.replicaDataResponse();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PartitionMessageChoice& lhs,
                         const bmqp_ctrlmsg::PartitionMessageChoice& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                               stream,
                         const bmqp_ctrlmsg::PartitionMessageChoice& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PartitionSyncDataQuery& lhs,
                         const bmqp_ctrlmsg::PartitionSyncDataQuery& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.lastPrimaryLeaseId() == rhs.lastPrimaryLeaseId() &&
           lhs.lastSequenceNum() == rhs.lastSequenceNum() &&
           lhs.uptoPrimaryLeaseId() == rhs.uptoPrimaryLeaseId() &&
           lhs.uptoSequenceNum() == rhs.uptoSequenceNum() &&
           lhs.lastSyncPointOffsetPair() == rhs.lastSyncPointOffsetPair();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PartitionSyncDataQuery& lhs,
                         const bmqp_ctrlmsg::PartitionSyncDataQuery& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                               stream,
                         const bmqp_ctrlmsg::PartitionSyncDataQuery& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PartitionSyncDataQueryStatus& lhs,
                         const bmqp_ctrlmsg::PartitionSyncDataQueryStatus& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.status() == rhs.status();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PartitionSyncDataQueryStatus& lhs,
                         const bmqp_ctrlmsg::PartitionSyncDataQueryStatus& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream& stream,
                         const bmqp_ctrlmsg::PartitionSyncDataQueryStatus& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(
    const bmqp_ctrlmsg::PartitionSyncStateQueryResponse& lhs,
    const bmqp_ctrlmsg::PartitionSyncStateQueryResponse& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.primaryLeaseId() == rhs.primaryLeaseId() &&
           lhs.sequenceNum() == rhs.sequenceNum() &&
           lhs.lastSyncPointOffsetPair() == rhs.lastSyncPointOffsetPair();
}

inline bool bmqp_ctrlmsg::operator!=(
    const bmqp_ctrlmsg::PartitionSyncStateQueryResponse& lhs,
    const bmqp_ctrlmsg::PartitionSyncStateQueryResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream& bmqp_ctrlmsg::operator<<(
    bsl::ostream&                                        stream,
    const bmqp_ctrlmsg::PartitionSyncStateQueryResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueAssignmentAdvisory& lhs,
                         const bmqp_ctrlmsg::QueueAssignmentAdvisory& rhs)
{
    return lhs.sequenceNumber() == rhs.sequenceNumber() &&
           lhs.queues() == rhs.queues();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueAssignmentAdvisory& lhs,
                         const bmqp_ctrlmsg::QueueAssignmentAdvisory& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                stream,
                         const bmqp_ctrlmsg::QueueAssignmentAdvisory& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueUnAssignmentAdvisory& lhs,
                         const bmqp_ctrlmsg::QueueUnAssignmentAdvisory& rhs)
{
    return lhs.primaryNodeId() == rhs.primaryNodeId() &&
           lhs.primaryLeaseId() == rhs.primaryLeaseId() &&
           lhs.partitionId() == rhs.partitionId() &&
           lhs.queues() == rhs.queues();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueUnAssignmentAdvisory& lhs,
                         const bmqp_ctrlmsg::QueueUnAssignmentAdvisory& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                  stream,
                         const bmqp_ctrlmsg::QueueUnAssignmentAdvisory& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueUnassignedAdvisory& lhs,
                         const bmqp_ctrlmsg::QueueUnassignedAdvisory& rhs)
{
    return lhs.sequenceNumber() == rhs.sequenceNumber() &&
           lhs.partitionId() == rhs.partitionId() &&
           lhs.primaryLeaseId() == rhs.primaryLeaseId() &&
           lhs.primaryNodeId() == rhs.primaryNodeId() &&
           lhs.queues() == rhs.queues();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueUnassignedAdvisory& lhs,
                         const bmqp_ctrlmsg::QueueUnassignedAdvisory& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                stream,
                         const bmqp_ctrlmsg::QueueUnassignedAdvisory& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::QueueUpdateAdvisory& lhs,
                         const bmqp_ctrlmsg::QueueUpdateAdvisory& rhs)
{
    return lhs.sequenceNumber() == rhs.sequenceNumber() &&
           lhs.queueUpdates() == rhs.queueUpdates();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::QueueUpdateAdvisory& lhs,
                         const bmqp_ctrlmsg::QueueUpdateAdvisory& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                            stream,
                         const bmqp_ctrlmsg::QueueUpdateAdvisory& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::StateNotification& lhs,
                         const bmqp_ctrlmsg::StateNotification& rhs)
{
    return lhs.choice() == rhs.choice();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::StateNotification& lhs,
                         const bmqp_ctrlmsg::StateNotification& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                          stream,
                         const bmqp_ctrlmsg::StateNotification& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::StorageSyncRequest& lhs,
                         const bmqp_ctrlmsg::StorageSyncRequest& rhs)
{
    return lhs.partitionId() == rhs.partitionId() &&
           lhs.beginSyncPointOffsetPair() == rhs.beginSyncPointOffsetPair() &&
           lhs.endSyncPointOffsetPair() == rhs.endSyncPointOffsetPair();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::StorageSyncRequest& lhs,
                         const bmqp_ctrlmsg::StorageSyncRequest& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                           stream,
                         const bmqp_ctrlmsg::StorageSyncRequest& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::Subscription& lhs,
                                     const bmqp_ctrlmsg::Subscription& rhs)
{
    return lhs.sId() == rhs.sId() && lhs.expression() == rhs.expression() &&
           lhs.consumers() == rhs.consumers();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::Subscription& lhs,
                                     const bmqp_ctrlmsg::Subscription& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                     stream,
                         const bmqp_ctrlmsg::Subscription& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ConfigureQueueStreamResponse& lhs,
                         const bmqp_ctrlmsg::ConfigureQueueStreamResponse& rhs)
{
    return lhs.request() == rhs.request();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ConfigureQueueStreamResponse& lhs,
                         const bmqp_ctrlmsg::ConfigureQueueStreamResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream& stream,
                         const bmqp_ctrlmsg::ConfigureQueueStreamResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::FollowerClusterStateResponse& lhs,
                         const bmqp_ctrlmsg::FollowerClusterStateResponse& rhs)
{
    return lhs.clusterStateSnapshot() == rhs.clusterStateSnapshot();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::FollowerClusterStateResponse& lhs,
                         const bmqp_ctrlmsg::FollowerClusterStateResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream& stream,
                         const bmqp_ctrlmsg::FollowerClusterStateResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::LeaderSyncDataQueryResponse& lhs,
                         const bmqp_ctrlmsg::LeaderSyncDataQueryResponse& rhs)
{
    return lhs.leaderSyncData() == rhs.leaderSyncData();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::LeaderSyncDataQueryResponse& lhs,
                         const bmqp_ctrlmsg::LeaderSyncDataQueryResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream& stream,
                         const bmqp_ctrlmsg::LeaderSyncDataQueryResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::NegotiationMessage& lhs,
                         const bmqp_ctrlmsg::NegotiationMessage& rhs)
{
    typedef bmqp_ctrlmsg::NegotiationMessage Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_CLIENT_IDENTITY:
            return lhs.clientIdentity() == rhs.clientIdentity();
        case Class::SELECTION_ID_BROKER_RESPONSE:
            return lhs.brokerResponse() == rhs.brokerResponse();
        case Class::SELECTION_ID_REVERSE_CONNECTION_REQUEST:
            return lhs.reverseConnectionRequest() ==
                   rhs.reverseConnectionRequest();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::NegotiationMessage& lhs,
                         const bmqp_ctrlmsg::NegotiationMessage& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                           stream,
                         const bmqp_ctrlmsg::NegotiationMessage& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::OpenQueueResponse& lhs,
                         const bmqp_ctrlmsg::OpenQueueResponse& rhs)
{
    return lhs.originalRequest() == rhs.originalRequest() &&
           lhs.routingConfiguration() == rhs.routingConfiguration() &&
           lhs.deduplicationTimeMs() == rhs.deduplicationTimeMs();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::OpenQueueResponse& lhs,
                         const bmqp_ctrlmsg::OpenQueueResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                          stream,
                         const bmqp_ctrlmsg::OpenQueueResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::PartitionMessage& lhs,
                                     const bmqp_ctrlmsg::PartitionMessage& rhs)
{
    return lhs.choice() == rhs.choice();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::PartitionMessage& lhs,
                                     const bmqp_ctrlmsg::PartitionMessage& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                         stream,
                         const bmqp_ctrlmsg::PartitionMessage& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::StreamParameters& lhs,
                                     const bmqp_ctrlmsg::StreamParameters& rhs)
{
    return lhs.appId() == rhs.appId() &&
           lhs.subscriptions() == rhs.subscriptions();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::StreamParameters& lhs,
                                     const bmqp_ctrlmsg::StreamParameters& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                         stream,
                         const bmqp_ctrlmsg::StreamParameters& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ClusterStateFSMMessageChoice& lhs,
                         const bmqp_ctrlmsg::ClusterStateFSMMessageChoice& rhs)
{
    typedef bmqp_ctrlmsg::ClusterStateFSMMessageChoice Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_FOLLOWER_L_S_N_REQUEST:
            return lhs.followerLSNRequest() == rhs.followerLSNRequest();
        case Class::SELECTION_ID_FOLLOWER_L_S_N_RESPONSE:
            return lhs.followerLSNResponse() == rhs.followerLSNResponse();
        case Class::SELECTION_ID_REGISTRATION_REQUEST:
            return lhs.registrationRequest() == rhs.registrationRequest();
        case Class::SELECTION_ID_REGISTRATION_RESPONSE:
            return lhs.registrationResponse() == rhs.registrationResponse();
        case Class::SELECTION_ID_FOLLOWER_CLUSTER_STATE_REQUEST:
            return lhs.followerClusterStateRequest() ==
                   rhs.followerClusterStateRequest();
        case Class::SELECTION_ID_FOLLOWER_CLUSTER_STATE_RESPONSE:
            return lhs.followerClusterStateResponse() ==
                   rhs.followerClusterStateResponse();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ClusterStateFSMMessageChoice& lhs,
                         const bmqp_ctrlmsg::ClusterStateFSMMessageChoice& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream& stream,
                         const bmqp_ctrlmsg::ClusterStateFSMMessageChoice& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ConfigureStream& lhs,
                                     const bmqp_ctrlmsg::ConfigureStream& rhs)
{
    return lhs.qId() == rhs.qId() &&
           lhs.streamParameters() == rhs.streamParameters();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ConfigureStream& lhs,
                                     const bmqp_ctrlmsg::ConfigureStream& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                        stream,
                         const bmqp_ctrlmsg::ConfigureStream& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ClusterStateFSMMessage& lhs,
                         const bmqp_ctrlmsg::ClusterStateFSMMessage& rhs)
{
    return lhs.choice() == rhs.choice();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ClusterStateFSMMessage& lhs,
                         const bmqp_ctrlmsg::ClusterStateFSMMessage& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                               stream,
                         const bmqp_ctrlmsg::ClusterStateFSMMessage& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ConfigureStreamResponse& lhs,
                         const bmqp_ctrlmsg::ConfigureStreamResponse& rhs)
{
    return lhs.request() == rhs.request();
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ConfigureStreamResponse& lhs,
                         const bmqp_ctrlmsg::ConfigureStreamResponse& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                                stream,
                         const bmqp_ctrlmsg::ConfigureStreamResponse& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ClusterMessageChoice& lhs,
                         const bmqp_ctrlmsg::ClusterMessageChoice& rhs)
{
    typedef bmqp_ctrlmsg::ClusterMessageChoice Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_PARTITION_PRIMARY_ADVISORY:
            return lhs.partitionPrimaryAdvisory() ==
                   rhs.partitionPrimaryAdvisory();
        case Class::SELECTION_ID_LEADER_ADVISORY:
            return lhs.leaderAdvisory() == rhs.leaderAdvisory();
        case Class::SELECTION_ID_QUEUE_ASSIGNMENT_ADVISORY:
            return lhs.queueAssignmentAdvisory() ==
                   rhs.queueAssignmentAdvisory();
        case Class::SELECTION_ID_NODE_STATUS_ADVISORY:
            return lhs.nodeStatusAdvisory() == rhs.nodeStatusAdvisory();
        case Class::SELECTION_ID_LEADER_SYNC_STATE_QUERY:
            return lhs.leaderSyncStateQuery() == rhs.leaderSyncStateQuery();
        case Class::SELECTION_ID_LEADER_SYNC_STATE_QUERY_RESPONSE:
            return lhs.leaderSyncStateQueryResponse() ==
                   rhs.leaderSyncStateQueryResponse();
        case Class::SELECTION_ID_LEADER_SYNC_DATA_QUERY:
            return lhs.leaderSyncDataQuery() == rhs.leaderSyncDataQuery();
        case Class::SELECTION_ID_LEADER_SYNC_DATA_QUERY_RESPONSE:
            return lhs.leaderSyncDataQueryResponse() ==
                   rhs.leaderSyncDataQueryResponse();
        case Class::SELECTION_ID_QUEUE_ASSIGNMENT_REQUEST:
            return lhs.queueAssignmentRequest() ==
                   rhs.queueAssignmentRequest();
        case Class::SELECTION_ID_STORAGE_SYNC_REQUEST:
            return lhs.storageSyncRequest() == rhs.storageSyncRequest();
        case Class::SELECTION_ID_STORAGE_SYNC_RESPONSE:
            return lhs.storageSyncResponse() == rhs.storageSyncResponse();
        case Class::SELECTION_ID_PARTITION_SYNC_STATE_QUERY:
            return lhs.partitionSyncStateQuery() ==
                   rhs.partitionSyncStateQuery();
        case Class::SELECTION_ID_PARTITION_SYNC_STATE_QUERY_RESPONSE:
            return lhs.partitionSyncStateQueryResponse() ==
                   rhs.partitionSyncStateQueryResponse();
        case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY:
            return lhs.partitionSyncDataQuery() ==
                   rhs.partitionSyncDataQuery();
        case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_RESPONSE:
            return lhs.partitionSyncDataQueryResponse() ==
                   rhs.partitionSyncDataQueryResponse();
        case Class::SELECTION_ID_PARTITION_SYNC_DATA_QUERY_STATUS:
            return lhs.partitionSyncDataQueryStatus() ==
                   rhs.partitionSyncDataQueryStatus();
        case Class::SELECTION_ID_PRIMARY_STATUS_ADVISORY:
            return lhs.primaryStatusAdvisory() == rhs.primaryStatusAdvisory();
        case Class::SELECTION_ID_CLUSTER_SYNC_REQUEST:
            return lhs.clusterSyncRequest() == rhs.clusterSyncRequest();
        case Class::SELECTION_ID_CLUSTER_SYNC_RESPONSE:
            return lhs.clusterSyncResponse() == rhs.clusterSyncResponse();
        case Class::SELECTION_ID_QUEUE_UN_ASSIGNMENT_ADVISORY:
            return lhs.queueUnAssignmentAdvisory() ==
                   rhs.queueUnAssignmentAdvisory();
        case Class::SELECTION_ID_QUEUE_UNASSIGNED_ADVISORY:
            return lhs.queueUnassignedAdvisory() ==
                   rhs.queueUnassignedAdvisory();
        case Class::SELECTION_ID_LEADER_ADVISORY_ACK:
            return lhs.leaderAdvisoryAck() == rhs.leaderAdvisoryAck();
        case Class::SELECTION_ID_LEADER_ADVISORY_COMMIT:
            return lhs.leaderAdvisoryCommit() == rhs.leaderAdvisoryCommit();
        case Class::SELECTION_ID_STATE_NOTIFICATION:
            return lhs.stateNotification() == rhs.stateNotification();
        case Class::SELECTION_ID_STOP_REQUEST:
            return lhs.stopRequest() == rhs.stopRequest();
        case Class::SELECTION_ID_STOP_RESPONSE:
            return lhs.stopResponse() == rhs.stopResponse();
        case Class::SELECTION_ID_QUEUE_UNASSIGNMENT_REQUEST:
            return lhs.queueUnassignmentRequest() ==
                   rhs.queueUnassignmentRequest();
        case Class::SELECTION_ID_QUEUE_UPDATE_ADVISORY:
            return lhs.queueUpdateAdvisory() == rhs.queueUpdateAdvisory();
        case Class::SELECTION_ID_CLUSTER_STATE_F_S_M_MESSAGE:
            return lhs.clusterStateFSMMessage() ==
                   rhs.clusterStateFSMMessage();
        case Class::SELECTION_ID_PARTITION_MESSAGE:
            return lhs.partitionMessage() == rhs.partitionMessage();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ClusterMessageChoice& lhs,
                         const bmqp_ctrlmsg::ClusterMessageChoice& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::ClusterMessageChoice& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ClusterMessage& lhs,
                                     const bmqp_ctrlmsg::ClusterMessage& rhs)
{
    return lhs.choice() == rhs.choice();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ClusterMessage& lhs,
                                     const bmqp_ctrlmsg::ClusterMessage& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         const bmqp_ctrlmsg::ClusterMessage& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool
bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ControlMessageChoice& lhs,
                         const bmqp_ctrlmsg::ControlMessageChoice& rhs)
{
    typedef bmqp_ctrlmsg::ControlMessageChoice Class;
    if (lhs.selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_STATUS: return lhs.status() == rhs.status();
        case Class::SELECTION_ID_DISCONNECT:
            return lhs.disconnect() == rhs.disconnect();
        case Class::SELECTION_ID_DISCONNECT_RESPONSE:
            return lhs.disconnectResponse() == rhs.disconnectResponse();
        case Class::SELECTION_ID_ADMIN_COMMAND:
            return lhs.adminCommand() == rhs.adminCommand();
        case Class::SELECTION_ID_ADMIN_COMMAND_RESPONSE:
            return lhs.adminCommandResponse() == rhs.adminCommandResponse();
        case Class::SELECTION_ID_CLUSTER_MESSAGE:
            return lhs.clusterMessage() == rhs.clusterMessage();
        case Class::SELECTION_ID_OPEN_QUEUE:
            return lhs.openQueue() == rhs.openQueue();
        case Class::SELECTION_ID_OPEN_QUEUE_RESPONSE:
            return lhs.openQueueResponse() == rhs.openQueueResponse();
        case Class::SELECTION_ID_CLOSE_QUEUE:
            return lhs.closeQueue() == rhs.closeQueue();
        case Class::SELECTION_ID_CLOSE_QUEUE_RESPONSE:
            return lhs.closeQueueResponse() == rhs.closeQueueResponse();
        case Class::SELECTION_ID_CONFIGURE_QUEUE_STREAM:
            return lhs.configureQueueStream() == rhs.configureQueueStream();
        case Class::SELECTION_ID_CONFIGURE_QUEUE_STREAM_RESPONSE:
            return lhs.configureQueueStreamResponse() ==
                   rhs.configureQueueStreamResponse();
        case Class::SELECTION_ID_CONFIGURE_STREAM:
            return lhs.configureStream() == rhs.configureStream();
        case Class::SELECTION_ID_CONFIGURE_STREAM_RESPONSE:
            return lhs.configureStreamResponse() ==
                   rhs.configureStreamResponse();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

inline bool
bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ControlMessageChoice& lhs,
                         const bmqp_ctrlmsg::ControlMessageChoice& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                             stream,
                         const bmqp_ctrlmsg::ControlMessageChoice& rhs)
{
    return rhs.print(stream, 0, -1);
}

inline bool bmqp_ctrlmsg::operator==(const bmqp_ctrlmsg::ControlMessage& lhs,
                                     const bmqp_ctrlmsg::ControlMessage& rhs)
{
    return lhs.rId() == rhs.rId() && lhs.choice() == rhs.choice();
}

inline bool bmqp_ctrlmsg::operator!=(const bmqp_ctrlmsg::ControlMessage& lhs,
                                     const bmqp_ctrlmsg::ControlMessage& rhs)
{
    return !(lhs == rhs);
}

inline bsl::ostream&
bmqp_ctrlmsg::operator<<(bsl::ostream&                       stream,
                         const bmqp_ctrlmsg::ControlMessage& rhs)
{
    return rhs.print(stream, 0, -1);
}

}  // close enterprise namespace
#endif

// GENERATED BY @BLP_BAS_CODEGEN_VERSION@
// USING bas_codegen.pl -m msg --noAggregateConversion --noExternalization
// --noIdent --package bmqp_ctrlmsg --msgComponent messages bmqp_ctrlmsg.xsd
