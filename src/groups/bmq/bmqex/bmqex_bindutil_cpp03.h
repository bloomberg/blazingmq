// Copyright 2019-2023 Bloomberg Finance L.P.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// bmqex_bindutil_cpp03.h                                             -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BMQEX_BINDUTIL_CPP03
#define INCLUDED_BMQEX_BINDUTIL_CPP03

//@PURPOSE: Provide C++03 implementation for bmqex_bindutil.h
//
//@CLASSES: See bmqex_bindutil.h for list of classes
//
//@SEE_ALSO: bmqex_bindutil
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Thu Oct 17 16:05:31 2024
// Command line: sim_cpp11_features.pl bmqex_bindutil.h

#ifdef COMPILING_BMQEX_BINDUTIL_H

namespace BloombergLP {
namespace bmqex {

// ====================================
// struct BindUtil_DummyNullaryFunction
// ====================================

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bmqex_bindutil.h
#ifndef BMQEX_BINDUTIL_VARIADIC_LIMIT
#define BMQEX_BINDUTIL_VARIADIC_LIMIT 9
#endif
#ifndef BMQEX_BINDUTIL_VARIADIC_LIMIT_A
#define BMQEX_BINDUTIL_VARIADIC_LIMIT_A BMQEX_BINDUTIL_VARIADIC_LIMIT
#endif

template <class FUNCTION
#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 0
          ,
          class ARGS_0 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 0

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 1
          ,
          class ARGS_1 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 1

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 2
          ,
          class ARGS_2 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 2

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 3
          ,
          class ARGS_3 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 3

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 4
          ,
          class ARGS_4 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 4

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 5
          ,
          class ARGS_5 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 5

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 6
          ,
          class ARGS_6 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 6

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 7
          ,
          class ARGS_7 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 7

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 8
          ,
          class ARGS_8 = BSLS_COMPILERFEATURES_NILT
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 8
          ,
          class = BSLS_COMPILERFEATURES_NILT>
struct BindUtil_DummyNullaryFunction;

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 0
template <class FUNCTION>
struct BindUtil_DummyNullaryFunction<FUNCTION> {
    typedef typename bsl::invoke_result<FUNCTION>::type ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 0

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 1
template <class FUNCTION, class ARGS_1>
struct BindUtil_DummyNullaryFunction<FUNCTION, ARGS_1> {
    typedef typename bsl::invoke_result<FUNCTION, ARGS_1>::type ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 1

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 2
template <class FUNCTION, class ARGS_1, class ARGS_2>
struct BindUtil_DummyNullaryFunction<FUNCTION, ARGS_1, ARGS_2> {
    typedef
        typename bsl::invoke_result<FUNCTION, ARGS_1, ARGS_2>::type ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 2

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 3
template <class FUNCTION, class ARGS_1, class ARGS_2, class ARGS_3>
struct BindUtil_DummyNullaryFunction<FUNCTION, ARGS_1, ARGS_2, ARGS_3> {
    typedef typename bsl::invoke_result<FUNCTION, ARGS_1, ARGS_2, ARGS_3>::type
        ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 3

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 4
template <class FUNCTION,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4>
struct BindUtil_DummyNullaryFunction<FUNCTION,
                                     ARGS_1,
                                     ARGS_2,
                                     ARGS_3,
                                     ARGS_4> {
    typedef
        typename bsl::invoke_result<FUNCTION, ARGS_1, ARGS_2, ARGS_3, ARGS_4>::
            type ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 4

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 5
template <class FUNCTION,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5>
struct BindUtil_DummyNullaryFunction<FUNCTION,
                                     ARGS_1,
                                     ARGS_2,
                                     ARGS_3,
                                     ARGS_4,
                                     ARGS_5> {
    typedef typename bsl::
        invoke_result<FUNCTION, ARGS_1, ARGS_2, ARGS_3, ARGS_4, ARGS_5>::type
            ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 5

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 6
template <class FUNCTION,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6>
struct BindUtil_DummyNullaryFunction<FUNCTION,
                                     ARGS_1,
                                     ARGS_2,
                                     ARGS_3,
                                     ARGS_4,
                                     ARGS_5,
                                     ARGS_6> {
    typedef typename bsl::invoke_result<FUNCTION,
                                        ARGS_1,
                                        ARGS_2,
                                        ARGS_3,
                                        ARGS_4,
                                        ARGS_5,
                                        ARGS_6>::type ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 6

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 7
template <class FUNCTION,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6,
          class ARGS_7>
struct BindUtil_DummyNullaryFunction<FUNCTION,
                                     ARGS_1,
                                     ARGS_2,
                                     ARGS_3,
                                     ARGS_4,
                                     ARGS_5,
                                     ARGS_6,
                                     ARGS_7> {
    typedef typename bsl::invoke_result<FUNCTION,
                                        ARGS_1,
                                        ARGS_2,
                                        ARGS_3,
                                        ARGS_4,
                                        ARGS_5,
                                        ARGS_6,
                                        ARGS_7>::type ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 7

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 8
template <class FUNCTION,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6,
          class ARGS_7,
          class ARGS_8>
struct BindUtil_DummyNullaryFunction<FUNCTION,
                                     ARGS_1,
                                     ARGS_2,
                                     ARGS_3,
                                     ARGS_4,
                                     ARGS_5,
                                     ARGS_6,
                                     ARGS_7,
                                     ARGS_8> {
    typedef typename bsl::invoke_result<FUNCTION,
                                        ARGS_1,
                                        ARGS_2,
                                        ARGS_3,
                                        ARGS_4,
                                        ARGS_5,
                                        ARGS_6,
                                        ARGS_7,
                                        ARGS_8>::type ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 8

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 9
template <class FUNCTION,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6,
          class ARGS_7,
          class ARGS_8,
          class ARGS_9>
struct BindUtil_DummyNullaryFunction<FUNCTION,
                                     ARGS_1,
                                     ARGS_2,
                                     ARGS_3,
                                     ARGS_4,
                                     ARGS_5,
                                     ARGS_6,
                                     ARGS_7,
                                     ARGS_8,
                                     ARGS_9> {
    typedef typename bsl::invoke_result<FUNCTION,
                                        ARGS_1,
                                        ARGS_2,
                                        ARGS_3,
                                        ARGS_4,
                                        ARGS_5,
                                        ARGS_6,
                                        ARGS_7,
                                        ARGS_8,
                                        ARGS_9>::type ResultType;

    ResultType operator()() const;
};
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_A >= 9

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.

template <class FUNCTION, class... ARGS>
struct BindUtil_DummyNullaryFunction {
    typedef typename bsl::invoke_result<FUNCTION, ARGS...>::type ResultType;

    ResultType operator()() const;
};

// }}} END GENERATED CODE
#endif

// ==========================
// class BindUtil_BindWrapper
// ==========================

/// Provides a callable bind wrapper containing an execution policy and a
/// function object bound to the invocation of `ExecutionUtil::execute`.
///
/// `POLICY` must be an execution policy type (see `bmqex_executionpolicy`).
///
/// `FUNCTION` must meet the requirements of Destructible as specified in
/// the C++ standard.
template <class POLICY, class FUNCTION>
class BindUtil_BindWrapper {
  private:
    // PRIVATE DATA
    POLICY d_policy;

    bslalg::ConstructorProxy<FUNCTION> d_function;

  public:
    // CREATORS

    /// Create a `BindUtil_BindWrapper` object containing an execution
    /// policy of type `POLICY` direct-non-list-initialized with
    /// `bsl::forward<POLICY_PARAM>(policy)` and a function object of type
    /// `FUNCTION` direct-non-list-initialized with
    /// `bsl::forward<FUNCTION_PARAM>(function)`. Specify an `allocator`
    /// used to supply memory.
    ///
    /// `POLICY` must be constructible from
    /// `bsl::forward<POLICY_PARAM>(policy)`.
    ///
    /// `FUNCTION` must be constructible from
    /// `bsl::forward<FUNCTION_PARAM>(function)`.
    template <class POLICY_PARAM, class FUNCTION_PARAM>
    BindUtil_BindWrapper(BSLS_COMPILERFEATURES_FORWARD_REF(POLICY_PARAM)
                             policy,
                         BSLS_COMPILERFEATURES_FORWARD_REF(FUNCTION_PARAM)
                             function,
                         bslma::Allocator* allocator);

    /// Create a `BindUtil_BindWrapper` object having the same state as the
    /// specified `original` object. Optionally specify an `allocator` used
    /// to supply memory. If `allocator` is 0, the default memory allocator
    /// is used.
    BindUtil_BindWrapper(const BindUtil_BindWrapper& original,
                         bslma::Allocator*           allocator = 0);

    /// Create a `BindUtil_BindWrapper` object having the same state as the
    /// specified `original` object, leaving `original` in an unspecified
    /// state. Optionally specify an `allocator` used to supply memory. If
    /// `allocator` is 0, the default memory allocator is used.
    BindUtil_BindWrapper(bslmf::MovableRef<BindUtil_BindWrapper> original,
                         bslma::Allocator* allocator = 0);

  public:
    // ACCESSORS

    /// Call `ExecutionUtil::execute(p, f)` and return the result of that
    /// operation, where `p` is the contained execution policy and `f` is
    /// the contained function object.
    ///
    /// Given an object `f` of type `FUNCTION`, `f()` shall be a valid
    /// expression.
    typename ExecutionUtil::ExecuteResult<POLICY, FUNCTION>::Type
    operator()() const;

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bmqex_bindutil.h
#ifndef BMQEX_BINDUTIL_VARIADIC_LIMIT
#define BMQEX_BINDUTIL_VARIADIC_LIMIT 8
#endif
#ifndef BMQEX_BINDUTIL_VARIADIC_LIMIT_B
#define BMQEX_BINDUTIL_VARIADIC_LIMIT_B BMQEX_BINDUTIL_VARIADIC_LIMIT
#endif

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 0
    template <class ARG1>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type> >::Type
    operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 0

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 1
    template <class ARG1, class ARGS_1>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 1

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 2
    template <class ARG1, class ARGS_1, class ARGS_2>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 2

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 3
    template <class ARG1, class ARGS_1, class ARGS_2, class ARGS_3>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 3

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 4
    template <class ARG1,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 4

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 5
    template <class ARG1,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type,
                                      typename bsl::decay<ARGS_5>::type> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 5

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 6
    template <class ARG1,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5,
              class ARGS_6>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type,
                                      typename bsl::decay<ARGS_5>::type,
                                      typename bsl::decay<ARGS_6>::type> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 6

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 7
    template <class ARG1,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5,
              class ARGS_6,
              class ARGS_7>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type,
                                      typename bsl::decay<ARGS_5>::type,
                                      typename bsl::decay<ARGS_6>::type,
                                      typename bsl::decay<ARGS_7>::type> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 7

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 8
    template <class ARG1,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5,
              class ARGS_6,
              class ARGS_7,
              class ARGS_8>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type,
                                      typename bsl::decay<ARGS_5>::type,
                                      typename bsl::decay<ARGS_6>::type,
                                      typename bsl::decay<ARGS_7>::type,
                                      typename bsl::decay<ARGS_8>::type> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_8) args_8) const;
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_B >= 8

#else
    // The generated code below is a workaround for the absence of perfect
    // forwarding in some compilers.

    template <class ARG1, class... ARGS>
    typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS>::type...> >::
        Type
        operator()(BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
                   BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args) const;
// }}} END GENERATED CODE
#endif

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(BindUtil_BindWrapper,
                                   bslma::UsesBslmaAllocator)
};

// ===============
// struct BindUtil
// ===============

/// Provides a namespace for utility functions to bind functors to execution
/// functions.
struct BindUtil {
    // CLASS METHODS

    /// Return a callable object of unspecified type containing an execution
    /// policy `p` of type `bsl::decay_t<POLICY>` direct-non-list-
    /// initialized with `bsl::forward<POLICY>(policy)` and a function
    /// object `f` of type `bsl::decay_t<FUNCTION>` direct-non-list-
    /// initialized with `bsl::forward<FUNCTION>(function)`, such that:
    /// * When called with no arguments, performs
    ///:  `ExecutionUtil::execute(p, f)` and returns the result of that
    ///:  operation.
    /// * When called with 1 or more arguments `args...` of type `ARGS...`,
    ///   performs `ExecutionUtil::execute(p, bsl::move(f2))` and return
    ///   the result of that operation, where `f1` is the result of
    ///   `DECAY_COPY(f)` evaluated in the calling thread, `args1...` is
    ///   the result of `DECAY_COPY(args)...` evaluated in the calling
    ///   thread, and `f2` is a function object of unspecified type that,
    ///   when called as `f2()`, performs `return f1(args1...)`.
    ///
    /// `POLICY` must be an execution policy type (see
    /// `bmqex_executionpolicy`).
    ///
    /// `bsl::decay_t<FUNCTION>` must meet the requirements of Destructible
    /// and MoveConstructible as specified in the C++ standard.
    template <class POLICY, class FUNCTION>
    static BindUtil_BindWrapper<typename bsl::decay<POLICY>::type,
                                typename bsl::decay<FUNCTION>::type>
        bindExecute(BSLS_COMPILERFEATURES_FORWARD_REF(POLICY) policy,
                    BSLS_COMPILERFEATURES_FORWARD_REF(FUNCTION) function);
};

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

// --------------------------
// class BindUtil_BindWrapper
// --------------------------

// CREATORS
template <class POLICY, class FUNCTION>
template <class POLICY_PARAM, class FUNCTION_PARAM>
inline BindUtil_BindWrapper<POLICY, FUNCTION>::BindUtil_BindWrapper(
    BSLS_COMPILERFEATURES_FORWARD_REF(POLICY_PARAM) policy,
    BSLS_COMPILERFEATURES_FORWARD_REF(FUNCTION_PARAM) function,
    bslma::Allocator* allocator)
: d_policy(policy)
, d_function(BSLS_COMPILERFEATURES_FORWARD(FUNCTION_PARAM, function),
             allocator)
{
    // NOTHING
}

template <class POLICY, class FUNCTION>
inline BindUtil_BindWrapper<POLICY, FUNCTION>::BindUtil_BindWrapper(
    const BindUtil_BindWrapper& original,
    bslma::Allocator*           allocator)
: d_policy(original.d_policy)
, d_function(original.d_function.object(), allocator)
{
    // NOTHING
}

template <class POLICY, class FUNCTION>
inline BindUtil_BindWrapper<POLICY, FUNCTION>::BindUtil_BindWrapper(
    bslmf::MovableRef<BindUtil_BindWrapper> original,
    bslma::Allocator*                       allocator)
: d_policy(bslmf::MovableRefUtil::move(
      bslmf::MovableRefUtil::access(original).d_policy))
, d_function(bslmf::MovableRefUtil::move(
                 bslmf::MovableRefUtil::access(original).d_function.object()),
             allocator)
{
    // NOTHING
}

// ACCESSORS
template <class POLICY, class FUNCTION>
inline typename ExecutionUtil::ExecuteResult<POLICY, FUNCTION>::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()() const
{
    return ExecutionUtil::execute(d_policy, d_function.object());
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bmqex_bindutil.h
#ifndef BMQEX_BINDUTIL_VARIADIC_LIMIT
#define BMQEX_BINDUTIL_VARIADIC_LIMIT 8
#endif
#ifndef BMQEX_BINDUTIL_VARIADIC_LIMIT_C
#define BMQEX_BINDUTIL_VARIADIC_LIMIT_C BMQEX_BINDUTIL_VARIADIC_LIMIT
#endif
#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 0
template <class POLICY, class FUNCTION>
template <class ARG1>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type> >::Type
        ResultType;

    return ExecutionUtil::execute(
        d_policy,
        bdlf::BindUtil::bindR<ResultType>(d_function.object(),
                                          bslmf::Util::forward<ARG1>(arg1)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 0

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 1
template <class POLICY, class FUNCTION>
template <class ARG1, class ARGS_1>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS_1>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS_1>(args_1)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 1

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 2
template <class POLICY, class FUNCTION>
template <class ARG1, class ARGS_1, class ARGS_2>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS_1>::type,
                                  typename bsl::decay<ARGS_2>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS_1>(args_1),
                                      bslmf::Util::forward<ARGS_2>(args_2)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 2

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 3
template <class POLICY, class FUNCTION>
template <class ARG1, class ARGS_1, class ARGS_2, class ARGS_3>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS_1>::type,
                                  typename bsl::decay<ARGS_2>::type,
                                  typename bsl::decay<ARGS_3>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS_1>(args_1),
                                      bslmf::Util::forward<ARGS_2>(args_2),
                                      bslmf::Util::forward<ARGS_3>(args_3)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 3

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 4
template <class POLICY, class FUNCTION>
template <class ARG1, class ARGS_1, class ARGS_2, class ARGS_3, class ARGS_4>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS_1>::type,
                                  typename bsl::decay<ARGS_2>::type,
                                  typename bsl::decay<ARGS_3>::type,
                                  typename bsl::decay<ARGS_4>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS_1>(args_1),
                                      bslmf::Util::forward<ARGS_2>(args_2),
                                      bslmf::Util::forward<ARGS_3>(args_3),
                                      bslmf::Util::forward<ARGS_4>(args_4)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 4

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 5
template <class POLICY, class FUNCTION>
template <class ARG1,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS_1>::type,
                                  typename bsl::decay<ARGS_2>::type,
                                  typename bsl::decay<ARGS_3>::type,
                                  typename bsl::decay<ARGS_4>::type,
                                  typename bsl::decay<ARGS_5>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type,
                                      typename bsl::decay<ARGS_5>::type> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS_1>(args_1),
                                      bslmf::Util::forward<ARGS_2>(args_2),
                                      bslmf::Util::forward<ARGS_3>(args_3),
                                      bslmf::Util::forward<ARGS_4>(args_4),
                                      bslmf::Util::forward<ARGS_5>(args_5)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 5

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 6
template <class POLICY, class FUNCTION>
template <class ARG1,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS_1>::type,
                                  typename bsl::decay<ARGS_2>::type,
                                  typename bsl::decay<ARGS_3>::type,
                                  typename bsl::decay<ARGS_4>::type,
                                  typename bsl::decay<ARGS_5>::type,
                                  typename bsl::decay<ARGS_6>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type,
                                      typename bsl::decay<ARGS_5>::type,
                                      typename bsl::decay<ARGS_6>::type> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS_1>(args_1),
                                      bslmf::Util::forward<ARGS_2>(args_2),
                                      bslmf::Util::forward<ARGS_3>(args_3),
                                      bslmf::Util::forward<ARGS_4>(args_4),
                                      bslmf::Util::forward<ARGS_5>(args_5),
                                      bslmf::Util::forward<ARGS_6>(args_6)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 6

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 7
template <class POLICY, class FUNCTION>
template <class ARG1,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6,
          class ARGS_7>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS_1>::type,
                                  typename bsl::decay<ARGS_2>::type,
                                  typename bsl::decay<ARGS_3>::type,
                                  typename bsl::decay<ARGS_4>::type,
                                  typename bsl::decay<ARGS_5>::type,
                                  typename bsl::decay<ARGS_6>::type,
                                  typename bsl::decay<ARGS_7>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type,
                                      typename bsl::decay<ARGS_5>::type,
                                      typename bsl::decay<ARGS_6>::type,
                                      typename bsl::decay<ARGS_7>::type> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS_1>(args_1),
                                      bslmf::Util::forward<ARGS_2>(args_2),
                                      bslmf::Util::forward<ARGS_3>(args_3),
                                      bslmf::Util::forward<ARGS_4>(args_4),
                                      bslmf::Util::forward<ARGS_5>(args_5),
                                      bslmf::Util::forward<ARGS_6>(args_6),
                                      bslmf::Util::forward<ARGS_7>(args_7)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 7

#if BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 8
template <class POLICY, class FUNCTION>
template <class ARG1,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6,
          class ARGS_7,
          class ARGS_8>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS_1>::type,
                                  typename bsl::decay<ARGS_2>::type,
                                  typename bsl::decay<ARGS_3>::type,
                                  typename bsl::decay<ARGS_4>::type,
                                  typename bsl::decay<ARGS_5>::type,
                                  typename bsl::decay<ARGS_6>::type,
                                  typename bsl::decay<ARGS_7>::type,
                                  typename bsl::decay<ARGS_8>::type> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_8) args_8) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS_1>::type,
                                      typename bsl::decay<ARGS_2>::type,
                                      typename bsl::decay<ARGS_3>::type,
                                      typename bsl::decay<ARGS_4>::type,
                                      typename bsl::decay<ARGS_5>::type,
                                      typename bsl::decay<ARGS_6>::type,
                                      typename bsl::decay<ARGS_7>::type,
                                      typename bsl::decay<ARGS_8>::type> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS_1>(args_1),
                                      bslmf::Util::forward<ARGS_2>(args_2),
                                      bslmf::Util::forward<ARGS_3>(args_3),
                                      bslmf::Util::forward<ARGS_4>(args_4),
                                      bslmf::Util::forward<ARGS_5>(args_5),
                                      bslmf::Util::forward<ARGS_6>(args_6),
                                      bslmf::Util::forward<ARGS_7>(args_7),
                                      bslmf::Util::forward<ARGS_8>(args_8)));
}
#endif  // BMQEX_BINDUTIL_VARIADIC_LIMIT_C >= 8

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class POLICY, class FUNCTION>
template <class ARG1, class... ARGS>
inline typename ExecutionUtil::ExecuteResult<
    POLICY,
    BindUtil_DummyNullaryFunction<FUNCTION,
                                  typename bsl::decay<ARG1>::type,
                                  typename bsl::decay<ARGS>::type...> >::Type
BindUtil_BindWrapper<POLICY, FUNCTION>::operator()(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARG1) arg1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args) const
{
    typedef typename ExecutionUtil::ExecuteResult<
        POLICY,
        BindUtil_DummyNullaryFunction<FUNCTION,
                                      typename bsl::decay<ARG1>::type,
                                      typename bsl::decay<ARGS>::type...> >::
        Type ResultType;

    return ExecutionUtil::execute(d_policy,
                                  bdlf::BindUtil::bindR<ResultType>(
                                      d_function.object(),
                                      bslmf::Util::forward<ARG1>(arg1),
                                      bslmf::Util::forward<ARGS>(args)...));
}
// }}} END GENERATED CODE
#endif

// ---------------
// struct BindUtil
// ---------------

// CLASS METHODS
template <class POLICY, class FUNCTION>
inline BindUtil_BindWrapper<typename bsl::decay<POLICY>::type,
                            typename bsl::decay<FUNCTION>::type>
BindUtil::bindExecute(BSLS_COMPILERFEATURES_FORWARD_REF(POLICY) policy,
                      BSLS_COMPILERFEATURES_FORWARD_REF(FUNCTION) function)
{
    return BindUtil_BindWrapper<typename bsl::decay<POLICY>::type,
                                typename bsl::decay<FUNCTION>::type>(
        BSLS_COMPILERFEATURES_FORWARD(POLICY, policy),
        BSLS_COMPILERFEATURES_FORWARD(FUNCTION, function),
        bslma::Default::allocator());
}

}  // close package namespace
}  // close enterprise namespace

#else  // if ! defined(DEFINED_BMQEX_BINDUTIL_H)
#error Not valid except when included from bmqex_bindutil.h
#endif  // ! defined(COMPILING_BMQEX_BINDUTIL_H)

#endif  // ! defined(INCLUDED_BMQEX_BINDUTIL_CPP03)

// SCRIPT-SHA: 60926cad35f1091c31a7d8cc9d33acc38edd25e4891f3e1d41fe7c40fd6e02f5
// SOURCE-SHA: 5f2b7427931a119efbbe9a485a7c750fd96f10272c1f3732ffa7af0b1827d1de
