// Copyright 2025 Bloomberg Finance L.P.
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// bmqu_managedcallback_cpp03.h                                       -*-C++-*-

// Automatically generated file.  **DO NOT EDIT**

#ifndef INCLUDED_BMQU_MANAGEDCALLBACK_CPP03
#define INCLUDED_BMQU_MANAGEDCALLBACK_CPP03

//@PURPOSE: Provide C++03 implementation for bmqu_managedcallback.h
//
//@CLASSES: See bmqu_managedcallback.h for list of classes
//
//@SEE_ALSO: bmqu_managedcallback
//
//@DESCRIPTION:  This component is the C++03 translation of a C++11 component,
// generated by the 'sim_cpp11_features.pl' program.  If the original header
// contains any specially delimited regions of C++11 code, then this generated
// file contains the C++03 equivalent, i.e., with variadic templates expanded
// and rvalue-references replaced by 'bslmf::MovableRef' objects.  The header
// code in this file is designed to be '#include'd into the original header
// when compiling with a C++03 compiler.  If there are no specially delimited
// regions of C++11 code, then this header contains no code and is not
// '#include'd in the original header.
//
// Generated on Wed Apr  2 14:54:56 2025
// Command line: sim_cpp11_features.pl bmqu_managedcallback.h

#ifdef COMPILING_BMQU_MANAGEDCALLBACK_H

namespace BloombergLP {
namespace bmqu {

// ===============
// ManagedCallback
// ===============

class ManagedCallback BSLS_KEYWORD_FINAL {
    /// The class useful for in-place construction and passing of functors
    /// between different actors.
  private:
    // DATA
    /// Reusable buffer holding the stored callback.
    bsl::vector<char> d_callbackBuffer;

    /// The flag indicating if `d_callbackBuffer` is empty now.
    bool d_empty;

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(ManagedCallback, bslma::UsesBslmaAllocator)

    // PUBLIC TYPES
    /// Signature of a `void` functor method.
    typedef bsl::function<void(void)> VoidFunctor;

    // ===============
    // CallbackFunctor
    // ===============
    /// The interface for all callback functors passed to ManagedCallback.
    struct CallbackFunctor {
        // CREATORS
        virtual ~CallbackFunctor();

        // ACCESSORS
        virtual void operator()() const = 0;
    };

    // CREATORS
    /// Create a ManagedCallback object using the optionally specified
    /// `allocator`.
    explicit ManagedCallback(bslma::Allocator* allocator = 0);

    /// Destroy this object.
    ~ManagedCallback();

    // MANIPULATORS
    /// Reset the state of this object.  If this object stores a callback,
    /// call a destructor for it and set this object empty.
    void reset();

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bmqu_managedcallback.h
#ifndef BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT
#define BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT 9
#endif
#ifndef BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A
#define BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A                                 \
    BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT
#endif
#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 0
    template <class CALLBACK_TYPE>
    void createInplace();
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 0

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 1
    template <class CALLBACK_TYPE, class ARGS_1>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 1

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 2
    template <class CALLBACK_TYPE, class ARGS_1, class ARGS_2>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 2

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 3
    template <class CALLBACK_TYPE, class ARGS_1, class ARGS_2, class ARGS_3>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 3

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 4
    template <class CALLBACK_TYPE,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 4

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 5
    template <class CALLBACK_TYPE,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 5

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 6
    template <class CALLBACK_TYPE,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5,
              class ARGS_6>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 6

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 7
    template <class CALLBACK_TYPE,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5,
              class ARGS_6,
              class ARGS_7>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 7

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 8
    template <class CALLBACK_TYPE,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5,
              class ARGS_6,
              class ARGS_7,
              class ARGS_8>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_8) args_8);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 8

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 9
    template <class CALLBACK_TYPE,
              class ARGS_1,
              class ARGS_2,
              class ARGS_3,
              class ARGS_4,
              class ARGS_5,
              class ARGS_6,
              class ARGS_7,
              class ARGS_8,
              class ARGS_9>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_8) args_8,
                       BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_9) args_9);
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_A >= 9

#else
    // The generated code below is a workaround for the absence of perfect
    // forwarding in some compilers.
    template <class CALLBACK_TYPE, class... ARGS>
    void createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args);
// }}} END GENERATED CODE
#endif

    /// Store the specified `callback` in this object.
    /// Note: these setters are slow because they performs function copy, going
    ///       against the basic idea of ManagedCallback.  They exist solely for
    ///       the compatibility with other code where this copy is acceptable.
    ///       In performance-critical paths, `createInplace` should always be
    ///       used together with reusable ManagedCallback object(s).
    void set(const VoidFunctor& callback);
    void set(bslmf::MovableRef<VoidFunctor> callback);

    // ACCESSORS
    /// Is this object empty or not.
    bool empty() const;

    /// Call the stored callback.
    /// The object must be `!empty()` before calling `operator()`.
    void operator()() const;

  private:
    // NOT IMPLEMENTED

    /// Copy constructor and assignment operator are removed because we cannot
    /// guarantee that the internal buffer copy is safe.
    /// TODO: use is_trivially_copyable trait to ensure this on a standard
    ///       upgrade.  Alternatively keep copy operators and store the buffer
    ///       under a shared pointer.
    ManagedCallback(const ManagedCallback&) BSLS_KEYWORD_DELETED;
    ManagedCallback& operator=(const ManagedCallback&) BSLS_KEYWORD_DELETED;

    // PRIVATE MANIPULATORS

    /// Book and return the allocated memory to store the specified
    /// `CALLBACK_TYPE` that has to be inherited from `CallbackFunctor`.
    /// Note that it's the user's responsibility to construct a functor object
    /// at the provided address.
    /// The object must be `empty()` before calling `place()`.
    template <class CALLBACK_TYPE>
    char* place();
};

// ============================================================================
//                             INLINE DEFINITIONS
// ============================================================================

// ---------------
// ManagedCallback
// ---------------

inline ManagedCallback::ManagedCallback(bslma::Allocator* allocator)
: d_callbackBuffer(allocator)
, d_empty(true)
{
    // NOTHING
}

inline ManagedCallback::~ManagedCallback()
{
    reset();
}

inline void ManagedCallback::reset()
{
    if (!d_empty) {
        // Not necessary to resize the vector or memset its elements to 0,
        // we just call the virtual destructor, and `d_empty` flag
        // prevents us from calling outdated callback.
        reinterpret_cast<CallbackFunctor*>(d_callbackBuffer.data())
            ->~CallbackFunctor();
        d_empty = true;
    }
}

template <class CALLBACK_TYPE>
inline char* ManagedCallback::place()
{
    // PRECONDITIONS
    BSLS_ASSERT_SAFE(d_empty);

    /// Ensure that CALLBACK_TYPE inherits from CallbackFunctor interface.
#if __cplusplus >= 201103L
    static_assert(
        bslmf::IsAccessibleBaseOf<CallbackFunctor, CALLBACK_TYPE>::value);
#else
    typedef bslmf::IsAccessibleBaseOf<CallbackFunctor, CALLBACK_TYPE> IsBase;
    BSLS_ASSERT_SAFE(IsBase::value);
#endif

    d_callbackBuffer.resize(
        bsls::AlignmentUtil::roundUpToMaximalAlignment(sizeof(CALLBACK_TYPE)));
    d_empty = false;
    return d_callbackBuffer.data();
}

inline bool ManagedCallback::empty() const
{
    return d_empty;
}

inline void ManagedCallback::operator()() const
{
    // PRECONDITIONS
    BSLS_ASSERT_SAFE(!d_empty);

    (*reinterpret_cast<const CallbackFunctor*>(d_callbackBuffer.data()))();
}

#if BSLS_COMPILERFEATURES_SIMULATE_VARIADIC_TEMPLATES
// {{{ BEGIN GENERATED CODE
// Command line: sim_cpp11_features.pl bmqu_managedcallback.h
#ifndef BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT
#define BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT 9
#endif
#ifndef BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B
#define BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B                                 \
    BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT
#endif
#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 0
template <class CALLBACK_TYPE>
inline void ManagedCallback::createInplace()
{
    new (place<CALLBACK_TYPE>()) CALLBACK_TYPE();
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 0

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 1
template <class CALLBACK_TYPE, class ARGS_1>
inline void
ManagedCallback::createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1)
                                   args_1)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 1

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 2
template <class CALLBACK_TYPE, class ARGS_1, class ARGS_2>
inline void ManagedCallback::createInplace(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 2

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 3
template <class CALLBACK_TYPE, class ARGS_1, class ARGS_2, class ARGS_3>
inline void ManagedCallback::createInplace(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 3

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 4
template <class CALLBACK_TYPE,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4>
inline void ManagedCallback::createInplace(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 4

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 5
template <class CALLBACK_TYPE,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5>
inline void ManagedCallback::createInplace(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_5, args_5));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 5

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 6
template <class CALLBACK_TYPE,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6>
inline void ManagedCallback::createInplace(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_5, args_5),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_6, args_6));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 6

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 7
template <class CALLBACK_TYPE,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6,
          class ARGS_7>
inline void ManagedCallback::createInplace(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_5, args_5),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_6, args_6),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_7, args_7));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 7

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 8
template <class CALLBACK_TYPE,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6,
          class ARGS_7,
          class ARGS_8>
inline void ManagedCallback::createInplace(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_8) args_8)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_5, args_5),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_6, args_6),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_7, args_7),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_8, args_8));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 8

#if BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 9
template <class CALLBACK_TYPE,
          class ARGS_1,
          class ARGS_2,
          class ARGS_3,
          class ARGS_4,
          class ARGS_5,
          class ARGS_6,
          class ARGS_7,
          class ARGS_8,
          class ARGS_9>
inline void ManagedCallback::createInplace(
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_1) args_1,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_2) args_2,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_3) args_3,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_4) args_4,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_5) args_5,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_6) args_6,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_7) args_7,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_8) args_8,
    BSLS_COMPILERFEATURES_FORWARD_REF(ARGS_9) args_9)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS_1, args_1),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_2, args_2),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_3, args_3),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_4, args_4),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_5, args_5),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_6, args_6),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_7, args_7),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_8, args_8),
                      BSLS_COMPILERFEATURES_FORWARD(ARGS_9, args_9));
}
#endif  // BMQU_MANAGEDCALLBACK_VARIADIC_LIMIT_B >= 9

#else
// The generated code below is a workaround for the absence of perfect
// forwarding in some compilers.
template <class CALLBACK_TYPE, class... ARGS>
inline void
ManagedCallback::createInplace(BSLS_COMPILERFEATURES_FORWARD_REF(ARGS)... args)
{
    new (place<CALLBACK_TYPE>())
        CALLBACK_TYPE(BSLS_COMPILERFEATURES_FORWARD(ARGS, args)...);
}
// }}} END GENERATED CODE
#endif

}  // close package namespace
}  // close enterprise namespace

#else  // if ! defined(DEFINED_BMQU_MANAGEDCALLBACK_H)
#error Not valid except when included from bmqu_managedcallback.h
#endif  // ! defined(COMPILING_BMQU_MANAGEDCALLBACK_H)

#endif  // ! defined(INCLUDED_BMQU_MANAGEDCALLBACK_CPP03)
