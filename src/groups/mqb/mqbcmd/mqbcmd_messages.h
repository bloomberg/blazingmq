// mqbcmd_messages.h             *DO NOT EDIT*             @generated -*-C++-*-
#ifndef INCLUDED_MQBCMD_MESSAGES
#define INCLUDED_MQBCMD_MESSAGES

//@PURPOSE: Provide value-semantic attribute classes

#include <bslalg_typetraits.h>

#include <bdlat_attributeinfo.h>

#include <bdlat_enumeratorinfo.h>

#include <bdlat_selectioninfo.h>

#include <bdlat_typetraits.h>

#include <bslh_hash.h>
#include <bsls_objectbuffer.h>

#include <bslma_default.h>

#include <bsls_assert.h>

#include <bdlb_nullableallocatedvalue.h>

#include <bdlb_nullablevalue.h>

#include <bdlt_datetimetz.h>

#include <bdlt_datetz.h>

#include <bdlt_timetz.h>

#include <bsl_string.h>

#include <bsl_vector.h>

#include <bsls_types.h>

#include <bsl_iosfwd.h>
#include <bsl_limits.h>

#include <bsl_ostream.h>
#include <bsl_string.h>

namespace BloombergLP {

namespace bslma {
class Allocator;
}

namespace mqbcmd {
class AddReverseProxy;
}
namespace mqbcmd {
class BrokerConfig;
}
namespace mqbcmd {
class CapacityMeter;
}
namespace mqbcmd {
class ClientMsgGroupsCount;
}
namespace mqbcmd {
class ClusterDomain;
}
namespace mqbcmd {
class ClusterNode;
}
namespace mqbcmd {
class CommandSpec;
}
namespace mqbcmd {
class ConsumerInfo;
}
namespace mqbcmd {
class Context;
}
namespace mqbcmd {
class DomainReconfigure;
}
namespace mqbcmd {
class Error;
}
namespace mqbcmd {
class FileInfo;
}
namespace mqbcmd {
class FileSet;
}
namespace mqbcmd {
class HelpCommand;
}
namespace mqbcmd {
class LeaderMessageSequence;
}
namespace mqbcmd {
class LeastRecentlyUsedGroupId;
}
namespace mqbcmd {
class ListMessages;
}
namespace mqbcmd {
class Message;
}
namespace mqbcmd {
class PurgedQueueDetails;
}
namespace mqbcmd {
class RelayQueueEngineSubStream;
}
namespace mqbcmd {
class RemoteStreamInfo;
}
namespace mqbcmd {
class RouteResponse;
}
namespace mqbcmd {
class StorageQueueCommand;
}
namespace mqbcmd {
class StorageQueueInfo;
}
namespace mqbcmd {
class SubId;
}
namespace mqbcmd {
class Subscriber;
}
namespace mqbcmd {
class UninitializedQueue;
}
namespace mqbcmd {
class VirtualStorage;
}
namespace mqbcmd {
class Void;
}
namespace mqbcmd {
class ActiveFileSet;
}
namespace mqbcmd {
class BrokerConfigCommand;
}
namespace mqbcmd {
class ClearCache;
}
namespace mqbcmd {
class ClusterInfo;
}
namespace mqbcmd {
class ClusterNodeInfo;
}
namespace mqbcmd {
class ClusterQueue;
}
namespace mqbcmd {
class DangerCommand;
}
namespace mqbcmd {
class ElectorInfo;
}
namespace mqbcmd {
class GetTunableChoice;
}
namespace mqbcmd {
class Help;
}
namespace mqbcmd {
class MessageGroupIdManagerIndex;
}
namespace mqbcmd {
class PartitionInfo;
}
namespace mqbcmd {
class PurgeQueueResult;
}
namespace mqbcmd {
class QueueCommand;
}
namespace mqbcmd {
class QueueContents;
}
namespace mqbcmd {
class QueueStorage;
}
namespace mqbcmd {
class ResourceUsageMonitor;
}
namespace mqbcmd {
class RouteResponseList;
}
namespace mqbcmd {
class SetTunableChoice;
}
namespace mqbcmd {
class StorageContent;
}
namespace mqbcmd {
class StorageDomainCommand;
}
namespace mqbcmd {
class StoragePartitionCommand;
}
namespace mqbcmd {
class StorageQueue;
}
namespace mqbcmd {
class Subscription;
}
namespace mqbcmd {
class Value;
}
namespace mqbcmd {
class ClusterList;
}
namespace mqbcmd {
class ClusterQueueHelper;
}
namespace mqbcmd {
class ConfigProviderCommand;
}
namespace mqbcmd {
class DomainInfo;
}
namespace mqbcmd {
class DomainQueue;
}
namespace mqbcmd {
class DomainResolverCommand;
}
namespace mqbcmd {
class FileStoreSummary;
}
namespace mqbcmd {
class GetTunable;
}
namespace mqbcmd {
class MessageGroupIdHelper;
}
namespace mqbcmd {
class NodeStatuses;
}
namespace mqbcmd {
class PartitionsInfo;
}
namespace mqbcmd {
class PriorityGroup;
}
namespace mqbcmd {
class PurgedQueues;
}
namespace mqbcmd {
class QueueHandleSubStream;
}
namespace mqbcmd {
class QueueStatuses;
}
namespace mqbcmd {
class SetTunable;
}
namespace mqbcmd {
class StorageDomain;
}
namespace mqbcmd {
class StoragePartition;
}
namespace mqbcmd {
class Tunable;
}
namespace mqbcmd {
class TunableConfirmation;
}
namespace mqbcmd {
class ClusterDomainQueueStatuses;
}
namespace mqbcmd {
class ClusterProxyStatus;
}
namespace mqbcmd {
class DomainCommand;
}
namespace mqbcmd {
class ElectorCommand;
}
namespace mqbcmd {
class FileStore;
}
namespace mqbcmd {
class QueueHandle;
}
namespace mqbcmd {
class ReplicationCommand;
}
namespace mqbcmd {
class StatCommand;
}
namespace mqbcmd {
class SubscriptionGroup;
}
namespace mqbcmd {
class Tunables;
}
namespace mqbcmd {
class ClusterStateCommand;
}
namespace mqbcmd {
class ClusterStorageSummary;
}
namespace mqbcmd {
class Domain;
}
namespace mqbcmd {
class ElectorResult;
}
namespace mqbcmd {
class QueueState;
}
namespace mqbcmd {
class ReplicationResult;
}
namespace mqbcmd {
class RouterConsumer;
}
namespace mqbcmd {
class Routing;
}
namespace mqbcmd {
class StatResult;
}
namespace mqbcmd {
class StorageCommand;
}
namespace mqbcmd {
class ClusterCommand;
}
namespace mqbcmd {
class ClusterStatus;
}
namespace mqbcmd {
class DomainsCommand;
}
namespace mqbcmd {
class RoundRobinRouter;
}
namespace mqbcmd {
class StorageResult;
}
namespace mqbcmd {
class AppState;
}
namespace mqbcmd {
class Cluster;
}
namespace mqbcmd {
class ClusterResult;
}
namespace mqbcmd {
class ClustersCommand;
}
namespace mqbcmd {
class ClustersResult;
}
namespace mqbcmd {
class ConsumerState;
}
namespace mqbcmd {
class RelayQueueEngine;
}
namespace mqbcmd {
class CommandChoice;
}
namespace mqbcmd {
class FanoutQueueEngine;
}
namespace mqbcmd {
class Command;
}
namespace mqbcmd {
class QueueEngine;
}
namespace mqbcmd {
class LocalQueue;
}
namespace mqbcmd {
class RemoteQueue;
}
namespace mqbcmd {
class Queue;
}
namespace mqbcmd {
class QueueInternals;
}
namespace mqbcmd {
class QueueResult;
}
namespace mqbcmd {
class Result;
}
namespace mqbcmd {
class DomainResult;
}
namespace mqbcmd {
class RouteResponseResult;
}
namespace mqbcmd {
class DomainsResult;
}
namespace mqbcmd {
class RouteResponseResultList;
}
namespace mqbcmd {
class InternalResult;
}
namespace mqbcmd {

// =====================
// class AddReverseProxy
// =====================

class AddReverseProxy {
    // INSTANCE DATA
    bsl::string d_clusterName;
    bsl::string d_remotePeer;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CLUSTER_NAME = 0, ATTRIBUTE_ID_REMOTE_PEER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_CLUSTER_NAME = 0, ATTRIBUTE_INDEX_REMOTE_PEER = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit AddReverseProxy(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'AddReverseProxy' having the default value.
    //  Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    AddReverseProxy(const AddReverseProxy& original,
                    bslma::Allocator*      basicAllocator = 0);
    // Create an object of type 'AddReverseProxy' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AddReverseProxy(AddReverseProxy&& original) noexcept;
    // Create an object of type 'AddReverseProxy' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    AddReverseProxy(AddReverseProxy&& original,
                    bslma::Allocator* basicAllocator);
    // Create an object of type 'AddReverseProxy' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~AddReverseProxy();
    // Destroy this object.

    // MANIPULATORS
    AddReverseProxy& operator=(const AddReverseProxy& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AddReverseProxy& operator=(AddReverseProxy&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clusterName();
    // Return a reference to the modifiable "ClusterName" attribute of this
    // object.

    bsl::string& remotePeer();
    // Return a reference to the modifiable "RemotePeer" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clusterName() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterName" attribute of this object.

    const bsl::string& remotePeer() const;
    // Return a reference offering non-modifiable access to the
    // "RemotePeer" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const AddReverseProxy& lhs,
                           const AddReverseProxy& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clusterName() == rhs.clusterName() &&
               lhs.remotePeer() == rhs.remotePeer();
    }

    friend bool operator!=(const AddReverseProxy& lhs,
                           const AddReverseProxy& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&          stream,
                                    const AddReverseProxy& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&      hashAlg,
                           const AddReverseProxy& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'AddReverseProxy'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.clusterName());
        hashAppend(hashAlg, object.remotePeer());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::AddReverseProxy)

namespace mqbcmd {

// ==================
// class BrokerConfig
// ==================

class BrokerConfig {
    // INSTANCE DATA
    bsl::string d_asJSON;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_AS_J_S_O_N = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_AS_J_S_O_N = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit BrokerConfig(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'BrokerConfig' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    BrokerConfig(const BrokerConfig& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'BrokerConfig' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerConfig(BrokerConfig&& original) noexcept;
    // Create an object of type 'BrokerConfig' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    BrokerConfig(BrokerConfig&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'BrokerConfig' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~BrokerConfig();
    // Destroy this object.

    // MANIPULATORS
    BrokerConfig& operator=(const BrokerConfig& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerConfig& operator=(BrokerConfig&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& asJSON();
    // Return a reference to the modifiable "AsJSON" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& asJSON() const;
    // Return a reference offering non-modifiable access to the "AsJSON"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const BrokerConfig& lhs, const BrokerConfig& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.asJSON() == rhs.asJSON();
    }

    friend bool operator!=(const BrokerConfig& lhs, const BrokerConfig& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const BrokerConfig& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const BrokerConfig& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'BrokerConfig'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.asJSON());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::BrokerConfig)

namespace mqbcmd {

// ===================
// class CapacityMeter
// ===================

class CapacityMeter {
    // INSTANCE DATA
    bsls::Types::Int64                          d_numMessages;
    bsls::Types::Int64                          d_messageCapacity;
    bsls::Types::Int64                          d_numMessagesReserved;
    bsls::Types::Int64                          d_numBytes;
    bsls::Types::Int64                          d_byteCapacity;
    bsls::Types::Int64                          d_numBytesReserved;
    bsl::string                                 d_name;
    bdlb::NullableAllocatedValue<CapacityMeter> d_parent;
    bool                                        d_isDisabled;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const CapacityMeter& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NAME                  = 0,
        ATTRIBUTE_ID_IS_DISABLED           = 1,
        ATTRIBUTE_ID_NUM_MESSAGES          = 2,
        ATTRIBUTE_ID_MESSAGE_CAPACITY      = 3,
        ATTRIBUTE_ID_NUM_MESSAGES_RESERVED = 4,
        ATTRIBUTE_ID_NUM_BYTES             = 5,
        ATTRIBUTE_ID_BYTE_CAPACITY         = 6,
        ATTRIBUTE_ID_NUM_BYTES_RESERVED    = 7,
        ATTRIBUTE_ID_PARENT                = 8
    };

    enum { NUM_ATTRIBUTES = 9 };

    enum {
        ATTRIBUTE_INDEX_NAME                  = 0,
        ATTRIBUTE_INDEX_IS_DISABLED           = 1,
        ATTRIBUTE_INDEX_NUM_MESSAGES          = 2,
        ATTRIBUTE_INDEX_MESSAGE_CAPACITY      = 3,
        ATTRIBUTE_INDEX_NUM_MESSAGES_RESERVED = 4,
        ATTRIBUTE_INDEX_NUM_BYTES             = 5,
        ATTRIBUTE_INDEX_BYTE_CAPACITY         = 6,
        ATTRIBUTE_INDEX_NUM_BYTES_RESERVED    = 7,
        ATTRIBUTE_INDEX_PARENT                = 8
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit CapacityMeter(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'CapacityMeter' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    CapacityMeter(const CapacityMeter& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'CapacityMeter' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CapacityMeter(CapacityMeter&& original) noexcept;
    // Create an object of type 'CapacityMeter' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    CapacityMeter(CapacityMeter&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'CapacityMeter' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~CapacityMeter();
    // Destroy this object.

    // MANIPULATORS
    CapacityMeter& operator=(const CapacityMeter& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CapacityMeter& operator=(CapacityMeter&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    bool& isDisabled();
    // Return a reference to the modifiable "IsDisabled" attribute of this
    // object.

    bsls::Types::Int64& numMessages();
    // Return a reference to the modifiable "NumMessages" attribute of this
    // object.

    bsls::Types::Int64& messageCapacity();
    // Return a reference to the modifiable "MessageCapacity" attribute of
    // this object.

    bsls::Types::Int64& numMessagesReserved();
    // Return a reference to the modifiable "NumMessagesReserved" attribute
    // of this object.

    bsls::Types::Int64& numBytes();
    // Return a reference to the modifiable "NumBytes" attribute of this
    // object.

    bsls::Types::Int64& byteCapacity();
    // Return a reference to the modifiable "ByteCapacity" attribute of
    // this object.

    bsls::Types::Int64& numBytesReserved();
    // Return a reference to the modifiable "NumBytesReserved" attribute of
    // this object.

    bdlb::NullableAllocatedValue<CapacityMeter>& parent();
    // Return a reference to the modifiable "Parent" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    bool isDisabled() const;
    // Return the value of the "IsDisabled" attribute of this object.

    bsls::Types::Int64 numMessages() const;
    // Return the value of the "NumMessages" attribute of this object.

    bsls::Types::Int64 messageCapacity() const;
    // Return the value of the "MessageCapacity" attribute of this object.

    bsls::Types::Int64 numMessagesReserved() const;
    // Return the value of the "NumMessagesReserved" attribute of this
    // object.

    bsls::Types::Int64 numBytes() const;
    // Return the value of the "NumBytes" attribute of this object.

    bsls::Types::Int64 byteCapacity() const;
    // Return the value of the "ByteCapacity" attribute of this object.

    bsls::Types::Int64 numBytesReserved() const;
    // Return the value of the "NumBytesReserved" attribute of this object.

    const bdlb::NullableAllocatedValue<CapacityMeter>& parent() const;
    // Return a reference offering non-modifiable access to the "Parent"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const CapacityMeter& lhs, const CapacityMeter& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const CapacityMeter& lhs, const CapacityMeter& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const CapacityMeter& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const CapacityMeter& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'CapacityMeter'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::CapacityMeter)

namespace mqbcmd {

// ==========================
// class ClientMsgGroupsCount
// ==========================

class ClientMsgGroupsCount {
    // INSTANCE DATA
    bsl::string  d_clientDescription;
    unsigned int d_numMsgGroupIds;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CLIENT_DESCRIPTION = 0,
        ATTRIBUTE_ID_NUM_MSG_GROUP_IDS  = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_CLIENT_DESCRIPTION = 0,
        ATTRIBUTE_INDEX_NUM_MSG_GROUP_IDS  = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClientMsgGroupsCount(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClientMsgGroupsCount' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ClientMsgGroupsCount(const ClientMsgGroupsCount& original,
                         bslma::Allocator*           basicAllocator = 0);
    // Create an object of type 'ClientMsgGroupsCount' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClientMsgGroupsCount(ClientMsgGroupsCount&& original) noexcept;
    // Create an object of type 'ClientMsgGroupsCount' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClientMsgGroupsCount(ClientMsgGroupsCount&& original,
                         bslma::Allocator*      basicAllocator);
    // Create an object of type 'ClientMsgGroupsCount' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClientMsgGroupsCount();
    // Destroy this object.

    // MANIPULATORS
    ClientMsgGroupsCount& operator=(const ClientMsgGroupsCount& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClientMsgGroupsCount& operator=(ClientMsgGroupsCount&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clientDescription();
    // Return a reference to the modifiable "ClientDescription" attribute
    // of this object.

    unsigned int& numMsgGroupIds();
    // Return a reference to the modifiable "NumMsgGroupIds" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clientDescription() const;
    // Return a reference offering non-modifiable access to the
    // "ClientDescription" attribute of this object.

    unsigned int numMsgGroupIds() const;
    // Return the value of the "NumMsgGroupIds" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClientMsgGroupsCount& lhs,
                           const ClientMsgGroupsCount& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clientDescription() == rhs.clientDescription() &&
               lhs.numMsgGroupIds() == rhs.numMsgGroupIds();
    }

    friend bool operator!=(const ClientMsgGroupsCount& lhs,
                           const ClientMsgGroupsCount& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const ClientMsgGroupsCount& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const ClientMsgGroupsCount& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClientMsgGroupsCount'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.clientDescription());
        hashAppend(hashAlg, object.numMsgGroupIds());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClientMsgGroupsCount)

namespace mqbcmd {

// ===================
// class ClusterDomain
// ===================

class ClusterDomain {
    // INSTANCE DATA
    bsl::string  d_name;
    unsigned int d_numAssignedQueues;
    bool         d_loaded;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NAME                = 0,
        ATTRIBUTE_ID_NUM_ASSIGNED_QUEUES = 1,
        ATTRIBUTE_ID_LOADED              = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_NAME                = 0,
        ATTRIBUTE_INDEX_NUM_ASSIGNED_QUEUES = 1,
        ATTRIBUTE_INDEX_LOADED              = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterDomain(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterDomain' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterDomain(const ClusterDomain& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'ClusterDomain' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterDomain(ClusterDomain&& original) noexcept;
    // Create an object of type 'ClusterDomain' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterDomain(ClusterDomain&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterDomain' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterDomain();
    // Destroy this object.

    // MANIPULATORS
    ClusterDomain& operator=(const ClusterDomain& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterDomain& operator=(ClusterDomain&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    unsigned int& numAssignedQueues();
    // Return a reference to the modifiable "NumAssignedQueues" attribute
    // of this object.

    bool& loaded();
    // Return a reference to the modifiable "Loaded" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    unsigned int numAssignedQueues() const;
    // Return the value of the "NumAssignedQueues" attribute of this
    // object.

    bool loaded() const;
    // Return the value of the "Loaded" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterDomain& lhs, const ClusterDomain& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() &&
               lhs.numAssignedQueues() == rhs.numAssignedQueues() &&
               lhs.loaded() == rhs.loaded();
    }

    friend bool operator!=(const ClusterDomain& lhs, const ClusterDomain& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const ClusterDomain& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const ClusterDomain& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterDomain'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClusterDomain)

namespace mqbcmd {

// =================
// class ClusterNode
// =================

class ClusterNode {
    // INSTANCE DATA
    bsl::string d_hostName;
    bsl::string d_dataCenter;
    int         d_nodeId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_HOST_NAME   = 0,
        ATTRIBUTE_ID_NODE_ID     = 1,
        ATTRIBUTE_ID_DATA_CENTER = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_HOST_NAME   = 0,
        ATTRIBUTE_INDEX_NODE_ID     = 1,
        ATTRIBUTE_INDEX_DATA_CENTER = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterNode(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterNode' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterNode(const ClusterNode& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'ClusterNode' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterNode(ClusterNode&& original) noexcept;
    // Create an object of type 'ClusterNode' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterNode(ClusterNode&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterNode' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterNode();
    // Destroy this object.

    // MANIPULATORS
    ClusterNode& operator=(const ClusterNode& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterNode& operator=(ClusterNode&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& hostName();
    // Return a reference to the modifiable "HostName" attribute of this
    // object.

    int& nodeId();
    // Return a reference to the modifiable "NodeId" attribute of this
    // object.

    bsl::string& dataCenter();
    // Return a reference to the modifiable "DataCenter" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& hostName() const;
    // Return a reference offering non-modifiable access to the "HostName"
    // attribute of this object.

    int nodeId() const;
    // Return the value of the "NodeId" attribute of this object.

    const bsl::string& dataCenter() const;
    // Return a reference offering non-modifiable access to the
    // "DataCenter" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterNode& lhs, const ClusterNode& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.hostName() == rhs.hostName() &&
               lhs.nodeId() == rhs.nodeId() &&
               lhs.dataCenter() == rhs.dataCenter();
    }

    friend bool operator!=(const ClusterNode& lhs, const ClusterNode& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const ClusterNode& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const ClusterNode& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'ClusterNode'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ClusterNode)

namespace mqbcmd {

// =================
// class CommandSpec
// =================

class CommandSpec {
    // INSTANCE DATA
    bsl::string d_command;
    bsl::string d_description;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_COMMAND = 0, ATTRIBUTE_ID_DESCRIPTION = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_COMMAND = 0, ATTRIBUTE_INDEX_DESCRIPTION = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit CommandSpec(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'CommandSpec' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    CommandSpec(const CommandSpec& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'CommandSpec' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CommandSpec(CommandSpec&& original) noexcept;
    // Create an object of type 'CommandSpec' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    CommandSpec(CommandSpec&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'CommandSpec' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~CommandSpec();
    // Destroy this object.

    // MANIPULATORS
    CommandSpec& operator=(const CommandSpec& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CommandSpec& operator=(CommandSpec&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& command();
    // Return a reference to the modifiable "Command" attribute of this
    // object.

    bsl::string& description();
    // Return a reference to the modifiable "Description" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& command() const;
    // Return a reference offering non-modifiable access to the "Command"
    // attribute of this object.

    const bsl::string& description() const;
    // Return a reference offering non-modifiable access to the
    // "Description" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const CommandSpec& lhs, const CommandSpec& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.command() == rhs.command() &&
               lhs.description() == rhs.description();
    }

    friend bool operator!=(const CommandSpec& lhs, const CommandSpec& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const CommandSpec& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const CommandSpec& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'CommandSpec'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.command());
        hashAppend(hashAlg, object.description());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::CommandSpec)

namespace mqbcmd {

// ==================
// class ConsumerInfo
// ==================

class ConsumerInfo {
    // INSTANCE DATA
    bsls::Types::Int64 d_maxUnconfirmedMessages;
    bsls::Types::Int64 d_maxUnconfirmedBytes;
    int                d_consumerPriority;
    int                d_consumerPriorityCount;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ConsumerInfo& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES = 0,
        ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES    = 1,
        ATTRIBUTE_ID_CONSUMER_PRIORITY        = 2,
        ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT  = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES = 0,
        ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES    = 1,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY        = 2,
        ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT  = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ConsumerInfo();
    // Create an object of type 'ConsumerInfo' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Int64& maxUnconfirmedMessages();
    // Return a reference to the modifiable "MaxUnconfirmedMessages"
    // attribute of this object.

    bsls::Types::Int64& maxUnconfirmedBytes();
    // Return a reference to the modifiable "MaxUnconfirmedBytes" attribute
    // of this object.

    int& consumerPriority();
    // Return a reference to the modifiable "ConsumerPriority" attribute of
    // this object.

    int& consumerPriorityCount();
    // Return a reference to the modifiable "ConsumerPriorityCount"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Int64 maxUnconfirmedMessages() const;
    // Return the value of the "MaxUnconfirmedMessages" attribute of this
    // object.

    bsls::Types::Int64 maxUnconfirmedBytes() const;
    // Return the value of the "MaxUnconfirmedBytes" attribute of this
    // object.

    int consumerPriority() const;
    // Return the value of the "ConsumerPriority" attribute of this object.

    int consumerPriorityCount() const;
    // Return the value of the "ConsumerPriorityCount" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const ConsumerInfo& lhs, const ConsumerInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ConsumerInfo& lhs, const ConsumerInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const ConsumerInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const ConsumerInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ConsumerInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::ConsumerInfo)

namespace mqbcmd {

// ====================
// class ConsumerStatus
// ====================

struct ConsumerStatus {
  public:
    // TYPES
    enum Value { ALIVE = 0, REGISTERED = 1, UNAUTHORIZED = 2 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return ConsumerStatus::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::ConsumerStatus)

namespace mqbcmd {

// =============
// class Context
// =============

class Context {
    // INSTANCE DATA
    bsl::string d_queueHandleParametersJson;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_QUEUE_HANDLE_PARAMETERS_JSON = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_QUEUE_HANDLE_PARAMETERS_JSON = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Context(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Context' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Context(const Context& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Context' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Context(Context&& original) noexcept;
    // Create an object of type 'Context' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Context(Context&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Context' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Context();
    // Destroy this object.

    // MANIPULATORS
    Context& operator=(const Context& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Context& operator=(Context&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& queueHandleParametersJson();
    // Return a reference to the modifiable "QueueHandleParametersJson"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& queueHandleParametersJson() const;
    // Return a reference offering non-modifiable access to the
    // "QueueHandleParametersJson" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Context& lhs, const Context& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.queueHandleParametersJson() ==
               rhs.queueHandleParametersJson();
    }

    friend bool operator!=(const Context& lhs, const Context& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Context& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Context& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Context'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.queueHandleParametersJson());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Context)

namespace mqbcmd {

// =======================
// class DomainReconfigure
// =======================

class DomainReconfigure {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<bsl::string> d_domain;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const DomainReconfigure& rhs) const;

  public:
    // TYPES

    enum { SELECTION_ID_UNDEFINED = -1, SELECTION_ID_DOMAIN = 0 };

    enum { NUM_SELECTIONS = 1 };

    enum { SELECTION_INDEX_DOMAIN = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit DomainReconfigure(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainReconfigure' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    DomainReconfigure(const DomainReconfigure& original,
                      bslma::Allocator*        basicAllocator = 0);
    // Create an object of type 'DomainReconfigure' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainReconfigure(DomainReconfigure&& original) noexcept;
    // Create an object of type 'DomainReconfigure' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    DomainReconfigure(DomainReconfigure&& original,
                      bslma::Allocator*   basicAllocator);
    // Create an object of type 'DomainReconfigure' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~DomainReconfigure();
    // Destroy this object.

    // MANIPULATORS
    DomainReconfigure& operator=(const DomainReconfigure& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainReconfigure& operator=(DomainReconfigure&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    bsl::string& makeDomain();
    bsl::string& makeDomain(const bsl::string& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bsl::string& makeDomain(bsl::string&& value);
#endif
    // Set the value of this object to be a "Domain" value.  Optionally
    // specify the 'value' of the "Domain".  If 'value' is not specified,
    // the default "Domain" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    bsl::string& domain();
    // Return a reference to the modifiable "Domain" selection of this
    // object if "Domain" is the current selection.  The behavior is
    // undefined unless "Domain" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const bsl::string& domain() const;
    // Return a reference to the non-modifiable "Domain" selection of this
    // object if "Domain" is the current selection.  The behavior is
    // undefined unless "Domain" is the selection of this object.

    bool isDomainValue() const;
    // Return 'true' if the value of this object is a "Domain" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DomainReconfigure& lhs,
                           const DomainReconfigure& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'DomainReconfigure' objects have
    // the same value if either the selections in both objects have the
    // same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const DomainReconfigure& lhs,
                           const DomainReconfigure& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const DomainReconfigure& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const DomainReconfigure& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DomainReconfigure'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::DomainReconfigure)

namespace mqbcmd {

// ==================
// class ElectorState
// ==================

struct ElectorState {
  public:
    // TYPES
    enum Value { DORMANT = 0, FOLLOWER = 1, CANDIDATE = 2, LEADER = 3 };

    enum { NUM_ENUMERATORS = 4 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return ElectorState::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::ElectorState)

namespace mqbcmd {

// ====================
// class EncodingFormat
// ====================

struct EncodingFormat {
    // Enumeration of the various encoding format versions.

  public:
    // TYPES
    enum Value { TEXT = 0, JSON_COMPACT = 1, JSON_PRETTY = 2 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return EncodingFormat::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::EncodingFormat)

namespace mqbcmd {

// ===========
// class Error
// ===========

class Error {
    // INSTANCE DATA
    bsl::string d_message;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_MESSAGE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_MESSAGE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Error(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Error' having the default value.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Error(const Error& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Error' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error(Error&& original) noexcept;
    // Create an object of type 'Error' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Error(Error&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Error' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Error();
    // Destroy this object.

    // MANIPULATORS
    Error& operator=(const Error& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& operator=(Error&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& message();
    // Return a reference to the modifiable "Message" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& message() const;
    // Return a reference offering non-modifiable access to the "Message"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Error& lhs, const Error& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.message() == rhs.message();
    }

    friend bool operator!=(const Error& lhs, const Error& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Error& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Error& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Error'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.message());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Error)

namespace mqbcmd {

// ==============
// class FileInfo
// ==============

class FileInfo {
    // INSTANCE DATA
    bsls::Types::Uint64 d_positionBytes;
    bsls::Types::Uint64 d_sizeBytes;
    bsls::Types::Uint64 d_outstandingBytes;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_POSITION_BYTES    = 0,
        ATTRIBUTE_ID_SIZE_BYTES        = 1,
        ATTRIBUTE_ID_OUTSTANDING_BYTES = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_POSITION_BYTES    = 0,
        ATTRIBUTE_INDEX_SIZE_BYTES        = 1,
        ATTRIBUTE_INDEX_OUTSTANDING_BYTES = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    FileInfo();
    // Create an object of type 'FileInfo' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Uint64& positionBytes();
    // Return a reference to the modifiable "PositionBytes" attribute of
    // this object.

    bsls::Types::Uint64& sizeBytes();
    // Return a reference to the modifiable "SizeBytes" attribute of this
    // object.

    bsls::Types::Uint64& outstandingBytes();
    // Return a reference to the modifiable "OutstandingBytes" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Uint64 positionBytes() const;
    // Return the value of the "PositionBytes" attribute of this object.

    bsls::Types::Uint64 sizeBytes() const;
    // Return the value of the "SizeBytes" attribute of this object.

    bsls::Types::Uint64 outstandingBytes() const;
    // Return the value of the "OutstandingBytes" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const FileInfo& lhs, const FileInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.positionBytes() == rhs.positionBytes() &&
               lhs.sizeBytes() == rhs.sizeBytes() &&
               lhs.outstandingBytes() == rhs.outstandingBytes();
    }

    friend bool operator!=(const FileInfo& lhs, const FileInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const FileInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const FileInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'FileInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::FileInfo)

namespace mqbcmd {

// =============
// class FileSet
// =============

class FileSet {
    // INSTANCE DATA
    bsls::Types::Uint64 d_aliasedBlobBufferCount;
    bsl::string         d_dataFileName;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_DATA_FILE_NAME            = 0,
        ATTRIBUTE_ID_ALIASED_BLOB_BUFFER_COUNT = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_DATA_FILE_NAME            = 0,
        ATTRIBUTE_INDEX_ALIASED_BLOB_BUFFER_COUNT = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit FileSet(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'FileSet' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    FileSet(const FileSet& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'FileSet' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FileSet(FileSet&& original) noexcept;
    // Create an object of type 'FileSet' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    FileSet(FileSet&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'FileSet' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~FileSet();
    // Destroy this object.

    // MANIPULATORS
    FileSet& operator=(const FileSet& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FileSet& operator=(FileSet&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& dataFileName();
    // Return a reference to the modifiable "DataFileName" attribute of
    // this object.

    bsls::Types::Uint64& aliasedBlobBufferCount();
    // Return a reference to the modifiable "AliasedBlobBufferCount"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& dataFileName() const;
    // Return a reference offering non-modifiable access to the
    // "DataFileName" attribute of this object.

    bsls::Types::Uint64 aliasedBlobBufferCount() const;
    // Return the value of the "AliasedBlobBufferCount" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const FileSet& lhs, const FileSet& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.dataFileName() == rhs.dataFileName() &&
               lhs.aliasedBlobBufferCount() == rhs.aliasedBlobBufferCount();
    }

    friend bool operator!=(const FileSet& lhs, const FileSet& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const FileSet& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const FileSet& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'FileSet'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.dataFileName());
        hashAppend(hashAlg, object.aliasedBlobBufferCount());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::FileSet)

namespace mqbcmd {

// ====================
// class FileStoreState
// ====================

struct FileStoreState {
  public:
    // TYPES
    enum Value { OPEN = 0, CLOSED = 1, STOPPING = 2 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return FileStoreState::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::FileStoreState)

namespace mqbcmd {

// =================
// class HelpCommand
// =================

class HelpCommand {
    // INSTANCE DATA
    bool d_plumbing;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PLUMBING = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_PLUMBING = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bool DEFAULT_INITIALIZER_PLUMBING;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    HelpCommand();
    // Create an object of type 'HelpCommand' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bool& plumbing();
    // Return a reference to the modifiable "Plumbing" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bool plumbing() const;
    // Return the value of the "Plumbing" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const HelpCommand& lhs, const HelpCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.plumbing() == rhs.plumbing();
    }

    friend bool operator!=(const HelpCommand& lhs, const HelpCommand& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const HelpCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const HelpCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'HelpCommand'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.plumbing());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::HelpCommand)

namespace mqbcmd {

// ===========================
// class LeaderMessageSequence
// ===========================

class LeaderMessageSequence {
    // INSTANCE DATA
    bsls::Types::Uint64 d_electorTerm;
    bsls::Types::Uint64 d_sequenceNumber;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_ELECTOR_TERM = 0, ATTRIBUTE_ID_SEQUENCE_NUMBER = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_ELECTOR_TERM    = 0,
        ATTRIBUTE_INDEX_SEQUENCE_NUMBER = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    LeaderMessageSequence();
    // Create an object of type 'LeaderMessageSequence' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Uint64& electorTerm();
    // Return a reference to the modifiable "ElectorTerm" attribute of this
    // object.

    bsls::Types::Uint64& sequenceNumber();
    // Return a reference to the modifiable "SequenceNumber" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Uint64 electorTerm() const;
    // Return the value of the "ElectorTerm" attribute of this object.

    bsls::Types::Uint64 sequenceNumber() const;
    // Return the value of the "SequenceNumber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const LeaderMessageSequence& lhs,
                           const LeaderMessageSequence& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.electorTerm() == rhs.electorTerm() &&
               lhs.sequenceNumber() == rhs.sequenceNumber();
    }

    friend bool operator!=(const LeaderMessageSequence& lhs,
                           const LeaderMessageSequence& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                stream,
                                    const LeaderMessageSequence& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&            hashAlg,
                           const LeaderMessageSequence& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeaderMessageSequence'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.electorTerm());
        hashAppend(hashAlg, object.sequenceNumber());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::LeaderMessageSequence)

namespace mqbcmd {

// ==================
// class LeaderStatus
// ==================

struct LeaderStatus {
  public:
    // TYPES
    enum Value { UNDEFINED = 0, PASSIVE = 1, ACTIVE = 2 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return LeaderStatus::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::LeaderStatus)

namespace mqbcmd {

// ==============================
// class LeastRecentlyUsedGroupId
// ==============================

class LeastRecentlyUsedGroupId {
    // INSTANCE DATA
    bsls::Types::Int64 d_lastSeenDeltaNanoseconds;
    bsl::string        d_clientDescription;
    bsl::string        d_msgGroupId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CLIENT_DESCRIPTION          = 0,
        ATTRIBUTE_ID_MSG_GROUP_ID                = 1,
        ATTRIBUTE_ID_LAST_SEEN_DELTA_NANOSECONDS = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_CLIENT_DESCRIPTION          = 0,
        ATTRIBUTE_INDEX_MSG_GROUP_ID                = 1,
        ATTRIBUTE_INDEX_LAST_SEEN_DELTA_NANOSECONDS = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit LeastRecentlyUsedGroupId(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'LeastRecentlyUsedGroupId' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    LeastRecentlyUsedGroupId(const LeastRecentlyUsedGroupId& original,
                             bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'LeastRecentlyUsedGroupId' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeastRecentlyUsedGroupId(LeastRecentlyUsedGroupId&& original) noexcept;
    // Create an object of type 'LeastRecentlyUsedGroupId' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    LeastRecentlyUsedGroupId(LeastRecentlyUsedGroupId&& original,
                             bslma::Allocator*          basicAllocator);
    // Create an object of type 'LeastRecentlyUsedGroupId' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~LeastRecentlyUsedGroupId();
    // Destroy this object.

    // MANIPULATORS
    LeastRecentlyUsedGroupId& operator=(const LeastRecentlyUsedGroupId& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LeastRecentlyUsedGroupId& operator=(LeastRecentlyUsedGroupId&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clientDescription();
    // Return a reference to the modifiable "ClientDescription" attribute
    // of this object.

    bsl::string& msgGroupId();
    // Return a reference to the modifiable "MsgGroupId" attribute of this
    // object.

    bsls::Types::Int64& lastSeenDeltaNanoseconds();
    // Return a reference to the modifiable "LastSeenDeltaNanoseconds"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clientDescription() const;
    // Return a reference offering non-modifiable access to the
    // "ClientDescription" attribute of this object.

    const bsl::string& msgGroupId() const;
    // Return a reference offering non-modifiable access to the
    // "MsgGroupId" attribute of this object.

    bsls::Types::Int64 lastSeenDeltaNanoseconds() const;
    // Return the value of the "LastSeenDeltaNanoseconds" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const LeastRecentlyUsedGroupId& lhs,
                           const LeastRecentlyUsedGroupId& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clientDescription() == rhs.clientDescription() &&
               lhs.msgGroupId() == rhs.msgGroupId() &&
               lhs.lastSeenDeltaNanoseconds() ==
                   rhs.lastSeenDeltaNanoseconds();
    }

    friend bool operator!=(const LeastRecentlyUsedGroupId& lhs,
                           const LeastRecentlyUsedGroupId& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                   stream,
                                    const LeastRecentlyUsedGroupId& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&               hashAlg,
                           const LeastRecentlyUsedGroupId& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'LeastRecentlyUsedGroupId'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::LeastRecentlyUsedGroupId)

namespace mqbcmd {

// ==================
// class ListMessages
// ==================

class ListMessages {
    // INSTANCE DATA
    bdlb::NullableValue<bsl::string> d_appId;
    int                              d_offset;
    int                              d_count;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_APP_ID = 0,
        ATTRIBUTE_ID_OFFSET = 1,
        ATTRIBUTE_ID_COUNT  = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_APP_ID = 0,
        ATTRIBUTE_INDEX_OFFSET = 1,
        ATTRIBUTE_INDEX_COUNT  = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ListMessages(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ListMessages' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ListMessages(const ListMessages& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'ListMessages' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ListMessages(ListMessages&& original) noexcept;
    // Create an object of type 'ListMessages' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ListMessages(ListMessages&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ListMessages' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ListMessages();
    // Destroy this object.

    // MANIPULATORS
    ListMessages& operator=(const ListMessages& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ListMessages& operator=(ListMessages&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bdlb::NullableValue<bsl::string>& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    int& offset();
    // Return a reference to the modifiable "Offset" attribute of this
    // object.

    int& count();
    // Return a reference to the modifiable "Count" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bdlb::NullableValue<bsl::string>& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    int offset() const;
    // Return the value of the "Offset" attribute of this object.

    int count() const;
    // Return the value of the "Count" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ListMessages& lhs, const ListMessages& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.appId() == rhs.appId() && lhs.offset() == rhs.offset() &&
               lhs.count() == rhs.count();
    }

    friend bool operator!=(const ListMessages& lhs, const ListMessages& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const ListMessages& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const ListMessages& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ListMessages'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ListMessages)

namespace mqbcmd {

// ==============
// class Locality
// ==============

struct Locality {
  public:
    // TYPES
    enum Value { REMOTE = 0, LOCAL = 1, MEMBER = 2 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return Locality::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::Locality)

namespace mqbcmd {

// =============
// class Message
// =============

class Message {
    // INSTANCE DATA
    bsls::Types::Int64 d_sizeBytes;
    bsl::string        d_guid;
    bdlt::DatetimeTz   d_arrivalTimestamp;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_GUID              = 0,
        ATTRIBUTE_ID_SIZE_BYTES        = 1,
        ATTRIBUTE_ID_ARRIVAL_TIMESTAMP = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_GUID              = 0,
        ATTRIBUTE_INDEX_SIZE_BYTES        = 1,
        ATTRIBUTE_INDEX_ARRIVAL_TIMESTAMP = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Message(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Message' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Message(const Message& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Message' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Message(Message&& original) noexcept;
    // Create an object of type 'Message' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Message(Message&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Message' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Message();
    // Destroy this object.

    // MANIPULATORS
    Message& operator=(const Message& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Message& operator=(Message&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& guid();
    // Return a reference to the modifiable "Guid" attribute of this
    // object.

    bsls::Types::Int64& sizeBytes();
    // Return a reference to the modifiable "SizeBytes" attribute of this
    // object.

    bdlt::DatetimeTz& arrivalTimestamp();
    // Return a reference to the modifiable "ArrivalTimestamp" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& guid() const;
    // Return a reference offering non-modifiable access to the "Guid"
    // attribute of this object.

    bsls::Types::Int64 sizeBytes() const;
    // Return the value of the "SizeBytes" attribute of this object.

    const bdlt::DatetimeTz& arrivalTimestamp() const;
    // Return a reference offering non-modifiable access to the
    // "ArrivalTimestamp" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Message& lhs, const Message& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.guid() == rhs.guid() &&
               lhs.sizeBytes() == rhs.sizeBytes() &&
               lhs.arrivalTimestamp() == rhs.arrivalTimestamp();
    }

    friend bool operator!=(const Message& lhs, const Message& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Message& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Message& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Message'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Message)

namespace mqbcmd {

// ================
// class NodeStatus
// ================

struct NodeStatus {
    // Enumeration of the various node states.

  public:
    // TYPES
    enum Value {
        E_UNKNOWN     = 0,
        E_STARTING    = 10,
        E_AVAILABLE   = 20,
        E_STOPPING    = 30,
        E_UNAVAILABLE = 40
    };

    enum { NUM_ENUMERATORS = 5 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return NodeStatus::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::NodeStatus)

namespace mqbcmd {

// ===================
// class PrimaryStatus
// ===================

struct PrimaryStatus {
  public:
    // TYPES
    enum Value { UNDEFINED = 0, PASSIVE = 1, ACTIVE = 5 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return PrimaryStatus::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::PrimaryStatus)

namespace mqbcmd {

// ========================
// class PurgedQueueDetails
// ========================

class PurgedQueueDetails {
    // INSTANCE DATA
    bsls::Types::Int64 d_numMessagesPurged;
    bsls::Types::Int64 d_numBytesPurged;
    bsl::string        d_queueUri;
    bsl::string        d_appId;
    bsl::string        d_appKey;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const PurgedQueueDetails& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_QUEUE_URI           = 0,
        ATTRIBUTE_ID_APP_ID              = 1,
        ATTRIBUTE_ID_APP_KEY             = 2,
        ATTRIBUTE_ID_NUM_MESSAGES_PURGED = 3,
        ATTRIBUTE_ID_NUM_BYTES_PURGED    = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_QUEUE_URI           = 0,
        ATTRIBUTE_INDEX_APP_ID              = 1,
        ATTRIBUTE_INDEX_APP_KEY             = 2,
        ATTRIBUTE_INDEX_NUM_MESSAGES_PURGED = 3,
        ATTRIBUTE_INDEX_NUM_BYTES_PURGED    = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit PurgedQueueDetails(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PurgedQueueDetails' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    PurgedQueueDetails(const PurgedQueueDetails& original,
                       bslma::Allocator*         basicAllocator = 0);
    // Create an object of type 'PurgedQueueDetails' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueueDetails(PurgedQueueDetails&& original) noexcept;
    // Create an object of type 'PurgedQueueDetails' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    PurgedQueueDetails(PurgedQueueDetails&& original,
                       bslma::Allocator*    basicAllocator);
    // Create an object of type 'PurgedQueueDetails' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~PurgedQueueDetails();
    // Destroy this object.

    // MANIPULATORS
    PurgedQueueDetails& operator=(const PurgedQueueDetails& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueueDetails& operator=(PurgedQueueDetails&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& queueUri();
    // Return a reference to the modifiable "QueueUri" attribute of this
    // object.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    bsl::string& appKey();
    // Return a reference to the modifiable "AppKey" attribute of this
    // object.

    bsls::Types::Int64& numMessagesPurged();
    // Return a reference to the modifiable "NumMessagesPurged" attribute
    // of this object.

    bsls::Types::Int64& numBytesPurged();
    // Return a reference to the modifiable "NumBytesPurged" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& queueUri() const;
    // Return a reference offering non-modifiable access to the "QueueUri"
    // attribute of this object.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    const bsl::string& appKey() const;
    // Return a reference offering non-modifiable access to the "AppKey"
    // attribute of this object.

    bsls::Types::Int64 numMessagesPurged() const;
    // Return the value of the "NumMessagesPurged" attribute of this
    // object.

    bsls::Types::Int64 numBytesPurged() const;
    // Return the value of the "NumBytesPurged" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PurgedQueueDetails& lhs,
                           const PurgedQueueDetails& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const PurgedQueueDetails& lhs,
                           const PurgedQueueDetails& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const PurgedQueueDetails& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&         hashAlg,
                           const PurgedQueueDetails& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PurgedQueueDetails'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::PurgedQueueDetails)

namespace mqbcmd {

// ===============================
// class RelayQueueEngineSubStream
// ===============================

class RelayQueueEngineSubStream {
    // INSTANCE DATA
    bsl::string d_appId;
    bsl::string d_appKey;
    // a.k.a.  "storage key"
    unsigned int d_numMessages;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_APP_ID       = 0,
        ATTRIBUTE_ID_APP_KEY      = 1,
        ATTRIBUTE_ID_NUM_MESSAGES = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_APP_ID       = 0,
        ATTRIBUTE_INDEX_APP_KEY      = 1,
        ATTRIBUTE_INDEX_NUM_MESSAGES = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RelayQueueEngineSubStream(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RelayQueueEngineSubStream' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    RelayQueueEngineSubStream(const RelayQueueEngineSubStream& original,
                              bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RelayQueueEngineSubStream' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RelayQueueEngineSubStream(RelayQueueEngineSubStream&& original) noexcept;
    // Create an object of type 'RelayQueueEngineSubStream' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    RelayQueueEngineSubStream(RelayQueueEngineSubStream&& original,
                              bslma::Allocator*           basicAllocator);
    // Create an object of type 'RelayQueueEngineSubStream' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~RelayQueueEngineSubStream();
    // Destroy this object.

    // MANIPULATORS
    RelayQueueEngineSubStream& operator=(const RelayQueueEngineSubStream& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RelayQueueEngineSubStream& operator=(RelayQueueEngineSubStream&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    bsl::string& appKey();
    // Return a reference to the modifiable "AppKey" attribute of this
    // object.

    unsigned int& numMessages();
    // Return a reference to the modifiable "NumMessages" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    const bsl::string& appKey() const;
    // Return a reference offering non-modifiable access to the "AppKey"
    // attribute of this object.

    unsigned int numMessages() const;
    // Return the value of the "NumMessages" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RelayQueueEngineSubStream& lhs,
                           const RelayQueueEngineSubStream& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.appId() == rhs.appId() && lhs.appKey() == rhs.appKey() &&
               lhs.numMessages() == rhs.numMessages();
    }

    friend bool operator!=(const RelayQueueEngineSubStream& lhs,
                           const RelayQueueEngineSubStream& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                    stream,
                                    const RelayQueueEngineSubStream& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                hashAlg,
                           const RelayQueueEngineSubStream& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RelayQueueEngineSubStream'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RelayQueueEngineSubStream)

namespace mqbcmd {

// ======================
// class RemoteStreamInfo
// ======================

class RemoteStreamInfo {
    // INSTANCE DATA
    bsls::Types::Int64 d_genCount;
    bsl::string        d_state;
    int                d_id;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_ID        = 0,
        ATTRIBUTE_ID_STATE     = 1,
        ATTRIBUTE_ID_GEN_COUNT = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_ID        = 0,
        ATTRIBUTE_INDEX_STATE     = 1,
        ATTRIBUTE_INDEX_GEN_COUNT = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RemoteStreamInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RemoteStreamInfo' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    RemoteStreamInfo(const RemoteStreamInfo& original,
                     bslma::Allocator*       basicAllocator = 0);
    // Create an object of type 'RemoteStreamInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RemoteStreamInfo(RemoteStreamInfo&& original) noexcept;
    // Create an object of type 'RemoteStreamInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    RemoteStreamInfo(RemoteStreamInfo&& original,
                     bslma::Allocator*  basicAllocator);
    // Create an object of type 'RemoteStreamInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~RemoteStreamInfo();
    // Destroy this object.

    // MANIPULATORS
    RemoteStreamInfo& operator=(const RemoteStreamInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RemoteStreamInfo& operator=(RemoteStreamInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& id();
    // Return a reference to the modifiable "Id" attribute of this object.

    bsl::string& state();
    // Return a reference to the modifiable "State" attribute of this
    // object.

    bsls::Types::Int64& genCount();
    // Return a reference to the modifiable "GenCount" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int id() const;
    // Return the value of the "Id" attribute of this object.

    const bsl::string& state() const;
    // Return a reference offering non-modifiable access to the "State"
    // attribute of this object.

    bsls::Types::Int64 genCount() const;
    // Return the value of the "GenCount" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RemoteStreamInfo& lhs,
                           const RemoteStreamInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.id() == rhs.id() && lhs.state() == rhs.state() &&
               lhs.genCount() == rhs.genCount();
    }

    friend bool operator!=(const RemoteStreamInfo& lhs,
                           const RemoteStreamInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const RemoteStreamInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const RemoteStreamInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RemoteStreamInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RemoteStreamInfo)

namespace mqbcmd {

// ===============================
// class ResourceUsageMonitorState
// ===============================

struct ResourceUsageMonitorState {
  public:
    // TYPES
    enum Value { STATE_NORMAL = 0, STATE_HIGH_WATERMARK = 1, STATE_FULL = 2 };

    enum { NUM_ENUMERATORS = 3 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_EnumeratorInfo ENUMERATOR_INFO_ARRAY[];

    // CLASS METHODS
    static const char* toString(Value value);
    // Return the string representation exactly matching the enumerator
    // name corresponding to the specified enumeration 'value'.

    static int fromString(Value* result, const char* string, int stringLength);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string' of the specified 'stringLength'.  Return 0 on
    // success, and a non-zero value with no effect on 'result' otherwise
    // (i.e., 'string' does not match any enumerator).

    static int fromString(Value* result, const bsl::string& string);
    // Load into the specified 'result' the enumerator matching the
    // specified 'string'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'string' does not match any
    // enumerator).

    static int fromInt(Value* result, int number);
    // Load into the specified 'result' the enumerator matching the
    // specified 'number'.  Return 0 on success, and a non-zero value with
    // no effect on 'result' otherwise (i.e., 'number' does not match any
    // enumerator).

    static bsl::ostream& print(bsl::ostream& stream, Value value);
    // Write to the specified 'stream' the string representation of
    // the specified enumeration 'value'.  Return a reference to
    // the modifiable 'stream'.

    // HIDDEN FRIENDS
    friend bsl::ostream& operator<<(bsl::ostream& stream, Value rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return ResourceUsageMonitorState::print(stream, rhs);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_ENUMERATION_TRAITS(mqbcmd::ResourceUsageMonitorState)

namespace mqbcmd {

// ===================
// class RouteResponse
// ===================

class RouteResponse {
    // A report of a command routed to a particular node.

    // INSTANCE DATA
    bsl::string d_source;
    bsl::string d_response;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SOURCE = 0, ATTRIBUTE_ID_RESPONSE = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SOURCE = 0, ATTRIBUTE_INDEX_RESPONSE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RouteResponse(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RouteResponse' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    RouteResponse(const RouteResponse& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'RouteResponse' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouteResponse(RouteResponse&& original) noexcept;
    // Create an object of type 'RouteResponse' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    RouteResponse(RouteResponse&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'RouteResponse' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~RouteResponse();
    // Destroy this object.

    // MANIPULATORS
    RouteResponse& operator=(const RouteResponse& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouteResponse& operator=(RouteResponse&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& source();
    // Return a reference to the modifiable "Source" attribute of this
    // object.

    bsl::string& response();
    // Return a reference to the modifiable "Response" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& source() const;
    // Return a reference offering non-modifiable access to the "Source"
    // attribute of this object.

    const bsl::string& response() const;
    // Return a reference offering non-modifiable access to the "Response"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RouteResponse& lhs, const RouteResponse& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.source() == rhs.source() &&
               lhs.response() == rhs.response();
    }

    friend bool operator!=(const RouteResponse& lhs, const RouteResponse& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const RouteResponse& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const RouteResponse& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RouteResponse'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.source());
        hashAppend(hashAlg, object.response());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RouteResponse)

namespace mqbcmd {

// =========================
// class StorageQueueCommand
// =========================

class StorageQueueCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<bsl::string> d_purgeAppId;
        // The special value "*" indicates the entire queue.
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StorageQueueCommand& rhs) const;

  public:
    // TYPES

    enum { SELECTION_ID_UNDEFINED = -1, SELECTION_ID_PURGE_APP_ID = 0 };

    enum { NUM_SELECTIONS = 1 };

    enum { SELECTION_INDEX_PURGE_APP_ID = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit StorageQueueCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StorageQueueCommand' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    StorageQueueCommand(const StorageQueueCommand& original,
                        bslma::Allocator*          basicAllocator = 0);
    // Create an object of type 'StorageQueueCommand' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageQueueCommand(StorageQueueCommand&& original) noexcept;
    // Create an object of type 'StorageQueueCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StorageQueueCommand(StorageQueueCommand&& original,
                        bslma::Allocator*     basicAllocator);
    // Create an object of type 'StorageQueueCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StorageQueueCommand();
    // Destroy this object.

    // MANIPULATORS
    StorageQueueCommand& operator=(const StorageQueueCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageQueueCommand& operator=(StorageQueueCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    bsl::string& makePurgeAppId();
    bsl::string& makePurgeAppId(const bsl::string& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bsl::string& makePurgeAppId(bsl::string&& value);
#endif
    // Set the value of this object to be a "PurgeAppId" value.  Optionally
    // specify the 'value' of the "PurgeAppId".  If 'value' is not
    // specified, the default "PurgeAppId" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    bsl::string& purgeAppId();
    // Return a reference to the modifiable "PurgeAppId" selection of this
    // object if "PurgeAppId" is the current selection.  The behavior is
    // undefined unless "PurgeAppId" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const bsl::string& purgeAppId() const;
    // Return a reference to the non-modifiable "PurgeAppId" selection of
    // this object if "PurgeAppId" is the current selection.  The behavior
    // is undefined unless "PurgeAppId" is the selection of this object.

    bool isPurgeAppIdValue() const;
    // Return 'true' if the value of this object is a "PurgeAppId" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageQueueCommand& lhs,
                           const StorageQueueCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'StorageQueueCommand' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StorageQueueCommand& lhs,
                           const StorageQueueCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const StorageQueueCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const StorageQueueCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageQueueCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::StorageQueueCommand)

namespace mqbcmd {

// ======================
// class StorageQueueInfo
// ======================

class StorageQueueInfo {
    // INSTANCE DATA
    bsls::Types::Int64 d_numMessages;
    bsls::Types::Int64 d_numBytes;
    bsl::string        d_queueUri;
    bsl::string        d_queueKey;
    unsigned int       d_internalQueueId;
    int                d_partitionId;
    bool               d_isPersistent;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StorageQueueInfo& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_QUEUE_URI         = 0,
        ATTRIBUTE_ID_QUEUE_KEY         = 1,
        ATTRIBUTE_ID_PARTITION_ID      = 2,
        ATTRIBUTE_ID_NUM_MESSAGES      = 3,
        ATTRIBUTE_ID_NUM_BYTES         = 4,
        ATTRIBUTE_ID_IS_PERSISTENT     = 5,
        ATTRIBUTE_ID_INTERNAL_QUEUE_ID = 6
    };

    enum { NUM_ATTRIBUTES = 7 };

    enum {
        ATTRIBUTE_INDEX_QUEUE_URI         = 0,
        ATTRIBUTE_INDEX_QUEUE_KEY         = 1,
        ATTRIBUTE_INDEX_PARTITION_ID      = 2,
        ATTRIBUTE_INDEX_NUM_MESSAGES      = 3,
        ATTRIBUTE_INDEX_NUM_BYTES         = 4,
        ATTRIBUTE_INDEX_IS_PERSISTENT     = 5,
        ATTRIBUTE_INDEX_INTERNAL_QUEUE_ID = 6
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit StorageQueueInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StorageQueueInfo' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    StorageQueueInfo(const StorageQueueInfo& original,
                     bslma::Allocator*       basicAllocator = 0);
    // Create an object of type 'StorageQueueInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageQueueInfo(StorageQueueInfo&& original) noexcept;
    // Create an object of type 'StorageQueueInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StorageQueueInfo(StorageQueueInfo&& original,
                     bslma::Allocator*  basicAllocator);
    // Create an object of type 'StorageQueueInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StorageQueueInfo();
    // Destroy this object.

    // MANIPULATORS
    StorageQueueInfo& operator=(const StorageQueueInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageQueueInfo& operator=(StorageQueueInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& queueUri();
    // Return a reference to the modifiable "QueueUri" attribute of this
    // object.

    bsl::string& queueKey();
    // Return a reference to the modifiable "QueueKey" attribute of this
    // object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    bsls::Types::Int64& numMessages();
    // Return a reference to the modifiable "NumMessages" attribute of this
    // object.

    bsls::Types::Int64& numBytes();
    // Return a reference to the modifiable "NumBytes" attribute of this
    // object.

    bool& isPersistent();
    // Return a reference to the modifiable "IsPersistent" attribute of
    // this object.

    unsigned int& internalQueueId();
    // Return a reference to the modifiable "InternalQueueId" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& queueUri() const;
    // Return a reference offering non-modifiable access to the "QueueUri"
    // attribute of this object.

    const bsl::string& queueKey() const;
    // Return a reference offering non-modifiable access to the "QueueKey"
    // attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    bsls::Types::Int64 numMessages() const;
    // Return the value of the "NumMessages" attribute of this object.

    bsls::Types::Int64 numBytes() const;
    // Return the value of the "NumBytes" attribute of this object.

    bool isPersistent() const;
    // Return the value of the "IsPersistent" attribute of this object.

    unsigned int internalQueueId() const;
    // Return the value of the "InternalQueueId" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageQueueInfo& lhs,
                           const StorageQueueInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StorageQueueInfo& lhs,
                           const StorageQueueInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const StorageQueueInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const StorageQueueInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageQueueInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::StorageQueueInfo)

namespace mqbcmd {

// ===========
// class SubId
// ===========

class SubId {
    // INSTANCE DATA
    bsl::string  d_appId;
    unsigned int d_subId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SUB_ID = 0, ATTRIBUTE_ID_APP_ID = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SUB_ID = 0, ATTRIBUTE_INDEX_APP_ID = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit SubId(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'SubId' having the default value.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    SubId(const SubId& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'SubId' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SubId(SubId&& original) noexcept;
    // Create an object of type 'SubId' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    SubId(SubId&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'SubId' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~SubId();
    // Destroy this object.

    // MANIPULATORS
    SubId& operator=(const SubId& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SubId& operator=(SubId&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& subId();
    // Return a reference to the modifiable "SubId" attribute of this
    // object.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int subId() const;
    // Return the value of the "SubId" attribute of this object.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const SubId& lhs, const SubId& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.subId() == rhs.subId() && lhs.appId() == rhs.appId();
    }

    friend bool operator!=(const SubId& lhs, const SubId& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const SubId& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const SubId& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'SubId'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.subId());
        hashAppend(hashAlg, object.appId());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::SubId)

namespace mqbcmd {

// ================
// class Subscriber
// ================

class Subscriber {
    // INSTANCE DATA
    bsls::Types::Int64 d_downstreamSubQueueId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_DOWNSTREAM_SUB_QUEUE_ID = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_DOWNSTREAM_SUB_QUEUE_ID = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    Subscriber();
    // Create an object of type 'Subscriber' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Int64& downstreamSubQueueId();
    // Return a reference to the modifiable "DownstreamSubQueueId"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Int64 downstreamSubQueueId() const;
    // Return the value of the "DownstreamSubQueueId" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const Subscriber& lhs, const Subscriber& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.downstreamSubQueueId() == rhs.downstreamSubQueueId();
    }

    friend bool operator!=(const Subscriber& lhs, const Subscriber& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const Subscriber& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Subscriber& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Subscriber'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.downstreamSubQueueId());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::Subscriber)

namespace mqbcmd {

// ========================
// class UninitializedQueue
// ========================

class UninitializedQueue {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const UninitializedQueue&,
                           const UninitializedQueue&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const UninitializedQueue& lhs,
                           const UninitializedQueue& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const UninitializedQueue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const UninitializedQueue&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'UninitializedQueue'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::UninitializedQueue)

namespace mqbcmd {

// ====================
// class VirtualStorage
// ====================

class VirtualStorage {
    // INSTANCE DATA
    bsl::string  d_appId;
    bsl::string  d_appKey;
    unsigned int d_numMessages;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_APP_ID       = 0,
        ATTRIBUTE_ID_APP_KEY      = 1,
        ATTRIBUTE_ID_NUM_MESSAGES = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_APP_ID       = 0,
        ATTRIBUTE_INDEX_APP_KEY      = 1,
        ATTRIBUTE_INDEX_NUM_MESSAGES = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit VirtualStorage(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'VirtualStorage' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    VirtualStorage(const VirtualStorage& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'VirtualStorage' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    VirtualStorage(VirtualStorage&& original) noexcept;
    // Create an object of type 'VirtualStorage' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    VirtualStorage(VirtualStorage&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'VirtualStorage' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~VirtualStorage();
    // Destroy this object.

    // MANIPULATORS
    VirtualStorage& operator=(const VirtualStorage& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    VirtualStorage& operator=(VirtualStorage&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    bsl::string& appKey();
    // Return a reference to the modifiable "AppKey" attribute of this
    // object.

    unsigned int& numMessages();
    // Return a reference to the modifiable "NumMessages" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    const bsl::string& appKey() const;
    // Return a reference offering non-modifiable access to the "AppKey"
    // attribute of this object.

    unsigned int numMessages() const;
    // Return the value of the "NumMessages" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const VirtualStorage& lhs,
                           const VirtualStorage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.appId() == rhs.appId() && lhs.appKey() == rhs.appKey() &&
               lhs.numMessages() == rhs.numMessages();
    }

    friend bool operator!=(const VirtualStorage& lhs,
                           const VirtualStorage& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const VirtualStorage& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const VirtualStorage& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'VirtualStorage'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::VirtualStorage)

namespace mqbcmd {

// ==========
// class Void
// ==========

class Void {
    // INSTANCE DATA

  public:
    // TYPES
    enum { NUM_ATTRIBUTES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    // HIDDEN FRIENDS
    friend bool operator==(const Void&, const Void&)
    // Returns 'true' as this type has no attributes and so all objects of
    // this type are considered equal.
    {
        return true;
    }

    friend bool operator!=(const Void& lhs, const Void& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Void& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&, const Void&)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Void'.
    {
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::Void)

namespace mqbcmd {

// ===================
// class ActiveFileSet
// ===================

class ActiveFileSet {
    // INSTANCE DATA
    FileInfo d_dataFile;
    FileInfo d_journalFile;
    FileInfo d_qlistFile;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_DATA_FILE    = 0,
        ATTRIBUTE_ID_JOURNAL_FILE = 1,
        ATTRIBUTE_ID_QLIST_FILE   = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_DATA_FILE    = 0,
        ATTRIBUTE_INDEX_JOURNAL_FILE = 1,
        ATTRIBUTE_INDEX_QLIST_FILE   = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ActiveFileSet();
    // Create an object of type 'ActiveFileSet' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    FileInfo& dataFile();
    // Return a reference to the modifiable "DataFile" attribute of this
    // object.

    FileInfo& journalFile();
    // Return a reference to the modifiable "JournalFile" attribute of this
    // object.

    FileInfo& qlistFile();
    // Return a reference to the modifiable "QlistFile" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const FileInfo& dataFile() const;
    // Return a reference offering non-modifiable access to the "DataFile"
    // attribute of this object.

    const FileInfo& journalFile() const;
    // Return a reference offering non-modifiable access to the
    // "JournalFile" attribute of this object.

    const FileInfo& qlistFile() const;
    // Return a reference offering non-modifiable access to the "QlistFile"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ActiveFileSet& lhs, const ActiveFileSet& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.dataFile() == rhs.dataFile() &&
               lhs.journalFile() == rhs.journalFile() &&
               lhs.qlistFile() == rhs.qlistFile();
    }

    friend bool operator!=(const ActiveFileSet& lhs, const ActiveFileSet& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const ActiveFileSet& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const ActiveFileSet& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ActiveFileSet'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::ActiveFileSet)

namespace mqbcmd {

// =========================
// class BrokerConfigCommand
// =========================

class BrokerConfigCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void> d_dump;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const BrokerConfigCommand& rhs) const;

  public:
    // TYPES

    enum { SELECTION_ID_UNDEFINED = -1, SELECTION_ID_DUMP = 0 };

    enum { NUM_SELECTIONS = 1 };

    enum { SELECTION_INDEX_DUMP = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    BrokerConfigCommand();
    // Create an object of type 'BrokerConfigCommand' having the default
    // value.

    BrokerConfigCommand(const BrokerConfigCommand& original);
    // Create an object of type 'BrokerConfigCommand' having the value of
    // the specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerConfigCommand(BrokerConfigCommand&& original) noexcept;
    // Create an object of type 'BrokerConfigCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
#endif

    ~BrokerConfigCommand();
    // Destroy this object.

    // MANIPULATORS
    BrokerConfigCommand& operator=(const BrokerConfigCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerConfigCommand& operator=(BrokerConfigCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeDump();
    Void& makeDump(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeDump(Void&& value);
#endif
    // Set the value of this object to be a "Dump" value.  Optionally
    // specify the 'value' of the "Dump".  If 'value' is not specified, the
    // default "Dump" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& dump();
    // Return a reference to the modifiable "Dump" selection of this object
    // if "Dump" is the current selection.  The behavior is undefined
    // unless "Dump" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& dump() const;
    // Return a reference to the non-modifiable "Dump" selection of this
    // object if "Dump" is the current selection.  The behavior is
    // undefined unless "Dump" is the selection of this object.

    bool isDumpValue() const;
    // Return 'true' if the value of this object is a "Dump" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const BrokerConfigCommand& lhs,
                           const BrokerConfigCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'BrokerConfigCommand' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const BrokerConfigCommand& lhs,
                           const BrokerConfigCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const BrokerConfigCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const BrokerConfigCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'BrokerConfigCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::BrokerConfigCommand)

namespace mqbcmd {

// ================
// class ClearCache
// ================

class ClearCache {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<bsl::string> d_domain;
        bsls::ObjectBuffer<Void>        d_all;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClearCache& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED = -1,
        SELECTION_ID_DOMAIN    = 0,
        SELECTION_ID_ALL       = 1
    };

    enum { NUM_SELECTIONS = 2 };

    enum { SELECTION_INDEX_DOMAIN = 0, SELECTION_INDEX_ALL = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClearCache(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClearCache' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClearCache(const ClearCache& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClearCache' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClearCache(ClearCache&& original) noexcept;
    // Create an object of type 'ClearCache' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClearCache(ClearCache&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ClearCache' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClearCache();
    // Destroy this object.

    // MANIPULATORS
    ClearCache& operator=(const ClearCache& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClearCache& operator=(ClearCache&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    bsl::string& makeDomain();
    bsl::string& makeDomain(const bsl::string& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bsl::string& makeDomain(bsl::string&& value);
#endif
    // Set the value of this object to be a "Domain" value.  Optionally
    // specify the 'value' of the "Domain".  If 'value' is not specified,
    // the default "Domain" value is used.

    Void& makeAll();
    Void& makeAll(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeAll(Void&& value);
#endif
    // Set the value of this object to be a "All" value.  Optionally
    // specify the 'value' of the "All".  If 'value' is not specified, the
    // default "All" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    bsl::string& domain();
    // Return a reference to the modifiable "Domain" selection of this
    // object if "Domain" is the current selection.  The behavior is
    // undefined unless "Domain" is the selection of this object.

    Void& all();
    // Return a reference to the modifiable "All" selection of this object
    // if "All" is the current selection.  The behavior is undefined unless
    // "All" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const bsl::string& domain() const;
    // Return a reference to the non-modifiable "Domain" selection of this
    // object if "Domain" is the current selection.  The behavior is
    // undefined unless "Domain" is the selection of this object.

    const Void& all() const;
    // Return a reference to the non-modifiable "All" selection of this
    // object if "All" is the current selection.  The behavior is undefined
    // unless "All" is the selection of this object.

    bool isDomainValue() const;
    // Return 'true' if the value of this object is a "Domain" value, and
    // return 'false' otherwise.

    bool isAllValue() const;
    // Return 'true' if the value of this object is a "All" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClearCache& lhs, const ClearCache& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ClearCache' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClearCache& lhs, const ClearCache& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const ClearCache& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const ClearCache& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'ClearCache'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ClearCache)

namespace mqbcmd {

// =================
// class ClusterInfo
// =================

class ClusterInfo {
    // INSTANCE DATA
    bsl::vector<ClusterNode> d_nodes;
    bsl::string              d_name;
    Locality::Value          d_locality;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_LOCALITY = 0,
        ATTRIBUTE_ID_NAME     = 1,
        ATTRIBUTE_ID_NODES    = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_LOCALITY = 0,
        ATTRIBUTE_INDEX_NAME     = 1,
        ATTRIBUTE_INDEX_NODES    = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterInfo' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterInfo(const ClusterInfo& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'ClusterInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterInfo(ClusterInfo&& original) noexcept;
    // Create an object of type 'ClusterInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterInfo(ClusterInfo&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterInfo();
    // Destroy this object.

    // MANIPULATORS
    ClusterInfo& operator=(const ClusterInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterInfo& operator=(ClusterInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    Locality::Value& locality();
    // Return a reference to the modifiable "Locality" attribute of this
    // object.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    bsl::vector<ClusterNode>& nodes();
    // Return a reference to the modifiable "Nodes" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    Locality::Value locality() const;
    // Return the value of the "Locality" attribute of this object.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const bsl::vector<ClusterNode>& nodes() const;
    // Return a reference offering non-modifiable access to the "Nodes"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterInfo& lhs, const ClusterInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.locality() == rhs.locality() && lhs.name() == rhs.name() &&
               lhs.nodes() == rhs.nodes();
    }

    friend bool operator!=(const ClusterInfo& lhs, const ClusterInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const ClusterInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const ClusterInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'ClusterInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ClusterInfo)

namespace mqbcmd {

// =====================
// class ClusterNodeInfo
// =====================

class ClusterNodeInfo {
    // INSTANCE DATA
    bsl::vector<int>          d_primaryForPartitionIds;
    bsl::string               d_description;
    NodeStatus::Value         d_status;
    bdlb::NullableValue<bool> d_isAvailable;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterNodeInfo& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_DESCRIPTION               = 0,
        ATTRIBUTE_ID_IS_AVAILABLE              = 1,
        ATTRIBUTE_ID_STATUS                    = 2,
        ATTRIBUTE_ID_PRIMARY_FOR_PARTITION_IDS = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_DESCRIPTION               = 0,
        ATTRIBUTE_INDEX_IS_AVAILABLE              = 1,
        ATTRIBUTE_INDEX_STATUS                    = 2,
        ATTRIBUTE_INDEX_PRIMARY_FOR_PARTITION_IDS = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterNodeInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterNodeInfo' having the default value.
    //  Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterNodeInfo(const ClusterNodeInfo& original,
                    bslma::Allocator*      basicAllocator = 0);
    // Create an object of type 'ClusterNodeInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterNodeInfo(ClusterNodeInfo&& original) noexcept;
    // Create an object of type 'ClusterNodeInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterNodeInfo(ClusterNodeInfo&& original,
                    bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterNodeInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterNodeInfo();
    // Destroy this object.

    // MANIPULATORS
    ClusterNodeInfo& operator=(const ClusterNodeInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterNodeInfo& operator=(ClusterNodeInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& description();
    // Return a reference to the modifiable "Description" attribute of this
    // object.

    bdlb::NullableValue<bool>& isAvailable();
    // Return a reference to the modifiable "IsAvailable" attribute of this
    // object.

    NodeStatus::Value& status();
    // Return a reference to the modifiable "Status" attribute of this
    // object.

    bsl::vector<int>& primaryForPartitionIds();
    // Return a reference to the modifiable "PrimaryForPartitionIds"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& description() const;
    // Return a reference offering non-modifiable access to the
    // "Description" attribute of this object.

    const bdlb::NullableValue<bool>& isAvailable() const;
    // Return a reference offering non-modifiable access to the
    // "IsAvailable" attribute of this object.

    NodeStatus::Value status() const;
    // Return the value of the "Status" attribute of this object.

    const bsl::vector<int>& primaryForPartitionIds() const;
    // Return a reference offering non-modifiable access to the
    // "PrimaryForPartitionIds" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterNodeInfo& lhs,
                           const ClusterNodeInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterNodeInfo& lhs,
                           const ClusterNodeInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&          stream,
                                    const ClusterNodeInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&      hashAlg,
                           const ClusterNodeInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterNodeInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClusterNodeInfo)

namespace mqbcmd {

// ==================
// class ClusterQueue
// ==================

class ClusterQueue {
    // INSTANCE DATA
    bsl::vector<SubId>               d_subIds;
    bsl::vector<Context>             d_contexts;
    bsl::string                      d_uri;
    bsl::string                      d_key;
    bdlb::NullableValue<bsl::string> d_primaryNodeDescription;
    unsigned int                     d_numInFlightContexts;
    unsigned int                     d_id;
    int                              d_partitionId;
    bool                             d_isAssigned;
    bool                             d_isPrimaryAvailable;
    bool                             d_isCreated;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterQueue& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_URI                      = 0,
        ATTRIBUTE_ID_NUM_IN_FLIGHT_CONTEXTS   = 1,
        ATTRIBUTE_ID_IS_ASSIGNED              = 2,
        ATTRIBUTE_ID_IS_PRIMARY_AVAILABLE     = 3,
        ATTRIBUTE_ID_ID                       = 4,
        ATTRIBUTE_ID_SUB_IDS                  = 5,
        ATTRIBUTE_ID_PARTITION_ID             = 6,
        ATTRIBUTE_ID_PRIMARY_NODE_DESCRIPTION = 7,
        ATTRIBUTE_ID_KEY                      = 8,
        ATTRIBUTE_ID_IS_CREATED               = 9,
        ATTRIBUTE_ID_CONTEXTS                 = 10
    };

    enum { NUM_ATTRIBUTES = 11 };

    enum {
        ATTRIBUTE_INDEX_URI                      = 0,
        ATTRIBUTE_INDEX_NUM_IN_FLIGHT_CONTEXTS   = 1,
        ATTRIBUTE_INDEX_IS_ASSIGNED              = 2,
        ATTRIBUTE_INDEX_IS_PRIMARY_AVAILABLE     = 3,
        ATTRIBUTE_INDEX_ID                       = 4,
        ATTRIBUTE_INDEX_SUB_IDS                  = 5,
        ATTRIBUTE_INDEX_PARTITION_ID             = 6,
        ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION = 7,
        ATTRIBUTE_INDEX_KEY                      = 8,
        ATTRIBUTE_INDEX_IS_CREATED               = 9,
        ATTRIBUTE_INDEX_CONTEXTS                 = 10
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterQueue(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterQueue' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterQueue(const ClusterQueue& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'ClusterQueue' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterQueue(ClusterQueue&& original) noexcept;
    // Create an object of type 'ClusterQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterQueue(ClusterQueue&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterQueue();
    // Destroy this object.

    // MANIPULATORS
    ClusterQueue& operator=(const ClusterQueue& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterQueue& operator=(ClusterQueue&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& uri();
    // Return a reference to the modifiable "Uri" attribute of this object.

    unsigned int& numInFlightContexts();
    // Return a reference to the modifiable "NumInFlightContexts" attribute
    // of this object.

    bool& isAssigned();
    // Return a reference to the modifiable "IsAssigned" attribute of this
    // object.

    bool& isPrimaryAvailable();
    // Return a reference to the modifiable "IsPrimaryAvailable" attribute
    // of this object.

    unsigned int& id();
    // Return a reference to the modifiable "Id" attribute of this object.

    bsl::vector<SubId>& subIds();
    // Return a reference to the modifiable "SubIds" attribute of this
    // object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    bdlb::NullableValue<bsl::string>& primaryNodeDescription();
    // Return a reference to the modifiable "PrimaryNodeDescription"
    // attribute of this object.

    bsl::string& key();
    // Return a reference to the modifiable "Key" attribute of this object.

    bool& isCreated();
    // Return a reference to the modifiable "IsCreated" attribute of this
    // object.

    bsl::vector<Context>& contexts();
    // Return a reference to the modifiable "Contexts" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& uri() const;
    // Return a reference offering non-modifiable access to the "Uri"
    // attribute of this object.

    unsigned int numInFlightContexts() const;
    // Return the value of the "NumInFlightContexts" attribute of this
    // object.

    bool isAssigned() const;
    // Return the value of the "IsAssigned" attribute of this object.

    bool isPrimaryAvailable() const;
    // Return the value of the "IsPrimaryAvailable" attribute of this
    // object.

    unsigned int id() const;
    // Return the value of the "Id" attribute of this object.

    const bsl::vector<SubId>& subIds() const;
    // Return a reference offering non-modifiable access to the "SubIds"
    // attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const bdlb::NullableValue<bsl::string>& primaryNodeDescription() const;
    // Return a reference offering non-modifiable access to the
    // "PrimaryNodeDescription" attribute of this object.

    const bsl::string& key() const;
    // Return a reference offering non-modifiable access to the "Key"
    // attribute of this object.

    bool isCreated() const;
    // Return the value of the "IsCreated" attribute of this object.

    const bsl::vector<Context>& contexts() const;
    // Return a reference offering non-modifiable access to the "Contexts"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterQueue& lhs, const ClusterQueue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterQueue& lhs, const ClusterQueue& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const ClusterQueue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const ClusterQueue& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterQueue'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ClusterQueue)

namespace mqbcmd {

// ===================
// class DangerCommand
// ===================

class DangerCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void> d_shutdown;
        bsls::ObjectBuffer<Void> d_terminate;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const DangerCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED = -1,
        SELECTION_ID_SHUTDOWN  = 0,
        SELECTION_ID_TERMINATE = 1
    };

    enum { NUM_SELECTIONS = 2 };

    enum { SELECTION_INDEX_SHUTDOWN = 0, SELECTION_INDEX_TERMINATE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    DangerCommand();
    // Create an object of type 'DangerCommand' having the default value.

    DangerCommand(const DangerCommand& original);
    // Create an object of type 'DangerCommand' having the value of the
    // specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DangerCommand(DangerCommand&& original) noexcept;
    // Create an object of type 'DangerCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
#endif

    ~DangerCommand();
    // Destroy this object.

    // MANIPULATORS
    DangerCommand& operator=(const DangerCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DangerCommand& operator=(DangerCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeShutdown();
    Void& makeShutdown(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeShutdown(Void&& value);
#endif
    // Set the value of this object to be a "Shutdown" value.  Optionally
    // specify the 'value' of the "Shutdown".  If 'value' is not specified,
    // the default "Shutdown" value is used.

    Void& makeTerminate();
    Void& makeTerminate(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeTerminate(Void&& value);
#endif
    // Set the value of this object to be a "Terminate" value.  Optionally
    // specify the 'value' of the "Terminate".  If 'value' is not
    // specified, the default "Terminate" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& shutdown();
    // Return a reference to the modifiable "Shutdown" selection of this
    // object if "Shutdown" is the current selection.  The behavior is
    // undefined unless "Shutdown" is the selection of this object.

    Void& terminate();
    // Return a reference to the modifiable "Terminate" selection of this
    // object if "Terminate" is the current selection.  The behavior is
    // undefined unless "Terminate" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& shutdown() const;
    // Return a reference to the non-modifiable "Shutdown" selection of
    // this object if "Shutdown" is the current selection.  The behavior is
    // undefined unless "Shutdown" is the selection of this object.

    const Void& terminate() const;
    // Return a reference to the non-modifiable "Terminate" selection of
    // this object if "Terminate" is the current selection.  The behavior
    // is undefined unless "Terminate" is the selection of this object.

    bool isShutdownValue() const;
    // Return 'true' if the value of this object is a "Shutdown" value, and
    // return 'false' otherwise.

    bool isTerminateValue() const;
    // Return 'true' if the value of this object is a "Terminate" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DangerCommand& lhs, const DangerCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'DangerCommand' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const DangerCommand& lhs, const DangerCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const DangerCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const DangerCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DangerCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::DangerCommand)

namespace mqbcmd {

// =================
// class ElectorInfo
// =================

class ElectorInfo {
    // INSTANCE DATA
    bsl::string           d_leaderNode;
    LeaderMessageSequence d_leaderMessageSequence;
    LeaderStatus::Value   d_leaderStatus;
    ElectorState::Value   d_electorState;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ElectorInfo& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_ELECTOR_STATE           = 0,
        ATTRIBUTE_ID_LEADER_NODE             = 1,
        ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE = 2,
        ATTRIBUTE_ID_LEADER_STATUS           = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_ELECTOR_STATE           = 0,
        ATTRIBUTE_INDEX_LEADER_NODE             = 1,
        ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE = 2,
        ATTRIBUTE_INDEX_LEADER_STATUS           = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ElectorInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ElectorInfo' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ElectorInfo(const ElectorInfo& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'ElectorInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorInfo(ElectorInfo&& original) noexcept;
    // Create an object of type 'ElectorInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ElectorInfo(ElectorInfo&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ElectorInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ElectorInfo();
    // Destroy this object.

    // MANIPULATORS
    ElectorInfo& operator=(const ElectorInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorInfo& operator=(ElectorInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ElectorState::Value& electorState();
    // Return a reference to the modifiable "ElectorState" attribute of
    // this object.

    bsl::string& leaderNode();
    // Return a reference to the modifiable "LeaderNode" attribute of this
    // object.

    LeaderMessageSequence& leaderMessageSequence();
    // Return a reference to the modifiable "LeaderMessageSequence"
    // attribute of this object.

    LeaderStatus::Value& leaderStatus();
    // Return a reference to the modifiable "LeaderStatus" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    ElectorState::Value electorState() const;
    // Return the value of the "ElectorState" attribute of this object.

    const bsl::string& leaderNode() const;
    // Return a reference offering non-modifiable access to the
    // "LeaderNode" attribute of this object.

    const LeaderMessageSequence& leaderMessageSequence() const;
    // Return a reference offering non-modifiable access to the
    // "LeaderMessageSequence" attribute of this object.

    LeaderStatus::Value leaderStatus() const;
    // Return the value of the "LeaderStatus" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ElectorInfo& lhs, const ElectorInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ElectorInfo& lhs, const ElectorInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const ElectorInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const ElectorInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'ElectorInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ElectorInfo)

namespace mqbcmd {

// ======================
// class GetTunableChoice
// ======================

class GetTunableChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void> d_all;
        bsls::ObjectBuffer<Void> d_self;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const GetTunableChoice& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED = -1,
        SELECTION_ID_ALL       = 0,
        SELECTION_ID_SELF      = 1
    };

    enum { NUM_SELECTIONS = 2 };

    enum { SELECTION_INDEX_ALL = 0, SELECTION_INDEX_SELF = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    GetTunableChoice();
    // Create an object of type 'GetTunableChoice' having the default
    // value.

    GetTunableChoice(const GetTunableChoice& original);
    // Create an object of type 'GetTunableChoice' having the value of the
    // specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    GetTunableChoice(GetTunableChoice&& original) noexcept;
    // Create an object of type 'GetTunableChoice' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
#endif

    ~GetTunableChoice();
    // Destroy this object.

    // MANIPULATORS
    GetTunableChoice& operator=(const GetTunableChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    GetTunableChoice& operator=(GetTunableChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeAll();
    Void& makeAll(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeAll(Void&& value);
#endif
    // Set the value of this object to be a "All" value.  Optionally
    // specify the 'value' of the "All".  If 'value' is not specified, the
    // default "All" value is used.

    Void& makeSelf();
    Void& makeSelf(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSelf(Void&& value);
#endif
    // Set the value of this object to be a "Self" value.  Optionally
    // specify the 'value' of the "Self".  If 'value' is not specified, the
    // default "Self" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& all();
    // Return a reference to the modifiable "All" selection of this object
    // if "All" is the current selection.  The behavior is undefined unless
    // "All" is the selection of this object.

    Void& self();
    // Return a reference to the modifiable "Self" selection of this object
    // if "Self" is the current selection.  The behavior is undefined
    // unless "Self" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& all() const;
    // Return a reference to the non-modifiable "All" selection of this
    // object if "All" is the current selection.  The behavior is undefined
    // unless "All" is the selection of this object.

    const Void& self() const;
    // Return a reference to the non-modifiable "Self" selection of this
    // object if "Self" is the current selection.  The behavior is
    // undefined unless "Self" is the selection of this object.

    bool isAllValue() const;
    // Return 'true' if the value of this object is a "All" value, and
    // return 'false' otherwise.

    bool isSelfValue() const;
    // Return 'true' if the value of this object is a "Self" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const GetTunableChoice& lhs,
                           const GetTunableChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'GetTunableChoice' objects have
    // the same value if either the selections in both objects have the
    // same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const GetTunableChoice& lhs,
                           const GetTunableChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const GetTunableChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const GetTunableChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'GetTunableChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::GetTunableChoice)

namespace mqbcmd {

// ==========
// class Help
// ==========

class Help {
    // INSTANCE DATA
    bsl::vector<CommandSpec> d_commands;
    bool                     d_isPlumbing;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_COMMANDS = 0, ATTRIBUTE_ID_IS_PLUMBING = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_COMMANDS = 0, ATTRIBUTE_INDEX_IS_PLUMBING = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Help(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Help' having the default value.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Help(const Help& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Help' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Help(Help&& original) noexcept;
    // Create an object of type 'Help' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Help(Help&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Help' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Help();
    // Destroy this object.

    // MANIPULATORS
    Help& operator=(const Help& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Help& operator=(Help&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<CommandSpec>& commands();
    // Return a reference to the modifiable "Commands" attribute of this
    // object.

    bool& isPlumbing();
    // Return a reference to the modifiable "IsPlumbing" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<CommandSpec>& commands() const;
    // Return a reference offering non-modifiable access to the "Commands"
    // attribute of this object.

    bool isPlumbing() const;
    // Return the value of the "IsPlumbing" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Help& lhs, const Help& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.commands() == rhs.commands() &&
               lhs.isPlumbing() == rhs.isPlumbing();
    }

    friend bool operator!=(const Help& lhs, const Help& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Help& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Help& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Help'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.commands());
        hashAppend(hashAlg, object.isPlumbing());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Help)

namespace mqbcmd {

// ================================
// class MessageGroupIdManagerIndex
// ================================

class MessageGroupIdManagerIndex {
    // INSTANCE DATA
    bsl::vector<LeastRecentlyUsedGroupId> d_leastRecentlyUsedGroupIds;
    bsl::vector<ClientMsgGroupsCount>     d_numMsgGroupsPerClient;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_LEAST_RECENTLY_USED_GROUP_IDS = 0,
        ATTRIBUTE_ID_NUM_MSG_GROUPS_PER_CLIENT     = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_LEAST_RECENTLY_USED_GROUP_IDS = 0,
        ATTRIBUTE_INDEX_NUM_MSG_GROUPS_PER_CLIENT     = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit MessageGroupIdManagerIndex(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'MessageGroupIdManagerIndex' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    MessageGroupIdManagerIndex(const MessageGroupIdManagerIndex& original,
                               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'MessageGroupIdManagerIndex' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    MessageGroupIdManagerIndex(MessageGroupIdManagerIndex&& original) noexcept;
    // Create an object of type 'MessageGroupIdManagerIndex' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    MessageGroupIdManagerIndex(MessageGroupIdManagerIndex&& original,
                               bslma::Allocator*            basicAllocator);
    // Create an object of type 'MessageGroupIdManagerIndex' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~MessageGroupIdManagerIndex();
    // Destroy this object.

    // MANIPULATORS
    MessageGroupIdManagerIndex&
    operator=(const MessageGroupIdManagerIndex& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    MessageGroupIdManagerIndex& operator=(MessageGroupIdManagerIndex&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<LeastRecentlyUsedGroupId>& leastRecentlyUsedGroupIds();
    // Return a reference to the modifiable "LeastRecentlyUsedGroupIds"
    // attribute of this object.

    bsl::vector<ClientMsgGroupsCount>& numMsgGroupsPerClient();
    // Return a reference to the modifiable "NumMsgGroupsPerClient"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<LeastRecentlyUsedGroupId>&
    leastRecentlyUsedGroupIds() const;
    // Return a reference offering non-modifiable access to the
    // "LeastRecentlyUsedGroupIds" attribute of this object.

    const bsl::vector<ClientMsgGroupsCount>& numMsgGroupsPerClient() const;
    // Return a reference offering non-modifiable access to the
    // "NumMsgGroupsPerClient" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const MessageGroupIdManagerIndex& lhs,
                           const MessageGroupIdManagerIndex& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.leastRecentlyUsedGroupIds() ==
                   rhs.leastRecentlyUsedGroupIds() &&
               lhs.numMsgGroupsPerClient() == rhs.numMsgGroupsPerClient();
    }

    friend bool operator!=(const MessageGroupIdManagerIndex& lhs,
                           const MessageGroupIdManagerIndex& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                     stream,
                                    const MessageGroupIdManagerIndex& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                 hashAlg,
                           const MessageGroupIdManagerIndex& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'MessageGroupIdManagerIndex'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.leastRecentlyUsedGroupIds());
        hashAppend(hashAlg, object.numMsgGroupsPerClient());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::MessageGroupIdManagerIndex)

namespace mqbcmd {

// ===================
// class PartitionInfo
// ===================

class PartitionInfo {
    // INSTANCE DATA
    bdlb::NullableValue<bsl::string> d_primaryNode;
    unsigned int                     d_primaryLeaseId;
    int                              d_numQueuesMapped;
    int                              d_numActiveQueues;
    PrimaryStatus::Value             d_primaryStatus;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const PartitionInfo& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NUM_QUEUES_MAPPED = 0,
        ATTRIBUTE_ID_NUM_ACTIVE_QUEUES = 1,
        ATTRIBUTE_ID_PRIMARY_NODE      = 2,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID  = 3,
        ATTRIBUTE_ID_PRIMARY_STATUS    = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_NUM_QUEUES_MAPPED = 0,
        ATTRIBUTE_INDEX_NUM_ACTIVE_QUEUES = 1,
        ATTRIBUTE_INDEX_PRIMARY_NODE      = 2,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID  = 3,
        ATTRIBUTE_INDEX_PRIMARY_STATUS    = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit PartitionInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PartitionInfo' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    PartitionInfo(const PartitionInfo& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'PartitionInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionInfo(PartitionInfo&& original) noexcept;
    // Create an object of type 'PartitionInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    PartitionInfo(PartitionInfo&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'PartitionInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~PartitionInfo();
    // Destroy this object.

    // MANIPULATORS
    PartitionInfo& operator=(const PartitionInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionInfo& operator=(PartitionInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& numQueuesMapped();
    // Return a reference to the modifiable "NumQueuesMapped" attribute of
    // this object.

    int& numActiveQueues();
    // Return a reference to the modifiable "NumActiveQueues" attribute of
    // this object.

    bdlb::NullableValue<bsl::string>& primaryNode();
    // Return a reference to the modifiable "PrimaryNode" attribute of this
    // object.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    PrimaryStatus::Value& primaryStatus();
    // Return a reference to the modifiable "PrimaryStatus" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int numQueuesMapped() const;
    // Return the value of the "NumQueuesMapped" attribute of this object.

    int numActiveQueues() const;
    // Return the value of the "NumActiveQueues" attribute of this object.

    const bdlb::NullableValue<bsl::string>& primaryNode() const;
    // Return a reference offering non-modifiable access to the
    // "PrimaryNode" attribute of this object.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    PrimaryStatus::Value primaryStatus() const;
    // Return the value of the "PrimaryStatus" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionInfo& lhs, const PartitionInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const PartitionInfo& lhs, const PartitionInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const PartitionInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const PartitionInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::PartitionInfo)

namespace mqbcmd {

// ======================
// class PurgeQueueResult
// ======================

class PurgeQueueResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>              d_error;
        bsls::ObjectBuffer<PurgedQueueDetails> d_queue;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const PurgeQueueResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED = -1,
        SELECTION_ID_ERROR     = 0,
        SELECTION_ID_QUEUE     = 1
    };

    enum { NUM_SELECTIONS = 2 };

    enum { SELECTION_INDEX_ERROR = 0, SELECTION_INDEX_QUEUE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit PurgeQueueResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PurgeQueueResult' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    PurgeQueueResult(const PurgeQueueResult& original,
                     bslma::Allocator*       basicAllocator = 0);
    // Create an object of type 'PurgeQueueResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgeQueueResult(PurgeQueueResult&& original) noexcept;
    // Create an object of type 'PurgeQueueResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    PurgeQueueResult(PurgeQueueResult&& original,
                     bslma::Allocator*  basicAllocator);
    // Create an object of type 'PurgeQueueResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~PurgeQueueResult();
    // Destroy this object.

    // MANIPULATORS
    PurgeQueueResult& operator=(const PurgeQueueResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgeQueueResult& operator=(PurgeQueueResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    PurgedQueueDetails& makeQueue();
    PurgedQueueDetails& makeQueue(const PurgedQueueDetails& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueueDetails& makeQueue(PurgedQueueDetails&& value);
#endif
    // Set the value of this object to be a "Queue" value.  Optionally
    // specify the 'value' of the "Queue".  If 'value' is not specified,
    // the default "Queue" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    PurgedQueueDetails& queue();
    // Return a reference to the modifiable "Queue" selection of this
    // object if "Queue" is the current selection.  The behavior is
    // undefined unless "Queue" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const PurgedQueueDetails& queue() const;
    // Return a reference to the non-modifiable "Queue" selection of this
    // object if "Queue" is the current selection.  The behavior is
    // undefined unless "Queue" is the selection of this object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isQueueValue() const;
    // Return 'true' if the value of this object is a "Queue" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PurgeQueueResult& lhs,
                           const PurgeQueueResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'PurgeQueueResult' objects have
    // the same value if either the selections in both objects have the
    // same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const PurgeQueueResult& lhs,
                           const PurgeQueueResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const PurgeQueueResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const PurgeQueueResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PurgeQueueResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::PurgeQueueResult)

namespace mqbcmd {

// ==================
// class QueueCommand
// ==================

class QueueCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<bsl::string> d_purgeAppId;
        // The special value "*" indicates the entire queue.
        bsls::ObjectBuffer<Void>         d_internals;
        bsls::ObjectBuffer<ListMessages> d_messages;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED    = -1,
        SELECTION_ID_PURGE_APP_ID = 0,
        SELECTION_ID_INTERNALS    = 1,
        SELECTION_ID_MESSAGES     = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_PURGE_APP_ID = 0,
        SELECTION_INDEX_INTERNALS    = 1,
        SELECTION_INDEX_MESSAGES     = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueCommand' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueCommand(const QueueCommand& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'QueueCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueCommand(QueueCommand&& original) noexcept;
    // Create an object of type 'QueueCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueCommand(QueueCommand&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueCommand();
    // Destroy this object.

    // MANIPULATORS
    QueueCommand& operator=(const QueueCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueCommand& operator=(QueueCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    bsl::string& makePurgeAppId();
    bsl::string& makePurgeAppId(const bsl::string& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bsl::string& makePurgeAppId(bsl::string&& value);
#endif
    // Set the value of this object to be a "PurgeAppId" value.  Optionally
    // specify the 'value' of the "PurgeAppId".  If 'value' is not
    // specified, the default "PurgeAppId" value is used.

    Void& makeInternals();
    Void& makeInternals(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeInternals(Void&& value);
#endif
    // Set the value of this object to be a "Internals" value.  Optionally
    // specify the 'value' of the "Internals".  If 'value' is not
    // specified, the default "Internals" value is used.

    ListMessages& makeMessages();
    ListMessages& makeMessages(const ListMessages& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ListMessages& makeMessages(ListMessages&& value);
#endif
    // Set the value of this object to be a "Messages" value.  Optionally
    // specify the 'value' of the "Messages".  If 'value' is not specified,
    // the default "Messages" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    bsl::string& purgeAppId();
    // Return a reference to the modifiable "PurgeAppId" selection of this
    // object if "PurgeAppId" is the current selection.  The behavior is
    // undefined unless "PurgeAppId" is the selection of this object.

    Void& internals();
    // Return a reference to the modifiable "Internals" selection of this
    // object if "Internals" is the current selection.  The behavior is
    // undefined unless "Internals" is the selection of this object.

    ListMessages& messages();
    // Return a reference to the modifiable "Messages" selection of this
    // object if "Messages" is the current selection.  The behavior is
    // undefined unless "Messages" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const bsl::string& purgeAppId() const;
    // Return a reference to the non-modifiable "PurgeAppId" selection of
    // this object if "PurgeAppId" is the current selection.  The behavior
    // is undefined unless "PurgeAppId" is the selection of this object.

    const Void& internals() const;
    // Return a reference to the non-modifiable "Internals" selection of
    // this object if "Internals" is the current selection.  The behavior
    // is undefined unless "Internals" is the selection of this object.

    const ListMessages& messages() const;
    // Return a reference to the non-modifiable "Messages" selection of
    // this object if "Messages" is the current selection.  The behavior is
    // undefined unless "Messages" is the selection of this object.

    bool isPurgeAppIdValue() const;
    // Return 'true' if the value of this object is a "PurgeAppId" value,
    // and return 'false' otherwise.

    bool isInternalsValue() const;
    // Return 'true' if the value of this object is a "Internals" value,
    // and return 'false' otherwise.

    bool isMessagesValue() const;
    // Return 'true' if the value of this object is a "Messages" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueCommand& lhs, const QueueCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'QueueCommand' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueCommand& lhs, const QueueCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const QueueCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const QueueCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::QueueCommand)

namespace mqbcmd {

// ===================
// class QueueContents
// ===================

class QueueContents {
    // INSTANCE DATA
    bsls::Types::Int64   d_offset;
    bsls::Types::Int64   d_totalQueueMessages;
    bsl::vector<Message> d_messages;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_MESSAGES             = 0,
        ATTRIBUTE_ID_OFFSET               = 1,
        ATTRIBUTE_ID_TOTAL_QUEUE_MESSAGES = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_MESSAGES             = 0,
        ATTRIBUTE_INDEX_OFFSET               = 1,
        ATTRIBUTE_INDEX_TOTAL_QUEUE_MESSAGES = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueContents(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueContents' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueContents(const QueueContents& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'QueueContents' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueContents(QueueContents&& original) noexcept;
    // Create an object of type 'QueueContents' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueContents(QueueContents&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueContents' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueContents();
    // Destroy this object.

    // MANIPULATORS
    QueueContents& operator=(const QueueContents& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueContents& operator=(QueueContents&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<Message>& messages();
    // Return a reference to the modifiable "Messages" attribute of this
    // object.

    bsls::Types::Int64& offset();
    // Return a reference to the modifiable "Offset" attribute of this
    // object.

    bsls::Types::Int64& totalQueueMessages();
    // Return a reference to the modifiable "TotalQueueMessages" attribute
    // of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<Message>& messages() const;
    // Return a reference offering non-modifiable access to the "Messages"
    // attribute of this object.

    bsls::Types::Int64 offset() const;
    // Return the value of the "Offset" attribute of this object.

    bsls::Types::Int64 totalQueueMessages() const;
    // Return the value of the "TotalQueueMessages" attribute of this
    // object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueContents& lhs, const QueueContents& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.messages() == rhs.messages() &&
               lhs.offset() == rhs.offset() &&
               lhs.totalQueueMessages() == rhs.totalQueueMessages();
    }

    friend bool operator!=(const QueueContents& lhs, const QueueContents& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const QueueContents& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const QueueContents& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueContents'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::QueueContents)

namespace mqbcmd {

// ==================
// class QueueStorage
// ==================

class QueueStorage {
    // INSTANCE DATA
    bsl::vector<VirtualStorage> d_virtualStorages;
    unsigned int                d_numMessages;
    unsigned int                d_numBytes;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NUM_MESSAGES     = 0,
        ATTRIBUTE_ID_NUM_BYTES        = 1,
        ATTRIBUTE_ID_VIRTUAL_STORAGES = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_NUM_MESSAGES     = 0,
        ATTRIBUTE_INDEX_NUM_BYTES        = 1,
        ATTRIBUTE_INDEX_VIRTUAL_STORAGES = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueStorage(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueStorage' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueStorage(const QueueStorage& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'QueueStorage' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueStorage(QueueStorage&& original) noexcept;
    // Create an object of type 'QueueStorage' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueStorage(QueueStorage&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueStorage' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueStorage();
    // Destroy this object.

    // MANIPULATORS
    QueueStorage& operator=(const QueueStorage& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueStorage& operator=(QueueStorage&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& numMessages();
    // Return a reference to the modifiable "NumMessages" attribute of this
    // object.

    unsigned int& numBytes();
    // Return a reference to the modifiable "NumBytes" attribute of this
    // object.

    bsl::vector<VirtualStorage>& virtualStorages();
    // Return a reference to the modifiable "VirtualStorages" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int numMessages() const;
    // Return the value of the "NumMessages" attribute of this object.

    unsigned int numBytes() const;
    // Return the value of the "NumBytes" attribute of this object.

    const bsl::vector<VirtualStorage>& virtualStorages() const;
    // Return a reference offering non-modifiable access to the
    // "VirtualStorages" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueStorage& lhs, const QueueStorage& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.numMessages() == rhs.numMessages() &&
               lhs.numBytes() == rhs.numBytes() &&
               lhs.virtualStorages() == rhs.virtualStorages();
    }

    friend bool operator!=(const QueueStorage& lhs, const QueueStorage& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const QueueStorage& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const QueueStorage& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueStorage'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::QueueStorage)

namespace mqbcmd {

// ==========================
// class ResourceUsageMonitor
// ==========================

class ResourceUsageMonitor {
    // INSTANCE DATA
    bsls::Types::Int64               d_numMessages;
    bsls::Types::Int64               d_messagesLowWatermarkRatio;
    bsls::Types::Int64               d_messagesHighWatermarkRatio;
    bsls::Types::Int64               d_messagesCapacity;
    bsls::Types::Int64               d_numBytes;
    bsls::Types::Int64               d_bytesLowWatermarkRatio;
    bsls::Types::Int64               d_bytesHighWatermarkRatio;
    bsls::Types::Int64               d_bytesCapacity;
    ResourceUsageMonitorState::Value d_state;
    ResourceUsageMonitorState::Value d_messagesState;
    ResourceUsageMonitorState::Value d_bytesState;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ResourceUsageMonitor& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_STATE                         = 0,
        ATTRIBUTE_ID_MESSAGES_STATE                = 1,
        ATTRIBUTE_ID_NUM_MESSAGES                  = 2,
        ATTRIBUTE_ID_MESSAGES_LOW_WATERMARK_RATIO  = 3,
        ATTRIBUTE_ID_MESSAGES_HIGH_WATERMARK_RATIO = 4,
        ATTRIBUTE_ID_MESSAGES_CAPACITY             = 5,
        ATTRIBUTE_ID_BYTES_STATE                   = 6,
        ATTRIBUTE_ID_NUM_BYTES                     = 7,
        ATTRIBUTE_ID_BYTES_LOW_WATERMARK_RATIO     = 8,
        ATTRIBUTE_ID_BYTES_HIGH_WATERMARK_RATIO    = 9,
        ATTRIBUTE_ID_BYTES_CAPACITY                = 10
    };

    enum { NUM_ATTRIBUTES = 11 };

    enum {
        ATTRIBUTE_INDEX_STATE                         = 0,
        ATTRIBUTE_INDEX_MESSAGES_STATE                = 1,
        ATTRIBUTE_INDEX_NUM_MESSAGES                  = 2,
        ATTRIBUTE_INDEX_MESSAGES_LOW_WATERMARK_RATIO  = 3,
        ATTRIBUTE_INDEX_MESSAGES_HIGH_WATERMARK_RATIO = 4,
        ATTRIBUTE_INDEX_MESSAGES_CAPACITY             = 5,
        ATTRIBUTE_INDEX_BYTES_STATE                   = 6,
        ATTRIBUTE_INDEX_NUM_BYTES                     = 7,
        ATTRIBUTE_INDEX_BYTES_LOW_WATERMARK_RATIO     = 8,
        ATTRIBUTE_INDEX_BYTES_HIGH_WATERMARK_RATIO    = 9,
        ATTRIBUTE_INDEX_BYTES_CAPACITY                = 10
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    ResourceUsageMonitor();
    // Create an object of type 'ResourceUsageMonitor' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    ResourceUsageMonitorState::Value& state();
    // Return a reference to the modifiable "State" attribute of this
    // object.

    ResourceUsageMonitorState::Value& messagesState();
    // Return a reference to the modifiable "MessagesState" attribute of
    // this object.

    bsls::Types::Int64& numMessages();
    // Return a reference to the modifiable "NumMessages" attribute of this
    // object.

    bsls::Types::Int64& messagesLowWatermarkRatio();
    // Return a reference to the modifiable "MessagesLowWatermarkRatio"
    // attribute of this object.

    bsls::Types::Int64& messagesHighWatermarkRatio();
    // Return a reference to the modifiable "MessagesHighWatermarkRatio"
    // attribute of this object.

    bsls::Types::Int64& messagesCapacity();
    // Return a reference to the modifiable "MessagesCapacity" attribute of
    // this object.

    ResourceUsageMonitorState::Value& bytesState();
    // Return a reference to the modifiable "BytesState" attribute of this
    // object.

    bsls::Types::Int64& numBytes();
    // Return a reference to the modifiable "NumBytes" attribute of this
    // object.

    bsls::Types::Int64& bytesLowWatermarkRatio();
    // Return a reference to the modifiable "BytesLowWatermarkRatio"
    // attribute of this object.

    bsls::Types::Int64& bytesHighWatermarkRatio();
    // Return a reference to the modifiable "BytesHighWatermarkRatio"
    // attribute of this object.

    bsls::Types::Int64& bytesCapacity();
    // Return a reference to the modifiable "BytesCapacity" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    ResourceUsageMonitorState::Value state() const;
    // Return the value of the "State" attribute of this object.

    ResourceUsageMonitorState::Value messagesState() const;
    // Return the value of the "MessagesState" attribute of this object.

    bsls::Types::Int64 numMessages() const;
    // Return the value of the "NumMessages" attribute of this object.

    bsls::Types::Int64 messagesLowWatermarkRatio() const;
    // Return the value of the "MessagesLowWatermarkRatio" attribute of
    // this object.

    bsls::Types::Int64 messagesHighWatermarkRatio() const;
    // Return the value of the "MessagesHighWatermarkRatio" attribute of
    // this object.

    bsls::Types::Int64 messagesCapacity() const;
    // Return the value of the "MessagesCapacity" attribute of this object.

    ResourceUsageMonitorState::Value bytesState() const;
    // Return the value of the "BytesState" attribute of this object.

    bsls::Types::Int64 numBytes() const;
    // Return the value of the "NumBytes" attribute of this object.

    bsls::Types::Int64 bytesLowWatermarkRatio() const;
    // Return the value of the "BytesLowWatermarkRatio" attribute of this
    // object.

    bsls::Types::Int64 bytesHighWatermarkRatio() const;
    // Return the value of the "BytesHighWatermarkRatio" attribute of this
    // object.

    bsls::Types::Int64 bytesCapacity() const;
    // Return the value of the "BytesCapacity" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ResourceUsageMonitor& lhs,
                           const ResourceUsageMonitor& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ResourceUsageMonitor& lhs,
                           const ResourceUsageMonitor& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const ResourceUsageMonitor& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const ResourceUsageMonitor& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ResourceUsageMonitor'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::ResourceUsageMonitor)

namespace mqbcmd {

// =======================
// class RouteResponseList
// =======================

class RouteResponseList {
    // Contains a single array of all responses from a routed command.

    // INSTANCE DATA
    bsl::vector<RouteResponse> d_responses;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_RESPONSES = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_RESPONSES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RouteResponseList(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RouteResponseList' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    RouteResponseList(const RouteResponseList& original,
                      bslma::Allocator*        basicAllocator = 0);
    // Create an object of type 'RouteResponseList' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouteResponseList(RouteResponseList&& original) noexcept;
    // Create an object of type 'RouteResponseList' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    RouteResponseList(RouteResponseList&& original,
                      bslma::Allocator*   basicAllocator);
    // Create an object of type 'RouteResponseList' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~RouteResponseList();
    // Destroy this object.

    // MANIPULATORS
    RouteResponseList& operator=(const RouteResponseList& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouteResponseList& operator=(RouteResponseList&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<RouteResponse>& responses();
    // Return a reference to the modifiable "Responses" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<RouteResponse>& responses() const;
    // Return a reference offering non-modifiable access to the "Responses"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RouteResponseList& lhs,
                           const RouteResponseList& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.responses() == rhs.responses();
    }

    friend bool operator!=(const RouteResponseList& lhs,
                           const RouteResponseList& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const RouteResponseList& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const RouteResponseList& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RouteResponseList'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.responses());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RouteResponseList)

namespace mqbcmd {

// ======================
// class SetTunableChoice
// ======================

class SetTunableChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void> d_all;
        bsls::ObjectBuffer<Void> d_self;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const SetTunableChoice& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED = -1,
        SELECTION_ID_ALL       = 0,
        SELECTION_ID_SELF      = 1
    };

    enum { NUM_SELECTIONS = 2 };

    enum { SELECTION_INDEX_ALL = 0, SELECTION_INDEX_SELF = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    SetTunableChoice();
    // Create an object of type 'SetTunableChoice' having the default
    // value.

    SetTunableChoice(const SetTunableChoice& original);
    // Create an object of type 'SetTunableChoice' having the value of the
    // specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SetTunableChoice(SetTunableChoice&& original) noexcept;
    // Create an object of type 'SetTunableChoice' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
#endif

    ~SetTunableChoice();
    // Destroy this object.

    // MANIPULATORS
    SetTunableChoice& operator=(const SetTunableChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SetTunableChoice& operator=(SetTunableChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeAll();
    Void& makeAll(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeAll(Void&& value);
#endif
    // Set the value of this object to be a "All" value.  Optionally
    // specify the 'value' of the "All".  If 'value' is not specified, the
    // default "All" value is used.

    Void& makeSelf();
    Void& makeSelf(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSelf(Void&& value);
#endif
    // Set the value of this object to be a "Self" value.  Optionally
    // specify the 'value' of the "Self".  If 'value' is not specified, the
    // default "Self" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& all();
    // Return a reference to the modifiable "All" selection of this object
    // if "All" is the current selection.  The behavior is undefined unless
    // "All" is the selection of this object.

    Void& self();
    // Return a reference to the modifiable "Self" selection of this object
    // if "Self" is the current selection.  The behavior is undefined
    // unless "Self" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& all() const;
    // Return a reference to the non-modifiable "All" selection of this
    // object if "All" is the current selection.  The behavior is undefined
    // unless "All" is the selection of this object.

    const Void& self() const;
    // Return a reference to the non-modifiable "Self" selection of this
    // object if "Self" is the current selection.  The behavior is
    // undefined unless "Self" is the selection of this object.

    bool isAllValue() const;
    // Return 'true' if the value of this object is a "All" value, and
    // return 'false' otherwise.

    bool isSelfValue() const;
    // Return 'true' if the value of this object is a "Self" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const SetTunableChoice& lhs,
                           const SetTunableChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'SetTunableChoice' objects have
    // the same value if either the selections in both objects have the
    // same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const SetTunableChoice& lhs,
                           const SetTunableChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const SetTunableChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const SetTunableChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'SetTunableChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::SetTunableChoice)

namespace mqbcmd {

// ====================
// class StorageContent
// ====================

class StorageContent {
    // INSTANCE DATA
    bsl::vector<StorageQueueInfo> d_storages;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_STORAGES = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_STORAGES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit StorageContent(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StorageContent' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StorageContent(const StorageContent& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'StorageContent' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageContent(StorageContent&& original) noexcept;
    // Create an object of type 'StorageContent' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StorageContent(StorageContent&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'StorageContent' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StorageContent();
    // Destroy this object.

    // MANIPULATORS
    StorageContent& operator=(const StorageContent& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageContent& operator=(StorageContent&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<StorageQueueInfo>& storages();
    // Return a reference to the modifiable "Storages" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<StorageQueueInfo>& storages() const;
    // Return a reference offering non-modifiable access to the "Storages"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageContent& lhs,
                           const StorageContent& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.storages() == rhs.storages();
    }

    friend bool operator!=(const StorageContent& lhs,
                           const StorageContent& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const StorageContent& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const StorageContent& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageContent'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.storages());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::StorageContent)

namespace mqbcmd {

// ==========================
// class StorageDomainCommand
// ==========================

class StorageDomainCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void> d_queueStatus;
        bsls::ObjectBuffer<Void> d_purge;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StorageDomainCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED    = -1,
        SELECTION_ID_QUEUE_STATUS = 0,
        SELECTION_ID_PURGE        = 1
    };

    enum { NUM_SELECTIONS = 2 };

    enum { SELECTION_INDEX_QUEUE_STATUS = 0, SELECTION_INDEX_PURGE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    StorageDomainCommand();
    // Create an object of type 'StorageDomainCommand' having the default
    // value.

    StorageDomainCommand(const StorageDomainCommand& original);
    // Create an object of type 'StorageDomainCommand' having the value of
    // the specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageDomainCommand(StorageDomainCommand&& original) noexcept;
    // Create an object of type 'StorageDomainCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
#endif

    ~StorageDomainCommand();
    // Destroy this object.

    // MANIPULATORS
    StorageDomainCommand& operator=(const StorageDomainCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageDomainCommand& operator=(StorageDomainCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeQueueStatus();
    Void& makeQueueStatus(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeQueueStatus(Void&& value);
#endif
    // Set the value of this object to be a "QueueStatus" value.
    // Optionally specify the 'value' of the "QueueStatus".  If 'value' is
    // not specified, the default "QueueStatus" value is used.

    Void& makePurge();
    Void& makePurge(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makePurge(Void&& value);
#endif
    // Set the value of this object to be a "Purge" value.  Optionally
    // specify the 'value' of the "Purge".  If 'value' is not specified,
    // the default "Purge" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& queueStatus();
    // Return a reference to the modifiable "QueueStatus" selection of this
    // object if "QueueStatus" is the current selection.  The behavior is
    // undefined unless "QueueStatus" is the selection of this object.

    Void& purge();
    // Return a reference to the modifiable "Purge" selection of this
    // object if "Purge" is the current selection.  The behavior is
    // undefined unless "Purge" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& queueStatus() const;
    // Return a reference to the non-modifiable "QueueStatus" selection of
    // this object if "QueueStatus" is the current selection.  The behavior
    // is undefined unless "QueueStatus" is the selection of this object.

    const Void& purge() const;
    // Return a reference to the non-modifiable "Purge" selection of this
    // object if "Purge" is the current selection.  The behavior is
    // undefined unless "Purge" is the selection of this object.

    bool isQueueStatusValue() const;
    // Return 'true' if the value of this object is a "QueueStatus" value,
    // and return 'false' otherwise.

    bool isPurgeValue() const;
    // Return 'true' if the value of this object is a "Purge" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageDomainCommand& lhs,
                           const StorageDomainCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'StorageDomainCommand' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StorageDomainCommand& lhs,
                           const StorageDomainCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const StorageDomainCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const StorageDomainCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageDomainCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::StorageDomainCommand)

namespace mqbcmd {

// =============================
// class StoragePartitionCommand
// =============================

class StoragePartitionCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void> d_enable;
        bsls::ObjectBuffer<Void> d_disable;
        bsls::ObjectBuffer<Void> d_summary;
    };

    int d_selectionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StoragePartitionCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED = -1,
        SELECTION_ID_ENABLE    = 0,
        SELECTION_ID_DISABLE   = 1,
        SELECTION_ID_SUMMARY   = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_ENABLE  = 0,
        SELECTION_INDEX_DISABLE = 1,
        SELECTION_INDEX_SUMMARY = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    StoragePartitionCommand();
    // Create an object of type 'StoragePartitionCommand' having the
    // default value.

    StoragePartitionCommand(const StoragePartitionCommand& original);
    // Create an object of type 'StoragePartitionCommand' having the value
    // of the specified 'original' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StoragePartitionCommand(StoragePartitionCommand&& original) noexcept;
    // Create an object of type 'StoragePartitionCommand' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.
#endif

    ~StoragePartitionCommand();
    // Destroy this object.

    // MANIPULATORS
    StoragePartitionCommand& operator=(const StoragePartitionCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StoragePartitionCommand& operator=(StoragePartitionCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeEnable();
    Void& makeEnable(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeEnable(Void&& value);
#endif
    // Set the value of this object to be a "Enable" value.  Optionally
    // specify the 'value' of the "Enable".  If 'value' is not specified,
    // the default "Enable" value is used.

    Void& makeDisable();
    Void& makeDisable(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeDisable(Void&& value);
#endif
    // Set the value of this object to be a "Disable" value.  Optionally
    // specify the 'value' of the "Disable".  If 'value' is not specified,
    // the default "Disable" value is used.

    Void& makeSummary();
    Void& makeSummary(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSummary(Void&& value);
#endif
    // Set the value of this object to be a "Summary" value.  Optionally
    // specify the 'value' of the "Summary".  If 'value' is not specified,
    // the default "Summary" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& enable();
    // Return a reference to the modifiable "Enable" selection of this
    // object if "Enable" is the current selection.  The behavior is
    // undefined unless "Enable" is the selection of this object.

    Void& disable();
    // Return a reference to the modifiable "Disable" selection of this
    // object if "Disable" is the current selection.  The behavior is
    // undefined unless "Disable" is the selection of this object.

    Void& summary();
    // Return a reference to the modifiable "Summary" selection of this
    // object if "Summary" is the current selection.  The behavior is
    // undefined unless "Summary" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& enable() const;
    // Return a reference to the non-modifiable "Enable" selection of this
    // object if "Enable" is the current selection.  The behavior is
    // undefined unless "Enable" is the selection of this object.

    const Void& disable() const;
    // Return a reference to the non-modifiable "Disable" selection of this
    // object if "Disable" is the current selection.  The behavior is
    // undefined unless "Disable" is the selection of this object.

    const Void& summary() const;
    // Return a reference to the non-modifiable "Summary" selection of this
    // object if "Summary" is the current selection.  The behavior is
    // undefined unless "Summary" is the selection of this object.

    bool isEnableValue() const;
    // Return 'true' if the value of this object is a "Enable" value, and
    // return 'false' otherwise.

    bool isDisableValue() const;
    // Return 'true' if the value of this object is a "Disable" value, and
    // return 'false' otherwise.

    bool isSummaryValue() const;
    // Return 'true' if the value of this object is a "Summary" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StoragePartitionCommand& lhs,
                           const StoragePartitionCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'StoragePartitionCommand' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StoragePartitionCommand& lhs,
                           const StoragePartitionCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                  stream,
                                    const StoragePartitionCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&              hashAlg,
                           const StoragePartitionCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StoragePartitionCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::StoragePartitionCommand)

namespace mqbcmd {

// ==================
// class StorageQueue
// ==================

class StorageQueue {
    // INSTANCE DATA
    bsl::string         d_canonicalUri;
    StorageQueueCommand d_command;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CANONICAL_URI = 0, ATTRIBUTE_ID_COMMAND = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_CANONICAL_URI = 0, ATTRIBUTE_INDEX_COMMAND = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit StorageQueue(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StorageQueue' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StorageQueue(const StorageQueue& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'StorageQueue' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageQueue(StorageQueue&& original) noexcept;
    // Create an object of type 'StorageQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StorageQueue(StorageQueue&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'StorageQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StorageQueue();
    // Destroy this object.

    // MANIPULATORS
    StorageQueue& operator=(const StorageQueue& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageQueue& operator=(StorageQueue&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& canonicalUri();
    // Return a reference to the modifiable "CanonicalUri" attribute of
    // this object.

    StorageQueueCommand& command();
    // Return a reference to the modifiable "Command" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& canonicalUri() const;
    // Return a reference offering non-modifiable access to the
    // "CanonicalUri" attribute of this object.

    const StorageQueueCommand& command() const;
    // Return a reference offering non-modifiable access to the "Command"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageQueue& lhs, const StorageQueue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.canonicalUri() == rhs.canonicalUri() &&
               lhs.command() == rhs.command();
    }

    friend bool operator!=(const StorageQueue& lhs, const StorageQueue& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const StorageQueue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const StorageQueue& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageQueue'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.canonicalUri());
        hashAppend(hashAlg, object.command());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::StorageQueue)

namespace mqbcmd {

// ==================
// class Subscription
// ==================

class Subscription {
    // INSTANCE DATA
    Subscriber   d_subscriber;
    ConsumerInfo d_consumer;
    unsigned int d_downstreamSubscriptionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_DOWNSTREAM_SUBSCRIPTION_ID = 0,
        ATTRIBUTE_ID_CONSUMER                   = 1,
        ATTRIBUTE_ID_SUBSCRIBER                 = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_DOWNSTREAM_SUBSCRIPTION_ID = 0,
        ATTRIBUTE_INDEX_CONSUMER                   = 1,
        ATTRIBUTE_INDEX_SUBSCRIBER                 = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    Subscription();
    // Create an object of type 'Subscription' having the default value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& downstreamSubscriptionId();
    // Return a reference to the modifiable "DownstreamSubscriptionId"
    // attribute of this object.

    ConsumerInfo& consumer();
    // Return a reference to the modifiable "Consumer" attribute of this
    // object.

    Subscriber& subscriber();
    // Return a reference to the modifiable "Subscriber" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int downstreamSubscriptionId() const;
    // Return the value of the "DownstreamSubscriptionId" attribute of this
    // object.

    const ConsumerInfo& consumer() const;
    // Return a reference offering non-modifiable access to the "Consumer"
    // attribute of this object.

    const Subscriber& subscriber() const;
    // Return a reference offering non-modifiable access to the
    // "Subscriber" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Subscription& lhs, const Subscription& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.downstreamSubscriptionId() ==
                   rhs.downstreamSubscriptionId() &&
               lhs.consumer() == rhs.consumer() &&
               lhs.subscriber() == rhs.subscriber();
    }

    friend bool operator!=(const Subscription& lhs, const Subscription& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const Subscription& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const Subscription& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'Subscription'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::Subscription)

namespace mqbcmd {

// ===========
// class Value
// ===========

class Value {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>               d_theNull;
        bsls::ObjectBuffer<bool>               d_theBool;
        bsls::ObjectBuffer<bsls::Types::Int64> d_theInteger;
        bsls::ObjectBuffer<double>             d_theDouble;
        bsls::ObjectBuffer<bdlt::DateTz>       d_theDate;
        bsls::ObjectBuffer<bdlt::TimeTz>       d_theTime;
        bsls::ObjectBuffer<bdlt::DatetimeTz>   d_theDatetime;
        bsls::ObjectBuffer<bsl::string>        d_theString;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const Value& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED    = -1,
        SELECTION_ID_THE_NULL     = 0,
        SELECTION_ID_THE_BOOL     = 1,
        SELECTION_ID_THE_INTEGER  = 2,
        SELECTION_ID_THE_DOUBLE   = 3,
        SELECTION_ID_THE_DATE     = 4,
        SELECTION_ID_THE_TIME     = 5,
        SELECTION_ID_THE_DATETIME = 6,
        SELECTION_ID_THE_STRING   = 7
    };

    enum { NUM_SELECTIONS = 8 };

    enum {
        SELECTION_INDEX_THE_NULL     = 0,
        SELECTION_INDEX_THE_BOOL     = 1,
        SELECTION_INDEX_THE_INTEGER  = 2,
        SELECTION_INDEX_THE_DOUBLE   = 3,
        SELECTION_INDEX_THE_DATE     = 4,
        SELECTION_INDEX_THE_TIME     = 5,
        SELECTION_INDEX_THE_DATETIME = 6,
        SELECTION_INDEX_THE_STRING   = 7
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit Value(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Value' having the default value.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Value(const Value& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Value' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Value(Value&& original) noexcept;
    // Create an object of type 'Value' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Value(Value&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Value' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Value();
    // Destroy this object.

    // MANIPULATORS
    Value& operator=(const Value& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Value& operator=(Value&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeTheNull();
    Void& makeTheNull(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeTheNull(Void&& value);
#endif
    // Set the value of this object to be a "TheNull" value.  Optionally
    // specify the 'value' of the "TheNull".  If 'value' is not specified,
    // the default "TheNull" value is used.

    bool& makeTheBool();
    bool& makeTheBool(bool value);
    // Set the value of this object to be a "TheBool" value.  Optionally
    // specify the 'value' of the "TheBool".  If 'value' is not specified,
    // the default "TheBool" value is used.

    bsls::Types::Int64& makeTheInteger();
    bsls::Types::Int64& makeTheInteger(bsls::Types::Int64 value);
    // Set the value of this object to be a "TheInteger" value.  Optionally
    // specify the 'value' of the "TheInteger".  If 'value' is not
    // specified, the default "TheInteger" value is used.

    double& makeTheDouble();
    double& makeTheDouble(double value);
    // Set the value of this object to be a "TheDouble" value.  Optionally
    // specify the 'value' of the "TheDouble".  If 'value' is not
    // specified, the default "TheDouble" value is used.

    bdlt::DateTz& makeTheDate();
    bdlt::DateTz& makeTheDate(const bdlt::DateTz& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bdlt::DateTz& makeTheDate(bdlt::DateTz&& value);
#endif
    // Set the value of this object to be a "TheDate" value.  Optionally
    // specify the 'value' of the "TheDate".  If 'value' is not specified,
    // the default "TheDate" value is used.

    bdlt::TimeTz& makeTheTime();
    bdlt::TimeTz& makeTheTime(const bdlt::TimeTz& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bdlt::TimeTz& makeTheTime(bdlt::TimeTz&& value);
#endif
    // Set the value of this object to be a "TheTime" value.  Optionally
    // specify the 'value' of the "TheTime".  If 'value' is not specified,
    // the default "TheTime" value is used.

    bdlt::DatetimeTz& makeTheDatetime();
    bdlt::DatetimeTz& makeTheDatetime(const bdlt::DatetimeTz& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bdlt::DatetimeTz& makeTheDatetime(bdlt::DatetimeTz&& value);
#endif
    // Set the value of this object to be a "TheDatetime" value.
    // Optionally specify the 'value' of the "TheDatetime".  If 'value' is
    // not specified, the default "TheDatetime" value is used.

    bsl::string& makeTheString();
    bsl::string& makeTheString(const bsl::string& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bsl::string& makeTheString(bsl::string&& value);
#endif
    // Set the value of this object to be a "TheString" value.  Optionally
    // specify the 'value' of the "TheString".  If 'value' is not
    // specified, the default "TheString" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& theNull();
    // Return a reference to the modifiable "TheNull" selection of this
    // object if "TheNull" is the current selection.  The behavior is
    // undefined unless "TheNull" is the selection of this object.

    bool& theBool();
    // Return a reference to the modifiable "TheBool" selection of this
    // object if "TheBool" is the current selection.  The behavior is
    // undefined unless "TheBool" is the selection of this object.

    bsls::Types::Int64& theInteger();
    // Return a reference to the modifiable "TheInteger" selection of this
    // object if "TheInteger" is the current selection.  The behavior is
    // undefined unless "TheInteger" is the selection of this object.

    double& theDouble();
    // Return a reference to the modifiable "TheDouble" selection of this
    // object if "TheDouble" is the current selection.  The behavior is
    // undefined unless "TheDouble" is the selection of this object.

    bdlt::DateTz& theDate();
    // Return a reference to the modifiable "TheDate" selection of this
    // object if "TheDate" is the current selection.  The behavior is
    // undefined unless "TheDate" is the selection of this object.

    bdlt::TimeTz& theTime();
    // Return a reference to the modifiable "TheTime" selection of this
    // object if "TheTime" is the current selection.  The behavior is
    // undefined unless "TheTime" is the selection of this object.

    bdlt::DatetimeTz& theDatetime();
    // Return a reference to the modifiable "TheDatetime" selection of this
    // object if "TheDatetime" is the current selection.  The behavior is
    // undefined unless "TheDatetime" is the selection of this object.

    bsl::string& theString();
    // Return a reference to the modifiable "TheString" selection of this
    // object if "TheString" is the current selection.  The behavior is
    // undefined unless "TheString" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& theNull() const;
    // Return a reference to the non-modifiable "TheNull" selection of this
    // object if "TheNull" is the current selection.  The behavior is
    // undefined unless "TheNull" is the selection of this object.

    const bool& theBool() const;
    // Return a reference to the non-modifiable "TheBool" selection of this
    // object if "TheBool" is the current selection.  The behavior is
    // undefined unless "TheBool" is the selection of this object.

    const bsls::Types::Int64& theInteger() const;
    // Return a reference to the non-modifiable "TheInteger" selection of
    // this object if "TheInteger" is the current selection.  The behavior
    // is undefined unless "TheInteger" is the selection of this object.

    const double& theDouble() const;
    // Return a reference to the non-modifiable "TheDouble" selection of
    // this object if "TheDouble" is the current selection.  The behavior
    // is undefined unless "TheDouble" is the selection of this object.

    const bdlt::DateTz& theDate() const;
    // Return a reference to the non-modifiable "TheDate" selection of this
    // object if "TheDate" is the current selection.  The behavior is
    // undefined unless "TheDate" is the selection of this object.

    const bdlt::TimeTz& theTime() const;
    // Return a reference to the non-modifiable "TheTime" selection of this
    // object if "TheTime" is the current selection.  The behavior is
    // undefined unless "TheTime" is the selection of this object.

    const bdlt::DatetimeTz& theDatetime() const;
    // Return a reference to the non-modifiable "TheDatetime" selection of
    // this object if "TheDatetime" is the current selection.  The behavior
    // is undefined unless "TheDatetime" is the selection of this object.

    const bsl::string& theString() const;
    // Return a reference to the non-modifiable "TheString" selection of
    // this object if "TheString" is the current selection.  The behavior
    // is undefined unless "TheString" is the selection of this object.

    bool isTheNullValue() const;
    // Return 'true' if the value of this object is a "TheNull" value, and
    // return 'false' otherwise.

    bool isTheBoolValue() const;
    // Return 'true' if the value of this object is a "TheBool" value, and
    // return 'false' otherwise.

    bool isTheIntegerValue() const;
    // Return 'true' if the value of this object is a "TheInteger" value,
    // and return 'false' otherwise.

    bool isTheDoubleValue() const;
    // Return 'true' if the value of this object is a "TheDouble" value,
    // and return 'false' otherwise.

    bool isTheDateValue() const;
    // Return 'true' if the value of this object is a "TheDate" value, and
    // return 'false' otherwise.

    bool isTheTimeValue() const;
    // Return 'true' if the value of this object is a "TheTime" value, and
    // return 'false' otherwise.

    bool isTheDatetimeValue() const;
    // Return 'true' if the value of this object is a "TheDatetime" value,
    // and return 'false' otherwise.

    bool isTheStringValue() const;
    // Return 'true' if the value of this object is a "TheString" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Value& lhs, const Value& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'Value' objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const Value& lhs, const Value& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Value& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Value& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Value'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Value)

namespace mqbcmd {

// =================
// class ClusterList
// =================

class ClusterList {
    // INSTANCE DATA
    bsl::vector<ClusterInfo> d_clusters;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CLUSTERS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CLUSTERS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterList(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterList' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterList(const ClusterList& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'ClusterList' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterList(ClusterList&& original) noexcept;
    // Create an object of type 'ClusterList' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterList(ClusterList&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterList' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterList();
    // Destroy this object.

    // MANIPULATORS
    ClusterList& operator=(const ClusterList& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterList& operator=(ClusterList&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<ClusterInfo>& clusters();
    // Return a reference to the modifiable "Clusters" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<ClusterInfo>& clusters() const;
    // Return a reference offering non-modifiable access to the "Clusters"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterList& lhs, const ClusterList& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clusters() == rhs.clusters();
    }

    friend bool operator!=(const ClusterList& lhs, const ClusterList& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const ClusterList& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const ClusterList& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'ClusterList'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.clusters());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ClusterList)

namespace mqbcmd {

// ========================
// class ClusterQueueHelper
// ========================

class ClusterQueueHelper {
    // INSTANCE DATA
    bsl::vector<ClusterQueue>  d_queues;
    bsl::vector<ClusterDomain> d_domains;
    bsl::string                d_clusterName;
    unsigned int               d_numQueues;
    unsigned int               d_numQueueKeys;
    unsigned int               d_numPendingReopenQueueRequests;
    Locality::Value            d_locality;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterQueueHelper& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CLUSTER_NAME                      = 0,
        ATTRIBUTE_ID_LOCALITY                          = 1,
        ATTRIBUTE_ID_NUM_QUEUES                        = 2,
        ATTRIBUTE_ID_NUM_QUEUE_KEYS                    = 3,
        ATTRIBUTE_ID_NUM_PENDING_REOPEN_QUEUE_REQUESTS = 4,
        ATTRIBUTE_ID_DOMAINS                           = 5,
        ATTRIBUTE_ID_QUEUES                            = 6
    };

    enum { NUM_ATTRIBUTES = 7 };

    enum {
        ATTRIBUTE_INDEX_CLUSTER_NAME                      = 0,
        ATTRIBUTE_INDEX_LOCALITY                          = 1,
        ATTRIBUTE_INDEX_NUM_QUEUES                        = 2,
        ATTRIBUTE_INDEX_NUM_QUEUE_KEYS                    = 3,
        ATTRIBUTE_INDEX_NUM_PENDING_REOPEN_QUEUE_REQUESTS = 4,
        ATTRIBUTE_INDEX_DOMAINS                           = 5,
        ATTRIBUTE_INDEX_QUEUES                            = 6
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterQueueHelper(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterQueueHelper' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ClusterQueueHelper(const ClusterQueueHelper& original,
                       bslma::Allocator*         basicAllocator = 0);
    // Create an object of type 'ClusterQueueHelper' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterQueueHelper(ClusterQueueHelper&& original) noexcept;
    // Create an object of type 'ClusterQueueHelper' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterQueueHelper(ClusterQueueHelper&& original,
                       bslma::Allocator*    basicAllocator);
    // Create an object of type 'ClusterQueueHelper' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterQueueHelper();
    // Destroy this object.

    // MANIPULATORS
    ClusterQueueHelper& operator=(const ClusterQueueHelper& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterQueueHelper& operator=(ClusterQueueHelper&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clusterName();
    // Return a reference to the modifiable "ClusterName" attribute of this
    // object.

    Locality::Value& locality();
    // Return a reference to the modifiable "Locality" attribute of this
    // object.

    unsigned int& numQueues();
    // Return a reference to the modifiable "NumQueues" attribute of this
    // object.

    unsigned int& numQueueKeys();
    // Return a reference to the modifiable "NumQueueKeys" attribute of
    // this object.

    unsigned int& numPendingReopenQueueRequests();
    // Return a reference to the modifiable "NumPendingReopenQueueRequests"
    // attribute of this object.

    bsl::vector<ClusterDomain>& domains();
    // Return a reference to the modifiable "Domains" attribute of this
    // object.

    bsl::vector<ClusterQueue>& queues();
    // Return a reference to the modifiable "Queues" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clusterName() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterName" attribute of this object.

    Locality::Value locality() const;
    // Return the value of the "Locality" attribute of this object.

    unsigned int numQueues() const;
    // Return the value of the "NumQueues" attribute of this object.

    unsigned int numQueueKeys() const;
    // Return the value of the "NumQueueKeys" attribute of this object.

    unsigned int numPendingReopenQueueRequests() const;
    // Return the value of the "NumPendingReopenQueueRequests" attribute of
    // this object.

    const bsl::vector<ClusterDomain>& domains() const;
    // Return a reference offering non-modifiable access to the "Domains"
    // attribute of this object.

    const bsl::vector<ClusterQueue>& queues() const;
    // Return a reference offering non-modifiable access to the "Queues"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterQueueHelper& lhs,
                           const ClusterQueueHelper& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterQueueHelper& lhs,
                           const ClusterQueueHelper& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const ClusterQueueHelper& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&         hashAlg,
                           const ClusterQueueHelper& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterQueueHelper'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClusterQueueHelper)

namespace mqbcmd {

// ===========================
// class ConfigProviderCommand
// ===========================

class ConfigProviderCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ClearCache> d_clearCache;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ConfigProviderCommand& rhs) const;

  public:
    // TYPES

    enum { SELECTION_ID_UNDEFINED = -1, SELECTION_ID_CLEAR_CACHE = 0 };

    enum { NUM_SELECTIONS = 1 };

    enum { SELECTION_INDEX_CLEAR_CACHE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ConfigProviderCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ConfigProviderCommand' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ConfigProviderCommand(const ConfigProviderCommand& original,
                          bslma::Allocator*            basicAllocator = 0);
    // Create an object of type 'ConfigProviderCommand' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigProviderCommand(ConfigProviderCommand&& original) noexcept;
    // Create an object of type 'ConfigProviderCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ConfigProviderCommand(ConfigProviderCommand&& original,
                          bslma::Allocator*       basicAllocator);
    // Create an object of type 'ConfigProviderCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ConfigProviderCommand();
    // Destroy this object.

    // MANIPULATORS
    ConfigProviderCommand& operator=(const ConfigProviderCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigProviderCommand& operator=(ConfigProviderCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    ClearCache& makeClearCache();
    ClearCache& makeClearCache(const ClearCache& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClearCache& makeClearCache(ClearCache&& value);
#endif
    // Set the value of this object to be a "ClearCache" value.  Optionally
    // specify the 'value' of the "ClearCache".  If 'value' is not
    // specified, the default "ClearCache" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    ClearCache& clearCache();
    // Return a reference to the modifiable "ClearCache" selection of this
    // object if "ClearCache" is the current selection.  The behavior is
    // undefined unless "ClearCache" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const ClearCache& clearCache() const;
    // Return a reference to the non-modifiable "ClearCache" selection of
    // this object if "ClearCache" is the current selection.  The behavior
    // is undefined unless "ClearCache" is the selection of this object.

    bool isClearCacheValue() const;
    // Return 'true' if the value of this object is a "ClearCache" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ConfigProviderCommand& lhs,
                           const ConfigProviderCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ConfigProviderCommand' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ConfigProviderCommand& lhs,
                           const ConfigProviderCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                stream,
                                    const ConfigProviderCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&            hashAlg,
                           const ConfigProviderCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ConfigProviderCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ConfigProviderCommand)

namespace mqbcmd {

// ================
// class DomainInfo
// ================

class DomainInfo {
    // INSTANCE DATA
    bslma::Allocator*        d_allocator_p;
    bsl::vector<bsl::string> d_queueUris;
    bsl::string              d_name;
    bsl::string              d_configJson;
    bsl::string              d_clusterName;
    StorageContent           d_storageContent;
    CapacityMeter*           d_capacityMeter;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const DomainInfo& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NAME            = 0,
        ATTRIBUTE_ID_CONFIG_JSON     = 1,
        ATTRIBUTE_ID_CLUSTER_NAME    = 2,
        ATTRIBUTE_ID_CAPACITY_METER  = 3,
        ATTRIBUTE_ID_QUEUE_URIS      = 4,
        ATTRIBUTE_ID_STORAGE_CONTENT = 5
    };

    enum { NUM_ATTRIBUTES = 6 };

    enum {
        ATTRIBUTE_INDEX_NAME            = 0,
        ATTRIBUTE_INDEX_CONFIG_JSON     = 1,
        ATTRIBUTE_INDEX_CLUSTER_NAME    = 2,
        ATTRIBUTE_INDEX_CAPACITY_METER  = 3,
        ATTRIBUTE_INDEX_QUEUE_URIS      = 4,
        ATTRIBUTE_INDEX_STORAGE_CONTENT = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit DomainInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainInfo' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    DomainInfo(const DomainInfo& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainInfo(DomainInfo&& original) noexcept;
    // Create an object of type 'DomainInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    DomainInfo(DomainInfo&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'DomainInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~DomainInfo();
    // Destroy this object.

    // MANIPULATORS
    DomainInfo& operator=(const DomainInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainInfo& operator=(DomainInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    bsl::string& configJson();
    // Return a reference to the modifiable "ConfigJson" attribute of this
    // object.

    bsl::string& clusterName();
    // Return a reference to the modifiable "ClusterName" attribute of this
    // object.

    CapacityMeter& capacityMeter();
    // Return a reference to the modifiable "CapacityMeter" attribute of
    // this object.

    bsl::vector<bsl::string>& queueUris();
    // Return a reference to the modifiable "QueueUris" attribute of this
    // object.

    StorageContent& storageContent();
    // Return a reference to the modifiable "StorageContent" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const bsl::string& configJson() const;
    // Return a reference offering non-modifiable access to the
    // "ConfigJson" attribute of this object.

    const bsl::string& clusterName() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterName" attribute of this object.

    const CapacityMeter& capacityMeter() const;
    // Return a reference offering non-modifiable access to the
    // "CapacityMeter" attribute of this object.

    const bsl::vector<bsl::string>& queueUris() const;
    // Return a reference offering non-modifiable access to the "QueueUris"
    // attribute of this object.

    const StorageContent& storageContent() const;
    // Return a reference offering non-modifiable access to the
    // "StorageContent" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DomainInfo& lhs, const DomainInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const DomainInfo& lhs, const DomainInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const DomainInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const DomainInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'DomainInfo'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::DomainInfo)

namespace mqbcmd {

// =================
// class DomainQueue
// =================

class DomainQueue {
    // INSTANCE DATA
    bsl::string  d_name;
    QueueCommand d_command;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_NAME = 0, ATTRIBUTE_ID_COMMAND = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_NAME = 0, ATTRIBUTE_INDEX_COMMAND = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit DomainQueue(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainQueue' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    DomainQueue(const DomainQueue& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'DomainQueue' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainQueue(DomainQueue&& original) noexcept;
    // Create an object of type 'DomainQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    DomainQueue(DomainQueue&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'DomainQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~DomainQueue();
    // Destroy this object.

    // MANIPULATORS
    DomainQueue& operator=(const DomainQueue& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainQueue& operator=(DomainQueue&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    QueueCommand& command();
    // Return a reference to the modifiable "Command" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const QueueCommand& command() const;
    // Return a reference offering non-modifiable access to the "Command"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DomainQueue& lhs, const DomainQueue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() && lhs.command() == rhs.command();
    }

    friend bool operator!=(const DomainQueue& lhs, const DomainQueue& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const DomainQueue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const DomainQueue& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'DomainQueue'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.name());
        hashAppend(hashAlg, object.command());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::DomainQueue)

namespace mqbcmd {

// ===========================
// class DomainResolverCommand
// ===========================

class DomainResolverCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ClearCache> d_clearCache;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const DomainResolverCommand& rhs) const;

  public:
    // TYPES

    enum { SELECTION_ID_UNDEFINED = -1, SELECTION_ID_CLEAR_CACHE = 0 };

    enum { NUM_SELECTIONS = 1 };

    enum { SELECTION_INDEX_CLEAR_CACHE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit DomainResolverCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainResolverCommand' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    DomainResolverCommand(const DomainResolverCommand& original,
                          bslma::Allocator*            basicAllocator = 0);
    // Create an object of type 'DomainResolverCommand' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainResolverCommand(DomainResolverCommand&& original) noexcept;
    // Create an object of type 'DomainResolverCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    DomainResolverCommand(DomainResolverCommand&& original,
                          bslma::Allocator*       basicAllocator);
    // Create an object of type 'DomainResolverCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~DomainResolverCommand();
    // Destroy this object.

    // MANIPULATORS
    DomainResolverCommand& operator=(const DomainResolverCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainResolverCommand& operator=(DomainResolverCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    ClearCache& makeClearCache();
    ClearCache& makeClearCache(const ClearCache& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClearCache& makeClearCache(ClearCache&& value);
#endif
    // Set the value of this object to be a "ClearCache" value.  Optionally
    // specify the 'value' of the "ClearCache".  If 'value' is not
    // specified, the default "ClearCache" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    ClearCache& clearCache();
    // Return a reference to the modifiable "ClearCache" selection of this
    // object if "ClearCache" is the current selection.  The behavior is
    // undefined unless "ClearCache" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const ClearCache& clearCache() const;
    // Return a reference to the non-modifiable "ClearCache" selection of
    // this object if "ClearCache" is the current selection.  The behavior
    // is undefined unless "ClearCache" is the selection of this object.

    bool isClearCacheValue() const;
    // Return 'true' if the value of this object is a "ClearCache" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DomainResolverCommand& lhs,
                           const DomainResolverCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'DomainResolverCommand' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const DomainResolverCommand& lhs,
                           const DomainResolverCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                stream,
                                    const DomainResolverCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&            hashAlg,
                           const DomainResolverCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DomainResolverCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::DomainResolverCommand)

namespace mqbcmd {

// ======================
// class FileStoreSummary
// ======================

class FileStoreSummary {
    // INSTANCE DATA
    bsls::Types::Uint64  d_sequenceNum;
    bsls::Types::Uint64  d_totalMappedBytes;
    bsl::vector<FileSet> d_fileSets;
    bsl::string          d_primaryNodeDescription;
    StorageContent       d_storageContent;
    ActiveFileSet        d_activeFileSet;
    unsigned int         d_primaryLeaseId;
    unsigned int         d_numOutstandingRecords;
    unsigned int         d_numUnreceiptedMessages;
    unsigned int         d_naglePacketCount;
    bool                 d_isAvailable;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const FileStoreSummary& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PRIMARY_NODE_DESCRIPTION = 0,
        ATTRIBUTE_ID_PRIMARY_LEASE_ID         = 1,
        ATTRIBUTE_ID_SEQUENCE_NUM             = 2,
        ATTRIBUTE_ID_IS_AVAILABLE             = 3,
        ATTRIBUTE_ID_FILE_SETS                = 4,
        ATTRIBUTE_ID_ACTIVE_FILE_SET          = 5,
        ATTRIBUTE_ID_TOTAL_MAPPED_BYTES       = 6,
        ATTRIBUTE_ID_NUM_OUTSTANDING_RECORDS  = 7,
        ATTRIBUTE_ID_NUM_UNRECEIPTED_MESSAGES = 8,
        ATTRIBUTE_ID_NAGLE_PACKET_COUNT       = 9,
        ATTRIBUTE_ID_STORAGE_CONTENT          = 10
    };

    enum { NUM_ATTRIBUTES = 11 };

    enum {
        ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION = 0,
        ATTRIBUTE_INDEX_PRIMARY_LEASE_ID         = 1,
        ATTRIBUTE_INDEX_SEQUENCE_NUM             = 2,
        ATTRIBUTE_INDEX_IS_AVAILABLE             = 3,
        ATTRIBUTE_INDEX_FILE_SETS                = 4,
        ATTRIBUTE_INDEX_ACTIVE_FILE_SET          = 5,
        ATTRIBUTE_INDEX_TOTAL_MAPPED_BYTES       = 6,
        ATTRIBUTE_INDEX_NUM_OUTSTANDING_RECORDS  = 7,
        ATTRIBUTE_INDEX_NUM_UNRECEIPTED_MESSAGES = 8,
        ATTRIBUTE_INDEX_NAGLE_PACKET_COUNT       = 9,
        ATTRIBUTE_INDEX_STORAGE_CONTENT          = 10
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit FileStoreSummary(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'FileStoreSummary' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    FileStoreSummary(const FileStoreSummary& original,
                     bslma::Allocator*       basicAllocator = 0);
    // Create an object of type 'FileStoreSummary' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FileStoreSummary(FileStoreSummary&& original) noexcept;
    // Create an object of type 'FileStoreSummary' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    FileStoreSummary(FileStoreSummary&& original,
                     bslma::Allocator*  basicAllocator);
    // Create an object of type 'FileStoreSummary' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~FileStoreSummary();
    // Destroy this object.

    // MANIPULATORS
    FileStoreSummary& operator=(const FileStoreSummary& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FileStoreSummary& operator=(FileStoreSummary&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& primaryNodeDescription();
    // Return a reference to the modifiable "PrimaryNodeDescription"
    // attribute of this object.

    unsigned int& primaryLeaseId();
    // Return a reference to the modifiable "PrimaryLeaseId" attribute of
    // this object.

    bsls::Types::Uint64& sequenceNum();
    // Return a reference to the modifiable "SequenceNum" attribute of this
    // object.

    bool& isAvailable();
    // Return a reference to the modifiable "IsAvailable" attribute of this
    // object.

    bsl::vector<FileSet>& fileSets();
    // Return a reference to the modifiable "FileSets" attribute of this
    // object.

    ActiveFileSet& activeFileSet();
    // Return a reference to the modifiable "ActiveFileSet" attribute of
    // this object.

    bsls::Types::Uint64& totalMappedBytes();
    // Return a reference to the modifiable "TotalMappedBytes" attribute of
    // this object.

    unsigned int& numOutstandingRecords();
    // Return a reference to the modifiable "NumOutstandingRecords"
    // attribute of this object.

    unsigned int& numUnreceiptedMessages();
    // Return a reference to the modifiable "NumUnreceiptedMessages"
    // attribute of this object.

    unsigned int& naglePacketCount();
    // Return a reference to the modifiable "NaglePacketCount" attribute of
    // this object.

    StorageContent& storageContent();
    // Return a reference to the modifiable "StorageContent" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& primaryNodeDescription() const;
    // Return a reference offering non-modifiable access to the
    // "PrimaryNodeDescription" attribute of this object.

    unsigned int primaryLeaseId() const;
    // Return the value of the "PrimaryLeaseId" attribute of this object.

    bsls::Types::Uint64 sequenceNum() const;
    // Return the value of the "SequenceNum" attribute of this object.

    bool isAvailable() const;
    // Return the value of the "IsAvailable" attribute of this object.

    const bsl::vector<FileSet>& fileSets() const;
    // Return a reference offering non-modifiable access to the "FileSets"
    // attribute of this object.

    const ActiveFileSet& activeFileSet() const;
    // Return a reference offering non-modifiable access to the
    // "ActiveFileSet" attribute of this object.

    bsls::Types::Uint64 totalMappedBytes() const;
    // Return the value of the "TotalMappedBytes" attribute of this object.

    unsigned int numOutstandingRecords() const;
    // Return the value of the "NumOutstandingRecords" attribute of this
    // object.

    unsigned int numUnreceiptedMessages() const;
    // Return the value of the "NumUnreceiptedMessages" attribute of this
    // object.

    unsigned int naglePacketCount() const;
    // Return the value of the "NaglePacketCount" attribute of this object.

    const StorageContent& storageContent() const;
    // Return a reference offering non-modifiable access to the
    // "StorageContent" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const FileStoreSummary& lhs,
                           const FileStoreSummary& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const FileStoreSummary& lhs,
                           const FileStoreSummary& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const FileStoreSummary& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const FileStoreSummary& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'FileStoreSummary'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::FileStoreSummary)

namespace mqbcmd {

// ================
// class GetTunable
// ================

class GetTunable {
    // INSTANCE DATA
    bsl::string      d_name;
    GetTunableChoice d_choice;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_NAME = 0, ATTRIBUTE_ID_CHOICE = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_NAME = 0, ATTRIBUTE_INDEX_CHOICE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit GetTunable(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'GetTunable' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    GetTunable(const GetTunable& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'GetTunable' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    GetTunable(GetTunable&& original) noexcept;
    // Create an object of type 'GetTunable' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    GetTunable(GetTunable&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'GetTunable' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~GetTunable();
    // Destroy this object.

    // MANIPULATORS
    GetTunable& operator=(const GetTunable& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    GetTunable& operator=(GetTunable&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    GetTunableChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const GetTunableChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const GetTunable& lhs, const GetTunable& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() && lhs.choice() == rhs.choice();
    }

    friend bool operator!=(const GetTunable& lhs, const GetTunable& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const GetTunable& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const GetTunable& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'GetTunable'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.name());
        hashAppend(hashAlg, object.choice());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::GetTunable)

namespace mqbcmd {

// ==========================
// class MessageGroupIdHelper
// ==========================

class MessageGroupIdHelper {
    // INSTANCE DATA
    bsls::Types::Int64         d_timeoutNanoseconds;
    MessageGroupIdManagerIndex d_status;
    int                        d_maxMsgGroupIds;
    bool                       d_isRebalanceOn;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const MessageGroupIdHelper& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_TIMEOUT_NANOSECONDS = 0,
        ATTRIBUTE_ID_MAX_MSG_GROUP_IDS   = 1,
        ATTRIBUTE_ID_IS_REBALANCE_ON     = 2,
        ATTRIBUTE_ID_STATUS              = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_TIMEOUT_NANOSECONDS = 0,
        ATTRIBUTE_INDEX_MAX_MSG_GROUP_IDS   = 1,
        ATTRIBUTE_INDEX_IS_REBALANCE_ON     = 2,
        ATTRIBUTE_INDEX_STATUS              = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit MessageGroupIdHelper(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'MessageGroupIdHelper' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    MessageGroupIdHelper(const MessageGroupIdHelper& original,
                         bslma::Allocator*           basicAllocator = 0);
    // Create an object of type 'MessageGroupIdHelper' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    MessageGroupIdHelper(MessageGroupIdHelper&& original) noexcept;
    // Create an object of type 'MessageGroupIdHelper' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    MessageGroupIdHelper(MessageGroupIdHelper&& original,
                         bslma::Allocator*      basicAllocator);
    // Create an object of type 'MessageGroupIdHelper' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~MessageGroupIdHelper();
    // Destroy this object.

    // MANIPULATORS
    MessageGroupIdHelper& operator=(const MessageGroupIdHelper& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    MessageGroupIdHelper& operator=(MessageGroupIdHelper&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Int64& timeoutNanoseconds();
    // Return a reference to the modifiable "TimeoutNanoseconds" attribute
    // of this object.

    int& maxMsgGroupIds();
    // Return a reference to the modifiable "MaxMsgGroupIds" attribute of
    // this object.

    bool& isRebalanceOn();
    // Return a reference to the modifiable "IsRebalanceOn" attribute of
    // this object.

    MessageGroupIdManagerIndex& status();
    // Return a reference to the modifiable "Status" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Int64 timeoutNanoseconds() const;
    // Return the value of the "TimeoutNanoseconds" attribute of this
    // object.

    int maxMsgGroupIds() const;
    // Return the value of the "MaxMsgGroupIds" attribute of this object.

    bool isRebalanceOn() const;
    // Return the value of the "IsRebalanceOn" attribute of this object.

    const MessageGroupIdManagerIndex& status() const;
    // Return a reference offering non-modifiable access to the "Status"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const MessageGroupIdHelper& lhs,
                           const MessageGroupIdHelper& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const MessageGroupIdHelper& lhs,
                           const MessageGroupIdHelper& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const MessageGroupIdHelper& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const MessageGroupIdHelper& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'MessageGroupIdHelper'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::MessageGroupIdHelper)

namespace mqbcmd {

// ==================
// class NodeStatuses
// ==================

class NodeStatuses {
    // INSTANCE DATA
    bsl::vector<ClusterNodeInfo> d_nodes;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_NODES = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_NODES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit NodeStatuses(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'NodeStatuses' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    NodeStatuses(const NodeStatuses& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'NodeStatuses' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    NodeStatuses(NodeStatuses&& original) noexcept;
    // Create an object of type 'NodeStatuses' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    NodeStatuses(NodeStatuses&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'NodeStatuses' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~NodeStatuses();
    // Destroy this object.

    // MANIPULATORS
    NodeStatuses& operator=(const NodeStatuses& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    NodeStatuses& operator=(NodeStatuses&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<ClusterNodeInfo>& nodes();
    // Return a reference to the modifiable "Nodes" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<ClusterNodeInfo>& nodes() const;
    // Return a reference offering non-modifiable access to the "Nodes"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const NodeStatuses& lhs, const NodeStatuses& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.nodes() == rhs.nodes();
    }

    friend bool operator!=(const NodeStatuses& lhs, const NodeStatuses& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const NodeStatuses& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const NodeStatuses& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'NodeStatuses'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.nodes());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::NodeStatuses)

namespace mqbcmd {

// ====================
// class PartitionsInfo
// ====================

class PartitionsInfo {
    // INSTANCE DATA
    bsl::vector<PartitionInfo> d_partitions;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITIONS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_PARTITIONS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit PartitionsInfo(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PartitionsInfo' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    PartitionsInfo(const PartitionsInfo& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'PartitionsInfo' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionsInfo(PartitionsInfo&& original) noexcept;
    // Create an object of type 'PartitionsInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    PartitionsInfo(PartitionsInfo&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'PartitionsInfo' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~PartitionsInfo();
    // Destroy this object.

    // MANIPULATORS
    PartitionsInfo& operator=(const PartitionsInfo& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionsInfo& operator=(PartitionsInfo&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<PartitionInfo>& partitions();
    // Return a reference to the modifiable "Partitions" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<PartitionInfo>& partitions() const;
    // Return a reference offering non-modifiable access to the
    // "Partitions" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PartitionsInfo& lhs,
                           const PartitionsInfo& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitions() == rhs.partitions();
    }

    friend bool operator!=(const PartitionsInfo& lhs,
                           const PartitionsInfo& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const PartitionsInfo& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const PartitionsInfo& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PartitionsInfo'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.partitions());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::PartitionsInfo)

namespace mqbcmd {

// ===================
// class PriorityGroup
// ===================

class PriorityGroup {
    // INSTANCE DATA
    bsl::vector<Subscription> d_highestSubscriptions;
    unsigned int              d_id;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_ID = 0, ATTRIBUTE_ID_HIGHEST_SUBSCRIPTIONS = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_ID = 0, ATTRIBUTE_INDEX_HIGHEST_SUBSCRIPTIONS = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit PriorityGroup(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PriorityGroup' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    PriorityGroup(const PriorityGroup& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'PriorityGroup' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PriorityGroup(PriorityGroup&& original) noexcept;
    // Create an object of type 'PriorityGroup' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    PriorityGroup(PriorityGroup&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'PriorityGroup' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~PriorityGroup();
    // Destroy this object.

    // MANIPULATORS
    PriorityGroup& operator=(const PriorityGroup& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PriorityGroup& operator=(PriorityGroup&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& id();
    // Return a reference to the modifiable "Id" attribute of this object.

    bsl::vector<Subscription>& highestSubscriptions();
    // Return a reference to the modifiable "HighestSubscriptions"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int id() const;
    // Return the value of the "Id" attribute of this object.

    const bsl::vector<Subscription>& highestSubscriptions() const;
    // Return a reference offering non-modifiable access to the
    // "HighestSubscriptions" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PriorityGroup& lhs, const PriorityGroup& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.id() == rhs.id() &&
               lhs.highestSubscriptions() == rhs.highestSubscriptions();
    }

    friend bool operator!=(const PriorityGroup& lhs, const PriorityGroup& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const PriorityGroup& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const PriorityGroup& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PriorityGroup'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.id());
        hashAppend(hashAlg, object.highestSubscriptions());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::PriorityGroup)

namespace mqbcmd {

// ==================
// class PurgedQueues
// ==================

class PurgedQueues {
    // INSTANCE DATA
    bsl::vector<PurgeQueueResult> d_queues;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_QUEUES = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_QUEUES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit PurgedQueues(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'PurgedQueues' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    PurgedQueues(const PurgedQueues& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'PurgedQueues' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueues(PurgedQueues&& original) noexcept;
    // Create an object of type 'PurgedQueues' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    PurgedQueues(PurgedQueues&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'PurgedQueues' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~PurgedQueues();
    // Destroy this object.

    // MANIPULATORS
    PurgedQueues& operator=(const PurgedQueues& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueues& operator=(PurgedQueues&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<PurgeQueueResult>& queues();
    // Return a reference to the modifiable "Queues" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<PurgeQueueResult>& queues() const;
    // Return a reference offering non-modifiable access to the "Queues"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const PurgedQueues& lhs, const PurgedQueues& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.queues() == rhs.queues();
    }

    friend bool operator!=(const PurgedQueues& lhs, const PurgedQueues& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const PurgedQueues& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const PurgedQueues& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'PurgedQueues'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.queues());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::PurgedQueues)

namespace mqbcmd {

// ==========================
// class QueueHandleSubStream
// ==========================

class QueueHandleSubStream {
    // INSTANCE DATA
    bsl::vector<ResourceUsageMonitor>       d_unconfirmedMonitors;
    bsl::string                             d_parametersJson;
    bdlb::NullableValue<bsls::Types::Int64> d_numUnconfirmedMessages;
    bdlb::NullableValue<bsl::string>        d_appId;
    unsigned int                            d_subId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueHandleSubStream& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_SUB_ID                   = 0,
        ATTRIBUTE_ID_APP_ID                   = 1,
        ATTRIBUTE_ID_PARAMETERS_JSON          = 2,
        ATTRIBUTE_ID_UNCONFIRMED_MONITORS     = 3,
        ATTRIBUTE_ID_NUM_UNCONFIRMED_MESSAGES = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_SUB_ID                   = 0,
        ATTRIBUTE_INDEX_APP_ID                   = 1,
        ATTRIBUTE_INDEX_PARAMETERS_JSON          = 2,
        ATTRIBUTE_INDEX_UNCONFIRMED_MONITORS     = 3,
        ATTRIBUTE_INDEX_NUM_UNCONFIRMED_MESSAGES = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueHandleSubStream(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueHandleSubStream' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    QueueHandleSubStream(const QueueHandleSubStream& original,
                         bslma::Allocator*           basicAllocator = 0);
    // Create an object of type 'QueueHandleSubStream' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueHandleSubStream(QueueHandleSubStream&& original) noexcept;
    // Create an object of type 'QueueHandleSubStream' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueHandleSubStream(QueueHandleSubStream&& original,
                         bslma::Allocator*      basicAllocator);
    // Create an object of type 'QueueHandleSubStream' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueHandleSubStream();
    // Destroy this object.

    // MANIPULATORS
    QueueHandleSubStream& operator=(const QueueHandleSubStream& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueHandleSubStream& operator=(QueueHandleSubStream&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& subId();
    // Return a reference to the modifiable "SubId" attribute of this
    // object.

    bdlb::NullableValue<bsl::string>& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    bsl::string& parametersJson();
    // Return a reference to the modifiable "ParametersJson" attribute of
    // this object.

    bsl::vector<ResourceUsageMonitor>& unconfirmedMonitors();
    // Return a reference to the modifiable "UnconfirmedMonitors" attribute
    // of this object.

    bdlb::NullableValue<bsls::Types::Int64>& numUnconfirmedMessages();
    // Return a reference to the modifiable "NumUnconfirmedMessages"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int subId() const;
    // Return the value of the "SubId" attribute of this object.

    const bdlb::NullableValue<bsl::string>& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    const bsl::string& parametersJson() const;
    // Return a reference offering non-modifiable access to the
    // "ParametersJson" attribute of this object.

    const bsl::vector<ResourceUsageMonitor>& unconfirmedMonitors() const;
    // Return a reference offering non-modifiable access to the
    // "UnconfirmedMonitors" attribute of this object.

    const bdlb::NullableValue<bsls::Types::Int64>&
    numUnconfirmedMessages() const;
    // Return a reference offering non-modifiable access to the
    // "NumUnconfirmedMessages" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueHandleSubStream& lhs,
                           const QueueHandleSubStream& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueHandleSubStream& lhs,
                           const QueueHandleSubStream& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&               stream,
                                    const QueueHandleSubStream& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&           hashAlg,
                           const QueueHandleSubStream& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueHandleSubStream'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::QueueHandleSubStream)

namespace mqbcmd {

// ===================
// class QueueStatuses
// ===================

class QueueStatuses {
    // INSTANCE DATA
    bsl::vector<StorageContent> d_queueStatuses;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_QUEUE_STATUSES = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_QUEUE_STATUSES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueStatuses(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueStatuses' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueStatuses(const QueueStatuses& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'QueueStatuses' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueStatuses(QueueStatuses&& original) noexcept;
    // Create an object of type 'QueueStatuses' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueStatuses(QueueStatuses&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueStatuses' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueStatuses();
    // Destroy this object.

    // MANIPULATORS
    QueueStatuses& operator=(const QueueStatuses& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueStatuses& operator=(QueueStatuses&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<StorageContent>& queueStatuses();
    // Return a reference to the modifiable "QueueStatuses" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<StorageContent>& queueStatuses() const;
    // Return a reference offering non-modifiable access to the
    // "QueueStatuses" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueStatuses& lhs, const QueueStatuses& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.queueStatuses() == rhs.queueStatuses();
    }

    friend bool operator!=(const QueueStatuses& lhs, const QueueStatuses& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const QueueStatuses& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const QueueStatuses& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueStatuses'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.queueStatuses());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::QueueStatuses)

namespace mqbcmd {

// ================
// class SetTunable
// ================

class SetTunable {
    // INSTANCE DATA
    bsl::string      d_name;
    Value            d_value;
    SetTunableChoice d_choice;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NAME   = 0,
        ATTRIBUTE_ID_VALUE  = 1,
        ATTRIBUTE_ID_CHOICE = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_NAME   = 0,
        ATTRIBUTE_INDEX_VALUE  = 1,
        ATTRIBUTE_INDEX_CHOICE = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit SetTunable(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'SetTunable' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    SetTunable(const SetTunable& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'SetTunable' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SetTunable(SetTunable&& original) noexcept;
    // Create an object of type 'SetTunable' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    SetTunable(SetTunable&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'SetTunable' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~SetTunable();
    // Destroy this object.

    // MANIPULATORS
    SetTunable& operator=(const SetTunable& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SetTunable& operator=(SetTunable&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    Value& value();
    // Return a reference to the modifiable "Value" attribute of this
    // object.

    SetTunableChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const Value& value() const;
    // Return a reference offering non-modifiable access to the "Value"
    // attribute of this object.

    const SetTunableChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const SetTunable& lhs, const SetTunable& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() && lhs.value() == rhs.value() &&
               lhs.choice() == rhs.choice();
    }

    friend bool operator!=(const SetTunable& lhs, const SetTunable& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const SetTunable& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const SetTunable& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'SetTunable'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::SetTunable)

namespace mqbcmd {

// ===================
// class StorageDomain
// ===================

class StorageDomain {
    // INSTANCE DATA
    bsl::string          d_name;
    StorageDomainCommand d_command;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_NAME = 0, ATTRIBUTE_ID_COMMAND = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_NAME = 0, ATTRIBUTE_INDEX_COMMAND = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit StorageDomain(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StorageDomain' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StorageDomain(const StorageDomain& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'StorageDomain' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageDomain(StorageDomain&& original) noexcept;
    // Create an object of type 'StorageDomain' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StorageDomain(StorageDomain&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'StorageDomain' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StorageDomain();
    // Destroy this object.

    // MANIPULATORS
    StorageDomain& operator=(const StorageDomain& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageDomain& operator=(StorageDomain&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    StorageDomainCommand& command();
    // Return a reference to the modifiable "Command" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const StorageDomainCommand& command() const;
    // Return a reference offering non-modifiable access to the "Command"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageDomain& lhs, const StorageDomain& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() && lhs.command() == rhs.command();
    }

    friend bool operator!=(const StorageDomain& lhs, const StorageDomain& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const StorageDomain& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const StorageDomain& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageDomain'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.name());
        hashAppend(hashAlg, object.command());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::StorageDomain)

namespace mqbcmd {

// ======================
// class StoragePartition
// ======================

class StoragePartition {
    // INSTANCE DATA
    StoragePartitionCommand d_command;
    int                     d_partitionId;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_PARTITION_ID = 0, ATTRIBUTE_ID_COMMAND = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_PARTITION_ID = 0, ATTRIBUTE_INDEX_COMMAND = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    StoragePartition();
    // Create an object of type 'StoragePartition' having the default
    // value.

    // MANIPULATORS
    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    StoragePartitionCommand& command();
    // Return a reference to the modifiable "Command" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const StoragePartitionCommand& command() const;
    // Return a reference offering non-modifiable access to the "Command"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StoragePartition& lhs,
                           const StoragePartition& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.command() == rhs.command();
    }

    friend bool operator!=(const StoragePartition& lhs,
                           const StoragePartition& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const StoragePartition& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const StoragePartition& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StoragePartition'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.partitionId());
        hashAppend(hashAlg, object.command());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_BITWISEMOVEABLE_TRAITS(mqbcmd::StoragePartition)

namespace mqbcmd {

// =============
// class Tunable
// =============

class Tunable {
    // INSTANCE DATA
    bsl::string d_name;
    bsl::string d_description;
    Value       d_value;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NAME        = 0,
        ATTRIBUTE_ID_VALUE       = 1,
        ATTRIBUTE_ID_DESCRIPTION = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_NAME        = 0,
        ATTRIBUTE_INDEX_VALUE       = 1,
        ATTRIBUTE_INDEX_DESCRIPTION = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Tunable(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Tunable' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Tunable(const Tunable& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Tunable' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunable(Tunable&& original) noexcept;
    // Create an object of type 'Tunable' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Tunable(Tunable&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Tunable' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Tunable();
    // Destroy this object.

    // MANIPULATORS
    Tunable& operator=(const Tunable& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunable& operator=(Tunable&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    Value& value();
    // Return a reference to the modifiable "Value" attribute of this
    // object.

    bsl::string& description();
    // Return a reference to the modifiable "Description" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const Value& value() const;
    // Return a reference offering non-modifiable access to the "Value"
    // attribute of this object.

    const bsl::string& description() const;
    // Return a reference offering non-modifiable access to the
    // "Description" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Tunable& lhs, const Tunable& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() && lhs.value() == rhs.value() &&
               lhs.description() == rhs.description();
    }

    friend bool operator!=(const Tunable& lhs, const Tunable& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Tunable& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Tunable& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Tunable'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Tunable)

namespace mqbcmd {

// =========================
// class TunableConfirmation
// =========================

class TunableConfirmation {
    // INSTANCE DATA
    bsl::string d_name;
    Value       d_oldValue;
    Value       d_newValue;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NAME      = 0,
        ATTRIBUTE_ID_OLD_VALUE = 1,
        ATTRIBUTE_ID_NEW_VALUE = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_NAME      = 0,
        ATTRIBUTE_INDEX_OLD_VALUE = 1,
        ATTRIBUTE_INDEX_NEW_VALUE = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit TunableConfirmation(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'TunableConfirmation' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    TunableConfirmation(const TunableConfirmation& original,
                        bslma::Allocator*          basicAllocator = 0);
    // Create an object of type 'TunableConfirmation' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    TunableConfirmation(TunableConfirmation&& original) noexcept;
    // Create an object of type 'TunableConfirmation' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    TunableConfirmation(TunableConfirmation&& original,
                        bslma::Allocator*     basicAllocator);
    // Create an object of type 'TunableConfirmation' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~TunableConfirmation();
    // Destroy this object.

    // MANIPULATORS
    TunableConfirmation& operator=(const TunableConfirmation& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    TunableConfirmation& operator=(TunableConfirmation&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    Value& oldValue();
    // Return a reference to the modifiable "OldValue" attribute of this
    // object.

    Value& newValue();
    // Return a reference to the modifiable "NewValue" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const Value& oldValue() const;
    // Return a reference offering non-modifiable access to the "OldValue"
    // attribute of this object.

    const Value& newValue() const;
    // Return a reference offering non-modifiable access to the "NewValue"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const TunableConfirmation& lhs,
                           const TunableConfirmation& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() && lhs.oldValue() == rhs.oldValue() &&
               lhs.newValue() == rhs.newValue();
    }

    friend bool operator!=(const TunableConfirmation& lhs,
                           const TunableConfirmation& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const TunableConfirmation& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const TunableConfirmation& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'TunableConfirmation'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::TunableConfirmation)

namespace mqbcmd {

// ================================
// class ClusterDomainQueueStatuses
// ================================

class ClusterDomainQueueStatuses {
    // INSTANCE DATA
    bdlb::NullableValue<QueueStatuses> d_statuses;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_STATUSES = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_STATUSES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterDomainQueueStatuses(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterDomainQueueStatuses' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    ClusterDomainQueueStatuses(const ClusterDomainQueueStatuses& original,
                               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterDomainQueueStatuses' having the
    // value of the specified 'original' object.  Use the optionally
    // specified 'basicAllocator' to supply memory.  If 'basicAllocator' is
    // 0, the currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterDomainQueueStatuses(ClusterDomainQueueStatuses&& original) noexcept;
    // Create an object of type 'ClusterDomainQueueStatuses' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.

    ClusterDomainQueueStatuses(ClusterDomainQueueStatuses&& original,
                               bslma::Allocator*            basicAllocator);
    // Create an object of type 'ClusterDomainQueueStatuses' having the
    // value of the specified 'original' object.  After performing this
    // action, the 'original' object will be left in a valid, but
    // unspecified state.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.
#endif

    ~ClusterDomainQueueStatuses();
    // Destroy this object.

    // MANIPULATORS
    ClusterDomainQueueStatuses&
    operator=(const ClusterDomainQueueStatuses& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterDomainQueueStatuses& operator=(ClusterDomainQueueStatuses&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bdlb::NullableValue<QueueStatuses>& statuses();
    // Return a reference to the modifiable "Statuses" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bdlb::NullableValue<QueueStatuses>& statuses() const;
    // Return a reference offering non-modifiable access to the "Statuses"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterDomainQueueStatuses& lhs,
                           const ClusterDomainQueueStatuses& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.statuses() == rhs.statuses();
    }

    friend bool operator!=(const ClusterDomainQueueStatuses& lhs,
                           const ClusterDomainQueueStatuses& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                     stream,
                                    const ClusterDomainQueueStatuses& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&                 hashAlg,
                           const ClusterDomainQueueStatuses& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterDomainQueueStatuses'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.statuses());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClusterDomainQueueStatuses)

namespace mqbcmd {

// ========================
// class ClusterProxyStatus
// ========================

class ClusterProxyStatus {
    // INSTANCE DATA
    bsl::string                      d_description;
    bdlb::NullableValue<bsl::string> d_activeNodeDescription;
    StorageContent                   d_queuesInfo;
    NodeStatuses                     d_nodeStatuses;
    bool                             d_isHealthy;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterProxyStatus& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_DESCRIPTION             = 0,
        ATTRIBUTE_ID_ACTIVE_NODE_DESCRIPTION = 1,
        ATTRIBUTE_ID_IS_HEALTHY              = 2,
        ATTRIBUTE_ID_NODE_STATUSES           = 3,
        ATTRIBUTE_ID_QUEUES_INFO             = 4
    };

    enum { NUM_ATTRIBUTES = 5 };

    enum {
        ATTRIBUTE_INDEX_DESCRIPTION             = 0,
        ATTRIBUTE_INDEX_ACTIVE_NODE_DESCRIPTION = 1,
        ATTRIBUTE_INDEX_IS_HEALTHY              = 2,
        ATTRIBUTE_INDEX_NODE_STATUSES           = 3,
        ATTRIBUTE_INDEX_QUEUES_INFO             = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterProxyStatus(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterProxyStatus' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ClusterProxyStatus(const ClusterProxyStatus& original,
                       bslma::Allocator*         basicAllocator = 0);
    // Create an object of type 'ClusterProxyStatus' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterProxyStatus(ClusterProxyStatus&& original) noexcept;
    // Create an object of type 'ClusterProxyStatus' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterProxyStatus(ClusterProxyStatus&& original,
                       bslma::Allocator*    basicAllocator);
    // Create an object of type 'ClusterProxyStatus' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterProxyStatus();
    // Destroy this object.

    // MANIPULATORS
    ClusterProxyStatus& operator=(const ClusterProxyStatus& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterProxyStatus& operator=(ClusterProxyStatus&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& description();
    // Return a reference to the modifiable "Description" attribute of this
    // object.

    bdlb::NullableValue<bsl::string>& activeNodeDescription();
    // Return a reference to the modifiable "ActiveNodeDescription"
    // attribute of this object.

    bool& isHealthy();
    // Return a reference to the modifiable "IsHealthy" attribute of this
    // object.

    NodeStatuses& nodeStatuses();
    // Return a reference to the modifiable "NodeStatuses" attribute of
    // this object.

    StorageContent& queuesInfo();
    // Return a reference to the modifiable "QueuesInfo" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& description() const;
    // Return a reference offering non-modifiable access to the
    // "Description" attribute of this object.

    const bdlb::NullableValue<bsl::string>& activeNodeDescription() const;
    // Return a reference offering non-modifiable access to the
    // "ActiveNodeDescription" attribute of this object.

    bool isHealthy() const;
    // Return the value of the "IsHealthy" attribute of this object.

    const NodeStatuses& nodeStatuses() const;
    // Return a reference offering non-modifiable access to the
    // "NodeStatuses" attribute of this object.

    const StorageContent& queuesInfo() const;
    // Return a reference offering non-modifiable access to the
    // "QueuesInfo" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterProxyStatus& lhs,
                           const ClusterProxyStatus& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterProxyStatus& lhs,
                           const ClusterProxyStatus& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const ClusterProxyStatus& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&         hashAlg,
                           const ClusterProxyStatus& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterProxyStatus'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClusterProxyStatus)

namespace mqbcmd {

// ===================
// class DomainCommand
// ===================

class DomainCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>        d_purge;
        bsls::ObjectBuffer<Void>        d_info;
        bsls::ObjectBuffer<DomainQueue> d_queue;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const DomainCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED = -1,
        SELECTION_ID_PURGE     = 0,
        SELECTION_ID_INFO      = 1,
        SELECTION_ID_QUEUE     = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_PURGE = 0,
        SELECTION_INDEX_INFO  = 1,
        SELECTION_INDEX_QUEUE = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit DomainCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainCommand' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    DomainCommand(const DomainCommand& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'DomainCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainCommand(DomainCommand&& original) noexcept;
    // Create an object of type 'DomainCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    DomainCommand(DomainCommand&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'DomainCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~DomainCommand();
    // Destroy this object.

    // MANIPULATORS
    DomainCommand& operator=(const DomainCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainCommand& operator=(DomainCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makePurge();
    Void& makePurge(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makePurge(Void&& value);
#endif
    // Set the value of this object to be a "Purge" value.  Optionally
    // specify the 'value' of the "Purge".  If 'value' is not specified,
    // the default "Purge" value is used.

    Void& makeInfo();
    Void& makeInfo(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeInfo(Void&& value);
#endif
    // Set the value of this object to be a "Info" value.  Optionally
    // specify the 'value' of the "Info".  If 'value' is not specified, the
    // default "Info" value is used.

    DomainQueue& makeQueue();
    DomainQueue& makeQueue(const DomainQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainQueue& makeQueue(DomainQueue&& value);
#endif
    // Set the value of this object to be a "Queue" value.  Optionally
    // specify the 'value' of the "Queue".  If 'value' is not specified,
    // the default "Queue" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& purge();
    // Return a reference to the modifiable "Purge" selection of this
    // object if "Purge" is the current selection.  The behavior is
    // undefined unless "Purge" is the selection of this object.

    Void& info();
    // Return a reference to the modifiable "Info" selection of this object
    // if "Info" is the current selection.  The behavior is undefined
    // unless "Info" is the selection of this object.

    DomainQueue& queue();
    // Return a reference to the modifiable "Queue" selection of this
    // object if "Queue" is the current selection.  The behavior is
    // undefined unless "Queue" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& purge() const;
    // Return a reference to the non-modifiable "Purge" selection of this
    // object if "Purge" is the current selection.  The behavior is
    // undefined unless "Purge" is the selection of this object.

    const Void& info() const;
    // Return a reference to the non-modifiable "Info" selection of this
    // object if "Info" is the current selection.  The behavior is
    // undefined unless "Info" is the selection of this object.

    const DomainQueue& queue() const;
    // Return a reference to the non-modifiable "Queue" selection of this
    // object if "Queue" is the current selection.  The behavior is
    // undefined unless "Queue" is the selection of this object.

    bool isPurgeValue() const;
    // Return 'true' if the value of this object is a "Purge" value, and
    // return 'false' otherwise.

    bool isInfoValue() const;
    // Return 'true' if the value of this object is a "Info" value, and
    // return 'false' otherwise.

    bool isQueueValue() const;
    // Return 'true' if the value of this object is a "Queue" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DomainCommand& lhs, const DomainCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'DomainCommand' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const DomainCommand& lhs, const DomainCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const DomainCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const DomainCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DomainCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::DomainCommand)

namespace mqbcmd {

// ====================
// class ElectorCommand
// ====================

class ElectorCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<SetTunable> d_setTunable;
        bsls::ObjectBuffer<GetTunable> d_getTunable;
        bsls::ObjectBuffer<Void>       d_listTunables;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ElectorCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED     = -1,
        SELECTION_ID_SET_TUNABLE   = 0,
        SELECTION_ID_GET_TUNABLE   = 1,
        SELECTION_ID_LIST_TUNABLES = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_SET_TUNABLE   = 0,
        SELECTION_INDEX_GET_TUNABLE   = 1,
        SELECTION_INDEX_LIST_TUNABLES = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ElectorCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ElectorCommand' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ElectorCommand(const ElectorCommand& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'ElectorCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorCommand(ElectorCommand&& original) noexcept;
    // Create an object of type 'ElectorCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ElectorCommand(ElectorCommand&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'ElectorCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ElectorCommand();
    // Destroy this object.

    // MANIPULATORS
    ElectorCommand& operator=(const ElectorCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorCommand& operator=(ElectorCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    SetTunable& makeSetTunable();
    SetTunable& makeSetTunable(const SetTunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SetTunable& makeSetTunable(SetTunable&& value);
#endif
    // Set the value of this object to be a "SetTunable" value.  Optionally
    // specify the 'value' of the "SetTunable".  If 'value' is not
    // specified, the default "SetTunable" value is used.

    GetTunable& makeGetTunable();
    GetTunable& makeGetTunable(const GetTunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    GetTunable& makeGetTunable(GetTunable&& value);
#endif
    // Set the value of this object to be a "GetTunable" value.  Optionally
    // specify the 'value' of the "GetTunable".  If 'value' is not
    // specified, the default "GetTunable" value is used.

    Void& makeListTunables();
    Void& makeListTunables(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeListTunables(Void&& value);
#endif
    // Set the value of this object to be a "ListTunables" value.
    // Optionally specify the 'value' of the "ListTunables".  If 'value' is
    // not specified, the default "ListTunables" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    SetTunable& setTunable();
    // Return a reference to the modifiable "SetTunable" selection of this
    // object if "SetTunable" is the current selection.  The behavior is
    // undefined unless "SetTunable" is the selection of this object.

    GetTunable& getTunable();
    // Return a reference to the modifiable "GetTunable" selection of this
    // object if "GetTunable" is the current selection.  The behavior is
    // undefined unless "GetTunable" is the selection of this object.

    Void& listTunables();
    // Return a reference to the modifiable "ListTunables" selection of
    // this object if "ListTunables" is the current selection.  The
    // behavior is undefined unless "ListTunables" is the selection of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const SetTunable& setTunable() const;
    // Return a reference to the non-modifiable "SetTunable" selection of
    // this object if "SetTunable" is the current selection.  The behavior
    // is undefined unless "SetTunable" is the selection of this object.

    const GetTunable& getTunable() const;
    // Return a reference to the non-modifiable "GetTunable" selection of
    // this object if "GetTunable" is the current selection.  The behavior
    // is undefined unless "GetTunable" is the selection of this object.

    const Void& listTunables() const;
    // Return a reference to the non-modifiable "ListTunables" selection of
    // this object if "ListTunables" is the current selection.  The
    // behavior is undefined unless "ListTunables" is the selection of this
    // object.

    bool isSetTunableValue() const;
    // Return 'true' if the value of this object is a "SetTunable" value,
    // and return 'false' otherwise.

    bool isGetTunableValue() const;
    // Return 'true' if the value of this object is a "GetTunable" value,
    // and return 'false' otherwise.

    bool isListTunablesValue() const;
    // Return 'true' if the value of this object is a "ListTunables" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ElectorCommand& lhs,
                           const ElectorCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ElectorCommand' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ElectorCommand& lhs,
                           const ElectorCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const ElectorCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const ElectorCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ElectorCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ElectorCommand)

namespace mqbcmd {

// ===============
// class FileStore
// ===============

class FileStore {
    // INSTANCE DATA
    FileStoreSummary      d_summary;
    int                   d_partitionId;
    FileStoreState::Value d_state;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PARTITION_ID = 0,
        ATTRIBUTE_ID_STATE        = 1,
        ATTRIBUTE_ID_SUMMARY      = 2
    };

    enum { NUM_ATTRIBUTES = 3 };

    enum {
        ATTRIBUTE_INDEX_PARTITION_ID = 0,
        ATTRIBUTE_INDEX_STATE        = 1,
        ATTRIBUTE_INDEX_SUMMARY      = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit FileStore(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'FileStore' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    FileStore(const FileStore& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'FileStore' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FileStore(FileStore&& original) noexcept;
    // Create an object of type 'FileStore' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    FileStore(FileStore&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'FileStore' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~FileStore();
    // Destroy this object.

    // MANIPULATORS
    FileStore& operator=(const FileStore& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FileStore& operator=(FileStore&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    FileStoreState::Value& state();
    // Return a reference to the modifiable "State" attribute of this
    // object.

    FileStoreSummary& summary();
    // Return a reference to the modifiable "Summary" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    FileStoreState::Value state() const;
    // Return the value of the "State" attribute of this object.

    const FileStoreSummary& summary() const;
    // Return a reference offering non-modifiable access to the "Summary"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const FileStore& lhs, const FileStore& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.partitionId() == rhs.partitionId() &&
               lhs.state() == rhs.state() && lhs.summary() == rhs.summary();
    }

    friend bool operator!=(const FileStore& lhs, const FileStore& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const FileStore& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const FileStore& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'FileStore'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::FileStore)

namespace mqbcmd {

// =================
// class QueueHandle
// =================

class QueueHandle {
    // INSTANCE DATA
    bsl::vector<QueueHandleSubStream> d_subStreams;
    bsl::string                       d_clientDescription;
    bsl::string                       d_parametersJson;
    bool                              d_isClientClusterMember;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueHandle& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CLIENT_DESCRIPTION       = 0,
        ATTRIBUTE_ID_PARAMETERS_JSON          = 1,
        ATTRIBUTE_ID_IS_CLIENT_CLUSTER_MEMBER = 2,
        ATTRIBUTE_ID_SUB_STREAMS              = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_CLIENT_DESCRIPTION       = 0,
        ATTRIBUTE_INDEX_PARAMETERS_JSON          = 1,
        ATTRIBUTE_INDEX_IS_CLIENT_CLUSTER_MEMBER = 2,
        ATTRIBUTE_INDEX_SUB_STREAMS              = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueHandle(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueHandle' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueHandle(const QueueHandle& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'QueueHandle' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueHandle(QueueHandle&& original) noexcept;
    // Create an object of type 'QueueHandle' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueHandle(QueueHandle&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueHandle' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueHandle();
    // Destroy this object.

    // MANIPULATORS
    QueueHandle& operator=(const QueueHandle& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueHandle& operator=(QueueHandle&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clientDescription();
    // Return a reference to the modifiable "ClientDescription" attribute
    // of this object.

    bsl::string& parametersJson();
    // Return a reference to the modifiable "ParametersJson" attribute of
    // this object.

    bool& isClientClusterMember();
    // Return a reference to the modifiable "IsClientClusterMember"
    // attribute of this object.

    bsl::vector<QueueHandleSubStream>& subStreams();
    // Return a reference to the modifiable "SubStreams" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clientDescription() const;
    // Return a reference offering non-modifiable access to the
    // "ClientDescription" attribute of this object.

    const bsl::string& parametersJson() const;
    // Return a reference offering non-modifiable access to the
    // "ParametersJson" attribute of this object.

    bool isClientClusterMember() const;
    // Return the value of the "IsClientClusterMember" attribute of this
    // object.

    const bsl::vector<QueueHandleSubStream>& subStreams() const;
    // Return a reference offering non-modifiable access to the
    // "SubStreams" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueHandle& lhs, const QueueHandle& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueHandle& lhs, const QueueHandle& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const QueueHandle& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const QueueHandle& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'QueueHandle'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::QueueHandle)

namespace mqbcmd {

// ========================
// class ReplicationCommand
// ========================

class ReplicationCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<SetTunable> d_setTunable;
        bsls::ObjectBuffer<GetTunable> d_getTunable;
        bsls::ObjectBuffer<Void>       d_listTunables;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ReplicationCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED     = -1,
        SELECTION_ID_SET_TUNABLE   = 0,
        SELECTION_ID_GET_TUNABLE   = 1,
        SELECTION_ID_LIST_TUNABLES = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_SET_TUNABLE   = 0,
        SELECTION_INDEX_GET_TUNABLE   = 1,
        SELECTION_INDEX_LIST_TUNABLES = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ReplicationCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ReplicationCommand' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ReplicationCommand(const ReplicationCommand& original,
                       bslma::Allocator*         basicAllocator = 0);
    // Create an object of type 'ReplicationCommand' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicationCommand(ReplicationCommand&& original) noexcept;
    // Create an object of type 'ReplicationCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ReplicationCommand(ReplicationCommand&& original,
                       bslma::Allocator*    basicAllocator);
    // Create an object of type 'ReplicationCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ReplicationCommand();
    // Destroy this object.

    // MANIPULATORS
    ReplicationCommand& operator=(const ReplicationCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicationCommand& operator=(ReplicationCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    SetTunable& makeSetTunable();
    SetTunable& makeSetTunable(const SetTunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SetTunable& makeSetTunable(SetTunable&& value);
#endif
    // Set the value of this object to be a "SetTunable" value.  Optionally
    // specify the 'value' of the "SetTunable".  If 'value' is not
    // specified, the default "SetTunable" value is used.

    GetTunable& makeGetTunable();
    GetTunable& makeGetTunable(const GetTunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    GetTunable& makeGetTunable(GetTunable&& value);
#endif
    // Set the value of this object to be a "GetTunable" value.  Optionally
    // specify the 'value' of the "GetTunable".  If 'value' is not
    // specified, the default "GetTunable" value is used.

    Void& makeListTunables();
    Void& makeListTunables(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeListTunables(Void&& value);
#endif
    // Set the value of this object to be a "ListTunables" value.
    // Optionally specify the 'value' of the "ListTunables".  If 'value' is
    // not specified, the default "ListTunables" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    SetTunable& setTunable();
    // Return a reference to the modifiable "SetTunable" selection of this
    // object if "SetTunable" is the current selection.  The behavior is
    // undefined unless "SetTunable" is the selection of this object.

    GetTunable& getTunable();
    // Return a reference to the modifiable "GetTunable" selection of this
    // object if "GetTunable" is the current selection.  The behavior is
    // undefined unless "GetTunable" is the selection of this object.

    Void& listTunables();
    // Return a reference to the modifiable "ListTunables" selection of
    // this object if "ListTunables" is the current selection.  The
    // behavior is undefined unless "ListTunables" is the selection of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const SetTunable& setTunable() const;
    // Return a reference to the non-modifiable "SetTunable" selection of
    // this object if "SetTunable" is the current selection.  The behavior
    // is undefined unless "SetTunable" is the selection of this object.

    const GetTunable& getTunable() const;
    // Return a reference to the non-modifiable "GetTunable" selection of
    // this object if "GetTunable" is the current selection.  The behavior
    // is undefined unless "GetTunable" is the selection of this object.

    const Void& listTunables() const;
    // Return a reference to the non-modifiable "ListTunables" selection of
    // this object if "ListTunables" is the current selection.  The
    // behavior is undefined unless "ListTunables" is the selection of this
    // object.

    bool isSetTunableValue() const;
    // Return 'true' if the value of this object is a "SetTunable" value,
    // and return 'false' otherwise.

    bool isGetTunableValue() const;
    // Return 'true' if the value of this object is a "GetTunable" value,
    // and return 'false' otherwise.

    bool isListTunablesValue() const;
    // Return 'true' if the value of this object is a "ListTunables" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ReplicationCommand& lhs,
                           const ReplicationCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ReplicationCommand' objects have
    // the same value if either the selections in both objects have the
    // same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ReplicationCommand& lhs,
                           const ReplicationCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&             stream,
                                    const ReplicationCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&         hashAlg,
                           const ReplicationCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ReplicationCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ReplicationCommand)

namespace mqbcmd {

// =================
// class StatCommand
// =================

class StatCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>        d_show;
        bsls::ObjectBuffer<SetTunable>  d_setTunable;
        bsls::ObjectBuffer<bsl::string> d_getTunable;
        bsls::ObjectBuffer<Void>        d_listTunables;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StatCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED     = -1,
        SELECTION_ID_SHOW          = 0,
        SELECTION_ID_SET_TUNABLE   = 1,
        SELECTION_ID_GET_TUNABLE   = 2,
        SELECTION_ID_LIST_TUNABLES = 3
    };

    enum { NUM_SELECTIONS = 4 };

    enum {
        SELECTION_INDEX_SHOW          = 0,
        SELECTION_INDEX_SET_TUNABLE   = 1,
        SELECTION_INDEX_GET_TUNABLE   = 2,
        SELECTION_INDEX_LIST_TUNABLES = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit StatCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StatCommand' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StatCommand(const StatCommand& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'StatCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StatCommand(StatCommand&& original) noexcept;
    // Create an object of type 'StatCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StatCommand(StatCommand&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'StatCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StatCommand();
    // Destroy this object.

    // MANIPULATORS
    StatCommand& operator=(const StatCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StatCommand& operator=(StatCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeShow();
    Void& makeShow(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeShow(Void&& value);
#endif
    // Set the value of this object to be a "Show" value.  Optionally
    // specify the 'value' of the "Show".  If 'value' is not specified, the
    // default "Show" value is used.

    SetTunable& makeSetTunable();
    SetTunable& makeSetTunable(const SetTunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SetTunable& makeSetTunable(SetTunable&& value);
#endif
    // Set the value of this object to be a "SetTunable" value.  Optionally
    // specify the 'value' of the "SetTunable".  If 'value' is not
    // specified, the default "SetTunable" value is used.

    bsl::string& makeGetTunable();
    bsl::string& makeGetTunable(const bsl::string& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bsl::string& makeGetTunable(bsl::string&& value);
#endif
    // Set the value of this object to be a "GetTunable" value.  Optionally
    // specify the 'value' of the "GetTunable".  If 'value' is not
    // specified, the default "GetTunable" value is used.

    Void& makeListTunables();
    Void& makeListTunables(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeListTunables(Void&& value);
#endif
    // Set the value of this object to be a "ListTunables" value.
    // Optionally specify the 'value' of the "ListTunables".  If 'value' is
    // not specified, the default "ListTunables" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& show();
    // Return a reference to the modifiable "Show" selection of this object
    // if "Show" is the current selection.  The behavior is undefined
    // unless "Show" is the selection of this object.

    SetTunable& setTunable();
    // Return a reference to the modifiable "SetTunable" selection of this
    // object if "SetTunable" is the current selection.  The behavior is
    // undefined unless "SetTunable" is the selection of this object.

    bsl::string& getTunable();
    // Return a reference to the modifiable "GetTunable" selection of this
    // object if "GetTunable" is the current selection.  The behavior is
    // undefined unless "GetTunable" is the selection of this object.

    Void& listTunables();
    // Return a reference to the modifiable "ListTunables" selection of
    // this object if "ListTunables" is the current selection.  The
    // behavior is undefined unless "ListTunables" is the selection of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& show() const;
    // Return a reference to the non-modifiable "Show" selection of this
    // object if "Show" is the current selection.  The behavior is
    // undefined unless "Show" is the selection of this object.

    const SetTunable& setTunable() const;
    // Return a reference to the non-modifiable "SetTunable" selection of
    // this object if "SetTunable" is the current selection.  The behavior
    // is undefined unless "SetTunable" is the selection of this object.

    const bsl::string& getTunable() const;
    // Return a reference to the non-modifiable "GetTunable" selection of
    // this object if "GetTunable" is the current selection.  The behavior
    // is undefined unless "GetTunable" is the selection of this object.

    const Void& listTunables() const;
    // Return a reference to the non-modifiable "ListTunables" selection of
    // this object if "ListTunables" is the current selection.  The
    // behavior is undefined unless "ListTunables" is the selection of this
    // object.

    bool isShowValue() const;
    // Return 'true' if the value of this object is a "Show" value, and
    // return 'false' otherwise.

    bool isSetTunableValue() const;
    // Return 'true' if the value of this object is a "SetTunable" value,
    // and return 'false' otherwise.

    bool isGetTunableValue() const;
    // Return 'true' if the value of this object is a "GetTunable" value,
    // and return 'false' otherwise.

    bool isListTunablesValue() const;
    // Return 'true' if the value of this object is a "ListTunables" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StatCommand& lhs, const StatCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'StatCommand' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StatCommand& lhs, const StatCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const StatCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const StatCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'StatCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::StatCommand)

namespace mqbcmd {

// =======================
// class SubscriptionGroup
// =======================

class SubscriptionGroup {
    // INSTANCE DATA
    bsl::string                        d_expression;
    bdlb::NullableValue<PriorityGroup> d_priorityGroup;
    unsigned int                       d_id;
    unsigned int                       d_upstreamSubQueueId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const SubscriptionGroup& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_ID                    = 0,
        ATTRIBUTE_ID_EXPRESSION            = 1,
        ATTRIBUTE_ID_UPSTREAM_SUB_QUEUE_ID = 2,
        ATTRIBUTE_ID_PRIORITY_GROUP        = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_ID                    = 0,
        ATTRIBUTE_INDEX_EXPRESSION            = 1,
        ATTRIBUTE_INDEX_UPSTREAM_SUB_QUEUE_ID = 2,
        ATTRIBUTE_INDEX_PRIORITY_GROUP        = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit SubscriptionGroup(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'SubscriptionGroup' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    SubscriptionGroup(const SubscriptionGroup& original,
                      bslma::Allocator*        basicAllocator = 0);
    // Create an object of type 'SubscriptionGroup' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SubscriptionGroup(SubscriptionGroup&& original) noexcept;
    // Create an object of type 'SubscriptionGroup' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    SubscriptionGroup(SubscriptionGroup&& original,
                      bslma::Allocator*   basicAllocator);
    // Create an object of type 'SubscriptionGroup' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~SubscriptionGroup();
    // Destroy this object.

    // MANIPULATORS
    SubscriptionGroup& operator=(const SubscriptionGroup& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    SubscriptionGroup& operator=(SubscriptionGroup&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& id();
    // Return a reference to the modifiable "Id" attribute of this object.

    bsl::string& expression();
    // Return a reference to the modifiable "Expression" attribute of this
    // object.

    unsigned int& upstreamSubQueueId();
    // Return a reference to the modifiable "UpstreamSubQueueId" attribute
    // of this object.

    bdlb::NullableValue<PriorityGroup>& priorityGroup();
    // Return a reference to the modifiable "PriorityGroup" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int id() const;
    // Return the value of the "Id" attribute of this object.

    const bsl::string& expression() const;
    // Return a reference offering non-modifiable access to the
    // "Expression" attribute of this object.

    unsigned int upstreamSubQueueId() const;
    // Return the value of the "UpstreamSubQueueId" attribute of this
    // object.

    const bdlb::NullableValue<PriorityGroup>& priorityGroup() const;
    // Return a reference offering non-modifiable access to the
    // "PriorityGroup" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const SubscriptionGroup& lhs,
                           const SubscriptionGroup& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const SubscriptionGroup& lhs,
                           const SubscriptionGroup& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const SubscriptionGroup& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const SubscriptionGroup& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'SubscriptionGroup'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::SubscriptionGroup)

namespace mqbcmd {

// ==============
// class Tunables
// ==============

class Tunables {
    // INSTANCE DATA
    bsl::vector<Tunable> d_tunables;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_TUNABLES = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_TUNABLES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Tunables(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Tunables' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Tunables(const Tunables& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Tunables' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunables(Tunables&& original) noexcept;
    // Create an object of type 'Tunables' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    Tunables(Tunables&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Tunables' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Tunables();
    // Destroy this object.

    // MANIPULATORS
    Tunables& operator=(const Tunables& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunables& operator=(Tunables&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<Tunable>& tunables();
    // Return a reference to the modifiable "Tunables" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<Tunable>& tunables() const;
    // Return a reference offering non-modifiable access to the "Tunables"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Tunables& lhs, const Tunables& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.tunables() == rhs.tunables();
    }

    friend bool operator!=(const Tunables& lhs, const Tunables& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Tunables& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Tunables& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Tunables'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.tunables());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Tunables)

namespace mqbcmd {

// =========================
// class ClusterStateCommand
// =========================

class ClusterStateCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<ElectorCommand> d_elector;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterStateCommand& rhs) const;

  public:
    // TYPES

    enum { SELECTION_ID_UNDEFINED = -1, SELECTION_ID_ELECTOR = 0 };

    enum { NUM_SELECTIONS = 1 };

    enum { SELECTION_INDEX_ELECTOR = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterStateCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterStateCommand' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ClusterStateCommand(const ClusterStateCommand& original,
                        bslma::Allocator*          basicAllocator = 0);
    // Create an object of type 'ClusterStateCommand' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateCommand(ClusterStateCommand&& original) noexcept;
    // Create an object of type 'ClusterStateCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterStateCommand(ClusterStateCommand&& original,
                        bslma::Allocator*     basicAllocator);
    // Create an object of type 'ClusterStateCommand' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterStateCommand();
    // Destroy this object.

    // MANIPULATORS
    ClusterStateCommand& operator=(const ClusterStateCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateCommand& operator=(ClusterStateCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    ElectorCommand& makeElector();
    ElectorCommand& makeElector(const ElectorCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorCommand& makeElector(ElectorCommand&& value);
#endif
    // Set the value of this object to be a "Elector" value.  Optionally
    // specify the 'value' of the "Elector".  If 'value' is not specified,
    // the default "Elector" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    ElectorCommand& elector();
    // Return a reference to the modifiable "Elector" selection of this
    // object if "Elector" is the current selection.  The behavior is
    // undefined unless "Elector" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const ElectorCommand& elector() const;
    // Return a reference to the non-modifiable "Elector" selection of this
    // object if "Elector" is the current selection.  The behavior is
    // undefined unless "Elector" is the selection of this object.

    bool isElectorValue() const;
    // Return 'true' if the value of this object is a "Elector" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterStateCommand& lhs,
                           const ClusterStateCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ClusterStateCommand' objects
    // have the same value if either the selections in both objects have
    // the same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterStateCommand& lhs,
                           const ClusterStateCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const ClusterStateCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const ClusterStateCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterStateCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClusterStateCommand)

namespace mqbcmd {

// ===========================
// class ClusterStorageSummary
// ===========================

class ClusterStorageSummary {
    // INSTANCE DATA
    bsl::vector<FileStore> d_fileStores;
    bsl::string            d_clusterFileStoreLocation;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_CLUSTER_FILE_STORE_LOCATION = 0,
        ATTRIBUTE_ID_FILE_STORES                 = 1
    };

    enum { NUM_ATTRIBUTES = 2 };

    enum {
        ATTRIBUTE_INDEX_CLUSTER_FILE_STORE_LOCATION = 0,
        ATTRIBUTE_INDEX_FILE_STORES                 = 1
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterStorageSummary(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterStorageSummary' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ClusterStorageSummary(const ClusterStorageSummary& original,
                          bslma::Allocator*            basicAllocator = 0);
    // Create an object of type 'ClusterStorageSummary' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStorageSummary(ClusterStorageSummary&& original) noexcept;
    // Create an object of type 'ClusterStorageSummary' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterStorageSummary(ClusterStorageSummary&& original,
                          bslma::Allocator*       basicAllocator);
    // Create an object of type 'ClusterStorageSummary' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterStorageSummary();
    // Destroy this object.

    // MANIPULATORS
    ClusterStorageSummary& operator=(const ClusterStorageSummary& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStorageSummary& operator=(ClusterStorageSummary&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& clusterFileStoreLocation();
    // Return a reference to the modifiable "ClusterFileStoreLocation"
    // attribute of this object.

    bsl::vector<FileStore>& fileStores();
    // Return a reference to the modifiable "FileStores" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& clusterFileStoreLocation() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterFileStoreLocation" attribute of this object.

    const bsl::vector<FileStore>& fileStores() const;
    // Return a reference offering non-modifiable access to the
    // "FileStores" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterStorageSummary& lhs,
                           const ClusterStorageSummary& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.clusterFileStoreLocation() ==
                   rhs.clusterFileStoreLocation() &&
               lhs.fileStores() == rhs.fileStores();
    }

    friend bool operator!=(const ClusterStorageSummary& lhs,
                           const ClusterStorageSummary& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                stream,
                                    const ClusterStorageSummary& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&            hashAlg,
                           const ClusterStorageSummary& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterStorageSummary'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.clusterFileStoreLocation());
        hashAppend(hashAlg, object.fileStores());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClusterStorageSummary)

namespace mqbcmd {

// ============
// class Domain
// ============

class Domain {
    // INSTANCE DATA
    bsl::string   d_name;
    DomainCommand d_command;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_NAME = 0, ATTRIBUTE_ID_COMMAND = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_NAME = 0, ATTRIBUTE_INDEX_COMMAND = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Domain(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Domain' having the default value.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Domain(const Domain& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Domain' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Domain(Domain&& original) noexcept;
    // Create an object of type 'Domain' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Domain(Domain&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Domain' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Domain();
    // Destroy this object.

    // MANIPULATORS
    Domain& operator=(const Domain& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Domain& operator=(Domain&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    DomainCommand& command();
    // Return a reference to the modifiable "Command" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const DomainCommand& command() const;
    // Return a reference offering non-modifiable access to the "Command"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Domain& lhs, const Domain& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() && lhs.command() == rhs.command();
    }

    friend bool operator!=(const Domain& lhs, const Domain& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Domain& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Domain& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Domain'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.name());
        hashAppend(hashAlg, object.command());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Domain)

namespace mqbcmd {

// ===================
// class ElectorResult
// ===================

class ElectorResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>               d_error;
        bsls::ObjectBuffer<Tunable>             d_tunable;
        bsls::ObjectBuffer<Tunables>            d_tunables;
        bsls::ObjectBuffer<TunableConfirmation> d_tunableConfirmation;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ElectorResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED            = -1,
        SELECTION_ID_ERROR                = 0,
        SELECTION_ID_TUNABLE              = 1,
        SELECTION_ID_TUNABLES             = 2,
        SELECTION_ID_TUNABLE_CONFIRMATION = 3
    };

    enum { NUM_SELECTIONS = 4 };

    enum {
        SELECTION_INDEX_ERROR                = 0,
        SELECTION_INDEX_TUNABLE              = 1,
        SELECTION_INDEX_TUNABLES             = 2,
        SELECTION_INDEX_TUNABLE_CONFIRMATION = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ElectorResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ElectorResult' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ElectorResult(const ElectorResult& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'ElectorResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorResult(ElectorResult&& original) noexcept;
    // Create an object of type 'ElectorResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ElectorResult(ElectorResult&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ElectorResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ElectorResult();
    // Destroy this object.

    // MANIPULATORS
    ElectorResult& operator=(const ElectorResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorResult& operator=(ElectorResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    Tunable& makeTunable();
    Tunable& makeTunable(const Tunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunable& makeTunable(Tunable&& value);
#endif
    // Set the value of this object to be a "Tunable" value.  Optionally
    // specify the 'value' of the "Tunable".  If 'value' is not specified,
    // the default "Tunable" value is used.

    Tunables& makeTunables();
    Tunables& makeTunables(const Tunables& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunables& makeTunables(Tunables&& value);
#endif
    // Set the value of this object to be a "Tunables" value.  Optionally
    // specify the 'value' of the "Tunables".  If 'value' is not specified,
    // the default "Tunables" value is used.

    TunableConfirmation& makeTunableConfirmation();
    TunableConfirmation&
    makeTunableConfirmation(const TunableConfirmation& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    TunableConfirmation& makeTunableConfirmation(TunableConfirmation&& value);
#endif
    // Set the value of this object to be a "TunableConfirmation" value.
    // Optionally specify the 'value' of the "TunableConfirmation".  If
    // 'value' is not specified, the default "TunableConfirmation" value is
    // used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    Tunable& tunable();
    // Return a reference to the modifiable "Tunable" selection of this
    // object if "Tunable" is the current selection.  The behavior is
    // undefined unless "Tunable" is the selection of this object.

    Tunables& tunables();
    // Return a reference to the modifiable "Tunables" selection of this
    // object if "Tunables" is the current selection.  The behavior is
    // undefined unless "Tunables" is the selection of this object.

    TunableConfirmation& tunableConfirmation();
    // Return a reference to the modifiable "TunableConfirmation" selection
    // of this object if "TunableConfirmation" is the current selection.
    // The behavior is undefined unless "TunableConfirmation" is the
    // selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const Tunable& tunable() const;
    // Return a reference to the non-modifiable "Tunable" selection of this
    // object if "Tunable" is the current selection.  The behavior is
    // undefined unless "Tunable" is the selection of this object.

    const Tunables& tunables() const;
    // Return a reference to the non-modifiable "Tunables" selection of
    // this object if "Tunables" is the current selection.  The behavior is
    // undefined unless "Tunables" is the selection of this object.

    const TunableConfirmation& tunableConfirmation() const;
    // Return a reference to the non-modifiable "TunableConfirmation"
    // selection of this object if "TunableConfirmation" is the current
    // selection.  The behavior is undefined unless "TunableConfirmation"
    // is the selection of this object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isTunableValue() const;
    // Return 'true' if the value of this object is a "Tunable" value, and
    // return 'false' otherwise.

    bool isTunablesValue() const;
    // Return 'true' if the value of this object is a "Tunables" value, and
    // return 'false' otherwise.

    bool isTunableConfirmationValue() const;
    // Return 'true' if the value of this object is a "TunableConfirmation"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ElectorResult& lhs, const ElectorResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ElectorResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ElectorResult& lhs, const ElectorResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const ElectorResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const ElectorResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ElectorResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ElectorResult)

namespace mqbcmd {

// ================
// class QueueState
// ================

class QueueState {
    // INSTANCE DATA
    bsl::vector<QueueHandle>           d_handles;
    bsl::string                        d_uri;
    bsl::string                        d_handleParametersJson;
    bsl::string                        d_streamParametersJson;
    bsl::string                        d_key;
    bdlb::NullableValue<QueueStorage>  d_storage;
    bdlb::NullableValue<CapacityMeter> d_capacityMeter;
    unsigned int                       d_id;
    int                                d_partitionId;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueState& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_URI                    = 0,
        ATTRIBUTE_ID_HANDLE_PARAMETERS_JSON = 1,
        ATTRIBUTE_ID_STREAM_PARAMETERS_JSON = 2,
        ATTRIBUTE_ID_ID                     = 3,
        ATTRIBUTE_ID_KEY                    = 4,
        ATTRIBUTE_ID_PARTITION_ID           = 5,
        ATTRIBUTE_ID_STORAGE                = 6,
        ATTRIBUTE_ID_CAPACITY_METER         = 7,
        ATTRIBUTE_ID_HANDLES                = 8
    };

    enum { NUM_ATTRIBUTES = 9 };

    enum {
        ATTRIBUTE_INDEX_URI                    = 0,
        ATTRIBUTE_INDEX_HANDLE_PARAMETERS_JSON = 1,
        ATTRIBUTE_INDEX_STREAM_PARAMETERS_JSON = 2,
        ATTRIBUTE_INDEX_ID                     = 3,
        ATTRIBUTE_INDEX_KEY                    = 4,
        ATTRIBUTE_INDEX_PARTITION_ID           = 5,
        ATTRIBUTE_INDEX_STORAGE                = 6,
        ATTRIBUTE_INDEX_CAPACITY_METER         = 7,
        ATTRIBUTE_INDEX_HANDLES                = 8
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueState(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueState' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueState(const QueueState& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueState' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueState(QueueState&& original) noexcept;
    // Create an object of type 'QueueState' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueState(QueueState&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueState' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueState();
    // Destroy this object.

    // MANIPULATORS
    QueueState& operator=(const QueueState& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueState& operator=(QueueState&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& uri();
    // Return a reference to the modifiable "Uri" attribute of this object.

    bsl::string& handleParametersJson();
    // Return a reference to the modifiable "HandleParametersJson"
    // attribute of this object.

    bsl::string& streamParametersJson();
    // Return a reference to the modifiable "StreamParametersJson"
    // attribute of this object.

    unsigned int& id();
    // Return a reference to the modifiable "Id" attribute of this object.

    bsl::string& key();
    // Return a reference to the modifiable "Key" attribute of this object.

    int& partitionId();
    // Return a reference to the modifiable "PartitionId" attribute of this
    // object.

    bdlb::NullableValue<QueueStorage>& storage();
    // Return a reference to the modifiable "Storage" attribute of this
    // object.

    bdlb::NullableValue<CapacityMeter>& capacityMeter();
    // Return a reference to the modifiable "CapacityMeter" attribute of
    // this object.

    bsl::vector<QueueHandle>& handles();
    // Return a reference to the modifiable "Handles" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& uri() const;
    // Return a reference offering non-modifiable access to the "Uri"
    // attribute of this object.

    const bsl::string& handleParametersJson() const;
    // Return a reference offering non-modifiable access to the
    // "HandleParametersJson" attribute of this object.

    const bsl::string& streamParametersJson() const;
    // Return a reference offering non-modifiable access to the
    // "StreamParametersJson" attribute of this object.

    unsigned int id() const;
    // Return the value of the "Id" attribute of this object.

    const bsl::string& key() const;
    // Return a reference offering non-modifiable access to the "Key"
    // attribute of this object.

    int partitionId() const;
    // Return the value of the "PartitionId" attribute of this object.

    const bdlb::NullableValue<QueueStorage>& storage() const;
    // Return a reference offering non-modifiable access to the "Storage"
    // attribute of this object.

    const bdlb::NullableValue<CapacityMeter>& capacityMeter() const;
    // Return a reference offering non-modifiable access to the
    // "CapacityMeter" attribute of this object.

    const bsl::vector<QueueHandle>& handles() const;
    // Return a reference offering non-modifiable access to the "Handles"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueState& lhs, const QueueState& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueState& lhs, const QueueState& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const QueueState& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const QueueState& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'QueueState'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::QueueState)

namespace mqbcmd {

// =======================
// class ReplicationResult
// =======================

class ReplicationResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>               d_error;
        bsls::ObjectBuffer<Tunable>             d_tunable;
        bsls::ObjectBuffer<Tunables>            d_tunables;
        bsls::ObjectBuffer<TunableConfirmation> d_tunableConfirmation;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ReplicationResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED            = -1,
        SELECTION_ID_ERROR                = 0,
        SELECTION_ID_TUNABLE              = 1,
        SELECTION_ID_TUNABLES             = 2,
        SELECTION_ID_TUNABLE_CONFIRMATION = 3
    };

    enum { NUM_SELECTIONS = 4 };

    enum {
        SELECTION_INDEX_ERROR                = 0,
        SELECTION_INDEX_TUNABLE              = 1,
        SELECTION_INDEX_TUNABLES             = 2,
        SELECTION_INDEX_TUNABLE_CONFIRMATION = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ReplicationResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ReplicationResult' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    ReplicationResult(const ReplicationResult& original,
                      bslma::Allocator*        basicAllocator = 0);
    // Create an object of type 'ReplicationResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicationResult(ReplicationResult&& original) noexcept;
    // Create an object of type 'ReplicationResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ReplicationResult(ReplicationResult&& original,
                      bslma::Allocator*   basicAllocator);
    // Create an object of type 'ReplicationResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ReplicationResult();
    // Destroy this object.

    // MANIPULATORS
    ReplicationResult& operator=(const ReplicationResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicationResult& operator=(ReplicationResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    Tunable& makeTunable();
    Tunable& makeTunable(const Tunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunable& makeTunable(Tunable&& value);
#endif
    // Set the value of this object to be a "Tunable" value.  Optionally
    // specify the 'value' of the "Tunable".  If 'value' is not specified,
    // the default "Tunable" value is used.

    Tunables& makeTunables();
    Tunables& makeTunables(const Tunables& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunables& makeTunables(Tunables&& value);
#endif
    // Set the value of this object to be a "Tunables" value.  Optionally
    // specify the 'value' of the "Tunables".  If 'value' is not specified,
    // the default "Tunables" value is used.

    TunableConfirmation& makeTunableConfirmation();
    TunableConfirmation&
    makeTunableConfirmation(const TunableConfirmation& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    TunableConfirmation& makeTunableConfirmation(TunableConfirmation&& value);
#endif
    // Set the value of this object to be a "TunableConfirmation" value.
    // Optionally specify the 'value' of the "TunableConfirmation".  If
    // 'value' is not specified, the default "TunableConfirmation" value is
    // used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    Tunable& tunable();
    // Return a reference to the modifiable "Tunable" selection of this
    // object if "Tunable" is the current selection.  The behavior is
    // undefined unless "Tunable" is the selection of this object.

    Tunables& tunables();
    // Return a reference to the modifiable "Tunables" selection of this
    // object if "Tunables" is the current selection.  The behavior is
    // undefined unless "Tunables" is the selection of this object.

    TunableConfirmation& tunableConfirmation();
    // Return a reference to the modifiable "TunableConfirmation" selection
    // of this object if "TunableConfirmation" is the current selection.
    // The behavior is undefined unless "TunableConfirmation" is the
    // selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const Tunable& tunable() const;
    // Return a reference to the non-modifiable "Tunable" selection of this
    // object if "Tunable" is the current selection.  The behavior is
    // undefined unless "Tunable" is the selection of this object.

    const Tunables& tunables() const;
    // Return a reference to the non-modifiable "Tunables" selection of
    // this object if "Tunables" is the current selection.  The behavior is
    // undefined unless "Tunables" is the selection of this object.

    const TunableConfirmation& tunableConfirmation() const;
    // Return a reference to the non-modifiable "TunableConfirmation"
    // selection of this object if "TunableConfirmation" is the current
    // selection.  The behavior is undefined unless "TunableConfirmation"
    // is the selection of this object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isTunableValue() const;
    // Return 'true' if the value of this object is a "Tunable" value, and
    // return 'false' otherwise.

    bool isTunablesValue() const;
    // Return 'true' if the value of this object is a "Tunables" value, and
    // return 'false' otherwise.

    bool isTunableConfirmationValue() const;
    // Return 'true' if the value of this object is a "TunableConfirmation"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ReplicationResult& lhs,
                           const ReplicationResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ReplicationResult' objects have
    // the same value if either the selections in both objects have the
    // same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ReplicationResult& lhs,
                           const ReplicationResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const ReplicationResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const ReplicationResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ReplicationResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ReplicationResult)

namespace mqbcmd {

// ====================
// class RouterConsumer
// ====================

class RouterConsumer {
    // INSTANCE DATA
    bsl::string  d_expression;
    QueueHandle  d_queueHandle;
    unsigned int d_count;
    int          d_priority;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const RouterConsumer& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_PRIORITY     = 0,
        ATTRIBUTE_ID_QUEUE_HANDLE = 1,
        ATTRIBUTE_ID_COUNT        = 2,
        ATTRIBUTE_ID_EXPRESSION   = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_PRIORITY     = 0,
        ATTRIBUTE_INDEX_QUEUE_HANDLE = 1,
        ATTRIBUTE_INDEX_COUNT        = 2,
        ATTRIBUTE_INDEX_EXPRESSION   = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RouterConsumer(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RouterConsumer' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    RouterConsumer(const RouterConsumer& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'RouterConsumer' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouterConsumer(RouterConsumer&& original) noexcept;
    // Create an object of type 'RouterConsumer' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    RouterConsumer(RouterConsumer&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'RouterConsumer' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~RouterConsumer();
    // Destroy this object.

    // MANIPULATORS
    RouterConsumer& operator=(const RouterConsumer& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouterConsumer& operator=(RouterConsumer&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    int& priority();
    // Return a reference to the modifiable "Priority" attribute of this
    // object.

    QueueHandle& queueHandle();
    // Return a reference to the modifiable "QueueHandle" attribute of this
    // object.

    unsigned int& count();
    // Return a reference to the modifiable "Count" attribute of this
    // object.

    bsl::string& expression();
    // Return a reference to the modifiable "Expression" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    int priority() const;
    // Return the value of the "Priority" attribute of this object.

    const QueueHandle& queueHandle() const;
    // Return a reference offering non-modifiable access to the
    // "QueueHandle" attribute of this object.

    unsigned int count() const;
    // Return the value of the "Count" attribute of this object.

    const bsl::string& expression() const;
    // Return a reference offering non-modifiable access to the
    // "Expression" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RouterConsumer& lhs,
                           const RouterConsumer& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const RouterConsumer& lhs,
                           const RouterConsumer& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const RouterConsumer& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const RouterConsumer& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RouterConsumer'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RouterConsumer)

namespace mqbcmd {

// =============
// class Routing
// =============

class Routing {
    // INSTANCE DATA
    bsl::vector<SubscriptionGroup> d_subscriptionGroups;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SUBSCRIPTION_GROUPS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_SUBSCRIPTION_GROUPS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Routing(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Routing' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Routing(const Routing& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Routing' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Routing(Routing&& original) noexcept;
    // Create an object of type 'Routing' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Routing(Routing&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Routing' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Routing();
    // Destroy this object.

    // MANIPULATORS
    Routing& operator=(const Routing& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Routing& operator=(Routing&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<SubscriptionGroup>& subscriptionGroups();
    // Return a reference to the modifiable "SubscriptionGroups" attribute
    // of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<SubscriptionGroup>& subscriptionGroups() const;
    // Return a reference offering non-modifiable access to the
    // "SubscriptionGroups" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Routing& lhs, const Routing& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.subscriptionGroups() == rhs.subscriptionGroups();
    }

    friend bool operator!=(const Routing& lhs, const Routing& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Routing& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Routing& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Routing'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.subscriptionGroups());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Routing)

namespace mqbcmd {

// ================
// class StatResult
// ================

class StatResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>               d_error;
        bsls::ObjectBuffer<bsl::string>         d_stats;
        bsls::ObjectBuffer<Tunable>             d_tunable;
        bsls::ObjectBuffer<Tunables>            d_tunables;
        bsls::ObjectBuffer<TunableConfirmation> d_tunableConfirmation;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StatResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED            = -1,
        SELECTION_ID_ERROR                = 0,
        SELECTION_ID_STATS                = 1,
        SELECTION_ID_TUNABLE              = 2,
        SELECTION_ID_TUNABLES             = 3,
        SELECTION_ID_TUNABLE_CONFIRMATION = 4
    };

    enum { NUM_SELECTIONS = 5 };

    enum {
        SELECTION_INDEX_ERROR                = 0,
        SELECTION_INDEX_STATS                = 1,
        SELECTION_INDEX_TUNABLE              = 2,
        SELECTION_INDEX_TUNABLES             = 3,
        SELECTION_INDEX_TUNABLE_CONFIRMATION = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit StatResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StatResult' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StatResult(const StatResult& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StatResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StatResult(StatResult&& original) noexcept;
    // Create an object of type 'StatResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StatResult(StatResult&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'StatResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StatResult();
    // Destroy this object.

    // MANIPULATORS
    StatResult& operator=(const StatResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StatResult& operator=(StatResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    bsl::string& makeStats();
    bsl::string& makeStats(const bsl::string& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bsl::string& makeStats(bsl::string&& value);
#endif
    // Set the value of this object to be a "Stats" value.  Optionally
    // specify the 'value' of the "Stats".  If 'value' is not specified,
    // the default "Stats" value is used.

    Tunable& makeTunable();
    Tunable& makeTunable(const Tunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunable& makeTunable(Tunable&& value);
#endif
    // Set the value of this object to be a "Tunable" value.  Optionally
    // specify the 'value' of the "Tunable".  If 'value' is not specified,
    // the default "Tunable" value is used.

    Tunables& makeTunables();
    Tunables& makeTunables(const Tunables& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunables& makeTunables(Tunables&& value);
#endif
    // Set the value of this object to be a "Tunables" value.  Optionally
    // specify the 'value' of the "Tunables".  If 'value' is not specified,
    // the default "Tunables" value is used.

    TunableConfirmation& makeTunableConfirmation();
    TunableConfirmation&
    makeTunableConfirmation(const TunableConfirmation& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    TunableConfirmation& makeTunableConfirmation(TunableConfirmation&& value);
#endif
    // Set the value of this object to be a "TunableConfirmation" value.
    // Optionally specify the 'value' of the "TunableConfirmation".  If
    // 'value' is not specified, the default "TunableConfirmation" value is
    // used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    bsl::string& stats();
    // Return a reference to the modifiable "Stats" selection of this
    // object if "Stats" is the current selection.  The behavior is
    // undefined unless "Stats" is the selection of this object.

    Tunable& tunable();
    // Return a reference to the modifiable "Tunable" selection of this
    // object if "Tunable" is the current selection.  The behavior is
    // undefined unless "Tunable" is the selection of this object.

    Tunables& tunables();
    // Return a reference to the modifiable "Tunables" selection of this
    // object if "Tunables" is the current selection.  The behavior is
    // undefined unless "Tunables" is the selection of this object.

    TunableConfirmation& tunableConfirmation();
    // Return a reference to the modifiable "TunableConfirmation" selection
    // of this object if "TunableConfirmation" is the current selection.
    // The behavior is undefined unless "TunableConfirmation" is the
    // selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const bsl::string& stats() const;
    // Return a reference to the non-modifiable "Stats" selection of this
    // object if "Stats" is the current selection.  The behavior is
    // undefined unless "Stats" is the selection of this object.

    const Tunable& tunable() const;
    // Return a reference to the non-modifiable "Tunable" selection of this
    // object if "Tunable" is the current selection.  The behavior is
    // undefined unless "Tunable" is the selection of this object.

    const Tunables& tunables() const;
    // Return a reference to the non-modifiable "Tunables" selection of
    // this object if "Tunables" is the current selection.  The behavior is
    // undefined unless "Tunables" is the selection of this object.

    const TunableConfirmation& tunableConfirmation() const;
    // Return a reference to the non-modifiable "TunableConfirmation"
    // selection of this object if "TunableConfirmation" is the current
    // selection.  The behavior is undefined unless "TunableConfirmation"
    // is the selection of this object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isStatsValue() const;
    // Return 'true' if the value of this object is a "Stats" value, and
    // return 'false' otherwise.

    bool isTunableValue() const;
    // Return 'true' if the value of this object is a "Tunable" value, and
    // return 'false' otherwise.

    bool isTunablesValue() const;
    // Return 'true' if the value of this object is a "Tunables" value, and
    // return 'false' otherwise.

    bool isTunableConfirmationValue() const;
    // Return 'true' if the value of this object is a "TunableConfirmation"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StatResult& lhs, const StatResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'StatResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StatResult& lhs, const StatResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const StatResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const StatResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'StatResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::StatResult)

namespace mqbcmd {

// ====================
// class StorageCommand
// ====================

class StorageCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>               d_summary;
        bsls::ObjectBuffer<StoragePartition>   d_partition;
        bsls::ObjectBuffer<StorageDomain>      d_domain;
        bsls::ObjectBuffer<StorageQueue>       d_queue;
        bsls::ObjectBuffer<ReplicationCommand> d_replication;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StorageCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED   = -1,
        SELECTION_ID_SUMMARY     = 0,
        SELECTION_ID_PARTITION   = 1,
        SELECTION_ID_DOMAIN      = 2,
        SELECTION_ID_QUEUE       = 3,
        SELECTION_ID_REPLICATION = 4
    };

    enum { NUM_SELECTIONS = 5 };

    enum {
        SELECTION_INDEX_SUMMARY     = 0,
        SELECTION_INDEX_PARTITION   = 1,
        SELECTION_INDEX_DOMAIN      = 2,
        SELECTION_INDEX_QUEUE       = 3,
        SELECTION_INDEX_REPLICATION = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit StorageCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StorageCommand' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StorageCommand(const StorageCommand& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'StorageCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageCommand(StorageCommand&& original) noexcept;
    // Create an object of type 'StorageCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StorageCommand(StorageCommand&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'StorageCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StorageCommand();
    // Destroy this object.

    // MANIPULATORS
    StorageCommand& operator=(const StorageCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageCommand& operator=(StorageCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeSummary();
    Void& makeSummary(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSummary(Void&& value);
#endif
    // Set the value of this object to be a "Summary" value.  Optionally
    // specify the 'value' of the "Summary".  If 'value' is not specified,
    // the default "Summary" value is used.

    StoragePartition& makePartition();
    StoragePartition& makePartition(const StoragePartition& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StoragePartition& makePartition(StoragePartition&& value);
#endif
    // Set the value of this object to be a "Partition" value.  Optionally
    // specify the 'value' of the "Partition".  If 'value' is not
    // specified, the default "Partition" value is used.

    StorageDomain& makeDomain();
    StorageDomain& makeDomain(const StorageDomain& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageDomain& makeDomain(StorageDomain&& value);
#endif
    // Set the value of this object to be a "Domain" value.  Optionally
    // specify the 'value' of the "Domain".  If 'value' is not specified,
    // the default "Domain" value is used.

    StorageQueue& makeQueue();
    StorageQueue& makeQueue(const StorageQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageQueue& makeQueue(StorageQueue&& value);
#endif
    // Set the value of this object to be a "Queue" value.  Optionally
    // specify the 'value' of the "Queue".  If 'value' is not specified,
    // the default "Queue" value is used.

    ReplicationCommand& makeReplication();
    ReplicationCommand& makeReplication(const ReplicationCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicationCommand& makeReplication(ReplicationCommand&& value);
#endif
    // Set the value of this object to be a "Replication" value.
    // Optionally specify the 'value' of the "Replication".  If 'value' is
    // not specified, the default "Replication" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& summary();
    // Return a reference to the modifiable "Summary" selection of this
    // object if "Summary" is the current selection.  The behavior is
    // undefined unless "Summary" is the selection of this object.

    StoragePartition& partition();
    // Return a reference to the modifiable "Partition" selection of this
    // object if "Partition" is the current selection.  The behavior is
    // undefined unless "Partition" is the selection of this object.

    StorageDomain& domain();
    // Return a reference to the modifiable "Domain" selection of this
    // object if "Domain" is the current selection.  The behavior is
    // undefined unless "Domain" is the selection of this object.

    StorageQueue& queue();
    // Return a reference to the modifiable "Queue" selection of this
    // object if "Queue" is the current selection.  The behavior is
    // undefined unless "Queue" is the selection of this object.

    ReplicationCommand& replication();
    // Return a reference to the modifiable "Replication" selection of this
    // object if "Replication" is the current selection.  The behavior is
    // undefined unless "Replication" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& summary() const;
    // Return a reference to the non-modifiable "Summary" selection of this
    // object if "Summary" is the current selection.  The behavior is
    // undefined unless "Summary" is the selection of this object.

    const StoragePartition& partition() const;
    // Return a reference to the non-modifiable "Partition" selection of
    // this object if "Partition" is the current selection.  The behavior
    // is undefined unless "Partition" is the selection of this object.

    const StorageDomain& domain() const;
    // Return a reference to the non-modifiable "Domain" selection of this
    // object if "Domain" is the current selection.  The behavior is
    // undefined unless "Domain" is the selection of this object.

    const StorageQueue& queue() const;
    // Return a reference to the non-modifiable "Queue" selection of this
    // object if "Queue" is the current selection.  The behavior is
    // undefined unless "Queue" is the selection of this object.

    const ReplicationCommand& replication() const;
    // Return a reference to the non-modifiable "Replication" selection of
    // this object if "Replication" is the current selection.  The behavior
    // is undefined unless "Replication" is the selection of this object.

    bool isSummaryValue() const;
    // Return 'true' if the value of this object is a "Summary" value, and
    // return 'false' otherwise.

    bool isPartitionValue() const;
    // Return 'true' if the value of this object is a "Partition" value,
    // and return 'false' otherwise.

    bool isDomainValue() const;
    // Return 'true' if the value of this object is a "Domain" value, and
    // return 'false' otherwise.

    bool isQueueValue() const;
    // Return 'true' if the value of this object is a "Queue" value, and
    // return 'false' otherwise.

    bool isReplicationValue() const;
    // Return 'true' if the value of this object is a "Replication" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageCommand& lhs,
                           const StorageCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'StorageCommand' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StorageCommand& lhs,
                           const StorageCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const StorageCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const StorageCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::StorageCommand)

namespace mqbcmd {

// ====================
// class ClusterCommand
// ====================

class ClusterCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>                d_status;
        bsls::ObjectBuffer<Void>                d_queueHelper;
        bsls::ObjectBuffer<Void>                d_forceGcQueues;
        bsls::ObjectBuffer<StorageCommand>      d_storage;
        bsls::ObjectBuffer<ClusterStateCommand> d_state;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED       = -1,
        SELECTION_ID_STATUS          = 0,
        SELECTION_ID_QUEUE_HELPER    = 1,
        SELECTION_ID_FORCE_GC_QUEUES = 2,
        SELECTION_ID_STORAGE         = 3,
        SELECTION_ID_STATE           = 4
    };

    enum { NUM_SELECTIONS = 5 };

    enum {
        SELECTION_INDEX_STATUS          = 0,
        SELECTION_INDEX_QUEUE_HELPER    = 1,
        SELECTION_INDEX_FORCE_GC_QUEUES = 2,
        SELECTION_INDEX_STORAGE         = 3,
        SELECTION_INDEX_STATE           = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterCommand' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterCommand(const ClusterCommand& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'ClusterCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterCommand(ClusterCommand&& original) noexcept;
    // Create an object of type 'ClusterCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterCommand(ClusterCommand&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterCommand();
    // Destroy this object.

    // MANIPULATORS
    ClusterCommand& operator=(const ClusterCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterCommand& operator=(ClusterCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeStatus();
    Void& makeStatus(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeStatus(Void&& value);
#endif
    // Set the value of this object to be a "Status" value.  Optionally
    // specify the 'value' of the "Status".  If 'value' is not specified,
    // the default "Status" value is used.

    Void& makeQueueHelper();
    Void& makeQueueHelper(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeQueueHelper(Void&& value);
#endif
    // Set the value of this object to be a "QueueHelper" value.
    // Optionally specify the 'value' of the "QueueHelper".  If 'value' is
    // not specified, the default "QueueHelper" value is used.

    Void& makeForceGcQueues();
    Void& makeForceGcQueues(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeForceGcQueues(Void&& value);
#endif
    // Set the value of this object to be a "ForceGcQueues" value.
    // Optionally specify the 'value' of the "ForceGcQueues".  If 'value'
    // is not specified, the default "ForceGcQueues" value is used.

    StorageCommand& makeStorage();
    StorageCommand& makeStorage(const StorageCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageCommand& makeStorage(StorageCommand&& value);
#endif
    // Set the value of this object to be a "Storage" value.  Optionally
    // specify the 'value' of the "Storage".  If 'value' is not specified,
    // the default "Storage" value is used.

    ClusterStateCommand& makeState();
    ClusterStateCommand& makeState(const ClusterStateCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStateCommand& makeState(ClusterStateCommand&& value);
#endif
    // Set the value of this object to be a "State" value.  Optionally
    // specify the 'value' of the "State".  If 'value' is not specified,
    // the default "State" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& status();
    // Return a reference to the modifiable "Status" selection of this
    // object if "Status" is the current selection.  The behavior is
    // undefined unless "Status" is the selection of this object.

    Void& queueHelper();
    // Return a reference to the modifiable "QueueHelper" selection of this
    // object if "QueueHelper" is the current selection.  The behavior is
    // undefined unless "QueueHelper" is the selection of this object.

    Void& forceGcQueues();
    // Return a reference to the modifiable "ForceGcQueues" selection of
    // this object if "ForceGcQueues" is the current selection.  The
    // behavior is undefined unless "ForceGcQueues" is the selection of
    // this object.

    StorageCommand& storage();
    // Return a reference to the modifiable "Storage" selection of this
    // object if "Storage" is the current selection.  The behavior is
    // undefined unless "Storage" is the selection of this object.

    ClusterStateCommand& state();
    // Return a reference to the modifiable "State" selection of this
    // object if "State" is the current selection.  The behavior is
    // undefined unless "State" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& status() const;
    // Return a reference to the non-modifiable "Status" selection of this
    // object if "Status" is the current selection.  The behavior is
    // undefined unless "Status" is the selection of this object.

    const Void& queueHelper() const;
    // Return a reference to the non-modifiable "QueueHelper" selection of
    // this object if "QueueHelper" is the current selection.  The behavior
    // is undefined unless "QueueHelper" is the selection of this object.

    const Void& forceGcQueues() const;
    // Return a reference to the non-modifiable "ForceGcQueues" selection
    // of this object if "ForceGcQueues" is the current selection.  The
    // behavior is undefined unless "ForceGcQueues" is the selection of
    // this object.

    const StorageCommand& storage() const;
    // Return a reference to the non-modifiable "Storage" selection of this
    // object if "Storage" is the current selection.  The behavior is
    // undefined unless "Storage" is the selection of this object.

    const ClusterStateCommand& state() const;
    // Return a reference to the non-modifiable "State" selection of this
    // object if "State" is the current selection.  The behavior is
    // undefined unless "State" is the selection of this object.

    bool isStatusValue() const;
    // Return 'true' if the value of this object is a "Status" value, and
    // return 'false' otherwise.

    bool isQueueHelperValue() const;
    // Return 'true' if the value of this object is a "QueueHelper" value,
    // and return 'false' otherwise.

    bool isForceGcQueuesValue() const;
    // Return 'true' if the value of this object is a "ForceGcQueues"
    // value, and return 'false' otherwise.

    bool isStorageValue() const;
    // Return 'true' if the value of this object is a "Storage" value, and
    // return 'false' otherwise.

    bool isStateValue() const;
    // Return 'true' if the value of this object is a "State" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterCommand& lhs,
                           const ClusterCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ClusterCommand' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterCommand& lhs,
                           const ClusterCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const ClusterCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const ClusterCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ClusterCommand)

namespace mqbcmd {

// ===================
// class ClusterStatus
// ===================

class ClusterStatus {
    // INSTANCE DATA
    bsl::string           d_name;
    bsl::string           d_description;
    bsl::string           d_selfNodeDescription;
    StorageContent        d_queuesInfo;
    PartitionsInfo        d_partitionsInfo;
    NodeStatuses          d_nodeStatuses;
    ElectorInfo           d_electorInfo;
    ClusterStorageSummary d_clusterStorageSummary;
    bool                  d_isHealthy;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterStatus& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NAME                    = 0,
        ATTRIBUTE_ID_DESCRIPTION             = 1,
        ATTRIBUTE_ID_SELF_NODE_DESCRIPTION   = 2,
        ATTRIBUTE_ID_IS_HEALTHY              = 3,
        ATTRIBUTE_ID_NODE_STATUSES           = 4,
        ATTRIBUTE_ID_ELECTOR_INFO            = 5,
        ATTRIBUTE_ID_PARTITIONS_INFO         = 6,
        ATTRIBUTE_ID_QUEUES_INFO             = 7,
        ATTRIBUTE_ID_CLUSTER_STORAGE_SUMMARY = 8
    };

    enum { NUM_ATTRIBUTES = 9 };

    enum {
        ATTRIBUTE_INDEX_NAME                    = 0,
        ATTRIBUTE_INDEX_DESCRIPTION             = 1,
        ATTRIBUTE_INDEX_SELF_NODE_DESCRIPTION   = 2,
        ATTRIBUTE_INDEX_IS_HEALTHY              = 3,
        ATTRIBUTE_INDEX_NODE_STATUSES           = 4,
        ATTRIBUTE_INDEX_ELECTOR_INFO            = 5,
        ATTRIBUTE_INDEX_PARTITIONS_INFO         = 6,
        ATTRIBUTE_INDEX_QUEUES_INFO             = 7,
        ATTRIBUTE_INDEX_CLUSTER_STORAGE_SUMMARY = 8
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterStatus(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterStatus' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterStatus(const ClusterStatus& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'ClusterStatus' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStatus(ClusterStatus&& original) noexcept;
    // Create an object of type 'ClusterStatus' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterStatus(ClusterStatus&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterStatus' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterStatus();
    // Destroy this object.

    // MANIPULATORS
    ClusterStatus& operator=(const ClusterStatus& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStatus& operator=(ClusterStatus&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    bsl::string& description();
    // Return a reference to the modifiable "Description" attribute of this
    // object.

    bsl::string& selfNodeDescription();
    // Return a reference to the modifiable "SelfNodeDescription" attribute
    // of this object.

    bool& isHealthy();
    // Return a reference to the modifiable "IsHealthy" attribute of this
    // object.

    NodeStatuses& nodeStatuses();
    // Return a reference to the modifiable "NodeStatuses" attribute of
    // this object.

    ElectorInfo& electorInfo();
    // Return a reference to the modifiable "ElectorInfo" attribute of this
    // object.

    PartitionsInfo& partitionsInfo();
    // Return a reference to the modifiable "PartitionsInfo" attribute of
    // this object.

    StorageContent& queuesInfo();
    // Return a reference to the modifiable "QueuesInfo" attribute of this
    // object.

    ClusterStorageSummary& clusterStorageSummary();
    // Return a reference to the modifiable "ClusterStorageSummary"
    // attribute of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const bsl::string& description() const;
    // Return a reference offering non-modifiable access to the
    // "Description" attribute of this object.

    const bsl::string& selfNodeDescription() const;
    // Return a reference offering non-modifiable access to the
    // "SelfNodeDescription" attribute of this object.

    bool isHealthy() const;
    // Return the value of the "IsHealthy" attribute of this object.

    const NodeStatuses& nodeStatuses() const;
    // Return a reference offering non-modifiable access to the
    // "NodeStatuses" attribute of this object.

    const ElectorInfo& electorInfo() const;
    // Return a reference offering non-modifiable access to the
    // "ElectorInfo" attribute of this object.

    const PartitionsInfo& partitionsInfo() const;
    // Return a reference offering non-modifiable access to the
    // "PartitionsInfo" attribute of this object.

    const StorageContent& queuesInfo() const;
    // Return a reference offering non-modifiable access to the
    // "QueuesInfo" attribute of this object.

    const ClusterStorageSummary& clusterStorageSummary() const;
    // Return a reference offering non-modifiable access to the
    // "ClusterStorageSummary" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterStatus& lhs, const ClusterStatus& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterStatus& lhs, const ClusterStatus& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const ClusterStatus& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const ClusterStatus& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterStatus'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClusterStatus)

namespace mqbcmd {

// ====================
// class DomainsCommand
// ====================

class DomainsCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Domain>                d_domain;
        bsls::ObjectBuffer<DomainResolverCommand> d_resolver;
        bsls::ObjectBuffer<DomainReconfigure>     d_reconfigure;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const DomainsCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED   = -1,
        SELECTION_ID_DOMAIN      = 0,
        SELECTION_ID_RESOLVER    = 1,
        SELECTION_ID_RECONFIGURE = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_DOMAIN      = 0,
        SELECTION_INDEX_RESOLVER    = 1,
        SELECTION_INDEX_RECONFIGURE = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit DomainsCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainsCommand' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    DomainsCommand(const DomainsCommand& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'DomainsCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainsCommand(DomainsCommand&& original) noexcept;
    // Create an object of type 'DomainsCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    DomainsCommand(DomainsCommand&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'DomainsCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~DomainsCommand();
    // Destroy this object.

    // MANIPULATORS
    DomainsCommand& operator=(const DomainsCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainsCommand& operator=(DomainsCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Domain& makeDomain();
    Domain& makeDomain(const Domain& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Domain& makeDomain(Domain&& value);
#endif
    // Set the value of this object to be a "Domain" value.  Optionally
    // specify the 'value' of the "Domain".  If 'value' is not specified,
    // the default "Domain" value is used.

    DomainResolverCommand& makeResolver();
    DomainResolverCommand& makeResolver(const DomainResolverCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainResolverCommand& makeResolver(DomainResolverCommand&& value);
#endif
    // Set the value of this object to be a "Resolver" value.  Optionally
    // specify the 'value' of the "Resolver".  If 'value' is not specified,
    // the default "Resolver" value is used.

    DomainReconfigure& makeReconfigure();
    DomainReconfigure& makeReconfigure(const DomainReconfigure& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainReconfigure& makeReconfigure(DomainReconfigure&& value);
#endif
    // Set the value of this object to be a "Reconfigure" value.
    // Optionally specify the 'value' of the "Reconfigure".  If 'value' is
    // not specified, the default "Reconfigure" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Domain& domain();
    // Return a reference to the modifiable "Domain" selection of this
    // object if "Domain" is the current selection.  The behavior is
    // undefined unless "Domain" is the selection of this object.

    DomainResolverCommand& resolver();
    // Return a reference to the modifiable "Resolver" selection of this
    // object if "Resolver" is the current selection.  The behavior is
    // undefined unless "Resolver" is the selection of this object.

    DomainReconfigure& reconfigure();
    // Return a reference to the modifiable "Reconfigure" selection of this
    // object if "Reconfigure" is the current selection.  The behavior is
    // undefined unless "Reconfigure" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Domain& domain() const;
    // Return a reference to the non-modifiable "Domain" selection of this
    // object if "Domain" is the current selection.  The behavior is
    // undefined unless "Domain" is the selection of this object.

    const DomainResolverCommand& resolver() const;
    // Return a reference to the non-modifiable "Resolver" selection of
    // this object if "Resolver" is the current selection.  The behavior is
    // undefined unless "Resolver" is the selection of this object.

    const DomainReconfigure& reconfigure() const;
    // Return a reference to the non-modifiable "Reconfigure" selection of
    // this object if "Reconfigure" is the current selection.  The behavior
    // is undefined unless "Reconfigure" is the selection of this object.

    bool isDomainValue() const;
    // Return 'true' if the value of this object is a "Domain" value, and
    // return 'false' otherwise.

    bool isResolverValue() const;
    // Return 'true' if the value of this object is a "Resolver" value, and
    // return 'false' otherwise.

    bool isReconfigureValue() const;
    // Return 'true' if the value of this object is a "Reconfigure" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DomainsCommand& lhs,
                           const DomainsCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'DomainsCommand' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const DomainsCommand& lhs,
                           const DomainsCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const DomainsCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const DomainsCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DomainsCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::DomainsCommand)

namespace mqbcmd {

// ======================
// class RoundRobinRouter
// ======================

class RoundRobinRouter {
    // INSTANCE DATA
    bsl::vector<RouterConsumer> d_consumers;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CONSUMERS = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_CONSUMERS = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RoundRobinRouter(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RoundRobinRouter' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    RoundRobinRouter(const RoundRobinRouter& original,
                     bslma::Allocator*       basicAllocator = 0);
    // Create an object of type 'RoundRobinRouter' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RoundRobinRouter(RoundRobinRouter&& original) noexcept;
    // Create an object of type 'RoundRobinRouter' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    RoundRobinRouter(RoundRobinRouter&& original,
                     bslma::Allocator*  basicAllocator);
    // Create an object of type 'RoundRobinRouter' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~RoundRobinRouter();
    // Destroy this object.

    // MANIPULATORS
    RoundRobinRouter& operator=(const RoundRobinRouter& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RoundRobinRouter& operator=(RoundRobinRouter&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<RouterConsumer>& consumers();
    // Return a reference to the modifiable "Consumers" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<RouterConsumer>& consumers() const;
    // Return a reference offering non-modifiable access to the "Consumers"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RoundRobinRouter& lhs,
                           const RoundRobinRouter& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.consumers() == rhs.consumers();
    }

    friend bool operator!=(const RoundRobinRouter& lhs,
                           const RoundRobinRouter& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const RoundRobinRouter& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const RoundRobinRouter& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RoundRobinRouter'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.consumers());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RoundRobinRouter)

namespace mqbcmd {

// ===================
// class StorageResult
// ===================

class StorageResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>                  d_success;
        bsls::ObjectBuffer<Error>                 d_error;
        bsls::ObjectBuffer<StorageContent>        d_storageContent;
        bsls::ObjectBuffer<ClusterStorageSummary> d_clusterStorageSummary;
        bsls::ObjectBuffer<ReplicationResult>     d_replicationResult;
        bsls::ObjectBuffer<PurgedQueues>          d_purgedQueues;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const StorageResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED               = -1,
        SELECTION_ID_SUCCESS                 = 0,
        SELECTION_ID_ERROR                   = 1,
        SELECTION_ID_STORAGE_CONTENT         = 2,
        SELECTION_ID_CLUSTER_STORAGE_SUMMARY = 3,
        SELECTION_ID_REPLICATION_RESULT      = 4,
        SELECTION_ID_PURGED_QUEUES           = 5
    };

    enum { NUM_SELECTIONS = 6 };

    enum {
        SELECTION_INDEX_SUCCESS                 = 0,
        SELECTION_INDEX_ERROR                   = 1,
        SELECTION_INDEX_STORAGE_CONTENT         = 2,
        SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY = 3,
        SELECTION_INDEX_REPLICATION_RESULT      = 4,
        SELECTION_INDEX_PURGED_QUEUES           = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit StorageResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'StorageResult' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    StorageResult(const StorageResult& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'StorageResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageResult(StorageResult&& original) noexcept;
    // Create an object of type 'StorageResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    StorageResult(StorageResult&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'StorageResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~StorageResult();
    // Destroy this object.

    // MANIPULATORS
    StorageResult& operator=(const StorageResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageResult& operator=(StorageResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeSuccess();
    Void& makeSuccess(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSuccess(Void&& value);
#endif
    // Set the value of this object to be a "Success" value.  Optionally
    // specify the 'value' of the "Success".  If 'value' is not specified,
    // the default "Success" value is used.

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    StorageContent& makeStorageContent();
    StorageContent& makeStorageContent(const StorageContent& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageContent& makeStorageContent(StorageContent&& value);
#endif
    // Set the value of this object to be a "StorageContent" value.
    // Optionally specify the 'value' of the "StorageContent".  If 'value'
    // is not specified, the default "StorageContent" value is used.

    ClusterStorageSummary& makeClusterStorageSummary();
    ClusterStorageSummary&
    makeClusterStorageSummary(const ClusterStorageSummary& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStorageSummary&
    makeClusterStorageSummary(ClusterStorageSummary&& value);
#endif
    // Set the value of this object to be a "ClusterStorageSummary" value.
    // Optionally specify the 'value' of the "ClusterStorageSummary".  If
    // 'value' is not specified, the default "ClusterStorageSummary" value
    // is used.

    ReplicationResult& makeReplicationResult();
    ReplicationResult& makeReplicationResult(const ReplicationResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ReplicationResult& makeReplicationResult(ReplicationResult&& value);
#endif
    // Set the value of this object to be a "ReplicationResult" value.
    // Optionally specify the 'value' of the "ReplicationResult".  If
    // 'value' is not specified, the default "ReplicationResult" value is
    // used.

    PurgedQueues& makePurgedQueues();
    PurgedQueues& makePurgedQueues(const PurgedQueues& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueues& makePurgedQueues(PurgedQueues&& value);
#endif
    // Set the value of this object to be a "PurgedQueues" value.
    // Optionally specify the 'value' of the "PurgedQueues".  If 'value' is
    // not specified, the default "PurgedQueues" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& success();
    // Return a reference to the modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    StorageContent& storageContent();
    // Return a reference to the modifiable "StorageContent" selection of
    // this object if "StorageContent" is the current selection.  The
    // behavior is undefined unless "StorageContent" is the selection of
    // this object.

    ClusterStorageSummary& clusterStorageSummary();
    // Return a reference to the modifiable "ClusterStorageSummary"
    // selection of this object if "ClusterStorageSummary" is the current
    // selection.  The behavior is undefined unless "ClusterStorageSummary"
    // is the selection of this object.

    ReplicationResult& replicationResult();
    // Return a reference to the modifiable "ReplicationResult" selection
    // of this object if "ReplicationResult" is the current selection.  The
    // behavior is undefined unless "ReplicationResult" is the selection of
    // this object.

    PurgedQueues& purgedQueues();
    // Return a reference to the modifiable "PurgedQueues" selection of
    // this object if "PurgedQueues" is the current selection.  The
    // behavior is undefined unless "PurgedQueues" is the selection of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& success() const;
    // Return a reference to the non-modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const StorageContent& storageContent() const;
    // Return a reference to the non-modifiable "StorageContent" selection
    // of this object if "StorageContent" is the current selection.  The
    // behavior is undefined unless "StorageContent" is the selection of
    // this object.

    const ClusterStorageSummary& clusterStorageSummary() const;
    // Return a reference to the non-modifiable "ClusterStorageSummary"
    // selection of this object if "ClusterStorageSummary" is the current
    // selection.  The behavior is undefined unless "ClusterStorageSummary"
    // is the selection of this object.

    const ReplicationResult& replicationResult() const;
    // Return a reference to the non-modifiable "ReplicationResult"
    // selection of this object if "ReplicationResult" is the current
    // selection.  The behavior is undefined unless "ReplicationResult" is
    // the selection of this object.

    const PurgedQueues& purgedQueues() const;
    // Return a reference to the non-modifiable "PurgedQueues" selection of
    // this object if "PurgedQueues" is the current selection.  The
    // behavior is undefined unless "PurgedQueues" is the selection of this
    // object.

    bool isSuccessValue() const;
    // Return 'true' if the value of this object is a "Success" value, and
    // return 'false' otherwise.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isStorageContentValue() const;
    // Return 'true' if the value of this object is a "StorageContent"
    // value, and return 'false' otherwise.

    bool isClusterStorageSummaryValue() const;
    // Return 'true' if the value of this object is a
    // "ClusterStorageSummary" value, and return 'false' otherwise.

    bool isReplicationResultValue() const;
    // Return 'true' if the value of this object is a "ReplicationResult"
    // value, and return 'false' otherwise.

    bool isPurgedQueuesValue() const;
    // Return 'true' if the value of this object is a "PurgedQueues" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const StorageResult& lhs, const StorageResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'StorageResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const StorageResult& lhs, const StorageResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const StorageResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const StorageResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'StorageResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::StorageResult)

namespace mqbcmd {

// ==============
// class AppState
// ==============

class AppState {
    // INSTANCE DATA
    bsls::Types::Int64 d_redeliveryListLength;
    bsl::string        d_appId;
    RoundRobinRouter   d_roundRobinRouter;
    unsigned int       d_numConsumers;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const AppState& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_APP_ID                 = 0,
        ATTRIBUTE_ID_NUM_CONSUMERS          = 1,
        ATTRIBUTE_ID_REDELIVERY_LIST_LENGTH = 2,
        ATTRIBUTE_ID_ROUND_ROBIN_ROUTER     = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_APP_ID                 = 0,
        ATTRIBUTE_INDEX_NUM_CONSUMERS          = 1,
        ATTRIBUTE_INDEX_REDELIVERY_LIST_LENGTH = 2,
        ATTRIBUTE_INDEX_ROUND_ROBIN_ROUTER     = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit AppState(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'AppState' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    AppState(const AppState& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'AppState' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AppState(AppState&& original) noexcept;
    // Create an object of type 'AppState' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    AppState(AppState&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'AppState' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~AppState();
    // Destroy this object.

    // MANIPULATORS
    AppState& operator=(const AppState& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AppState& operator=(AppState&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    unsigned int& numConsumers();
    // Return a reference to the modifiable "NumConsumers" attribute of
    // this object.

    bsls::Types::Int64& redeliveryListLength();
    // Return a reference to the modifiable "RedeliveryListLength"
    // attribute of this object.

    RoundRobinRouter& roundRobinRouter();
    // Return a reference to the modifiable "RoundRobinRouter" attribute of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    unsigned int numConsumers() const;
    // Return the value of the "NumConsumers" attribute of this object.

    bsls::Types::Int64 redeliveryListLength() const;
    // Return the value of the "RedeliveryListLength" attribute of this
    // object.

    const RoundRobinRouter& roundRobinRouter() const;
    // Return a reference offering non-modifiable access to the
    // "RoundRobinRouter" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const AppState& lhs, const AppState& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const AppState& lhs, const AppState& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const AppState& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const AppState& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'AppState'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::AppState)

namespace mqbcmd {

// =============
// class Cluster
// =============

class Cluster {
    // INSTANCE DATA
    bsl::string    d_name;
    ClusterCommand d_command;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_NAME = 0, ATTRIBUTE_ID_COMMAND = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_NAME = 0, ATTRIBUTE_INDEX_COMMAND = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Cluster(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Cluster' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Cluster(const Cluster& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Cluster' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Cluster(Cluster&& original) noexcept;
    // Create an object of type 'Cluster' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Cluster(Cluster&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Cluster' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Cluster();
    // Destroy this object.

    // MANIPULATORS
    Cluster& operator=(const Cluster& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Cluster& operator=(Cluster&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& name();
    // Return a reference to the modifiable "Name" attribute of this
    // object.

    ClusterCommand& command();
    // Return a reference to the modifiable "Command" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& name() const;
    // Return a reference offering non-modifiable access to the "Name"
    // attribute of this object.

    const ClusterCommand& command() const;
    // Return a reference offering non-modifiable access to the "Command"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Cluster& lhs, const Cluster& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.name() == rhs.name() && lhs.command() == rhs.command();
    }

    friend bool operator!=(const Cluster& lhs, const Cluster& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Cluster& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Cluster& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Cluster'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.name());
        hashAppend(hashAlg, object.command());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Cluster)

namespace mqbcmd {

// ===================
// class ClusterResult
// ===================

class ClusterResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>              d_error;
        bsls::ObjectBuffer<Void>               d_success;
        bsls::ObjectBuffer<ElectorResult>      d_electorResult;
        bsls::ObjectBuffer<StorageResult>      d_storageResult;
        bsls::ObjectBuffer<ClusterQueueHelper> d_clusterQueueHelper;
        bsls::ObjectBuffer<ClusterStatus>      d_clusterStatus;
        bsls::ObjectBuffer<ClusterProxyStatus> d_clusterProxyStatus;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClusterResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED            = -1,
        SELECTION_ID_ERROR                = 0,
        SELECTION_ID_SUCCESS              = 1,
        SELECTION_ID_ELECTOR_RESULT       = 2,
        SELECTION_ID_STORAGE_RESULT       = 3,
        SELECTION_ID_CLUSTER_QUEUE_HELPER = 4,
        SELECTION_ID_CLUSTER_STATUS       = 5,
        SELECTION_ID_CLUSTER_PROXY_STATUS = 6
    };

    enum { NUM_SELECTIONS = 7 };

    enum {
        SELECTION_INDEX_ERROR                = 0,
        SELECTION_INDEX_SUCCESS              = 1,
        SELECTION_INDEX_ELECTOR_RESULT       = 2,
        SELECTION_INDEX_STORAGE_RESULT       = 3,
        SELECTION_INDEX_CLUSTER_QUEUE_HELPER = 4,
        SELECTION_INDEX_CLUSTER_STATUS       = 5,
        SELECTION_INDEX_CLUSTER_PROXY_STATUS = 6
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClusterResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClusterResult' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClusterResult(const ClusterResult& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'ClusterResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterResult(ClusterResult&& original) noexcept;
    // Create an object of type 'ClusterResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClusterResult(ClusterResult&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ClusterResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClusterResult();
    // Destroy this object.

    // MANIPULATORS
    ClusterResult& operator=(const ClusterResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterResult& operator=(ClusterResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    Void& makeSuccess();
    Void& makeSuccess(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSuccess(Void&& value);
#endif
    // Set the value of this object to be a "Success" value.  Optionally
    // specify the 'value' of the "Success".  If 'value' is not specified,
    // the default "Success" value is used.

    ElectorResult& makeElectorResult();
    ElectorResult& makeElectorResult(const ElectorResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorResult& makeElectorResult(ElectorResult&& value);
#endif
    // Set the value of this object to be a "ElectorResult" value.
    // Optionally specify the 'value' of the "ElectorResult".  If 'value'
    // is not specified, the default "ElectorResult" value is used.

    StorageResult& makeStorageResult();
    StorageResult& makeStorageResult(const StorageResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageResult& makeStorageResult(StorageResult&& value);
#endif
    // Set the value of this object to be a "StorageResult" value.
    // Optionally specify the 'value' of the "StorageResult".  If 'value'
    // is not specified, the default "StorageResult" value is used.

    ClusterQueueHelper& makeClusterQueueHelper();
    ClusterQueueHelper&
    makeClusterQueueHelper(const ClusterQueueHelper& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterQueueHelper& makeClusterQueueHelper(ClusterQueueHelper&& value);
#endif
    // Set the value of this object to be a "ClusterQueueHelper" value.
    // Optionally specify the 'value' of the "ClusterQueueHelper".  If
    // 'value' is not specified, the default "ClusterQueueHelper" value is
    // used.

    ClusterStatus& makeClusterStatus();
    ClusterStatus& makeClusterStatus(const ClusterStatus& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStatus& makeClusterStatus(ClusterStatus&& value);
#endif
    // Set the value of this object to be a "ClusterStatus" value.
    // Optionally specify the 'value' of the "ClusterStatus".  If 'value'
    // is not specified, the default "ClusterStatus" value is used.

    ClusterProxyStatus& makeClusterProxyStatus();
    ClusterProxyStatus&
    makeClusterProxyStatus(const ClusterProxyStatus& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterProxyStatus& makeClusterProxyStatus(ClusterProxyStatus&& value);
#endif
    // Set the value of this object to be a "ClusterProxyStatus" value.
    // Optionally specify the 'value' of the "ClusterProxyStatus".  If
    // 'value' is not specified, the default "ClusterProxyStatus" value is
    // used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    Void& success();
    // Return a reference to the modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    ElectorResult& electorResult();
    // Return a reference to the modifiable "ElectorResult" selection of
    // this object if "ElectorResult" is the current selection.  The
    // behavior is undefined unless "ElectorResult" is the selection of
    // this object.

    StorageResult& storageResult();
    // Return a reference to the modifiable "StorageResult" selection of
    // this object if "StorageResult" is the current selection.  The
    // behavior is undefined unless "StorageResult" is the selection of
    // this object.

    ClusterQueueHelper& clusterQueueHelper();
    // Return a reference to the modifiable "ClusterQueueHelper" selection
    // of this object if "ClusterQueueHelper" is the current selection.
    // The behavior is undefined unless "ClusterQueueHelper" is the
    // selection of this object.

    ClusterStatus& clusterStatus();
    // Return a reference to the modifiable "ClusterStatus" selection of
    // this object if "ClusterStatus" is the current selection.  The
    // behavior is undefined unless "ClusterStatus" is the selection of
    // this object.

    ClusterProxyStatus& clusterProxyStatus();
    // Return a reference to the modifiable "ClusterProxyStatus" selection
    // of this object if "ClusterProxyStatus" is the current selection.
    // The behavior is undefined unless "ClusterProxyStatus" is the
    // selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const Void& success() const;
    // Return a reference to the non-modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    const ElectorResult& electorResult() const;
    // Return a reference to the non-modifiable "ElectorResult" selection
    // of this object if "ElectorResult" is the current selection.  The
    // behavior is undefined unless "ElectorResult" is the selection of
    // this object.

    const StorageResult& storageResult() const;
    // Return a reference to the non-modifiable "StorageResult" selection
    // of this object if "StorageResult" is the current selection.  The
    // behavior is undefined unless "StorageResult" is the selection of
    // this object.

    const ClusterQueueHelper& clusterQueueHelper() const;
    // Return a reference to the non-modifiable "ClusterQueueHelper"
    // selection of this object if "ClusterQueueHelper" is the current
    // selection.  The behavior is undefined unless "ClusterQueueHelper" is
    // the selection of this object.

    const ClusterStatus& clusterStatus() const;
    // Return a reference to the non-modifiable "ClusterStatus" selection
    // of this object if "ClusterStatus" is the current selection.  The
    // behavior is undefined unless "ClusterStatus" is the selection of
    // this object.

    const ClusterProxyStatus& clusterProxyStatus() const;
    // Return a reference to the non-modifiable "ClusterProxyStatus"
    // selection of this object if "ClusterProxyStatus" is the current
    // selection.  The behavior is undefined unless "ClusterProxyStatus" is
    // the selection of this object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isSuccessValue() const;
    // Return 'true' if the value of this object is a "Success" value, and
    // return 'false' otherwise.

    bool isElectorResultValue() const;
    // Return 'true' if the value of this object is a "ElectorResult"
    // value, and return 'false' otherwise.

    bool isStorageResultValue() const;
    // Return 'true' if the value of this object is a "StorageResult"
    // value, and return 'false' otherwise.

    bool isClusterQueueHelperValue() const;
    // Return 'true' if the value of this object is a "ClusterQueueHelper"
    // value, and return 'false' otherwise.

    bool isClusterStatusValue() const;
    // Return 'true' if the value of this object is a "ClusterStatus"
    // value, and return 'false' otherwise.

    bool isClusterProxyStatusValue() const;
    // Return 'true' if the value of this object is a "ClusterProxyStatus"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClusterResult& lhs, const ClusterResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ClusterResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClusterResult& lhs, const ClusterResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const ClusterResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const ClusterResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClusterResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ClusterResult)

namespace mqbcmd {

// =====================
// class ClustersCommand
// =====================

class ClustersCommand {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>            d_list;
        bsls::ObjectBuffer<AddReverseProxy> d_addReverseProxy;
        bsls::ObjectBuffer<Cluster>         d_cluster;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClustersCommand& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED         = -1,
        SELECTION_ID_LIST              = 0,
        SELECTION_ID_ADD_REVERSE_PROXY = 1,
        SELECTION_ID_CLUSTER           = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_LIST              = 0,
        SELECTION_INDEX_ADD_REVERSE_PROXY = 1,
        SELECTION_INDEX_CLUSTER           = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClustersCommand(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClustersCommand' having the default value.
    //  Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClustersCommand(const ClustersCommand& original,
                    bslma::Allocator*      basicAllocator = 0);
    // Create an object of type 'ClustersCommand' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClustersCommand(ClustersCommand&& original) noexcept;
    // Create an object of type 'ClustersCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClustersCommand(ClustersCommand&& original,
                    bslma::Allocator* basicAllocator);
    // Create an object of type 'ClustersCommand' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClustersCommand();
    // Destroy this object.

    // MANIPULATORS
    ClustersCommand& operator=(const ClustersCommand& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClustersCommand& operator=(ClustersCommand&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeList();
    Void& makeList(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeList(Void&& value);
#endif
    // Set the value of this object to be a "List" value.  Optionally
    // specify the 'value' of the "List".  If 'value' is not specified, the
    // default "List" value is used.

    AddReverseProxy& makeAddReverseProxy();
    AddReverseProxy& makeAddReverseProxy(const AddReverseProxy& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    AddReverseProxy& makeAddReverseProxy(AddReverseProxy&& value);
#endif
    // Set the value of this object to be a "AddReverseProxy" value.
    // Optionally specify the 'value' of the "AddReverseProxy".  If 'value'
    // is not specified, the default "AddReverseProxy" value is used.

    Cluster& makeCluster();
    Cluster& makeCluster(const Cluster& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Cluster& makeCluster(Cluster&& value);
#endif
    // Set the value of this object to be a "Cluster" value.  Optionally
    // specify the 'value' of the "Cluster".  If 'value' is not specified,
    // the default "Cluster" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& list();
    // Return a reference to the modifiable "List" selection of this object
    // if "List" is the current selection.  The behavior is undefined
    // unless "List" is the selection of this object.

    AddReverseProxy& addReverseProxy();
    // Return a reference to the modifiable "AddReverseProxy" selection of
    // this object if "AddReverseProxy" is the current selection.  The
    // behavior is undefined unless "AddReverseProxy" is the selection of
    // this object.

    Cluster& cluster();
    // Return a reference to the modifiable "Cluster" selection of this
    // object if "Cluster" is the current selection.  The behavior is
    // undefined unless "Cluster" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& list() const;
    // Return a reference to the non-modifiable "List" selection of this
    // object if "List" is the current selection.  The behavior is
    // undefined unless "List" is the selection of this object.

    const AddReverseProxy& addReverseProxy() const;
    // Return a reference to the non-modifiable "AddReverseProxy" selection
    // of this object if "AddReverseProxy" is the current selection.  The
    // behavior is undefined unless "AddReverseProxy" is the selection of
    // this object.

    const Cluster& cluster() const;
    // Return a reference to the non-modifiable "Cluster" selection of this
    // object if "Cluster" is the current selection.  The behavior is
    // undefined unless "Cluster" is the selection of this object.

    bool isListValue() const;
    // Return 'true' if the value of this object is a "List" value, and
    // return 'false' otherwise.

    bool isAddReverseProxyValue() const;
    // Return 'true' if the value of this object is a "AddReverseProxy"
    // value, and return 'false' otherwise.

    bool isClusterValue() const;
    // Return 'true' if the value of this object is a "Cluster" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClustersCommand& lhs,
                           const ClustersCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ClustersCommand' objects have
    // the same value if either the selections in both objects have the
    // same ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClustersCommand& lhs,
                           const ClustersCommand& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&          stream,
                                    const ClustersCommand& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&      hashAlg,
                           const ClustersCommand& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClustersCommand'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ClustersCommand)

namespace mqbcmd {

// ====================
// class ClustersResult
// ====================

class ClustersResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>         d_error;
        bsls::ObjectBuffer<Void>          d_success;
        bsls::ObjectBuffer<ClusterList>   d_clusterList;
        bsls::ObjectBuffer<ClusterResult> d_clusterResult;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ClustersResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED      = -1,
        SELECTION_ID_ERROR          = 0,
        SELECTION_ID_SUCCESS        = 1,
        SELECTION_ID_CLUSTER_LIST   = 2,
        SELECTION_ID_CLUSTER_RESULT = 3
    };

    enum { NUM_SELECTIONS = 4 };

    enum {
        SELECTION_INDEX_ERROR          = 0,
        SELECTION_INDEX_SUCCESS        = 1,
        SELECTION_INDEX_CLUSTER_LIST   = 2,
        SELECTION_INDEX_CLUSTER_RESULT = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit ClustersResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ClustersResult' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ClustersResult(const ClustersResult& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'ClustersResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClustersResult(ClustersResult&& original) noexcept;
    // Create an object of type 'ClustersResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ClustersResult(ClustersResult&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'ClustersResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ClustersResult();
    // Destroy this object.

    // MANIPULATORS
    ClustersResult& operator=(const ClustersResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClustersResult& operator=(ClustersResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    Void& makeSuccess();
    Void& makeSuccess(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSuccess(Void&& value);
#endif
    // Set the value of this object to be a "Success" value.  Optionally
    // specify the 'value' of the "Success".  If 'value' is not specified,
    // the default "Success" value is used.

    ClusterList& makeClusterList();
    ClusterList& makeClusterList(const ClusterList& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterList& makeClusterList(ClusterList&& value);
#endif
    // Set the value of this object to be a "ClusterList" value.
    // Optionally specify the 'value' of the "ClusterList".  If 'value' is
    // not specified, the default "ClusterList" value is used.

    ClusterResult& makeClusterResult();
    ClusterResult& makeClusterResult(const ClusterResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterResult& makeClusterResult(ClusterResult&& value);
#endif
    // Set the value of this object to be a "ClusterResult" value.
    // Optionally specify the 'value' of the "ClusterResult".  If 'value'
    // is not specified, the default "ClusterResult" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    Void& success();
    // Return a reference to the modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    ClusterList& clusterList();
    // Return a reference to the modifiable "ClusterList" selection of this
    // object if "ClusterList" is the current selection.  The behavior is
    // undefined unless "ClusterList" is the selection of this object.

    ClusterResult& clusterResult();
    // Return a reference to the modifiable "ClusterResult" selection of
    // this object if "ClusterResult" is the current selection.  The
    // behavior is undefined unless "ClusterResult" is the selection of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const Void& success() const;
    // Return a reference to the non-modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    const ClusterList& clusterList() const;
    // Return a reference to the non-modifiable "ClusterList" selection of
    // this object if "ClusterList" is the current selection.  The behavior
    // is undefined unless "ClusterList" is the selection of this object.

    const ClusterResult& clusterResult() const;
    // Return a reference to the non-modifiable "ClusterResult" selection
    // of this object if "ClusterResult" is the current selection.  The
    // behavior is undefined unless "ClusterResult" is the selection of
    // this object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isSuccessValue() const;
    // Return 'true' if the value of this object is a "Success" value, and
    // return 'false' otherwise.

    bool isClusterListValue() const;
    // Return 'true' if the value of this object is a "ClusterList" value,
    // and return 'false' otherwise.

    bool isClusterResultValue() const;
    // Return 'true' if the value of this object is a "ClusterResult"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ClustersResult& lhs,
                           const ClustersResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'ClustersResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ClustersResult& lhs,
                           const ClustersResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const ClustersResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const ClustersResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ClustersResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::ClustersResult)

namespace mqbcmd {

// ===================
// class ConsumerState
// ===================

class ConsumerState {
    // INSTANCE DATA
    bsl::string               d_appId;
    AppState                  d_appState;
    ConsumerStatus::Value     d_status;
    bdlb::NullableValue<bool> d_isAtEndOfStorage;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const ConsumerState& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_APP_ID               = 0,
        ATTRIBUTE_ID_STATUS               = 1,
        ATTRIBUTE_ID_IS_AT_END_OF_STORAGE = 2,
        ATTRIBUTE_ID_APP_STATE            = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_APP_ID               = 0,
        ATTRIBUTE_INDEX_STATUS               = 1,
        ATTRIBUTE_INDEX_IS_AT_END_OF_STORAGE = 2,
        ATTRIBUTE_INDEX_APP_STATE            = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit ConsumerState(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'ConsumerState' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    ConsumerState(const ConsumerState& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'ConsumerState' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConsumerState(ConsumerState&& original) noexcept;
    // Create an object of type 'ConsumerState' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    ConsumerState(ConsumerState&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'ConsumerState' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~ConsumerState();
    // Destroy this object.

    // MANIPULATORS
    ConsumerState& operator=(const ConsumerState& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConsumerState& operator=(ConsumerState&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& appId();
    // Return a reference to the modifiable "AppId" attribute of this
    // object.

    ConsumerStatus::Value& status();
    // Return a reference to the modifiable "Status" attribute of this
    // object.

    bdlb::NullableValue<bool>& isAtEndOfStorage();
    // Return a reference to the modifiable "IsAtEndOfStorage" attribute of
    // this object.

    AppState& appState();
    // Return a reference to the modifiable "AppState" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& appId() const;
    // Return a reference offering non-modifiable access to the "AppId"
    // attribute of this object.

    ConsumerStatus::Value status() const;
    // Return the value of the "Status" attribute of this object.

    const bdlb::NullableValue<bool>& isAtEndOfStorage() const;
    // Return a reference offering non-modifiable access to the
    // "IsAtEndOfStorage" attribute of this object.

    const AppState& appState() const;
    // Return a reference offering non-modifiable access to the "AppState"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const ConsumerState& lhs, const ConsumerState& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const ConsumerState& lhs, const ConsumerState& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const ConsumerState& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const ConsumerState& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'ConsumerState'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::ConsumerState)

namespace mqbcmd {

// ======================
// class RelayQueueEngine
// ======================

class RelayQueueEngine {
    // INSTANCE DATA
    bsl::vector<RelayQueueEngineSubStream> d_subStreams;
    bsl::vector<AppState>                  d_appStates;
    Routing                                d_routing;
    unsigned int                           d_numSubstreams;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const RelayQueueEngine& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NUM_SUBSTREAMS = 0,
        ATTRIBUTE_ID_SUB_STREAMS    = 1,
        ATTRIBUTE_ID_APP_STATES     = 2,
        ATTRIBUTE_ID_ROUTING        = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_NUM_SUBSTREAMS = 0,
        ATTRIBUTE_INDEX_SUB_STREAMS    = 1,
        ATTRIBUTE_INDEX_APP_STATES     = 2,
        ATTRIBUTE_INDEX_ROUTING        = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RelayQueueEngine(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RelayQueueEngine' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    RelayQueueEngine(const RelayQueueEngine& original,
                     bslma::Allocator*       basicAllocator = 0);
    // Create an object of type 'RelayQueueEngine' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RelayQueueEngine(RelayQueueEngine&& original) noexcept;
    // Create an object of type 'RelayQueueEngine' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    RelayQueueEngine(RelayQueueEngine&& original,
                     bslma::Allocator*  basicAllocator);
    // Create an object of type 'RelayQueueEngine' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~RelayQueueEngine();
    // Destroy this object.

    // MANIPULATORS
    RelayQueueEngine& operator=(const RelayQueueEngine& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RelayQueueEngine& operator=(RelayQueueEngine&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& numSubstreams();
    // Return a reference to the modifiable "NumSubstreams" attribute of
    // this object.

    bsl::vector<RelayQueueEngineSubStream>& subStreams();
    // Return a reference to the modifiable "SubStreams" attribute of this
    // object.

    bsl::vector<AppState>& appStates();
    // Return a reference to the modifiable "AppStates" attribute of this
    // object.

    Routing& routing();
    // Return a reference to the modifiable "Routing" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int numSubstreams() const;
    // Return the value of the "NumSubstreams" attribute of this object.

    const bsl::vector<RelayQueueEngineSubStream>& subStreams() const;
    // Return a reference offering non-modifiable access to the
    // "SubStreams" attribute of this object.

    const bsl::vector<AppState>& appStates() const;
    // Return a reference offering non-modifiable access to the "AppStates"
    // attribute of this object.

    const Routing& routing() const;
    // Return a reference offering non-modifiable access to the "Routing"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RelayQueueEngine& lhs,
                           const RelayQueueEngine& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const RelayQueueEngine& lhs,
                           const RelayQueueEngine& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&           stream,
                                    const RelayQueueEngine& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&       hashAlg,
                           const RelayQueueEngine& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RelayQueueEngine'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RelayQueueEngine)

namespace mqbcmd {

// ===================
// class CommandChoice
// ===================

class CommandChoice {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<HelpCommand>           d_help;
        bsls::ObjectBuffer<DomainsCommand>        d_domains;
        bsls::ObjectBuffer<ConfigProviderCommand> d_configProvider;
        bsls::ObjectBuffer<StatCommand>           d_stat;
        bsls::ObjectBuffer<ClustersCommand>       d_clusters;
        bsls::ObjectBuffer<DangerCommand>         d_danger;
        bsls::ObjectBuffer<BrokerConfigCommand>   d_brokerConfig;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const CommandChoice& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED       = -1,
        SELECTION_ID_HELP            = 0,
        SELECTION_ID_DOMAINS         = 1,
        SELECTION_ID_CONFIG_PROVIDER = 2,
        SELECTION_ID_STAT            = 3,
        SELECTION_ID_CLUSTERS        = 4,
        SELECTION_ID_DANGER          = 5,
        SELECTION_ID_BROKER_CONFIG   = 6
    };

    enum { NUM_SELECTIONS = 7 };

    enum {
        SELECTION_INDEX_HELP            = 0,
        SELECTION_INDEX_DOMAINS         = 1,
        SELECTION_INDEX_CONFIG_PROVIDER = 2,
        SELECTION_INDEX_STAT            = 3,
        SELECTION_INDEX_CLUSTERS        = 4,
        SELECTION_INDEX_DANGER          = 5,
        SELECTION_INDEX_BROKER_CONFIG   = 6
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit CommandChoice(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'CommandChoice' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    CommandChoice(const CommandChoice& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'CommandChoice' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CommandChoice(CommandChoice&& original) noexcept;
    // Create an object of type 'CommandChoice' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    CommandChoice(CommandChoice&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'CommandChoice' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~CommandChoice();
    // Destroy this object.

    // MANIPULATORS
    CommandChoice& operator=(const CommandChoice& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    CommandChoice& operator=(CommandChoice&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    HelpCommand& makeHelp();
    HelpCommand& makeHelp(const HelpCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    HelpCommand& makeHelp(HelpCommand&& value);
#endif
    // Set the value of this object to be a "Help" value.  Optionally
    // specify the 'value' of the "Help".  If 'value' is not specified, the
    // default "Help" value is used.

    DomainsCommand& makeDomains();
    DomainsCommand& makeDomains(const DomainsCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainsCommand& makeDomains(DomainsCommand&& value);
#endif
    // Set the value of this object to be a "Domains" value.  Optionally
    // specify the 'value' of the "Domains".  If 'value' is not specified,
    // the default "Domains" value is used.

    ConfigProviderCommand& makeConfigProvider();
    ConfigProviderCommand&
    makeConfigProvider(const ConfigProviderCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ConfigProviderCommand& makeConfigProvider(ConfigProviderCommand&& value);
#endif
    // Set the value of this object to be a "ConfigProvider" value.
    // Optionally specify the 'value' of the "ConfigProvider".  If 'value'
    // is not specified, the default "ConfigProvider" value is used.

    StatCommand& makeStat();
    StatCommand& makeStat(const StatCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StatCommand& makeStat(StatCommand&& value);
#endif
    // Set the value of this object to be a "Stat" value.  Optionally
    // specify the 'value' of the "Stat".  If 'value' is not specified, the
    // default "Stat" value is used.

    ClustersCommand& makeClusters();
    ClustersCommand& makeClusters(const ClustersCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClustersCommand& makeClusters(ClustersCommand&& value);
#endif
    // Set the value of this object to be a "Clusters" value.  Optionally
    // specify the 'value' of the "Clusters".  If 'value' is not specified,
    // the default "Clusters" value is used.

    DangerCommand& makeDanger();
    DangerCommand& makeDanger(const DangerCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DangerCommand& makeDanger(DangerCommand&& value);
#endif
    // Set the value of this object to be a "Danger" value.  Optionally
    // specify the 'value' of the "Danger".  If 'value' is not specified,
    // the default "Danger" value is used.

    BrokerConfigCommand& makeBrokerConfig();
    BrokerConfigCommand& makeBrokerConfig(const BrokerConfigCommand& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerConfigCommand& makeBrokerConfig(BrokerConfigCommand&& value);
#endif
    // Set the value of this object to be a "BrokerConfig" value.
    // Optionally specify the 'value' of the "BrokerConfig".  If 'value' is
    // not specified, the default "BrokerConfig" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    HelpCommand& help();
    // Return a reference to the modifiable "Help" selection of this object
    // if "Help" is the current selection.  The behavior is undefined
    // unless "Help" is the selection of this object.

    DomainsCommand& domains();
    // Return a reference to the modifiable "Domains" selection of this
    // object if "Domains" is the current selection.  The behavior is
    // undefined unless "Domains" is the selection of this object.

    ConfigProviderCommand& configProvider();
    // Return a reference to the modifiable "ConfigProvider" selection of
    // this object if "ConfigProvider" is the current selection.  The
    // behavior is undefined unless "ConfigProvider" is the selection of
    // this object.

    StatCommand& stat();
    // Return a reference to the modifiable "Stat" selection of this object
    // if "Stat" is the current selection.  The behavior is undefined
    // unless "Stat" is the selection of this object.

    ClustersCommand& clusters();
    // Return a reference to the modifiable "Clusters" selection of this
    // object if "Clusters" is the current selection.  The behavior is
    // undefined unless "Clusters" is the selection of this object.

    DangerCommand& danger();
    // Return a reference to the modifiable "Danger" selection of this
    // object if "Danger" is the current selection.  The behavior is
    // undefined unless "Danger" is the selection of this object.

    BrokerConfigCommand& brokerConfig();
    // Return a reference to the modifiable "BrokerConfig" selection of
    // this object if "BrokerConfig" is the current selection.  The
    // behavior is undefined unless "BrokerConfig" is the selection of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const HelpCommand& help() const;
    // Return a reference to the non-modifiable "Help" selection of this
    // object if "Help" is the current selection.  The behavior is
    // undefined unless "Help" is the selection of this object.

    const DomainsCommand& domains() const;
    // Return a reference to the non-modifiable "Domains" selection of this
    // object if "Domains" is the current selection.  The behavior is
    // undefined unless "Domains" is the selection of this object.

    const ConfigProviderCommand& configProvider() const;
    // Return a reference to the non-modifiable "ConfigProvider" selection
    // of this object if "ConfigProvider" is the current selection.  The
    // behavior is undefined unless "ConfigProvider" is the selection of
    // this object.

    const StatCommand& stat() const;
    // Return a reference to the non-modifiable "Stat" selection of this
    // object if "Stat" is the current selection.  The behavior is
    // undefined unless "Stat" is the selection of this object.

    const ClustersCommand& clusters() const;
    // Return a reference to the non-modifiable "Clusters" selection of
    // this object if "Clusters" is the current selection.  The behavior is
    // undefined unless "Clusters" is the selection of this object.

    const DangerCommand& danger() const;
    // Return a reference to the non-modifiable "Danger" selection of this
    // object if "Danger" is the current selection.  The behavior is
    // undefined unless "Danger" is the selection of this object.

    const BrokerConfigCommand& brokerConfig() const;
    // Return a reference to the non-modifiable "BrokerConfig" selection of
    // this object if "BrokerConfig" is the current selection.  The
    // behavior is undefined unless "BrokerConfig" is the selection of this
    // object.

    bool isHelpValue() const;
    // Return 'true' if the value of this object is a "Help" value, and
    // return 'false' otherwise.

    bool isDomainsValue() const;
    // Return 'true' if the value of this object is a "Domains" value, and
    // return 'false' otherwise.

    bool isConfigProviderValue() const;
    // Return 'true' if the value of this object is a "ConfigProvider"
    // value, and return 'false' otherwise.

    bool isStatValue() const;
    // Return 'true' if the value of this object is a "Stat" value, and
    // return 'false' otherwise.

    bool isClustersValue() const;
    // Return 'true' if the value of this object is a "Clusters" value, and
    // return 'false' otherwise.

    bool isDangerValue() const;
    // Return 'true' if the value of this object is a "Danger" value, and
    // return 'false' otherwise.

    bool isBrokerConfigValue() const;
    // Return 'true' if the value of this object is a "BrokerConfig" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const CommandChoice& lhs, const CommandChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'CommandChoice' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const CommandChoice& lhs, const CommandChoice& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const CommandChoice& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const CommandChoice& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'CommandChoice'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::CommandChoice)

namespace mqbcmd {

// =======================
// class FanoutQueueEngine
// =======================

class FanoutQueueEngine {
    // INSTANCE DATA
    bsl::vector<ConsumerState> d_consumerStates;
    bsl::string                d_mode;
    Routing                    d_routing;
    unsigned int               d_maxConsumers;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const FanoutQueueEngine& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_MAX_CONSUMERS   = 0,
        ATTRIBUTE_ID_MODE            = 1,
        ATTRIBUTE_ID_CONSUMER_STATES = 2,
        ATTRIBUTE_ID_ROUTING         = 3
    };

    enum { NUM_ATTRIBUTES = 4 };

    enum {
        ATTRIBUTE_INDEX_MAX_CONSUMERS   = 0,
        ATTRIBUTE_INDEX_MODE            = 1,
        ATTRIBUTE_INDEX_CONSUMER_STATES = 2,
        ATTRIBUTE_INDEX_ROUTING         = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit FanoutQueueEngine(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'FanoutQueueEngine' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    FanoutQueueEngine(const FanoutQueueEngine& original,
                      bslma::Allocator*        basicAllocator = 0);
    // Create an object of type 'FanoutQueueEngine' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FanoutQueueEngine(FanoutQueueEngine&& original) noexcept;
    // Create an object of type 'FanoutQueueEngine' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    FanoutQueueEngine(FanoutQueueEngine&& original,
                      bslma::Allocator*   basicAllocator);
    // Create an object of type 'FanoutQueueEngine' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~FanoutQueueEngine();
    // Destroy this object.

    // MANIPULATORS
    FanoutQueueEngine& operator=(const FanoutQueueEngine& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FanoutQueueEngine& operator=(FanoutQueueEngine&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    unsigned int& maxConsumers();
    // Return a reference to the modifiable "MaxConsumers" attribute of
    // this object.

    bsl::string& mode();
    // Return a reference to the modifiable "Mode" attribute of this
    // object.

    bsl::vector<ConsumerState>& consumerStates();
    // Return a reference to the modifiable "ConsumerStates" attribute of
    // this object.

    Routing& routing();
    // Return a reference to the modifiable "Routing" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    unsigned int maxConsumers() const;
    // Return the value of the "MaxConsumers" attribute of this object.

    const bsl::string& mode() const;
    // Return a reference offering non-modifiable access to the "Mode"
    // attribute of this object.

    const bsl::vector<ConsumerState>& consumerStates() const;
    // Return a reference offering non-modifiable access to the
    // "ConsumerStates" attribute of this object.

    const Routing& routing() const;
    // Return a reference offering non-modifiable access to the "Routing"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const FanoutQueueEngine& lhs,
                           const FanoutQueueEngine& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const FanoutQueueEngine& lhs,
                           const FanoutQueueEngine& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&            stream,
                                    const FanoutQueueEngine& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&        hashAlg,
                           const FanoutQueueEngine& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'FanoutQueueEngine'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::FanoutQueueEngine)

namespace mqbcmd {

// =============
// class Command
// =============

class Command {
    // The type represents a variant representing Command with options common
    // for all commands.
    // The optionally specified 'encoding' option contains the desired output
    // format of this command output.

    // INSTANCE DATA
    CommandChoice         d_choice;
    EncodingFormat::Value d_encoding;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_CHOICE = 0, ATTRIBUTE_ID_ENCODING = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_CHOICE = 0, ATTRIBUTE_INDEX_ENCODING = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const EncodingFormat::Value DEFAULT_INITIALIZER_ENCODING;

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit Command(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Command' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Command(const Command& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Command' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Command(Command&& original) noexcept;
    // Create an object of type 'Command' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Command(Command&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Command' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Command();
    // Destroy this object.

    // MANIPULATORS
    Command& operator=(const Command& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Command& operator=(Command&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    CommandChoice& choice();
    // Return a reference to the modifiable "Choice" attribute of this
    // object.

    EncodingFormat::Value& encoding();
    // Return a reference to the modifiable "Encoding" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const CommandChoice& choice() const;
    // Return a reference offering non-modifiable access to the "Choice"
    // attribute of this object.

    EncodingFormat::Value encoding() const;
    // Return the value of the "Encoding" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Command& lhs, const Command& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.choice() == rhs.choice() &&
               lhs.encoding() == rhs.encoding();
    }

    friend bool operator!=(const Command& lhs, const Command& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Command& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Command& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Command'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.choice());
        hashAppend(hashAlg, object.encoding());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Command)

namespace mqbcmd {

// =================
// class QueueEngine
// =================

class QueueEngine {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<FanoutQueueEngine> d_fanout;
        bsls::ObjectBuffer<RelayQueueEngine>  d_relay;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueEngine& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED = -1,
        SELECTION_ID_FANOUT    = 0,
        SELECTION_ID_RELAY     = 1
    };

    enum { NUM_SELECTIONS = 2 };

    enum { SELECTION_INDEX_FANOUT = 0, SELECTION_INDEX_RELAY = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueEngine(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueEngine' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueEngine(const QueueEngine& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'QueueEngine' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueEngine(QueueEngine&& original) noexcept;
    // Create an object of type 'QueueEngine' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueEngine(QueueEngine&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueEngine' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueEngine();
    // Destroy this object.

    // MANIPULATORS
    QueueEngine& operator=(const QueueEngine& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueEngine& operator=(QueueEngine&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    FanoutQueueEngine& makeFanout();
    FanoutQueueEngine& makeFanout(const FanoutQueueEngine& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    FanoutQueueEngine& makeFanout(FanoutQueueEngine&& value);
#endif
    // Set the value of this object to be a "Fanout" value.  Optionally
    // specify the 'value' of the "Fanout".  If 'value' is not specified,
    // the default "Fanout" value is used.

    RelayQueueEngine& makeRelay();
    RelayQueueEngine& makeRelay(const RelayQueueEngine& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RelayQueueEngine& makeRelay(RelayQueueEngine&& value);
#endif
    // Set the value of this object to be a "Relay" value.  Optionally
    // specify the 'value' of the "Relay".  If 'value' is not specified,
    // the default "Relay" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    FanoutQueueEngine& fanout();
    // Return a reference to the modifiable "Fanout" selection of this
    // object if "Fanout" is the current selection.  The behavior is
    // undefined unless "Fanout" is the selection of this object.

    RelayQueueEngine& relay();
    // Return a reference to the modifiable "Relay" selection of this
    // object if "Relay" is the current selection.  The behavior is
    // undefined unless "Relay" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const FanoutQueueEngine& fanout() const;
    // Return a reference to the non-modifiable "Fanout" selection of this
    // object if "Fanout" is the current selection.  The behavior is
    // undefined unless "Fanout" is the selection of this object.

    const RelayQueueEngine& relay() const;
    // Return a reference to the non-modifiable "Relay" selection of this
    // object if "Relay" is the current selection.  The behavior is
    // undefined unless "Relay" is the selection of this object.

    bool isFanoutValue() const;
    // Return 'true' if the value of this object is a "Fanout" value, and
    // return 'false' otherwise.

    bool isRelayValue() const;
    // Return 'true' if the value of this object is a "Relay" value, and
    // return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueEngine& lhs, const QueueEngine& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'QueueEngine' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueEngine& lhs, const QueueEngine& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const QueueEngine& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const QueueEngine& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'QueueEngine'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::QueueEngine)

namespace mqbcmd {

// ================
// class LocalQueue
// ================

class LocalQueue {
    // INSTANCE DATA
    QueueEngine d_queueEngine;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_QUEUE_ENGINE = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_QUEUE_ENGINE = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit LocalQueue(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'LocalQueue' having the default value.  Use
    // the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    LocalQueue(const LocalQueue& original,
               bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'LocalQueue' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LocalQueue(LocalQueue&& original) noexcept;
    // Create an object of type 'LocalQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    LocalQueue(LocalQueue&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'LocalQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~LocalQueue();
    // Destroy this object.

    // MANIPULATORS
    LocalQueue& operator=(const LocalQueue& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LocalQueue& operator=(LocalQueue&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    QueueEngine& queueEngine();
    // Return a reference to the modifiable "QueueEngine" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const QueueEngine& queueEngine() const;
    // Return a reference offering non-modifiable access to the
    // "QueueEngine" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const LocalQueue& lhs, const LocalQueue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.queueEngine() == rhs.queueEngine();
    }

    friend bool operator!=(const LocalQueue& lhs, const LocalQueue& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&     stream,
                                    const LocalQueue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const LocalQueue& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'LocalQueue'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.queueEngine());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::LocalQueue)

namespace mqbcmd {

// =================
// class RemoteQueue
// =================

class RemoteQueue {
    // INSTANCE DATA
    bsls::Types::Int64            d_numPendingPuts;
    bsls::Types::Int64            d_numPendingConfirms;
    bsl::vector<RemoteStreamInfo> d_streams;
    QueueEngine                   d_queueEngine;
    unsigned int                  d_numUpstreamGeneration;
    bool                          d_isPushExpirationTimerScheduled;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const RemoteQueue& rhs) const;

  public:
    // TYPES
    enum {
        ATTRIBUTE_ID_NUM_PENDING_PUTS                   = 0,
        ATTRIBUTE_ID_NUM_PENDING_CONFIRMS               = 1,
        ATTRIBUTE_ID_IS_PUSH_EXPIRATION_TIMER_SCHEDULED = 2,
        ATTRIBUTE_ID_NUM_UPSTREAM_GENERATION            = 3,
        ATTRIBUTE_ID_STREAMS                            = 4,
        ATTRIBUTE_ID_QUEUE_ENGINE                       = 5
    };

    enum { NUM_ATTRIBUTES = 6 };

    enum {
        ATTRIBUTE_INDEX_NUM_PENDING_PUTS                   = 0,
        ATTRIBUTE_INDEX_NUM_PENDING_CONFIRMS               = 1,
        ATTRIBUTE_INDEX_IS_PUSH_EXPIRATION_TIMER_SCHEDULED = 2,
        ATTRIBUTE_INDEX_NUM_UPSTREAM_GENERATION            = 3,
        ATTRIBUTE_INDEX_STREAMS                            = 4,
        ATTRIBUTE_INDEX_QUEUE_ENGINE                       = 5
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RemoteQueue(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RemoteQueue' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    RemoteQueue(const RemoteQueue& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'RemoteQueue' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RemoteQueue(RemoteQueue&& original) noexcept;
    // Create an object of type 'RemoteQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    RemoteQueue(RemoteQueue&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'RemoteQueue' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~RemoteQueue();
    // Destroy this object.

    // MANIPULATORS
    RemoteQueue& operator=(const RemoteQueue& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RemoteQueue& operator=(RemoteQueue&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsls::Types::Int64& numPendingPuts();
    // Return a reference to the modifiable "NumPendingPuts" attribute of
    // this object.

    bsls::Types::Int64& numPendingConfirms();
    // Return a reference to the modifiable "NumPendingConfirms" attribute
    // of this object.

    bool& isPushExpirationTimerScheduled();
    // Return a reference to the modifiable
    // "IsPushExpirationTimerScheduled" attribute of this object.

    unsigned int& numUpstreamGeneration();
    // Return a reference to the modifiable "NumUpstreamGeneration"
    // attribute of this object.

    bsl::vector<RemoteStreamInfo>& streams();
    // Return a reference to the modifiable "Streams" attribute of this
    // object.

    QueueEngine& queueEngine();
    // Return a reference to the modifiable "QueueEngine" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    bsls::Types::Int64 numPendingPuts() const;
    // Return the value of the "NumPendingPuts" attribute of this object.

    bsls::Types::Int64 numPendingConfirms() const;
    // Return the value of the "NumPendingConfirms" attribute of this
    // object.

    bool isPushExpirationTimerScheduled() const;
    // Return the value of the "IsPushExpirationTimerScheduled" attribute
    // of this object.

    unsigned int numUpstreamGeneration() const;
    // Return the value of the "NumUpstreamGeneration" attribute of this
    // object.

    const bsl::vector<RemoteStreamInfo>& streams() const;
    // Return a reference offering non-modifiable access to the "Streams"
    // attribute of this object.

    const QueueEngine& queueEngine() const;
    // Return a reference offering non-modifiable access to the
    // "QueueEngine" attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RemoteQueue& lhs, const RemoteQueue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const RemoteQueue& lhs, const RemoteQueue& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const RemoteQueue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const RemoteQueue& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'RemoteQueue'.
    {
        object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::RemoteQueue)

namespace mqbcmd {

// ===========
// class Queue
// ===========

class Queue {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<LocalQueue>         d_localQueue;
        bsls::ObjectBuffer<RemoteQueue>        d_remoteQueue;
        bsls::ObjectBuffer<UninitializedQueue> d_uninitializedQueue;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const Queue& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED           = -1,
        SELECTION_ID_LOCAL_QUEUE         = 0,
        SELECTION_ID_REMOTE_QUEUE        = 1,
        SELECTION_ID_UNINITIALIZED_QUEUE = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_LOCAL_QUEUE         = 0,
        SELECTION_INDEX_REMOTE_QUEUE        = 1,
        SELECTION_INDEX_UNINITIALIZED_QUEUE = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit Queue(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Queue' having the default value.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Queue(const Queue& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Queue' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Queue(Queue&& original) noexcept;
    // Create an object of type 'Queue' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Queue(Queue&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Queue' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Queue();
    // Destroy this object.

    // MANIPULATORS
    Queue& operator=(const Queue& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Queue& operator=(Queue&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    LocalQueue& makeLocalQueue();
    LocalQueue& makeLocalQueue(const LocalQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    LocalQueue& makeLocalQueue(LocalQueue&& value);
#endif
    // Set the value of this object to be a "LocalQueue" value.  Optionally
    // specify the 'value' of the "LocalQueue".  If 'value' is not
    // specified, the default "LocalQueue" value is used.

    RemoteQueue& makeRemoteQueue();
    RemoteQueue& makeRemoteQueue(const RemoteQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RemoteQueue& makeRemoteQueue(RemoteQueue&& value);
#endif
    // Set the value of this object to be a "RemoteQueue" value.
    // Optionally specify the 'value' of the "RemoteQueue".  If 'value' is
    // not specified, the default "RemoteQueue" value is used.

    UninitializedQueue& makeUninitializedQueue();
    UninitializedQueue&
    makeUninitializedQueue(const UninitializedQueue& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    UninitializedQueue& makeUninitializedQueue(UninitializedQueue&& value);
#endif
    // Set the value of this object to be a "UninitializedQueue" value.
    // Optionally specify the 'value' of the "UninitializedQueue".  If
    // 'value' is not specified, the default "UninitializedQueue" value is
    // used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    LocalQueue& localQueue();
    // Return a reference to the modifiable "LocalQueue" selection of this
    // object if "LocalQueue" is the current selection.  The behavior is
    // undefined unless "LocalQueue" is the selection of this object.

    RemoteQueue& remoteQueue();
    // Return a reference to the modifiable "RemoteQueue" selection of this
    // object if "RemoteQueue" is the current selection.  The behavior is
    // undefined unless "RemoteQueue" is the selection of this object.

    UninitializedQueue& uninitializedQueue();
    // Return a reference to the modifiable "UninitializedQueue" selection
    // of this object if "UninitializedQueue" is the current selection.
    // The behavior is undefined unless "UninitializedQueue" is the
    // selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const LocalQueue& localQueue() const;
    // Return a reference to the non-modifiable "LocalQueue" selection of
    // this object if "LocalQueue" is the current selection.  The behavior
    // is undefined unless "LocalQueue" is the selection of this object.

    const RemoteQueue& remoteQueue() const;
    // Return a reference to the non-modifiable "RemoteQueue" selection of
    // this object if "RemoteQueue" is the current selection.  The behavior
    // is undefined unless "RemoteQueue" is the selection of this object.

    const UninitializedQueue& uninitializedQueue() const;
    // Return a reference to the non-modifiable "UninitializedQueue"
    // selection of this object if "UninitializedQueue" is the current
    // selection.  The behavior is undefined unless "UninitializedQueue" is
    // the selection of this object.

    bool isLocalQueueValue() const;
    // Return 'true' if the value of this object is a "LocalQueue" value,
    // and return 'false' otherwise.

    bool isRemoteQueueValue() const;
    // Return 'true' if the value of this object is a "RemoteQueue" value,
    // and return 'false' otherwise.

    bool isUninitializedQueueValue() const;
    // Return 'true' if the value of this object is a "UninitializedQueue"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Queue& lhs, const Queue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'Queue' objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const Queue& lhs, const Queue& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Queue& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Queue& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Queue'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Queue)

namespace mqbcmd {

// ====================
// class QueueInternals
// ====================

class QueueInternals {
    // INSTANCE DATA
    QueueState d_state;
    Queue      d_queue;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_STATE = 0, ATTRIBUTE_ID_QUEUE = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_STATE = 0, ATTRIBUTE_INDEX_QUEUE = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueInternals(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueInternals' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueInternals(const QueueInternals& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'QueueInternals' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInternals(QueueInternals&& original) noexcept;
    // Create an object of type 'QueueInternals' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueInternals(QueueInternals&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueInternals' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueInternals();
    // Destroy this object.

    // MANIPULATORS
    QueueInternals& operator=(const QueueInternals& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInternals& operator=(QueueInternals&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    QueueState& state();
    // Return a reference to the modifiable "State" attribute of this
    // object.

    Queue& queue();
    // Return a reference to the modifiable "Queue" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const QueueState& state() const;
    // Return a reference offering non-modifiable access to the "State"
    // attribute of this object.

    const Queue& queue() const;
    // Return a reference offering non-modifiable access to the "Queue"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueInternals& lhs,
                           const QueueInternals& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.state() == rhs.state() && lhs.queue() == rhs.queue();
    }

    friend bool operator!=(const QueueInternals& lhs,
                           const QueueInternals& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const QueueInternals& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const QueueInternals& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'QueueInternals'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.state());
        hashAppend(hashAlg, object.queue());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::QueueInternals)

namespace mqbcmd {

// =================
// class QueueResult
// =================

class QueueResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>          d_error;
        bsls::ObjectBuffer<PurgedQueues>   d_purgedQueues;
        bsls::ObjectBuffer<QueueContents>  d_queueContents;
        bsls::ObjectBuffer<QueueInternals> d_queueInternals;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const QueueResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED       = -1,
        SELECTION_ID_ERROR           = 0,
        SELECTION_ID_PURGED_QUEUES   = 1,
        SELECTION_ID_QUEUE_CONTENTS  = 2,
        SELECTION_ID_QUEUE_INTERNALS = 3
    };

    enum { NUM_SELECTIONS = 4 };

    enum {
        SELECTION_INDEX_ERROR           = 0,
        SELECTION_INDEX_PURGED_QUEUES   = 1,
        SELECTION_INDEX_QUEUE_CONTENTS  = 2,
        SELECTION_INDEX_QUEUE_INTERNALS = 3
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit QueueResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'QueueResult' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    QueueResult(const QueueResult& original,
                bslma::Allocator*  basicAllocator = 0);
    // Create an object of type 'QueueResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueResult(QueueResult&& original) noexcept;
    // Create an object of type 'QueueResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    QueueResult(QueueResult&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'QueueResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~QueueResult();
    // Destroy this object.

    // MANIPULATORS
    QueueResult& operator=(const QueueResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueResult& operator=(QueueResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    PurgedQueues& makePurgedQueues();
    PurgedQueues& makePurgedQueues(const PurgedQueues& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueues& makePurgedQueues(PurgedQueues&& value);
#endif
    // Set the value of this object to be a "PurgedQueues" value.
    // Optionally specify the 'value' of the "PurgedQueues".  If 'value' is
    // not specified, the default "PurgedQueues" value is used.

    QueueContents& makeQueueContents();
    QueueContents& makeQueueContents(const QueueContents& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueContents& makeQueueContents(QueueContents&& value);
#endif
    // Set the value of this object to be a "QueueContents" value.
    // Optionally specify the 'value' of the "QueueContents".  If 'value'
    // is not specified, the default "QueueContents" value is used.

    QueueInternals& makeQueueInternals();
    QueueInternals& makeQueueInternals(const QueueInternals& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInternals& makeQueueInternals(QueueInternals&& value);
#endif
    // Set the value of this object to be a "QueueInternals" value.
    // Optionally specify the 'value' of the "QueueInternals".  If 'value'
    // is not specified, the default "QueueInternals" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    PurgedQueues& purgedQueues();
    // Return a reference to the modifiable "PurgedQueues" selection of
    // this object if "PurgedQueues" is the current selection.  The
    // behavior is undefined unless "PurgedQueues" is the selection of this
    // object.

    QueueContents& queueContents();
    // Return a reference to the modifiable "QueueContents" selection of
    // this object if "QueueContents" is the current selection.  The
    // behavior is undefined unless "QueueContents" is the selection of
    // this object.

    QueueInternals& queueInternals();
    // Return a reference to the modifiable "QueueInternals" selection of
    // this object if "QueueInternals" is the current selection.  The
    // behavior is undefined unless "QueueInternals" is the selection of
    // this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const PurgedQueues& purgedQueues() const;
    // Return a reference to the non-modifiable "PurgedQueues" selection of
    // this object if "PurgedQueues" is the current selection.  The
    // behavior is undefined unless "PurgedQueues" is the selection of this
    // object.

    const QueueContents& queueContents() const;
    // Return a reference to the non-modifiable "QueueContents" selection
    // of this object if "QueueContents" is the current selection.  The
    // behavior is undefined unless "QueueContents" is the selection of
    // this object.

    const QueueInternals& queueInternals() const;
    // Return a reference to the non-modifiable "QueueInternals" selection
    // of this object if "QueueInternals" is the current selection.  The
    // behavior is undefined unless "QueueInternals" is the selection of
    // this object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isPurgedQueuesValue() const;
    // Return 'true' if the value of this object is a "PurgedQueues" value,
    // and return 'false' otherwise.

    bool isQueueContentsValue() const;
    // Return 'true' if the value of this object is a "QueueContents"
    // value, and return 'false' otherwise.

    bool isQueueInternalsValue() const;
    // Return 'true' if the value of this object is a "QueueInternals"
    // value, and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const QueueResult& lhs, const QueueResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'QueueResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const QueueResult& lhs, const QueueResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&      stream,
                                    const QueueResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&  hashAlg,
                           const QueueResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'QueueResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::QueueResult)

namespace mqbcmd {

// ============
// class Result
// ============

class Result {
    // The type represents a command execution result flattened for a calling
    // client.  Client doesn't need to know about dispatcher hops happened to
    // process a command.

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>                 d_error;
        bsls::ObjectBuffer<Void>                  d_success;
        bsls::ObjectBuffer<Value>                 d_value;
        bsls::ObjectBuffer<Tunable>               d_tunable;
        bsls::ObjectBuffer<Tunables>              d_tunables;
        bsls::ObjectBuffer<TunableConfirmation>   d_tunableConfirmation;
        bsls::ObjectBuffer<Help>                  d_help;
        bsls::ObjectBuffer<DomainInfo>            d_domainInfo;
        bsls::ObjectBuffer<PurgedQueues>          d_purgedQueues;
        bsls::ObjectBuffer<QueueInternals>        d_queueInternals;
        bsls::ObjectBuffer<MessageGroupIdHelper>  d_messageGroupIdHelper;
        bsls::ObjectBuffer<QueueContents>         d_queueContents;
        bsls::ObjectBuffer<Message>               d_message;
        bsls::ObjectBuffer<bsl::string>           d_stats;
        bsls::ObjectBuffer<ClusterList>           d_clusterList;
        bsls::ObjectBuffer<ClusterStatus>         d_clusterStatus;
        bsls::ObjectBuffer<ClusterProxyStatus>    d_clusterProxyStatus;
        bsls::ObjectBuffer<NodeStatuses>          d_nodeStatuses;
        bsls::ObjectBuffer<ElectorInfo>           d_electorInfo;
        bsls::ObjectBuffer<PartitionsInfo>        d_partitionsInfo;
        bsls::ObjectBuffer<ClusterQueueHelper>    d_clusterQueueHelper;
        bsls::ObjectBuffer<StorageContent>        d_storageContent;
        bsls::ObjectBuffer<ClusterStorageSummary> d_clusterStorageSummary;
        bsls::ObjectBuffer<ClusterDomainQueueStatuses>
                                         d_clusterDomainQueueStatuses;
        bsls::ObjectBuffer<BrokerConfig> d_brokerConfig;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const Result& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                     = -1,
        SELECTION_ID_ERROR                         = 0,
        SELECTION_ID_SUCCESS                       = 1,
        SELECTION_ID_VALUE                         = 2,
        SELECTION_ID_TUNABLE                       = 3,
        SELECTION_ID_TUNABLES                      = 4,
        SELECTION_ID_TUNABLE_CONFIRMATION          = 5,
        SELECTION_ID_HELP                          = 6,
        SELECTION_ID_DOMAIN_INFO                   = 7,
        SELECTION_ID_PURGED_QUEUES                 = 8,
        SELECTION_ID_QUEUE_INTERNALS               = 9,
        SELECTION_ID_MESSAGE_GROUP_ID_HELPER       = 10,
        SELECTION_ID_QUEUE_CONTENTS                = 11,
        SELECTION_ID_MESSAGE                       = 12,
        SELECTION_ID_STATS                         = 13,
        SELECTION_ID_CLUSTER_LIST                  = 14,
        SELECTION_ID_CLUSTER_STATUS                = 15,
        SELECTION_ID_CLUSTER_PROXY_STATUS          = 16,
        SELECTION_ID_NODE_STATUSES                 = 17,
        SELECTION_ID_ELECTOR_INFO                  = 18,
        SELECTION_ID_PARTITIONS_INFO               = 19,
        SELECTION_ID_CLUSTER_QUEUE_HELPER          = 20,
        SELECTION_ID_STORAGE_CONTENT               = 21,
        SELECTION_ID_CLUSTER_STORAGE_SUMMARY       = 22,
        SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES = 23,
        SELECTION_ID_BROKER_CONFIG                 = 24
    };

    enum { NUM_SELECTIONS = 25 };

    enum {
        SELECTION_INDEX_ERROR                         = 0,
        SELECTION_INDEX_SUCCESS                       = 1,
        SELECTION_INDEX_VALUE                         = 2,
        SELECTION_INDEX_TUNABLE                       = 3,
        SELECTION_INDEX_TUNABLES                      = 4,
        SELECTION_INDEX_TUNABLE_CONFIRMATION          = 5,
        SELECTION_INDEX_HELP                          = 6,
        SELECTION_INDEX_DOMAIN_INFO                   = 7,
        SELECTION_INDEX_PURGED_QUEUES                 = 8,
        SELECTION_INDEX_QUEUE_INTERNALS               = 9,
        SELECTION_INDEX_MESSAGE_GROUP_ID_HELPER       = 10,
        SELECTION_INDEX_QUEUE_CONTENTS                = 11,
        SELECTION_INDEX_MESSAGE                       = 12,
        SELECTION_INDEX_STATS                         = 13,
        SELECTION_INDEX_CLUSTER_LIST                  = 14,
        SELECTION_INDEX_CLUSTER_STATUS                = 15,
        SELECTION_INDEX_CLUSTER_PROXY_STATUS          = 16,
        SELECTION_INDEX_NODE_STATUSES                 = 17,
        SELECTION_INDEX_ELECTOR_INFO                  = 18,
        SELECTION_INDEX_PARTITIONS_INFO               = 19,
        SELECTION_INDEX_CLUSTER_QUEUE_HELPER          = 20,
        SELECTION_INDEX_STORAGE_CONTENT               = 21,
        SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY       = 22,
        SELECTION_INDEX_CLUSTER_DOMAIN_QUEUE_STATUSES = 23,
        SELECTION_INDEX_BROKER_CONFIG                 = 24
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit Result(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Result' having the default value.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    Result(const Result& original, bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'Result' having the value of the specified
    // 'original' object.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Result(Result&& original) noexcept;
    // Create an object of type 'Result' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.

    Result(Result&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'Result' having the value of the specified
    // 'original' object.  After performing this action, the 'original'
    // object will be left in a valid, but unspecified state.  Use the
    // optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~Result();
    // Destroy this object.

    // MANIPULATORS
    Result& operator=(const Result& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Result& operator=(Result&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    Void& makeSuccess();
    Void& makeSuccess(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSuccess(Void&& value);
#endif
    // Set the value of this object to be a "Success" value.  Optionally
    // specify the 'value' of the "Success".  If 'value' is not specified,
    // the default "Success" value is used.

    Value& makeValue();
    Value& makeValue(const Value& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Value& makeValue(Value&& value);
#endif
    // Set the value of this object to be a "Value" value.  Optionally
    // specify the 'value' of the "Value".  If 'value' is not specified,
    // the default "Value" value is used.

    Tunable& makeTunable();
    Tunable& makeTunable(const Tunable& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunable& makeTunable(Tunable&& value);
#endif
    // Set the value of this object to be a "Tunable" value.  Optionally
    // specify the 'value' of the "Tunable".  If 'value' is not specified,
    // the default "Tunable" value is used.

    Tunables& makeTunables();
    Tunables& makeTunables(const Tunables& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Tunables& makeTunables(Tunables&& value);
#endif
    // Set the value of this object to be a "Tunables" value.  Optionally
    // specify the 'value' of the "Tunables".  If 'value' is not specified,
    // the default "Tunables" value is used.

    TunableConfirmation& makeTunableConfirmation();
    TunableConfirmation&
    makeTunableConfirmation(const TunableConfirmation& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    TunableConfirmation& makeTunableConfirmation(TunableConfirmation&& value);
#endif
    // Set the value of this object to be a "TunableConfirmation" value.
    // Optionally specify the 'value' of the "TunableConfirmation".  If
    // 'value' is not specified, the default "TunableConfirmation" value is
    // used.

    Help& makeHelp();
    Help& makeHelp(const Help& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Help& makeHelp(Help&& value);
#endif
    // Set the value of this object to be a "Help" value.  Optionally
    // specify the 'value' of the "Help".  If 'value' is not specified, the
    // default "Help" value is used.

    DomainInfo& makeDomainInfo();
    DomainInfo& makeDomainInfo(const DomainInfo& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainInfo& makeDomainInfo(DomainInfo&& value);
#endif
    // Set the value of this object to be a "DomainInfo" value.  Optionally
    // specify the 'value' of the "DomainInfo".  If 'value' is not
    // specified, the default "DomainInfo" value is used.

    PurgedQueues& makePurgedQueues();
    PurgedQueues& makePurgedQueues(const PurgedQueues& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueues& makePurgedQueues(PurgedQueues&& value);
#endif
    // Set the value of this object to be a "PurgedQueues" value.
    // Optionally specify the 'value' of the "PurgedQueues".  If 'value' is
    // not specified, the default "PurgedQueues" value is used.

    QueueInternals& makeQueueInternals();
    QueueInternals& makeQueueInternals(const QueueInternals& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInternals& makeQueueInternals(QueueInternals&& value);
#endif
    // Set the value of this object to be a "QueueInternals" value.
    // Optionally specify the 'value' of the "QueueInternals".  If 'value'
    // is not specified, the default "QueueInternals" value is used.

    MessageGroupIdHelper& makeMessageGroupIdHelper();
    MessageGroupIdHelper&
    makeMessageGroupIdHelper(const MessageGroupIdHelper& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    MessageGroupIdHelper&
    makeMessageGroupIdHelper(MessageGroupIdHelper&& value);
#endif
    // Set the value of this object to be a "MessageGroupIdHelper" value.
    // Optionally specify the 'value' of the "MessageGroupIdHelper".  If
    // 'value' is not specified, the default "MessageGroupIdHelper" value
    // is used.

    QueueContents& makeQueueContents();
    QueueContents& makeQueueContents(const QueueContents& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueContents& makeQueueContents(QueueContents&& value);
#endif
    // Set the value of this object to be a "QueueContents" value.
    // Optionally specify the 'value' of the "QueueContents".  If 'value'
    // is not specified, the default "QueueContents" value is used.

    Message& makeMessage();
    Message& makeMessage(const Message& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Message& makeMessage(Message&& value);
#endif
    // Set the value of this object to be a "Message" value.  Optionally
    // specify the 'value' of the "Message".  If 'value' is not specified,
    // the default "Message" value is used.

    bsl::string& makeStats();
    bsl::string& makeStats(const bsl::string& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    bsl::string& makeStats(bsl::string&& value);
#endif
    // Set the value of this object to be a "Stats" value.  Optionally
    // specify the 'value' of the "Stats".  If 'value' is not specified,
    // the default "Stats" value is used.

    ClusterList& makeClusterList();
    ClusterList& makeClusterList(const ClusterList& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterList& makeClusterList(ClusterList&& value);
#endif
    // Set the value of this object to be a "ClusterList" value.
    // Optionally specify the 'value' of the "ClusterList".  If 'value' is
    // not specified, the default "ClusterList" value is used.

    ClusterStatus& makeClusterStatus();
    ClusterStatus& makeClusterStatus(const ClusterStatus& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStatus& makeClusterStatus(ClusterStatus&& value);
#endif
    // Set the value of this object to be a "ClusterStatus" value.
    // Optionally specify the 'value' of the "ClusterStatus".  If 'value'
    // is not specified, the default "ClusterStatus" value is used.

    ClusterProxyStatus& makeClusterProxyStatus();
    ClusterProxyStatus&
    makeClusterProxyStatus(const ClusterProxyStatus& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterProxyStatus& makeClusterProxyStatus(ClusterProxyStatus&& value);
#endif
    // Set the value of this object to be a "ClusterProxyStatus" value.
    // Optionally specify the 'value' of the "ClusterProxyStatus".  If
    // 'value' is not specified, the default "ClusterProxyStatus" value is
    // used.

    NodeStatuses& makeNodeStatuses();
    NodeStatuses& makeNodeStatuses(const NodeStatuses& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    NodeStatuses& makeNodeStatuses(NodeStatuses&& value);
#endif
    // Set the value of this object to be a "NodeStatuses" value.
    // Optionally specify the 'value' of the "NodeStatuses".  If 'value' is
    // not specified, the default "NodeStatuses" value is used.

    ElectorInfo& makeElectorInfo();
    ElectorInfo& makeElectorInfo(const ElectorInfo& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ElectorInfo& makeElectorInfo(ElectorInfo&& value);
#endif
    // Set the value of this object to be a "ElectorInfo" value.
    // Optionally specify the 'value' of the "ElectorInfo".  If 'value' is
    // not specified, the default "ElectorInfo" value is used.

    PartitionsInfo& makePartitionsInfo();
    PartitionsInfo& makePartitionsInfo(const PartitionsInfo& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PartitionsInfo& makePartitionsInfo(PartitionsInfo&& value);
#endif
    // Set the value of this object to be a "PartitionsInfo" value.
    // Optionally specify the 'value' of the "PartitionsInfo".  If 'value'
    // is not specified, the default "PartitionsInfo" value is used.

    ClusterQueueHelper& makeClusterQueueHelper();
    ClusterQueueHelper&
    makeClusterQueueHelper(const ClusterQueueHelper& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterQueueHelper& makeClusterQueueHelper(ClusterQueueHelper&& value);
#endif
    // Set the value of this object to be a "ClusterQueueHelper" value.
    // Optionally specify the 'value' of the "ClusterQueueHelper".  If
    // 'value' is not specified, the default "ClusterQueueHelper" value is
    // used.

    StorageContent& makeStorageContent();
    StorageContent& makeStorageContent(const StorageContent& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StorageContent& makeStorageContent(StorageContent&& value);
#endif
    // Set the value of this object to be a "StorageContent" value.
    // Optionally specify the 'value' of the "StorageContent".  If 'value'
    // is not specified, the default "StorageContent" value is used.

    ClusterStorageSummary& makeClusterStorageSummary();
    ClusterStorageSummary&
    makeClusterStorageSummary(const ClusterStorageSummary& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStorageSummary&
    makeClusterStorageSummary(ClusterStorageSummary&& value);
#endif
    // Set the value of this object to be a "ClusterStorageSummary" value.
    // Optionally specify the 'value' of the "ClusterStorageSummary".  If
    // 'value' is not specified, the default "ClusterStorageSummary" value
    // is used.

    ClusterDomainQueueStatuses& makeClusterDomainQueueStatuses();
    ClusterDomainQueueStatuses&
    makeClusterDomainQueueStatuses(const ClusterDomainQueueStatuses& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterDomainQueueStatuses&
    makeClusterDomainQueueStatuses(ClusterDomainQueueStatuses&& value);
#endif
    // Set the value of this object to be a "ClusterDomainQueueStatuses"
    // value.  Optionally specify the 'value' of the
    // "ClusterDomainQueueStatuses".  If 'value' is not specified, the
    // default "ClusterDomainQueueStatuses" value is used.

    BrokerConfig& makeBrokerConfig();
    BrokerConfig& makeBrokerConfig(const BrokerConfig& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerConfig& makeBrokerConfig(BrokerConfig&& value);
#endif
    // Set the value of this object to be a "BrokerConfig" value.
    // Optionally specify the 'value' of the "BrokerConfig".  If 'value' is
    // not specified, the default "BrokerConfig" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    Void& success();
    // Return a reference to the modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    Value& value();
    // Return a reference to the modifiable "Value" selection of this
    // object if "Value" is the current selection.  The behavior is
    // undefined unless "Value" is the selection of this object.

    Tunable& tunable();
    // Return a reference to the modifiable "Tunable" selection of this
    // object if "Tunable" is the current selection.  The behavior is
    // undefined unless "Tunable" is the selection of this object.

    Tunables& tunables();
    // Return a reference to the modifiable "Tunables" selection of this
    // object if "Tunables" is the current selection.  The behavior is
    // undefined unless "Tunables" is the selection of this object.

    TunableConfirmation& tunableConfirmation();
    // Return a reference to the modifiable "TunableConfirmation" selection
    // of this object if "TunableConfirmation" is the current selection.
    // The behavior is undefined unless "TunableConfirmation" is the
    // selection of this object.

    Help& help();
    // Return a reference to the modifiable "Help" selection of this object
    // if "Help" is the current selection.  The behavior is undefined
    // unless "Help" is the selection of this object.

    DomainInfo& domainInfo();
    // Return a reference to the modifiable "DomainInfo" selection of this
    // object if "DomainInfo" is the current selection.  The behavior is
    // undefined unless "DomainInfo" is the selection of this object.

    PurgedQueues& purgedQueues();
    // Return a reference to the modifiable "PurgedQueues" selection of
    // this object if "PurgedQueues" is the current selection.  The
    // behavior is undefined unless "PurgedQueues" is the selection of this
    // object.

    QueueInternals& queueInternals();
    // Return a reference to the modifiable "QueueInternals" selection of
    // this object if "QueueInternals" is the current selection.  The
    // behavior is undefined unless "QueueInternals" is the selection of
    // this object.

    MessageGroupIdHelper& messageGroupIdHelper();
    // Return a reference to the modifiable "MessageGroupIdHelper"
    // selection of this object if "MessageGroupIdHelper" is the current
    // selection.  The behavior is undefined unless "MessageGroupIdHelper"
    // is the selection of this object.

    QueueContents& queueContents();
    // Return a reference to the modifiable "QueueContents" selection of
    // this object if "QueueContents" is the current selection.  The
    // behavior is undefined unless "QueueContents" is the selection of
    // this object.

    Message& message();
    // Return a reference to the modifiable "Message" selection of this
    // object if "Message" is the current selection.  The behavior is
    // undefined unless "Message" is the selection of this object.

    bsl::string& stats();
    // Return a reference to the modifiable "Stats" selection of this
    // object if "Stats" is the current selection.  The behavior is
    // undefined unless "Stats" is the selection of this object.

    ClusterList& clusterList();
    // Return a reference to the modifiable "ClusterList" selection of this
    // object if "ClusterList" is the current selection.  The behavior is
    // undefined unless "ClusterList" is the selection of this object.

    ClusterStatus& clusterStatus();
    // Return a reference to the modifiable "ClusterStatus" selection of
    // this object if "ClusterStatus" is the current selection.  The
    // behavior is undefined unless "ClusterStatus" is the selection of
    // this object.

    ClusterProxyStatus& clusterProxyStatus();
    // Return a reference to the modifiable "ClusterProxyStatus" selection
    // of this object if "ClusterProxyStatus" is the current selection.
    // The behavior is undefined unless "ClusterProxyStatus" is the
    // selection of this object.

    NodeStatuses& nodeStatuses();
    // Return a reference to the modifiable "NodeStatuses" selection of
    // this object if "NodeStatuses" is the current selection.  The
    // behavior is undefined unless "NodeStatuses" is the selection of this
    // object.

    ElectorInfo& electorInfo();
    // Return a reference to the modifiable "ElectorInfo" selection of this
    // object if "ElectorInfo" is the current selection.  The behavior is
    // undefined unless "ElectorInfo" is the selection of this object.

    PartitionsInfo& partitionsInfo();
    // Return a reference to the modifiable "PartitionsInfo" selection of
    // this object if "PartitionsInfo" is the current selection.  The
    // behavior is undefined unless "PartitionsInfo" is the selection of
    // this object.

    ClusterQueueHelper& clusterQueueHelper();
    // Return a reference to the modifiable "ClusterQueueHelper" selection
    // of this object if "ClusterQueueHelper" is the current selection.
    // The behavior is undefined unless "ClusterQueueHelper" is the
    // selection of this object.

    StorageContent& storageContent();
    // Return a reference to the modifiable "StorageContent" selection of
    // this object if "StorageContent" is the current selection.  The
    // behavior is undefined unless "StorageContent" is the selection of
    // this object.

    ClusterStorageSummary& clusterStorageSummary();
    // Return a reference to the modifiable "ClusterStorageSummary"
    // selection of this object if "ClusterStorageSummary" is the current
    // selection.  The behavior is undefined unless "ClusterStorageSummary"
    // is the selection of this object.

    ClusterDomainQueueStatuses& clusterDomainQueueStatuses();
    // Return a reference to the modifiable "ClusterDomainQueueStatuses"
    // selection of this object if "ClusterDomainQueueStatuses" is the
    // current selection.  The behavior is undefined unless
    // "ClusterDomainQueueStatuses" is the selection of this object.

    BrokerConfig& brokerConfig();
    // Return a reference to the modifiable "BrokerConfig" selection of
    // this object if "BrokerConfig" is the current selection.  The
    // behavior is undefined unless "BrokerConfig" is the selection of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const Void& success() const;
    // Return a reference to the non-modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    const Value& value() const;
    // Return a reference to the non-modifiable "Value" selection of this
    // object if "Value" is the current selection.  The behavior is
    // undefined unless "Value" is the selection of this object.

    const Tunable& tunable() const;
    // Return a reference to the non-modifiable "Tunable" selection of this
    // object if "Tunable" is the current selection.  The behavior is
    // undefined unless "Tunable" is the selection of this object.

    const Tunables& tunables() const;
    // Return a reference to the non-modifiable "Tunables" selection of
    // this object if "Tunables" is the current selection.  The behavior is
    // undefined unless "Tunables" is the selection of this object.

    const TunableConfirmation& tunableConfirmation() const;
    // Return a reference to the non-modifiable "TunableConfirmation"
    // selection of this object if "TunableConfirmation" is the current
    // selection.  The behavior is undefined unless "TunableConfirmation"
    // is the selection of this object.

    const Help& help() const;
    // Return a reference to the non-modifiable "Help" selection of this
    // object if "Help" is the current selection.  The behavior is
    // undefined unless "Help" is the selection of this object.

    const DomainInfo& domainInfo() const;
    // Return a reference to the non-modifiable "DomainInfo" selection of
    // this object if "DomainInfo" is the current selection.  The behavior
    // is undefined unless "DomainInfo" is the selection of this object.

    const PurgedQueues& purgedQueues() const;
    // Return a reference to the non-modifiable "PurgedQueues" selection of
    // this object if "PurgedQueues" is the current selection.  The
    // behavior is undefined unless "PurgedQueues" is the selection of this
    // object.

    const QueueInternals& queueInternals() const;
    // Return a reference to the non-modifiable "QueueInternals" selection
    // of this object if "QueueInternals" is the current selection.  The
    // behavior is undefined unless "QueueInternals" is the selection of
    // this object.

    const MessageGroupIdHelper& messageGroupIdHelper() const;
    // Return a reference to the non-modifiable "MessageGroupIdHelper"
    // selection of this object if "MessageGroupIdHelper" is the current
    // selection.  The behavior is undefined unless "MessageGroupIdHelper"
    // is the selection of this object.

    const QueueContents& queueContents() const;
    // Return a reference to the non-modifiable "QueueContents" selection
    // of this object if "QueueContents" is the current selection.  The
    // behavior is undefined unless "QueueContents" is the selection of
    // this object.

    const Message& message() const;
    // Return a reference to the non-modifiable "Message" selection of this
    // object if "Message" is the current selection.  The behavior is
    // undefined unless "Message" is the selection of this object.

    const bsl::string& stats() const;
    // Return a reference to the non-modifiable "Stats" selection of this
    // object if "Stats" is the current selection.  The behavior is
    // undefined unless "Stats" is the selection of this object.

    const ClusterList& clusterList() const;
    // Return a reference to the non-modifiable "ClusterList" selection of
    // this object if "ClusterList" is the current selection.  The behavior
    // is undefined unless "ClusterList" is the selection of this object.

    const ClusterStatus& clusterStatus() const;
    // Return a reference to the non-modifiable "ClusterStatus" selection
    // of this object if "ClusterStatus" is the current selection.  The
    // behavior is undefined unless "ClusterStatus" is the selection of
    // this object.

    const ClusterProxyStatus& clusterProxyStatus() const;
    // Return a reference to the non-modifiable "ClusterProxyStatus"
    // selection of this object if "ClusterProxyStatus" is the current
    // selection.  The behavior is undefined unless "ClusterProxyStatus" is
    // the selection of this object.

    const NodeStatuses& nodeStatuses() const;
    // Return a reference to the non-modifiable "NodeStatuses" selection of
    // this object if "NodeStatuses" is the current selection.  The
    // behavior is undefined unless "NodeStatuses" is the selection of this
    // object.

    const ElectorInfo& electorInfo() const;
    // Return a reference to the non-modifiable "ElectorInfo" selection of
    // this object if "ElectorInfo" is the current selection.  The behavior
    // is undefined unless "ElectorInfo" is the selection of this object.

    const PartitionsInfo& partitionsInfo() const;
    // Return a reference to the non-modifiable "PartitionsInfo" selection
    // of this object if "PartitionsInfo" is the current selection.  The
    // behavior is undefined unless "PartitionsInfo" is the selection of
    // this object.

    const ClusterQueueHelper& clusterQueueHelper() const;
    // Return a reference to the non-modifiable "ClusterQueueHelper"
    // selection of this object if "ClusterQueueHelper" is the current
    // selection.  The behavior is undefined unless "ClusterQueueHelper" is
    // the selection of this object.

    const StorageContent& storageContent() const;
    // Return a reference to the non-modifiable "StorageContent" selection
    // of this object if "StorageContent" is the current selection.  The
    // behavior is undefined unless "StorageContent" is the selection of
    // this object.

    const ClusterStorageSummary& clusterStorageSummary() const;
    // Return a reference to the non-modifiable "ClusterStorageSummary"
    // selection of this object if "ClusterStorageSummary" is the current
    // selection.  The behavior is undefined unless "ClusterStorageSummary"
    // is the selection of this object.

    const ClusterDomainQueueStatuses& clusterDomainQueueStatuses() const;
    // Return a reference to the non-modifiable
    // "ClusterDomainQueueStatuses" selection of this object if
    // "ClusterDomainQueueStatuses" is the current selection.  The behavior
    // is undefined unless "ClusterDomainQueueStatuses" is the selection of
    // this object.

    const BrokerConfig& brokerConfig() const;
    // Return a reference to the non-modifiable "BrokerConfig" selection of
    // this object if "BrokerConfig" is the current selection.  The
    // behavior is undefined unless "BrokerConfig" is the selection of this
    // object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isSuccessValue() const;
    // Return 'true' if the value of this object is a "Success" value, and
    // return 'false' otherwise.

    bool isValueValue() const;
    // Return 'true' if the value of this object is a "Value" value, and
    // return 'false' otherwise.

    bool isTunableValue() const;
    // Return 'true' if the value of this object is a "Tunable" value, and
    // return 'false' otherwise.

    bool isTunablesValue() const;
    // Return 'true' if the value of this object is a "Tunables" value, and
    // return 'false' otherwise.

    bool isTunableConfirmationValue() const;
    // Return 'true' if the value of this object is a "TunableConfirmation"
    // value, and return 'false' otherwise.

    bool isHelpValue() const;
    // Return 'true' if the value of this object is a "Help" value, and
    // return 'false' otherwise.

    bool isDomainInfoValue() const;
    // Return 'true' if the value of this object is a "DomainInfo" value,
    // and return 'false' otherwise.

    bool isPurgedQueuesValue() const;
    // Return 'true' if the value of this object is a "PurgedQueues" value,
    // and return 'false' otherwise.

    bool isQueueInternalsValue() const;
    // Return 'true' if the value of this object is a "QueueInternals"
    // value, and return 'false' otherwise.

    bool isMessageGroupIdHelperValue() const;
    // Return 'true' if the value of this object is a
    // "MessageGroupIdHelper" value, and return 'false' otherwise.

    bool isQueueContentsValue() const;
    // Return 'true' if the value of this object is a "QueueContents"
    // value, and return 'false' otherwise.

    bool isMessageValue() const;
    // Return 'true' if the value of this object is a "Message" value, and
    // return 'false' otherwise.

    bool isStatsValue() const;
    // Return 'true' if the value of this object is a "Stats" value, and
    // return 'false' otherwise.

    bool isClusterListValue() const;
    // Return 'true' if the value of this object is a "ClusterList" value,
    // and return 'false' otherwise.

    bool isClusterStatusValue() const;
    // Return 'true' if the value of this object is a "ClusterStatus"
    // value, and return 'false' otherwise.

    bool isClusterProxyStatusValue() const;
    // Return 'true' if the value of this object is a "ClusterProxyStatus"
    // value, and return 'false' otherwise.

    bool isNodeStatusesValue() const;
    // Return 'true' if the value of this object is a "NodeStatuses" value,
    // and return 'false' otherwise.

    bool isElectorInfoValue() const;
    // Return 'true' if the value of this object is a "ElectorInfo" value,
    // and return 'false' otherwise.

    bool isPartitionsInfoValue() const;
    // Return 'true' if the value of this object is a "PartitionsInfo"
    // value, and return 'false' otherwise.

    bool isClusterQueueHelperValue() const;
    // Return 'true' if the value of this object is a "ClusterQueueHelper"
    // value, and return 'false' otherwise.

    bool isStorageContentValue() const;
    // Return 'true' if the value of this object is a "StorageContent"
    // value, and return 'false' otherwise.

    bool isClusterStorageSummaryValue() const;
    // Return 'true' if the value of this object is a
    // "ClusterStorageSummary" value, and return 'false' otherwise.

    bool isClusterDomainQueueStatusesValue() const;
    // Return 'true' if the value of this object is a
    // "ClusterDomainQueueStatuses" value, and return 'false' otherwise.

    bool isBrokerConfigValue() const;
    // Return 'true' if the value of this object is a "BrokerConfig" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const Result& lhs, const Result& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'Result' objects have the same
    // value if either the selections in both objects have the same ids and
    // the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const Result& lhs, const Result& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream& stream, const Result& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM& hashAlg, const Result& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for 'Result'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::Result)

namespace mqbcmd {

// ==================
// class DomainResult
// ==================

class DomainResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>         d_success;
        bsls::ObjectBuffer<Error>        d_error;
        bsls::ObjectBuffer<DomainInfo>   d_domainInfo;
        bsls::ObjectBuffer<PurgedQueues> d_purgedQueues;
        bsls::ObjectBuffer<QueueResult>  d_queueResult;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const DomainResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED     = -1,
        SELECTION_ID_SUCCESS       = 0,
        SELECTION_ID_ERROR         = 1,
        SELECTION_ID_DOMAIN_INFO   = 2,
        SELECTION_ID_PURGED_QUEUES = 3,
        SELECTION_ID_QUEUE_RESULT  = 4
    };

    enum { NUM_SELECTIONS = 5 };

    enum {
        SELECTION_INDEX_SUCCESS       = 0,
        SELECTION_INDEX_ERROR         = 1,
        SELECTION_INDEX_DOMAIN_INFO   = 2,
        SELECTION_INDEX_PURGED_QUEUES = 3,
        SELECTION_INDEX_QUEUE_RESULT  = 4
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit DomainResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainResult' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    DomainResult(const DomainResult& original,
                 bslma::Allocator*   basicAllocator = 0);
    // Create an object of type 'DomainResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainResult(DomainResult&& original) noexcept;
    // Create an object of type 'DomainResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    DomainResult(DomainResult&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'DomainResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~DomainResult();
    // Destroy this object.

    // MANIPULATORS
    DomainResult& operator=(const DomainResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainResult& operator=(DomainResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeSuccess();
    Void& makeSuccess(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSuccess(Void&& value);
#endif
    // Set the value of this object to be a "Success" value.  Optionally
    // specify the 'value' of the "Success".  If 'value' is not specified,
    // the default "Success" value is used.

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    DomainInfo& makeDomainInfo();
    DomainInfo& makeDomainInfo(const DomainInfo& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainInfo& makeDomainInfo(DomainInfo&& value);
#endif
    // Set the value of this object to be a "DomainInfo" value.  Optionally
    // specify the 'value' of the "DomainInfo".  If 'value' is not
    // specified, the default "DomainInfo" value is used.

    PurgedQueues& makePurgedQueues();
    PurgedQueues& makePurgedQueues(const PurgedQueues& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    PurgedQueues& makePurgedQueues(PurgedQueues&& value);
#endif
    // Set the value of this object to be a "PurgedQueues" value.
    // Optionally specify the 'value' of the "PurgedQueues".  If 'value' is
    // not specified, the default "PurgedQueues" value is used.

    QueueResult& makeQueueResult();
    QueueResult& makeQueueResult(const QueueResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueResult& makeQueueResult(QueueResult&& value);
#endif
    // Set the value of this object to be a "QueueResult" value.
    // Optionally specify the 'value' of the "QueueResult".  If 'value' is
    // not specified, the default "QueueResult" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& success();
    // Return a reference to the modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    DomainInfo& domainInfo();
    // Return a reference to the modifiable "DomainInfo" selection of this
    // object if "DomainInfo" is the current selection.  The behavior is
    // undefined unless "DomainInfo" is the selection of this object.

    PurgedQueues& purgedQueues();
    // Return a reference to the modifiable "PurgedQueues" selection of
    // this object if "PurgedQueues" is the current selection.  The
    // behavior is undefined unless "PurgedQueues" is the selection of this
    // object.

    QueueResult& queueResult();
    // Return a reference to the modifiable "QueueResult" selection of this
    // object if "QueueResult" is the current selection.  The behavior is
    // undefined unless "QueueResult" is the selection of this object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& success() const;
    // Return a reference to the non-modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const DomainInfo& domainInfo() const;
    // Return a reference to the non-modifiable "DomainInfo" selection of
    // this object if "DomainInfo" is the current selection.  The behavior
    // is undefined unless "DomainInfo" is the selection of this object.

    const PurgedQueues& purgedQueues() const;
    // Return a reference to the non-modifiable "PurgedQueues" selection of
    // this object if "PurgedQueues" is the current selection.  The
    // behavior is undefined unless "PurgedQueues" is the selection of this
    // object.

    const QueueResult& queueResult() const;
    // Return a reference to the non-modifiable "QueueResult" selection of
    // this object if "QueueResult" is the current selection.  The behavior
    // is undefined unless "QueueResult" is the selection of this object.

    bool isSuccessValue() const;
    // Return 'true' if the value of this object is a "Success" value, and
    // return 'false' otherwise.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isDomainInfoValue() const;
    // Return 'true' if the value of this object is a "DomainInfo" value,
    // and return 'false' otherwise.

    bool isPurgedQueuesValue() const;
    // Return 'true' if the value of this object is a "PurgedQueues" value,
    // and return 'false' otherwise.

    bool isQueueResultValue() const;
    // Return 'true' if the value of this object is a "QueueResult" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DomainResult& lhs, const DomainResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'DomainResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const DomainResult& lhs, const DomainResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&       stream,
                                    const DomainResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&   hashAlg,
                           const DomainResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DomainResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::DomainResult)

namespace mqbcmd {

// =========================
// class RouteResponseResult
// =========================

class RouteResponseResult {
    // INSTANCE DATA
    bsl::string d_source;
    Result      d_result;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_SOURCE = 0, ATTRIBUTE_ID_RESULT = 1 };

    enum { NUM_ATTRIBUTES = 2 };

    enum { ATTRIBUTE_INDEX_SOURCE = 0, ATTRIBUTE_INDEX_RESULT = 1 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RouteResponseResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RouteResponseResult' having the default
    // value.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.

    RouteResponseResult(const RouteResponseResult& original,
                        bslma::Allocator*          basicAllocator = 0);
    // Create an object of type 'RouteResponseResult' having the value of
    // the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouteResponseResult(RouteResponseResult&& original) noexcept;
    // Create an object of type 'RouteResponseResult' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    RouteResponseResult(RouteResponseResult&& original,
                        bslma::Allocator*     basicAllocator);
    // Create an object of type 'RouteResponseResult' having the value of
    // the specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~RouteResponseResult();
    // Destroy this object.

    // MANIPULATORS
    RouteResponseResult& operator=(const RouteResponseResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouteResponseResult& operator=(RouteResponseResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::string& source();
    // Return a reference to the modifiable "Source" attribute of this
    // object.

    Result& result();
    // Return a reference to the modifiable "Result" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::string& source() const;
    // Return a reference offering non-modifiable access to the "Source"
    // attribute of this object.

    const Result& result() const;
    // Return a reference offering non-modifiable access to the "Result"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RouteResponseResult& lhs,
                           const RouteResponseResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.source() == rhs.source() && lhs.result() == rhs.result();
    }

    friend bool operator!=(const RouteResponseResult& lhs,
                           const RouteResponseResult& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&              stream,
                                    const RouteResponseResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&          hashAlg,
                           const RouteResponseResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RouteResponseResult'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.source());
        hashAppend(hashAlg, object.result());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RouteResponseResult)

namespace mqbcmd {

// ===================
// class DomainsResult
// ===================

class DomainsResult {
    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Void>         d_success;
        bsls::ObjectBuffer<Error>        d_error;
        bsls::ObjectBuffer<DomainResult> d_domainResult;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const DomainsResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED     = -1,
        SELECTION_ID_SUCCESS       = 0,
        SELECTION_ID_ERROR         = 1,
        SELECTION_ID_DOMAIN_RESULT = 2
    };

    enum { NUM_SELECTIONS = 3 };

    enum {
        SELECTION_INDEX_SUCCESS       = 0,
        SELECTION_INDEX_ERROR         = 1,
        SELECTION_INDEX_DOMAIN_RESULT = 2
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit DomainsResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'DomainsResult' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    DomainsResult(const DomainsResult& original,
                  bslma::Allocator*    basicAllocator = 0);
    // Create an object of type 'DomainsResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainsResult(DomainsResult&& original) noexcept;
    // Create an object of type 'DomainsResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    DomainsResult(DomainsResult&& original, bslma::Allocator* basicAllocator);
    // Create an object of type 'DomainsResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~DomainsResult();
    // Destroy this object.

    // MANIPULATORS
    DomainsResult& operator=(const DomainsResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainsResult& operator=(DomainsResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Void& makeSuccess();
    Void& makeSuccess(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSuccess(Void&& value);
#endif
    // Set the value of this object to be a "Success" value.  Optionally
    // specify the 'value' of the "Success".  If 'value' is not specified,
    // the default "Success" value is used.

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    DomainResult& makeDomainResult();
    DomainResult& makeDomainResult(const DomainResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainResult& makeDomainResult(DomainResult&& value);
#endif
    // Set the value of this object to be a "DomainResult" value.
    // Optionally specify the 'value' of the "DomainResult".  If 'value' is
    // not specified, the default "DomainResult" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Void& success();
    // Return a reference to the modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    DomainResult& domainResult();
    // Return a reference to the modifiable "DomainResult" selection of
    // this object if "DomainResult" is the current selection.  The
    // behavior is undefined unless "DomainResult" is the selection of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Void& success() const;
    // Return a reference to the non-modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const DomainResult& domainResult() const;
    // Return a reference to the non-modifiable "DomainResult" selection of
    // this object if "DomainResult" is the current selection.  The
    // behavior is undefined unless "DomainResult" is the selection of this
    // object.

    bool isSuccessValue() const;
    // Return 'true' if the value of this object is a "Success" value, and
    // return 'false' otherwise.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isDomainResultValue() const;
    // Return 'true' if the value of this object is a "DomainResult" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const DomainsResult& lhs, const DomainsResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'DomainsResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const DomainsResult& lhs, const DomainsResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&        stream,
                                    const DomainsResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&    hashAlg,
                           const DomainsResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'DomainsResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::DomainsResult)

namespace mqbcmd {

// =============================
// class RouteResponseResultList
// =============================

class RouteResponseResultList {
    // INSTANCE DATA
    bsl::vector<RouteResponseResult> d_responses;

  public:
    // TYPES
    enum { ATTRIBUTE_ID_RESPONSES = 0 };

    enum { NUM_ATTRIBUTES = 1 };

    enum { ATTRIBUTE_INDEX_RESPONSES = 0 };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_AttributeInfo ATTRIBUTE_INFO_ARRAY[];

  public:
    // CLASS METHODS
    static const bdlat_AttributeInfo* lookupAttributeInfo(int id);
    // Return attribute information for the attribute indicated by the
    // specified 'id' if the attribute exists, and 0 otherwise.

    static const bdlat_AttributeInfo* lookupAttributeInfo(const char* name,
                                                          int nameLength);
    // Return attribute information for the attribute indicated by the
    // specified 'name' of the specified 'nameLength' if the attribute
    // exists, and 0 otherwise.

    // CREATORS
    explicit RouteResponseResultList(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'RouteResponseResultList' having the
    // default value.  Use the optionally specified 'basicAllocator' to
    // supply memory.  If 'basicAllocator' is 0, the currently installed
    // default allocator is used.

    RouteResponseResultList(const RouteResponseResultList& original,
                            bslma::Allocator*              basicAllocator = 0);
    // Create an object of type 'RouteResponseResultList' having the value
    // of the specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouteResponseResultList(RouteResponseResultList&& original) noexcept;
    // Create an object of type 'RouteResponseResultList' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.

    RouteResponseResultList(RouteResponseResultList&& original,
                            bslma::Allocator*         basicAllocator);
    // Create an object of type 'RouteResponseResultList' having the value
    // of the specified 'original' object.  After performing this action,
    // the 'original' object will be left in a valid, but unspecified
    // state.  Use the optionally specified 'basicAllocator' to supply
    // memory.  If 'basicAllocator' is 0, the currently installed default
    // allocator is used.
#endif

    ~RouteResponseResultList();
    // Destroy this object.

    // MANIPULATORS
    RouteResponseResultList& operator=(const RouteResponseResultList& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    RouteResponseResultList& operator=(RouteResponseResultList&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon
    // default construction).

    template <typename t_MANIPULATOR>
    int manipulateAttributes(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' sequentially on the address of
    // each (modifiable) attribute of this object, supplying 'manipulator'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'manipulator' (i.e., the invocation that
    // terminated the sequence).

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator, int id);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'id',
    // supplying 'manipulator' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if 'id' identifies an attribute of this
    // class, and -1 otherwise.

    template <typename t_MANIPULATOR>
    int manipulateAttribute(t_MANIPULATOR& manipulator,
                            const char*    name,
                            int            nameLength);
    // Invoke the specified 'manipulator' on the address of
    // the (modifiable) attribute indicated by the specified 'name' of the
    // specified 'nameLength', supplying 'manipulator' with the
    // corresponding attribute information structure.  Return the value
    // returned from the invocation of 'manipulator' if 'name' identifies
    // an attribute of this class, and -1 otherwise.

    bsl::vector<RouteResponseResult>& responses();
    // Return a reference to the modifiable "Responses" attribute of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    template <typename t_ACCESSOR>
    int accessAttributes(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' sequentially on each
    // (non-modifiable) attribute of this object, supplying 'accessor'
    // with the corresponding attribute information structure until such
    // invocation returns a non-zero value.  Return the value from the
    // last invocation of 'accessor' (i.e., the invocation that terminated
    // the sequence).

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor, int id) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'id', supplying 'accessor'
    // with the corresponding attribute information structure.  Return the
    // value returned from the invocation of 'accessor' if 'id' identifies
    // an attribute of this class, and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessAttribute(t_ACCESSOR& accessor,
                        const char* name,
                        int         nameLength) const;
    // Invoke the specified 'accessor' on the (non-modifiable) attribute
    // of this object indicated by the specified 'name' of the specified
    // 'nameLength', supplying 'accessor' with the corresponding attribute
    // information structure.  Return the value returned from the
    // invocation of 'accessor' if 'name' identifies an attribute of this
    // class, and -1 otherwise.

    const bsl::vector<RouteResponseResult>& responses() const;
    // Return a reference offering non-modifiable access to the "Responses"
    // attribute of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const RouteResponseResultList& lhs,
                           const RouteResponseResultList& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' attribute objects
    // have the same value, and 'false' otherwise.  Two attribute objects
    // have the same value if each respective attribute has the same value.
    {
        return lhs.responses() == rhs.responses();
    }

    friend bool operator!=(const RouteResponseResultList& lhs,
                           const RouteResponseResultList& rhs)
    // Returns '!(lhs == rhs)'
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&                  stream,
                                    const RouteResponseResultList& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&              hashAlg,
                           const RouteResponseResultList& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'RouteResponseResultList'.
    {
        using bslh::hashAppend;
        hashAppend(hashAlg, object.responses());
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_SEQUENCE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(
    mqbcmd::RouteResponseResultList)

namespace mqbcmd {

// ====================
// class InternalResult
// ====================

class InternalResult {
    // The type represents a command execution result with all intermediate
    // structures created after each command dispatch.

    // INSTANCE DATA
    union {
        bsls::ObjectBuffer<Error>                 d_error;
        bsls::ObjectBuffer<Void>                  d_success;
        bsls::ObjectBuffer<DomainsResult>         d_domainsResult;
        bsls::ObjectBuffer<ClustersResult>        d_clustersResult;
        bsls::ObjectBuffer<Help>                  d_help;
        bsls::ObjectBuffer<QueueInternals>        d_queueInternals;
        bsls::ObjectBuffer<StatResult>            d_statResult;
        bsls::ObjectBuffer<ClusterList>           d_clusterList;
        bsls::ObjectBuffer<ClusterQueueHelper>    d_clusterQueueHelper;
        bsls::ObjectBuffer<ClusterStorageSummary> d_clusterStorageSummary;
        bsls::ObjectBuffer<ClusterDomainQueueStatuses>
                                         d_clusterDomainQueueStatuses;
        bsls::ObjectBuffer<BrokerConfig> d_brokerConfig;
    };

    int               d_selectionId;
    bslma::Allocator* d_allocator_p;

    // PRIVATE ACCESSORS
    template <typename t_HASH_ALGORITHM>
    void hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const;

    bool isEqualTo(const InternalResult& rhs) const;

  public:
    // TYPES

    enum {
        SELECTION_ID_UNDEFINED                     = -1,
        SELECTION_ID_ERROR                         = 0,
        SELECTION_ID_SUCCESS                       = 1,
        SELECTION_ID_DOMAINS_RESULT                = 2,
        SELECTION_ID_CLUSTERS_RESULT               = 3,
        SELECTION_ID_HELP                          = 4,
        SELECTION_ID_QUEUE_INTERNALS               = 5,
        SELECTION_ID_STAT_RESULT                   = 6,
        SELECTION_ID_CLUSTER_LIST                  = 7,
        SELECTION_ID_CLUSTER_QUEUE_HELPER          = 8,
        SELECTION_ID_CLUSTER_STORAGE_SUMMARY       = 9,
        SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES = 10,
        SELECTION_ID_BROKER_CONFIG                 = 11
    };

    enum { NUM_SELECTIONS = 12 };

    enum {
        SELECTION_INDEX_ERROR                         = 0,
        SELECTION_INDEX_SUCCESS                       = 1,
        SELECTION_INDEX_DOMAINS_RESULT                = 2,
        SELECTION_INDEX_CLUSTERS_RESULT               = 3,
        SELECTION_INDEX_HELP                          = 4,
        SELECTION_INDEX_QUEUE_INTERNALS               = 5,
        SELECTION_INDEX_STAT_RESULT                   = 6,
        SELECTION_INDEX_CLUSTER_LIST                  = 7,
        SELECTION_INDEX_CLUSTER_QUEUE_HELPER          = 8,
        SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY       = 9,
        SELECTION_INDEX_CLUSTER_DOMAIN_QUEUE_STATUSES = 10,
        SELECTION_INDEX_BROKER_CONFIG                 = 11
    };

    // CONSTANTS
    static const char CLASS_NAME[];

    static const bdlat_SelectionInfo SELECTION_INFO_ARRAY[];

    // CLASS METHODS
    static const bdlat_SelectionInfo* lookupSelectionInfo(int id);
    // Return selection information for the selection indicated by the
    // specified 'id' if the selection exists, and 0 otherwise.

    static const bdlat_SelectionInfo* lookupSelectionInfo(const char* name,
                                                          int nameLength);
    // Return selection information for the selection indicated by the
    // specified 'name' of the specified 'nameLength' if the selection
    // exists, and 0 otherwise.

    // CREATORS
    explicit InternalResult(bslma::Allocator* basicAllocator = 0);
    // Create an object of type 'InternalResult' having the default value.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.

    InternalResult(const InternalResult& original,
                   bslma::Allocator*     basicAllocator = 0);
    // Create an object of type 'InternalResult' having the value of the
    // specified 'original' object.  Use the optionally specified
    // 'basicAllocator' to supply memory.  If 'basicAllocator' is 0, the
    // currently installed default allocator is used.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    InternalResult(InternalResult&& original) noexcept;
    // Create an object of type 'InternalResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.

    InternalResult(InternalResult&&  original,
                   bslma::Allocator* basicAllocator);
    // Create an object of type 'InternalResult' having the value of the
    // specified 'original' object.  After performing this action, the
    // 'original' object will be left in a valid, but unspecified state.
    // Use the optionally specified 'basicAllocator' to supply memory.  If
    // 'basicAllocator' is 0, the currently installed default allocator is
    // used.
#endif

    ~InternalResult();
    // Destroy this object.

    // MANIPULATORS
    InternalResult& operator=(const InternalResult& rhs);
    // Assign to this object the value of the specified 'rhs' object.

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    InternalResult& operator=(InternalResult&& rhs);
    // Assign to this object the value of the specified 'rhs' object.
    // After performing this action, the 'rhs' object will be left in a
    // valid, but unspecified state.
#endif

    void reset();
    // Reset this object to the default value (i.e., its value upon default
    // construction).

    int makeSelection(int selectionId);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'selectionId'.  Return 0 on success, and
    // non-zero value otherwise (i.e., the selection is not found).

    int makeSelection(const char* name, int nameLength);
    // Set the value of this object to be the default for the selection
    // indicated by the specified 'name' of the specified 'nameLength'.
    // Return 0 on success, and non-zero value otherwise (i.e., the
    // selection is not found).

    Error& makeError();
    Error& makeError(const Error& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Error& makeError(Error&& value);
#endif
    // Set the value of this object to be a "Error" value.  Optionally
    // specify the 'value' of the "Error".  If 'value' is not specified,
    // the default "Error" value is used.

    Void& makeSuccess();
    Void& makeSuccess(const Void& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Void& makeSuccess(Void&& value);
#endif
    // Set the value of this object to be a "Success" value.  Optionally
    // specify the 'value' of the "Success".  If 'value' is not specified,
    // the default "Success" value is used.

    DomainsResult& makeDomainsResult();
    DomainsResult& makeDomainsResult(const DomainsResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    DomainsResult& makeDomainsResult(DomainsResult&& value);
#endif
    // Set the value of this object to be a "DomainsResult" value.
    // Optionally specify the 'value' of the "DomainsResult".  If 'value'
    // is not specified, the default "DomainsResult" value is used.

    ClustersResult& makeClustersResult();
    ClustersResult& makeClustersResult(const ClustersResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClustersResult& makeClustersResult(ClustersResult&& value);
#endif
    // Set the value of this object to be a "ClustersResult" value.
    // Optionally specify the 'value' of the "ClustersResult".  If 'value'
    // is not specified, the default "ClustersResult" value is used.

    Help& makeHelp();
    Help& makeHelp(const Help& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    Help& makeHelp(Help&& value);
#endif
    // Set the value of this object to be a "Help" value.  Optionally
    // specify the 'value' of the "Help".  If 'value' is not specified, the
    // default "Help" value is used.

    QueueInternals& makeQueueInternals();
    QueueInternals& makeQueueInternals(const QueueInternals& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    QueueInternals& makeQueueInternals(QueueInternals&& value);
#endif
    // Set the value of this object to be a "QueueInternals" value.
    // Optionally specify the 'value' of the "QueueInternals".  If 'value'
    // is not specified, the default "QueueInternals" value is used.

    StatResult& makeStatResult();
    StatResult& makeStatResult(const StatResult& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    StatResult& makeStatResult(StatResult&& value);
#endif
    // Set the value of this object to be a "StatResult" value.  Optionally
    // specify the 'value' of the "StatResult".  If 'value' is not
    // specified, the default "StatResult" value is used.

    ClusterList& makeClusterList();
    ClusterList& makeClusterList(const ClusterList& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterList& makeClusterList(ClusterList&& value);
#endif
    // Set the value of this object to be a "ClusterList" value.
    // Optionally specify the 'value' of the "ClusterList".  If 'value' is
    // not specified, the default "ClusterList" value is used.

    ClusterQueueHelper& makeClusterQueueHelper();
    ClusterQueueHelper&
    makeClusterQueueHelper(const ClusterQueueHelper& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterQueueHelper& makeClusterQueueHelper(ClusterQueueHelper&& value);
#endif
    // Set the value of this object to be a "ClusterQueueHelper" value.
    // Optionally specify the 'value' of the "ClusterQueueHelper".  If
    // 'value' is not specified, the default "ClusterQueueHelper" value is
    // used.

    ClusterStorageSummary& makeClusterStorageSummary();
    ClusterStorageSummary&
    makeClusterStorageSummary(const ClusterStorageSummary& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterStorageSummary&
    makeClusterStorageSummary(ClusterStorageSummary&& value);
#endif
    // Set the value of this object to be a "ClusterStorageSummary" value.
    // Optionally specify the 'value' of the "ClusterStorageSummary".  If
    // 'value' is not specified, the default "ClusterStorageSummary" value
    // is used.

    ClusterDomainQueueStatuses& makeClusterDomainQueueStatuses();
    ClusterDomainQueueStatuses&
    makeClusterDomainQueueStatuses(const ClusterDomainQueueStatuses& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    ClusterDomainQueueStatuses&
    makeClusterDomainQueueStatuses(ClusterDomainQueueStatuses&& value);
#endif
    // Set the value of this object to be a "ClusterDomainQueueStatuses"
    // value.  Optionally specify the 'value' of the
    // "ClusterDomainQueueStatuses".  If 'value' is not specified, the
    // default "ClusterDomainQueueStatuses" value is used.

    BrokerConfig& makeBrokerConfig();
    BrokerConfig& makeBrokerConfig(const BrokerConfig& value);
#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES) &&               \
    defined(BSLS_COMPILERFEATURES_SUPPORT_NOEXCEPT)
    BrokerConfig& makeBrokerConfig(BrokerConfig&& value);
#endif
    // Set the value of this object to be a "BrokerConfig" value.
    // Optionally specify the 'value' of the "BrokerConfig".  If 'value' is
    // not specified, the default "BrokerConfig" value is used.

    template <typename t_MANIPULATOR>
    int manipulateSelection(t_MANIPULATOR& manipulator);
    // Invoke the specified 'manipulator' on the address of the modifiable
    // selection, supplying 'manipulator' with the corresponding selection
    // information structure.  Return the value returned from the
    // invocation of 'manipulator' if this object has a defined selection,
    // and -1 otherwise.

    Error& error();
    // Return a reference to the modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    Void& success();
    // Return a reference to the modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    DomainsResult& domainsResult();
    // Return a reference to the modifiable "DomainsResult" selection of
    // this object if "DomainsResult" is the current selection.  The
    // behavior is undefined unless "DomainsResult" is the selection of
    // this object.

    ClustersResult& clustersResult();
    // Return a reference to the modifiable "ClustersResult" selection of
    // this object if "ClustersResult" is the current selection.  The
    // behavior is undefined unless "ClustersResult" is the selection of
    // this object.

    Help& help();
    // Return a reference to the modifiable "Help" selection of this object
    // if "Help" is the current selection.  The behavior is undefined
    // unless "Help" is the selection of this object.

    QueueInternals& queueInternals();
    // Return a reference to the modifiable "QueueInternals" selection of
    // this object if "QueueInternals" is the current selection.  The
    // behavior is undefined unless "QueueInternals" is the selection of
    // this object.

    StatResult& statResult();
    // Return a reference to the modifiable "StatResult" selection of this
    // object if "StatResult" is the current selection.  The behavior is
    // undefined unless "StatResult" is the selection of this object.

    ClusterList& clusterList();
    // Return a reference to the modifiable "ClusterList" selection of this
    // object if "ClusterList" is the current selection.  The behavior is
    // undefined unless "ClusterList" is the selection of this object.

    ClusterQueueHelper& clusterQueueHelper();
    // Return a reference to the modifiable "ClusterQueueHelper" selection
    // of this object if "ClusterQueueHelper" is the current selection.
    // The behavior is undefined unless "ClusterQueueHelper" is the
    // selection of this object.

    ClusterStorageSummary& clusterStorageSummary();
    // Return a reference to the modifiable "ClusterStorageSummary"
    // selection of this object if "ClusterStorageSummary" is the current
    // selection.  The behavior is undefined unless "ClusterStorageSummary"
    // is the selection of this object.

    ClusterDomainQueueStatuses& clusterDomainQueueStatuses();
    // Return a reference to the modifiable "ClusterDomainQueueStatuses"
    // selection of this object if "ClusterDomainQueueStatuses" is the
    // current selection.  The behavior is undefined unless
    // "ClusterDomainQueueStatuses" is the selection of this object.

    BrokerConfig& brokerConfig();
    // Return a reference to the modifiable "BrokerConfig" selection of
    // this object if "BrokerConfig" is the current selection.  The
    // behavior is undefined unless "BrokerConfig" is the selection of this
    // object.

    // ACCESSORS
    bsl::ostream&
    print(bsl::ostream& stream, int level = 0, int spacesPerLevel = 4) const;
    // Format this object to the specified output 'stream' at the
    // optionally specified indentation 'level' and return a reference to
    // the modifiable 'stream'.  If 'level' is specified, optionally
    // specify 'spacesPerLevel', the number of spaces per indentation level
    // for this and all of its nested objects.  Each line is indented by
    // the absolute value of 'level * spacesPerLevel'.  If 'level' is
    // negative, suppress indentation of the first line.  If
    // 'spacesPerLevel' is negative, suppress line breaks and format the
    // entire output on one line.  If 'stream' is initially invalid, this
    // operation has no effect.  Note that a trailing newline is provided
    // in multiline mode only.

    int selectionId() const;
    // Return the id of the current selection if the selection is defined,
    // and -1 otherwise.

    template <typename t_ACCESSOR>
    int accessSelection(t_ACCESSOR& accessor) const;
    // Invoke the specified 'accessor' on the non-modifiable selection,
    // supplying 'accessor' with the corresponding selection information
    // structure.  Return the value returned from the invocation of
    // 'accessor' if this object has a defined selection, and -1 otherwise.

    const Error& error() const;
    // Return a reference to the non-modifiable "Error" selection of this
    // object if "Error" is the current selection.  The behavior is
    // undefined unless "Error" is the selection of this object.

    const Void& success() const;
    // Return a reference to the non-modifiable "Success" selection of this
    // object if "Success" is the current selection.  The behavior is
    // undefined unless "Success" is the selection of this object.

    const DomainsResult& domainsResult() const;
    // Return a reference to the non-modifiable "DomainsResult" selection
    // of this object if "DomainsResult" is the current selection.  The
    // behavior is undefined unless "DomainsResult" is the selection of
    // this object.

    const ClustersResult& clustersResult() const;
    // Return a reference to the non-modifiable "ClustersResult" selection
    // of this object if "ClustersResult" is the current selection.  The
    // behavior is undefined unless "ClustersResult" is the selection of
    // this object.

    const Help& help() const;
    // Return a reference to the non-modifiable "Help" selection of this
    // object if "Help" is the current selection.  The behavior is
    // undefined unless "Help" is the selection of this object.

    const QueueInternals& queueInternals() const;
    // Return a reference to the non-modifiable "QueueInternals" selection
    // of this object if "QueueInternals" is the current selection.  The
    // behavior is undefined unless "QueueInternals" is the selection of
    // this object.

    const StatResult& statResult() const;
    // Return a reference to the non-modifiable "StatResult" selection of
    // this object if "StatResult" is the current selection.  The behavior
    // is undefined unless "StatResult" is the selection of this object.

    const ClusterList& clusterList() const;
    // Return a reference to the non-modifiable "ClusterList" selection of
    // this object if "ClusterList" is the current selection.  The behavior
    // is undefined unless "ClusterList" is the selection of this object.

    const ClusterQueueHelper& clusterQueueHelper() const;
    // Return a reference to the non-modifiable "ClusterQueueHelper"
    // selection of this object if "ClusterQueueHelper" is the current
    // selection.  The behavior is undefined unless "ClusterQueueHelper" is
    // the selection of this object.

    const ClusterStorageSummary& clusterStorageSummary() const;
    // Return a reference to the non-modifiable "ClusterStorageSummary"
    // selection of this object if "ClusterStorageSummary" is the current
    // selection.  The behavior is undefined unless "ClusterStorageSummary"
    // is the selection of this object.

    const ClusterDomainQueueStatuses& clusterDomainQueueStatuses() const;
    // Return a reference to the non-modifiable
    // "ClusterDomainQueueStatuses" selection of this object if
    // "ClusterDomainQueueStatuses" is the current selection.  The behavior
    // is undefined unless "ClusterDomainQueueStatuses" is the selection of
    // this object.

    const BrokerConfig& brokerConfig() const;
    // Return a reference to the non-modifiable "BrokerConfig" selection of
    // this object if "BrokerConfig" is the current selection.  The
    // behavior is undefined unless "BrokerConfig" is the selection of this
    // object.

    bool isErrorValue() const;
    // Return 'true' if the value of this object is a "Error" value, and
    // return 'false' otherwise.

    bool isSuccessValue() const;
    // Return 'true' if the value of this object is a "Success" value, and
    // return 'false' otherwise.

    bool isDomainsResultValue() const;
    // Return 'true' if the value of this object is a "DomainsResult"
    // value, and return 'false' otherwise.

    bool isClustersResultValue() const;
    // Return 'true' if the value of this object is a "ClustersResult"
    // value, and return 'false' otherwise.

    bool isHelpValue() const;
    // Return 'true' if the value of this object is a "Help" value, and
    // return 'false' otherwise.

    bool isQueueInternalsValue() const;
    // Return 'true' if the value of this object is a "QueueInternals"
    // value, and return 'false' otherwise.

    bool isStatResultValue() const;
    // Return 'true' if the value of this object is a "StatResult" value,
    // and return 'false' otherwise.

    bool isClusterListValue() const;
    // Return 'true' if the value of this object is a "ClusterList" value,
    // and return 'false' otherwise.

    bool isClusterQueueHelperValue() const;
    // Return 'true' if the value of this object is a "ClusterQueueHelper"
    // value, and return 'false' otherwise.

    bool isClusterStorageSummaryValue() const;
    // Return 'true' if the value of this object is a
    // "ClusterStorageSummary" value, and return 'false' otherwise.

    bool isClusterDomainQueueStatusesValue() const;
    // Return 'true' if the value of this object is a
    // "ClusterDomainQueueStatuses" value, and return 'false' otherwise.

    bool isBrokerConfigValue() const;
    // Return 'true' if the value of this object is a "BrokerConfig" value,
    // and return 'false' otherwise.

    bool isUndefinedValue() const;
    // Return 'true' if the value of this object is undefined, and 'false'
    // otherwise.

    const char* selectionName() const;
    // Return the symbolic name of the current selection of this object.

    // HIDDEN FRIENDS
    friend bool operator==(const InternalResult& lhs,
                           const InternalResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects have the same
    // value, and 'false' otherwise.  Two 'InternalResult' objects have the
    // same value if either the selections in both objects have the same
    // ids and the same values, or both selections are undefined.
    {
        return lhs.isEqualTo(rhs);
    }

    friend bool operator!=(const InternalResult& lhs,
                           const InternalResult& rhs)
    // Return 'true' if the specified 'lhs' and 'rhs' objects do not have
    // the same values, as determined by 'operator==', and 'false'
    // otherwise.
    {
        return !(lhs == rhs);
    }

    friend bsl::ostream& operator<<(bsl::ostream&         stream,
                                    const InternalResult& rhs)
    // Format the specified 'rhs' to the specified output 'stream' and
    // return a reference to the modifiable 'stream'.
    {
        return rhs.print(stream, 0, -1);
    }

    template <typename t_HASH_ALGORITHM>
    friend void hashAppend(t_HASH_ALGORITHM&     hashAlg,
                           const InternalResult& object)
    // Pass the specified 'object' to the specified 'hashAlg'.  This
    // function integrates with the 'bslh' modular hashing system and
    // effectively provides a 'bsl::hash' specialization for
    // 'InternalResult'.
    {
        return object.hashAppendImpl(hashAlg);
    }
};

}  // close package namespace

// TRAITS

BDLAT_DECL_CHOICE_WITH_ALLOCATOR_BITWISEMOVEABLE_TRAITS(mqbcmd::InternalResult)

//=============================================================================
//                          INLINE DEFINITIONS
//=============================================================================

namespace mqbcmd {

// ---------------------
// class AddReverseProxy
// ---------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int AddReverseProxy::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_remotePeer,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOTE_PEER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int AddReverseProxy::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_REMOTE_PEER: {
        return manipulator(&d_remotePeer,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOTE_PEER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int AddReverseProxy::manipulateAttribute(t_MANIPULATOR& manipulator,
                                         const char*    name,
                                         int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& AddReverseProxy::clusterName()
{
    return d_clusterName;
}

inline bsl::string& AddReverseProxy::remotePeer()
{
    return d_remotePeer;
}

// ACCESSORS
template <typename t_ACCESSOR>
int AddReverseProxy::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_remotePeer,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOTE_PEER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int AddReverseProxy::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_REMOTE_PEER: {
        return accessor(d_remotePeer,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REMOTE_PEER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int AddReverseProxy::accessAttribute(t_ACCESSOR& accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& AddReverseProxy::clusterName() const
{
    return d_clusterName;
}

inline const bsl::string& AddReverseProxy::remotePeer() const
{
    return d_remotePeer;
}

// ------------------
// class BrokerConfig
// ------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int BrokerConfig::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_asJSON,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_AS_J_S_O_N]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int BrokerConfig::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_AS_J_S_O_N: {
        return manipulator(&d_asJSON,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_AS_J_S_O_N]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int BrokerConfig::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& BrokerConfig::asJSON()
{
    return d_asJSON;
}

// ACCESSORS
template <typename t_ACCESSOR>
int BrokerConfig::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_asJSON, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_AS_J_S_O_N]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int BrokerConfig::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_AS_J_S_O_N: {
        return accessor(d_asJSON,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_AS_J_S_O_N]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int BrokerConfig::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& BrokerConfig::asJSON() const
{
    return d_asJSON;
}

// -------------------
// class CapacityMeter
// -------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void CapacityMeter::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->name());
    hashAppend(hashAlgorithm, this->isDisabled());
    hashAppend(hashAlgorithm, this->numMessages());
    hashAppend(hashAlgorithm, this->messageCapacity());
    hashAppend(hashAlgorithm, this->numMessagesReserved());
    hashAppend(hashAlgorithm, this->numBytes());
    hashAppend(hashAlgorithm, this->byteCapacity());
    hashAppend(hashAlgorithm, this->numBytesReserved());
    hashAppend(hashAlgorithm, this->parent());
}

inline bool CapacityMeter::isEqualTo(const CapacityMeter& rhs) const
{
    return this->name() == rhs.name() &&
           this->isDisabled() == rhs.isDisabled() &&
           this->numMessages() == rhs.numMessages() &&
           this->messageCapacity() == rhs.messageCapacity() &&
           this->numMessagesReserved() == rhs.numMessagesReserved() &&
           this->numBytes() == rhs.numBytes() &&
           this->byteCapacity() == rhs.byteCapacity() &&
           this->numBytesReserved() == rhs.numBytesReserved() &&
           this->parent() == rhs.parent();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int CapacityMeter::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isDisabled,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DISABLED]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numMessages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_messageCapacity,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE_CAPACITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numMessagesReserved,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES_RESERVED]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numBytes,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_byteCapacity,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTE_CAPACITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numBytesReserved,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES_RESERVED]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_parent, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARENT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int CapacityMeter::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_IS_DISABLED: {
        return manipulator(&d_isDisabled,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DISABLED]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return manipulator(&d_numMessages,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    case ATTRIBUTE_ID_MESSAGE_CAPACITY: {
        return manipulator(
            &d_messageCapacity,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE_CAPACITY]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES_RESERVED: {
        return manipulator(
            &d_numMessagesReserved,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES_RESERVED]);
    }
    case ATTRIBUTE_ID_NUM_BYTES: {
        return manipulator(&d_numBytes,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    }
    case ATTRIBUTE_ID_BYTE_CAPACITY: {
        return manipulator(
            &d_byteCapacity,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTE_CAPACITY]);
    }
    case ATTRIBUTE_ID_NUM_BYTES_RESERVED: {
        return manipulator(
            &d_numBytesReserved,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES_RESERVED]);
    }
    case ATTRIBUTE_ID_PARENT: {
        return manipulator(&d_parent,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARENT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int CapacityMeter::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& CapacityMeter::name()
{
    return d_name;
}

inline bool& CapacityMeter::isDisabled()
{
    return d_isDisabled;
}

inline bsls::Types::Int64& CapacityMeter::numMessages()
{
    return d_numMessages;
}

inline bsls::Types::Int64& CapacityMeter::messageCapacity()
{
    return d_messageCapacity;
}

inline bsls::Types::Int64& CapacityMeter::numMessagesReserved()
{
    return d_numMessagesReserved;
}

inline bsls::Types::Int64& CapacityMeter::numBytes()
{
    return d_numBytes;
}

inline bsls::Types::Int64& CapacityMeter::byteCapacity()
{
    return d_byteCapacity;
}

inline bsls::Types::Int64& CapacityMeter::numBytesReserved()
{
    return d_numBytesReserved;
}

inline bdlb::NullableAllocatedValue<CapacityMeter>& CapacityMeter::parent()
{
    return d_parent;
}

// ACCESSORS
template <typename t_ACCESSOR>
int CapacityMeter::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isDisabled,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DISABLED]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numMessages,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_messageCapacity,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE_CAPACITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_numMessagesReserved,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES_RESERVED]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_byteCapacity,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTE_CAPACITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numBytesReserved,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES_RESERVED]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_parent, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARENT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int CapacityMeter::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_IS_DISABLED: {
        return accessor(d_isDisabled,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_DISABLED]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return accessor(d_numMessages,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    case ATTRIBUTE_ID_MESSAGE_CAPACITY: {
        return accessor(
            d_messageCapacity,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE_CAPACITY]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES_RESERVED: {
        return accessor(
            d_numMessagesReserved,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES_RESERVED]);
    }
    case ATTRIBUTE_ID_NUM_BYTES: {
        return accessor(d_numBytes,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    }
    case ATTRIBUTE_ID_BYTE_CAPACITY: {
        return accessor(d_byteCapacity,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTE_CAPACITY]);
    }
    case ATTRIBUTE_ID_NUM_BYTES_RESERVED: {
        return accessor(
            d_numBytesReserved,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES_RESERVED]);
    }
    case ATTRIBUTE_ID_PARENT: {
        return accessor(d_parent,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARENT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int CapacityMeter::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& CapacityMeter::name() const
{
    return d_name;
}

inline bool CapacityMeter::isDisabled() const
{
    return d_isDisabled;
}

inline bsls::Types::Int64 CapacityMeter::numMessages() const
{
    return d_numMessages;
}

inline bsls::Types::Int64 CapacityMeter::messageCapacity() const
{
    return d_messageCapacity;
}

inline bsls::Types::Int64 CapacityMeter::numMessagesReserved() const
{
    return d_numMessagesReserved;
}

inline bsls::Types::Int64 CapacityMeter::numBytes() const
{
    return d_numBytes;
}

inline bsls::Types::Int64 CapacityMeter::byteCapacity() const
{
    return d_byteCapacity;
}

inline bsls::Types::Int64 CapacityMeter::numBytesReserved() const
{
    return d_numBytesReserved;
}

inline const bdlb::NullableAllocatedValue<CapacityMeter>&
CapacityMeter::parent() const
{
    return d_parent;
}

// --------------------------
// class ClientMsgGroupsCount
// --------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClientMsgGroupsCount::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_clientDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numMsgGroupIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MSG_GROUP_IDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClientMsgGroupsCount::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_DESCRIPTION: {
        return manipulator(
            &d_clientDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_NUM_MSG_GROUP_IDS: {
        return manipulator(
            &d_numMsgGroupIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MSG_GROUP_IDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClientMsgGroupsCount::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClientMsgGroupsCount::clientDescription()
{
    return d_clientDescription;
}

inline unsigned int& ClientMsgGroupsCount::numMsgGroupIds()
{
    return d_numMsgGroupIds;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClientMsgGroupsCount::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clientDescription,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numMsgGroupIds,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MSG_GROUP_IDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClientMsgGroupsCount::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_DESCRIPTION: {
        return accessor(
            d_clientDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_NUM_MSG_GROUP_IDS: {
        return accessor(
            d_numMsgGroupIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MSG_GROUP_IDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClientMsgGroupsCount::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ClientMsgGroupsCount::clientDescription() const
{
    return d_clientDescription;
}

inline unsigned int ClientMsgGroupsCount::numMsgGroupIds() const
{
    return d_numMsgGroupIds;
}

// -------------------
// class ClusterDomain
// -------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterDomain::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->name());
    hashAppend(hashAlgorithm, this->numAssignedQueues());
    hashAppend(hashAlgorithm, this->loaded());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterDomain::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numAssignedQueues,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_ASSIGNED_QUEUES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_loaded, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOADED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterDomain::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_NUM_ASSIGNED_QUEUES: {
        return manipulator(
            &d_numAssignedQueues,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_ASSIGNED_QUEUES]);
    }
    case ATTRIBUTE_ID_LOADED: {
        return manipulator(&d_loaded,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOADED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterDomain::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClusterDomain::name()
{
    return d_name;
}

inline unsigned int& ClusterDomain::numAssignedQueues()
{
    return d_numAssignedQueues;
}

inline bool& ClusterDomain::loaded()
{
    return d_loaded;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterDomain::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numAssignedQueues,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_ASSIGNED_QUEUES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_loaded, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOADED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterDomain::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_NUM_ASSIGNED_QUEUES: {
        return accessor(
            d_numAssignedQueues,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_ASSIGNED_QUEUES]);
    }
    case ATTRIBUTE_ID_LOADED: {
        return accessor(d_loaded,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOADED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterDomain::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ClusterDomain::name() const
{
    return d_name;
}

inline unsigned int ClusterDomain::numAssignedQueues() const
{
    return d_numAssignedQueues;
}

inline bool ClusterDomain::loaded() const
{
    return d_loaded;
}

// -----------------
// class ClusterNode
// -----------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterNode::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->hostName());
    hashAppend(hashAlgorithm, this->nodeId());
    hashAppend(hashAlgorithm, this->dataCenter());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterNode::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_hostName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_nodeId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_dataCenter,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_CENTER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterNode::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HOST_NAME: {
        return manipulator(&d_hostName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    }
    case ATTRIBUTE_ID_NODE_ID: {
        return manipulator(&d_nodeId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_ID]);
    }
    case ATTRIBUTE_ID_DATA_CENTER: {
        return manipulator(&d_dataCenter,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_CENTER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterNode::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClusterNode::hostName()
{
    return d_hostName;
}

inline int& ClusterNode::nodeId()
{
    return d_nodeId;
}

inline bsl::string& ClusterNode::dataCenter()
{
    return d_dataCenter;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterNode::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_hostName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_nodeId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_dataCenter,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_CENTER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterNode::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_HOST_NAME: {
        return accessor(d_hostName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HOST_NAME]);
    }
    case ATTRIBUTE_ID_NODE_ID: {
        return accessor(d_nodeId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_ID]);
    }
    case ATTRIBUTE_ID_DATA_CENTER: {
        return accessor(d_dataCenter,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_CENTER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterNode::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ClusterNode::hostName() const
{
    return d_hostName;
}

inline int ClusterNode::nodeId() const
{
    return d_nodeId;
}

inline const bsl::string& ClusterNode::dataCenter() const
{
    return d_dataCenter;
}

// -----------------
// class CommandSpec
// -----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int CommandSpec::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_description,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int CommandSpec::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    case ATTRIBUTE_ID_DESCRIPTION: {
        return manipulator(&d_description,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int CommandSpec::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& CommandSpec::command()
{
    return d_command;
}

inline bsl::string& CommandSpec::description()
{
    return d_description;
}

// ACCESSORS
template <typename t_ACCESSOR>
int CommandSpec::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_description,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int CommandSpec::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    case ATTRIBUTE_ID_DESCRIPTION: {
        return accessor(d_description,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int CommandSpec::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& CommandSpec::command() const
{
    return d_command;
}

inline const bsl::string& CommandSpec::description() const
{
    return d_description;
}

// ------------------
// class ConsumerInfo
// ------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ConsumerInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->maxUnconfirmedMessages());
    hashAppend(hashAlgorithm, this->maxUnconfirmedBytes());
    hashAppend(hashAlgorithm, this->consumerPriority());
    hashAppend(hashAlgorithm, this->consumerPriorityCount());
}

inline bool ConsumerInfo::isEqualTo(const ConsumerInfo& rhs) const
{
    return this->maxUnconfirmedMessages() == rhs.maxUnconfirmedMessages() &&
           this->maxUnconfirmedBytes() == rhs.maxUnconfirmedBytes() &&
           this->consumerPriority() == rhs.consumerPriority() &&
           this->consumerPriorityCount() == rhs.consumerPriorityCount();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ConsumerInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumerPriority,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ConsumerInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return manipulator(
            &d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return manipulator(
            &d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return manipulator(
            &d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return manipulator(
            &d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ConsumerInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Int64& ConsumerInfo::maxUnconfirmedMessages()
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64& ConsumerInfo::maxUnconfirmedBytes()
{
    return d_maxUnconfirmedBytes;
}

inline int& ConsumerInfo::consumerPriority()
{
    return d_consumerPriority;
}

inline int& ConsumerInfo::consumerPriorityCount()
{
    return d_consumerPriorityCount;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ConsumerInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_maxUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_maxUnconfirmedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumerPriority,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_consumerPriorityCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ConsumerInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_MESSAGES: {
        return accessor(
            d_maxUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_MESSAGES]);
    }
    case ATTRIBUTE_ID_MAX_UNCONFIRMED_BYTES: {
        return accessor(
            d_maxUnconfirmedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_UNCONFIRMED_BYTES]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY: {
        return accessor(
            d_consumerPriority,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY]);
    }
    case ATTRIBUTE_ID_CONSUMER_PRIORITY_COUNT: {
        return accessor(
            d_consumerPriorityCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_PRIORITY_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ConsumerInfo::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Int64 ConsumerInfo::maxUnconfirmedMessages() const
{
    return d_maxUnconfirmedMessages;
}

inline bsls::Types::Int64 ConsumerInfo::maxUnconfirmedBytes() const
{
    return d_maxUnconfirmedBytes;
}

inline int ConsumerInfo::consumerPriority() const
{
    return d_consumerPriority;
}

inline int ConsumerInfo::consumerPriorityCount() const
{
    return d_consumerPriorityCount;
}

// --------------------
// class ConsumerStatus
// --------------------

// CLASS METHODS
inline int ConsumerStatus::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ConsumerStatus::print(bsl::ostream&         stream,
                                           ConsumerStatus::Value value)
{
    return stream << toString(value);
}

// -------------
// class Context
// -------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Context::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_queueHandleParametersJson,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_HANDLE_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Context::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_HANDLE_PARAMETERS_JSON: {
        return manipulator(&d_queueHandleParametersJson,
                           ATTRIBUTE_INFO_ARRAY
                               [ATTRIBUTE_INDEX_QUEUE_HANDLE_PARAMETERS_JSON]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Context::manipulateAttribute(t_MANIPULATOR& manipulator,
                                 const char*    name,
                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& Context::queueHandleParametersJson()
{
    return d_queueHandleParametersJson;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Context::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_queueHandleParametersJson,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_HANDLE_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Context::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_HANDLE_PARAMETERS_JSON: {
        return accessor(d_queueHandleParametersJson,
                        ATTRIBUTE_INFO_ARRAY
                            [ATTRIBUTE_INDEX_QUEUE_HANDLE_PARAMETERS_JSON]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Context::accessAttribute(t_ACCESSOR& accessor,
                             const char* name,
                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& Context::queueHandleParametersJson() const
{
    return d_queueHandleParametersJson;
}

// -----------------------
// class DomainReconfigure
// -----------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DomainReconfigure::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef DomainReconfigure Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_DOMAIN:
        hashAppend(hashAlgorithm, this->domain());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool DomainReconfigure::isEqualTo(const DomainReconfigure& rhs) const
{
    typedef DomainReconfigure Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_DOMAIN: return this->domain() == rhs.domain();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline DomainReconfigure::DomainReconfigure(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline DomainReconfigure::~DomainReconfigure()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int DomainReconfigure::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case DomainReconfigure::SELECTION_ID_DOMAIN:
        return manipulator(&d_domain.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN]);
    default:
        BSLS_ASSERT(DomainReconfigure::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline bsl::string& DomainReconfigure::domain()
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN == d_selectionId);
    return d_domain.object();
}

// ACCESSORS
inline int DomainReconfigure::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int DomainReconfigure::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_DOMAIN:
        return accessor(d_domain.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const bsl::string& DomainReconfigure::domain() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN == d_selectionId);
    return d_domain.object();
}

inline bool DomainReconfigure::isDomainValue() const
{
    return SELECTION_ID_DOMAIN == d_selectionId;
}

inline bool DomainReconfigure::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ------------------
// class ElectorState
// ------------------

// CLASS METHODS
inline int ElectorState::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& ElectorState::print(bsl::ostream&       stream,
                                         ElectorState::Value value)
{
    return stream << toString(value);
}

// --------------------
// class EncodingFormat
// --------------------

// CLASS METHODS
inline int EncodingFormat::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& EncodingFormat::print(bsl::ostream&         stream,
                                           EncodingFormat::Value value)
{
    return stream << toString(value);
}

// -----------
// class Error
// -----------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Error::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_message,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Error::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MESSAGE: {
        return manipulator(&d_message,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Error::manipulateAttribute(t_MANIPULATOR& manipulator,
                               const char*    name,
                               int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& Error::message()
{
    return d_message;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Error::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_message, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Error::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MESSAGE: {
        return accessor(d_message,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Error::accessAttribute(t_ACCESSOR& accessor,
                           const char* name,
                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& Error::message() const
{
    return d_message;
}

// --------------
// class FileInfo
// --------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void FileInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->positionBytes());
    hashAppend(hashAlgorithm, this->sizeBytes());
    hashAppend(hashAlgorithm, this->outstandingBytes());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FileInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_positionBytes,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_POSITION_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sizeBytes,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SIZE_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_outstandingBytes,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OUTSTANDING_BYTES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int FileInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_POSITION_BYTES: {
        return manipulator(
            &d_positionBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_POSITION_BYTES]);
    }
    case ATTRIBUTE_ID_SIZE_BYTES: {
        return manipulator(&d_sizeBytes,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SIZE_BYTES]);
    }
    case ATTRIBUTE_ID_OUTSTANDING_BYTES: {
        return manipulator(
            &d_outstandingBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OUTSTANDING_BYTES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FileInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                  const char*    name,
                                  int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Uint64& FileInfo::positionBytes()
{
    return d_positionBytes;
}

inline bsls::Types::Uint64& FileInfo::sizeBytes()
{
    return d_sizeBytes;
}

inline bsls::Types::Uint64& FileInfo::outstandingBytes()
{
    return d_outstandingBytes;
}

// ACCESSORS
template <typename t_ACCESSOR>
int FileInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_positionBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_POSITION_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sizeBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SIZE_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_outstandingBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OUTSTANDING_BYTES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int FileInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_POSITION_BYTES: {
        return accessor(d_positionBytes,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_POSITION_BYTES]);
    }
    case ATTRIBUTE_ID_SIZE_BYTES: {
        return accessor(d_sizeBytes,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SIZE_BYTES]);
    }
    case ATTRIBUTE_ID_OUTSTANDING_BYTES: {
        return accessor(
            d_outstandingBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OUTSTANDING_BYTES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FileInfo::accessAttribute(t_ACCESSOR& accessor,
                              const char* name,
                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Uint64 FileInfo::positionBytes() const
{
    return d_positionBytes;
}

inline bsls::Types::Uint64 FileInfo::sizeBytes() const
{
    return d_sizeBytes;
}

inline bsls::Types::Uint64 FileInfo::outstandingBytes() const
{
    return d_outstandingBytes;
}

// -------------
// class FileSet
// -------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FileSet::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_dataFileName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_aliasedBlobBufferCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ALIASED_BLOB_BUFFER_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int FileSet::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DATA_FILE_NAME: {
        return manipulator(
            &d_dataFileName,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_NAME]);
    }
    case ATTRIBUTE_ID_ALIASED_BLOB_BUFFER_COUNT: {
        return manipulator(
            &d_aliasedBlobBufferCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ALIASED_BLOB_BUFFER_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FileSet::manipulateAttribute(t_MANIPULATOR& manipulator,
                                 const char*    name,
                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& FileSet::dataFileName()
{
    return d_dataFileName;
}

inline bsls::Types::Uint64& FileSet::aliasedBlobBufferCount()
{
    return d_aliasedBlobBufferCount;
}

// ACCESSORS
template <typename t_ACCESSOR>
int FileSet::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_dataFileName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_aliasedBlobBufferCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ALIASED_BLOB_BUFFER_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int FileSet::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DATA_FILE_NAME: {
        return accessor(d_dataFileName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE_NAME]);
    }
    case ATTRIBUTE_ID_ALIASED_BLOB_BUFFER_COUNT: {
        return accessor(
            d_aliasedBlobBufferCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ALIASED_BLOB_BUFFER_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FileSet::accessAttribute(t_ACCESSOR& accessor,
                             const char* name,
                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& FileSet::dataFileName() const
{
    return d_dataFileName;
}

inline bsls::Types::Uint64 FileSet::aliasedBlobBufferCount() const
{
    return d_aliasedBlobBufferCount;
}

// --------------------
// class FileStoreState
// --------------------

// CLASS METHODS
inline int FileStoreState::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& FileStoreState::print(bsl::ostream&         stream,
                                           FileStoreState::Value value)
{
    return stream << toString(value);
}

// -----------------
// class HelpCommand
// -----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int HelpCommand::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_plumbing,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PLUMBING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int HelpCommand::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PLUMBING: {
        return manipulator(&d_plumbing,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PLUMBING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int HelpCommand::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bool& HelpCommand::plumbing()
{
    return d_plumbing;
}

// ACCESSORS
template <typename t_ACCESSOR>
int HelpCommand::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_plumbing, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PLUMBING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int HelpCommand::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PLUMBING: {
        return accessor(d_plumbing,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PLUMBING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int HelpCommand::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bool HelpCommand::plumbing() const
{
    return d_plumbing;
}

// ---------------------------
// class LeaderMessageSequence
// ---------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeaderMessageSequence::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_electorTerm,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNumber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LeaderMessageSequence::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ELECTOR_TERM: {
        return manipulator(&d_electorTerm,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return manipulator(
            &d_sequenceNumber,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeaderMessageSequence::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               const char*    name,
                                               int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Uint64& LeaderMessageSequence::electorTerm()
{
    return d_electorTerm;
}

inline bsls::Types::Uint64& LeaderMessageSequence::sequenceNumber()
{
    return d_sequenceNumber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeaderMessageSequence::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_electorTerm,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNumber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LeaderMessageSequence::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ELECTOR_TERM: {
        return accessor(d_electorTerm,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_TERM]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUMBER: {
        return accessor(d_sequenceNumber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUMBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeaderMessageSequence::accessAttribute(t_ACCESSOR& accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Uint64 LeaderMessageSequence::electorTerm() const
{
    return d_electorTerm;
}

inline bsls::Types::Uint64 LeaderMessageSequence::sequenceNumber() const
{
    return d_sequenceNumber;
}

// ------------------
// class LeaderStatus
// ------------------

// CLASS METHODS
inline int LeaderStatus::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& LeaderStatus::print(bsl::ostream&       stream,
                                         LeaderStatus::Value value)
{
    return stream << toString(value);
}

// ------------------------------
// class LeastRecentlyUsedGroupId
// ------------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void LeastRecentlyUsedGroupId::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->clientDescription());
    hashAppend(hashAlgorithm, this->msgGroupId());
    hashAppend(hashAlgorithm, this->lastSeenDeltaNanoseconds());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LeastRecentlyUsedGroupId::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_clientDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_msgGroupId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_GROUP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_lastSeenDeltaNanoseconds,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEEN_DELTA_NANOSECONDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LeastRecentlyUsedGroupId::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                  int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_DESCRIPTION: {
        return manipulator(
            &d_clientDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_MSG_GROUP_ID: {
        return manipulator(&d_msgGroupId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_GROUP_ID]);
    }
    case ATTRIBUTE_ID_LAST_SEEN_DELTA_NANOSECONDS: {
        return manipulator(
            &d_lastSeenDeltaNanoseconds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEEN_DELTA_NANOSECONDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LeastRecentlyUsedGroupId::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                  const char*    name,
                                                  int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& LeastRecentlyUsedGroupId::clientDescription()
{
    return d_clientDescription;
}

inline bsl::string& LeastRecentlyUsedGroupId::msgGroupId()
{
    return d_msgGroupId;
}

inline bsls::Types::Int64& LeastRecentlyUsedGroupId::lastSeenDeltaNanoseconds()
{
    return d_lastSeenDeltaNanoseconds;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LeastRecentlyUsedGroupId::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clientDescription,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_msgGroupId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_GROUP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_lastSeenDeltaNanoseconds,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEEN_DELTA_NANOSECONDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LeastRecentlyUsedGroupId::accessAttribute(t_ACCESSOR& accessor,
                                              int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_DESCRIPTION: {
        return accessor(
            d_clientDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_MSG_GROUP_ID: {
        return accessor(d_msgGroupId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MSG_GROUP_ID]);
    }
    case ATTRIBUTE_ID_LAST_SEEN_DELTA_NANOSECONDS: {
        return accessor(
            d_lastSeenDeltaNanoseconds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LAST_SEEN_DELTA_NANOSECONDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LeastRecentlyUsedGroupId::accessAttribute(t_ACCESSOR& accessor,
                                              const char* name,
                                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& LeastRecentlyUsedGroupId::clientDescription() const
{
    return d_clientDescription;
}

inline const bsl::string& LeastRecentlyUsedGroupId::msgGroupId() const
{
    return d_msgGroupId;
}

inline bsls::Types::Int64
LeastRecentlyUsedGroupId::lastSeenDeltaNanoseconds() const
{
    return d_lastSeenDeltaNanoseconds;
}

// ------------------
// class ListMessages
// ------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ListMessages::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->appId());
    hashAppend(hashAlgorithm, this->offset());
    hashAppend(hashAlgorithm, this->count());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ListMessages::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_offset, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_count, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ListMessages::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_OFFSET: {
        return manipulator(&d_offset,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    }
    case ATTRIBUTE_ID_COUNT: {
        return manipulator(&d_count,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ListMessages::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bdlb::NullableValue<bsl::string>& ListMessages::appId()
{
    return d_appId;
}

inline int& ListMessages::offset()
{
    return d_offset;
}

inline int& ListMessages::count()
{
    return d_count;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ListMessages::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_offset, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_count, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ListMessages::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_OFFSET: {
        return accessor(d_offset,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    }
    case ATTRIBUTE_ID_COUNT: {
        return accessor(d_count, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ListMessages::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bdlb::NullableValue<bsl::string>& ListMessages::appId() const
{
    return d_appId;
}

inline int ListMessages::offset() const
{
    return d_offset;
}

inline int ListMessages::count() const
{
    return d_count;
}

// --------------
// class Locality
// --------------

// CLASS METHODS
inline int Locality::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& Locality::print(bsl::ostream&   stream,
                                     Locality::Value value)
{
    return stream << toString(value);
}

// -------------
// class Message
// -------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void Message::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->guid());
    hashAppend(hashAlgorithm, this->sizeBytes());
    hashAppend(hashAlgorithm, this->arrivalTimestamp());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Message::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_guid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sizeBytes,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SIZE_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_arrivalTimestamp,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ARRIVAL_TIMESTAMP]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Message::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_GUID: {
        return manipulator(&d_guid,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID]);
    }
    case ATTRIBUTE_ID_SIZE_BYTES: {
        return manipulator(&d_sizeBytes,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SIZE_BYTES]);
    }
    case ATTRIBUTE_ID_ARRIVAL_TIMESTAMP: {
        return manipulator(
            &d_arrivalTimestamp,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ARRIVAL_TIMESTAMP]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Message::manipulateAttribute(t_MANIPULATOR& manipulator,
                                 const char*    name,
                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& Message::guid()
{
    return d_guid;
}

inline bsls::Types::Int64& Message::sizeBytes()
{
    return d_sizeBytes;
}

inline bdlt::DatetimeTz& Message::arrivalTimestamp()
{
    return d_arrivalTimestamp;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Message::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_guid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sizeBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SIZE_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_arrivalTimestamp,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ARRIVAL_TIMESTAMP]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Message::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_GUID: {
        return accessor(d_guid, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GUID]);
    }
    case ATTRIBUTE_ID_SIZE_BYTES: {
        return accessor(d_sizeBytes,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SIZE_BYTES]);
    }
    case ATTRIBUTE_ID_ARRIVAL_TIMESTAMP: {
        return accessor(
            d_arrivalTimestamp,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ARRIVAL_TIMESTAMP]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Message::accessAttribute(t_ACCESSOR& accessor,
                             const char* name,
                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& Message::guid() const
{
    return d_guid;
}

inline bsls::Types::Int64 Message::sizeBytes() const
{
    return d_sizeBytes;
}

inline const bdlt::DatetimeTz& Message::arrivalTimestamp() const
{
    return d_arrivalTimestamp;
}

// ----------------
// class NodeStatus
// ----------------

// CLASS METHODS
inline int NodeStatus::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& NodeStatus::print(bsl::ostream&     stream,
                                       NodeStatus::Value value)
{
    return stream << toString(value);
}

// -------------------
// class PrimaryStatus
// -------------------

// CLASS METHODS
inline int PrimaryStatus::fromString(Value* result, const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream& PrimaryStatus::print(bsl::ostream&        stream,
                                          PrimaryStatus::Value value)
{
    return stream << toString(value);
}

// ------------------------
// class PurgedQueueDetails
// ------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PurgedQueueDetails::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->queueUri());
    hashAppend(hashAlgorithm, this->appId());
    hashAppend(hashAlgorithm, this->appKey());
    hashAppend(hashAlgorithm, this->numMessagesPurged());
    hashAppend(hashAlgorithm, this->numBytesPurged());
}

inline bool PurgedQueueDetails::isEqualTo(const PurgedQueueDetails& rhs) const
{
    return this->queueUri() == rhs.queueUri() &&
           this->appId() == rhs.appId() && this->appKey() == rhs.appKey() &&
           this->numMessagesPurged() == rhs.numMessagesPurged() &&
           this->numBytesPurged() == rhs.numBytesPurged();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PurgedQueueDetails::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queueUri,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appKey,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numMessagesPurged,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES_PURGED]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numBytesPurged,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES_PURGED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PurgedQueueDetails::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return manipulator(&d_queueUri,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return manipulator(&d_appKey,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES_PURGED: {
        return manipulator(
            &d_numMessagesPurged,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES_PURGED]);
    }
    case ATTRIBUTE_ID_NUM_BYTES_PURGED: {
        return manipulator(
            &d_numBytesPurged,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES_PURGED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PurgedQueueDetails::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& PurgedQueueDetails::queueUri()
{
    return d_queueUri;
}

inline bsl::string& PurgedQueueDetails::appId()
{
    return d_appId;
}

inline bsl::string& PurgedQueueDetails::appKey()
{
    return d_appKey;
}

inline bsls::Types::Int64& PurgedQueueDetails::numMessagesPurged()
{
    return d_numMessagesPurged;
}

inline bsls::Types::Int64& PurgedQueueDetails::numBytesPurged()
{
    return d_numBytesPurged;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PurgedQueueDetails::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queueUri,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appKey, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numMessagesPurged,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES_PURGED]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numBytesPurged,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES_PURGED]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PurgedQueueDetails::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return accessor(d_queueUri,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return accessor(d_appKey,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES_PURGED: {
        return accessor(
            d_numMessagesPurged,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES_PURGED]);
    }
    case ATTRIBUTE_ID_NUM_BYTES_PURGED: {
        return accessor(
            d_numBytesPurged,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES_PURGED]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PurgedQueueDetails::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& PurgedQueueDetails::queueUri() const
{
    return d_queueUri;
}

inline const bsl::string& PurgedQueueDetails::appId() const
{
    return d_appId;
}

inline const bsl::string& PurgedQueueDetails::appKey() const
{
    return d_appKey;
}

inline bsls::Types::Int64 PurgedQueueDetails::numMessagesPurged() const
{
    return d_numMessagesPurged;
}

inline bsls::Types::Int64 PurgedQueueDetails::numBytesPurged() const
{
    return d_numBytesPurged;
}

// -------------------------------
// class RelayQueueEngineSubStream
// -------------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void RelayQueueEngineSubStream::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->appId());
    hashAppend(hashAlgorithm, this->appKey());
    hashAppend(hashAlgorithm, this->numMessages());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RelayQueueEngineSubStream::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appKey,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numMessages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RelayQueueEngineSubStream::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                   int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return manipulator(&d_appKey,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return manipulator(&d_numMessages,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RelayQueueEngineSubStream::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                   const char*    name,
                                                   int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& RelayQueueEngineSubStream::appId()
{
    return d_appId;
}

inline bsl::string& RelayQueueEngineSubStream::appKey()
{
    return d_appKey;
}

inline unsigned int& RelayQueueEngineSubStream::numMessages()
{
    return d_numMessages;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RelayQueueEngineSubStream::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appKey, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numMessages,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RelayQueueEngineSubStream::accessAttribute(t_ACCESSOR& accessor,
                                               int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return accessor(d_appKey,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return accessor(d_numMessages,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RelayQueueEngineSubStream::accessAttribute(t_ACCESSOR& accessor,
                                               const char* name,
                                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& RelayQueueEngineSubStream::appId() const
{
    return d_appId;
}

inline const bsl::string& RelayQueueEngineSubStream::appKey() const
{
    return d_appKey;
}

inline unsigned int RelayQueueEngineSubStream::numMessages() const
{
    return d_numMessages;
}

// ----------------------
// class RemoteStreamInfo
// ----------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void RemoteStreamInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->id());
    hashAppend(hashAlgorithm, this->state());
    hashAppend(hashAlgorithm, this->genCount());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RemoteStreamInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_genCount,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GEN_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RemoteStreamInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ID: {
        return manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_STATE: {
        return manipulator(&d_state,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    }
    case ATTRIBUTE_ID_GEN_COUNT: {
        return manipulator(&d_genCount,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GEN_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RemoteStreamInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& RemoteStreamInfo::id()
{
    return d_id;
}

inline bsl::string& RemoteStreamInfo::state()
{
    return d_state;
}

inline bsls::Types::Int64& RemoteStreamInfo::genCount()
{
    return d_genCount;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RemoteStreamInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_genCount,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GEN_COUNT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RemoteStreamInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ID: {
        return accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_STATE: {
        return accessor(d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    }
    case ATTRIBUTE_ID_GEN_COUNT: {
        return accessor(d_genCount,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_GEN_COUNT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RemoteStreamInfo::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int RemoteStreamInfo::id() const
{
    return d_id;
}

inline const bsl::string& RemoteStreamInfo::state() const
{
    return d_state;
}

inline bsls::Types::Int64 RemoteStreamInfo::genCount() const
{
    return d_genCount;
}

// -------------------------------
// class ResourceUsageMonitorState
// -------------------------------

// CLASS METHODS
inline int ResourceUsageMonitorState::fromString(Value*             result,
                                                 const bsl::string& string)
{
    return fromString(result,
                      string.c_str(),
                      static_cast<int>(string.length()));
}

inline bsl::ostream&
ResourceUsageMonitorState::print(bsl::ostream&                    stream,
                                 ResourceUsageMonitorState::Value value)
{
    return stream << toString(value);
}

// -------------------
// class RouteResponse
// -------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RouteResponse::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_source, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SOURCE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_response,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RouteResponse::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SOURCE: {
        return manipulator(&d_source,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SOURCE]);
    }
    case ATTRIBUTE_ID_RESPONSE: {
        return manipulator(&d_response,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RouteResponse::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& RouteResponse::source()
{
    return d_source;
}

inline bsl::string& RouteResponse::response()
{
    return d_response;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RouteResponse::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_source, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SOURCE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_response, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RouteResponse::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SOURCE: {
        return accessor(d_source,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SOURCE]);
    }
    case ATTRIBUTE_ID_RESPONSE: {
        return accessor(d_response,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RouteResponse::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& RouteResponse::source() const
{
    return d_source;
}

inline const bsl::string& RouteResponse::response() const
{
    return d_response;
}

// -------------------------
// class StorageQueueCommand
// -------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StorageQueueCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef StorageQueueCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_PURGE_APP_ID:
        hashAppend(hashAlgorithm, this->purgeAppId());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
StorageQueueCommand::isEqualTo(const StorageQueueCommand& rhs) const
{
    typedef StorageQueueCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_PURGE_APP_ID:
            return this->purgeAppId() == rhs.purgeAppId();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline StorageQueueCommand::StorageQueueCommand(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline StorageQueueCommand::~StorageQueueCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageQueueCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StorageQueueCommand::SELECTION_ID_PURGE_APP_ID:
        return manipulator(&d_purgeAppId.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGE_APP_ID]);
    default:
        BSLS_ASSERT(StorageQueueCommand::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline bsl::string& StorageQueueCommand::purgeAppId()
{
    BSLS_ASSERT(SELECTION_ID_PURGE_APP_ID == d_selectionId);
    return d_purgeAppId.object();
}

// ACCESSORS
inline int StorageQueueCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int StorageQueueCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_PURGE_APP_ID:
        return accessor(d_purgeAppId.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGE_APP_ID]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const bsl::string& StorageQueueCommand::purgeAppId() const
{
    BSLS_ASSERT(SELECTION_ID_PURGE_APP_ID == d_selectionId);
    return d_purgeAppId.object();
}

inline bool StorageQueueCommand::isPurgeAppIdValue() const
{
    return SELECTION_ID_PURGE_APP_ID == d_selectionId;
}

inline bool StorageQueueCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------------
// class StorageQueueInfo
// ----------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StorageQueueInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->queueUri());
    hashAppend(hashAlgorithm, this->queueKey());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->numMessages());
    hashAppend(hashAlgorithm, this->numBytes());
    hashAppend(hashAlgorithm, this->isPersistent());
    hashAppend(hashAlgorithm, this->internalQueueId());
}

inline bool StorageQueueInfo::isEqualTo(const StorageQueueInfo& rhs) const
{
    return this->queueUri() == rhs.queueUri() &&
           this->queueKey() == rhs.queueKey() &&
           this->partitionId() == rhs.partitionId() &&
           this->numMessages() == rhs.numMessages() &&
           this->numBytes() == rhs.numBytes() &&
           this->isPersistent() == rhs.isPersistent() &&
           this->internalQueueId() == rhs.internalQueueId();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageQueueInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queueUri,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queueKey,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numMessages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numBytes,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isPersistent,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PERSISTENT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_internalQueueId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_INTERNAL_QUEUE_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StorageQueueInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return manipulator(&d_queueUri,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    case ATTRIBUTE_ID_QUEUE_KEY: {
        return manipulator(&d_queueKey,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return manipulator(&d_numMessages,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    case ATTRIBUTE_ID_NUM_BYTES: {
        return manipulator(&d_numBytes,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    }
    case ATTRIBUTE_ID_IS_PERSISTENT: {
        return manipulator(
            &d_isPersistent,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PERSISTENT]);
    }
    case ATTRIBUTE_ID_INTERNAL_QUEUE_ID: {
        return manipulator(
            &d_internalQueueId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_INTERNAL_QUEUE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StorageQueueInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StorageQueueInfo::queueUri()
{
    return d_queueUri;
}

inline bsl::string& StorageQueueInfo::queueKey()
{
    return d_queueKey;
}

inline int& StorageQueueInfo::partitionId()
{
    return d_partitionId;
}

inline bsls::Types::Int64& StorageQueueInfo::numMessages()
{
    return d_numMessages;
}

inline bsls::Types::Int64& StorageQueueInfo::numBytes()
{
    return d_numBytes;
}

inline bool& StorageQueueInfo::isPersistent()
{
    return d_isPersistent;
}

inline unsigned int& StorageQueueInfo::internalQueueId()
{
    return d_internalQueueId;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StorageQueueInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queueUri,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queueKey,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numMessages,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isPersistent,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PERSISTENT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_internalQueueId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_INTERNAL_QUEUE_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StorageQueueInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_URI: {
        return accessor(d_queueUri,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URI]);
    }
    case ATTRIBUTE_ID_QUEUE_KEY: {
        return accessor(d_queueKey,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return accessor(d_numMessages,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    case ATTRIBUTE_ID_NUM_BYTES: {
        return accessor(d_numBytes,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    }
    case ATTRIBUTE_ID_IS_PERSISTENT: {
        return accessor(d_isPersistent,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PERSISTENT]);
    }
    case ATTRIBUTE_ID_INTERNAL_QUEUE_ID: {
        return accessor(
            d_internalQueueId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_INTERNAL_QUEUE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StorageQueueInfo::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StorageQueueInfo::queueUri() const
{
    return d_queueUri;
}

inline const bsl::string& StorageQueueInfo::queueKey() const
{
    return d_queueKey;
}

inline int StorageQueueInfo::partitionId() const
{
    return d_partitionId;
}

inline bsls::Types::Int64 StorageQueueInfo::numMessages() const
{
    return d_numMessages;
}

inline bsls::Types::Int64 StorageQueueInfo::numBytes() const
{
    return d_numBytes;
}

inline bool StorageQueueInfo::isPersistent() const
{
    return d_isPersistent;
}

inline unsigned int StorageQueueInfo::internalQueueId() const
{
    return d_internalQueueId;
}

// -----------
// class SubId
// -----------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int SubId::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int SubId::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID: {
        return manipulator(&d_subId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int SubId::manipulateAttribute(t_MANIPULATOR& manipulator,
                               const char*    name,
                               int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& SubId::subId()
{
    return d_subId;
}

inline bsl::string& SubId::appId()
{
    return d_appId;
}

// ACCESSORS
template <typename t_ACCESSOR>
int SubId::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int SubId::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID: {
        return accessor(d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int SubId::accessAttribute(t_ACCESSOR& accessor,
                           const char* name,
                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int SubId::subId() const
{
    return d_subId;
}

inline const bsl::string& SubId::appId() const
{
    return d_appId;
}

// ----------------
// class Subscriber
// ----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Subscriber::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_downstreamSubQueueId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOWNSTREAM_SUB_QUEUE_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Subscriber::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DOWNSTREAM_SUB_QUEUE_ID: {
        return manipulator(
            &d_downstreamSubQueueId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOWNSTREAM_SUB_QUEUE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Subscriber::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Int64& Subscriber::downstreamSubQueueId()
{
    return d_downstreamSubQueueId;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Subscriber::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_downstreamSubQueueId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOWNSTREAM_SUB_QUEUE_ID]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Subscriber::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DOWNSTREAM_SUB_QUEUE_ID: {
        return accessor(
            d_downstreamSubQueueId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOWNSTREAM_SUB_QUEUE_ID]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Subscriber::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Int64 Subscriber::downstreamSubQueueId() const
{
    return d_downstreamSubQueueId;
}

// ------------------------
// class UninitializedQueue
// ------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int UninitializedQueue::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int UninitializedQueue::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int UninitializedQueue::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int UninitializedQueue::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int UninitializedQueue::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int UninitializedQueue::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// --------------------
// class VirtualStorage
// --------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void VirtualStorage::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->appId());
    hashAppend(hashAlgorithm, this->appKey());
    hashAppend(hashAlgorithm, this->numMessages());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int VirtualStorage::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appKey,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numMessages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int VirtualStorage::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return manipulator(&d_appKey,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return manipulator(&d_numMessages,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int VirtualStorage::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& VirtualStorage::appId()
{
    return d_appId;
}

inline bsl::string& VirtualStorage::appKey()
{
    return d_appKey;
}

inline unsigned int& VirtualStorage::numMessages()
{
    return d_numMessages;
}

// ACCESSORS
template <typename t_ACCESSOR>
int VirtualStorage::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appKey, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numMessages,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int VirtualStorage::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_APP_KEY: {
        return accessor(d_appKey,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_KEY]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return accessor(d_numMessages,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int VirtualStorage::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& VirtualStorage::appId() const
{
    return d_appId;
}

inline const bsl::string& VirtualStorage::appKey() const
{
    return d_appKey;
}

inline unsigned int VirtualStorage::numMessages() const
{
    return d_numMessages;
}

// ----------
// class Void
// ----------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Void::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    (void)manipulator;
    return 0;
}

template <typename t_MANIPULATOR>
int Void::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    (void)manipulator;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Void::manipulateAttribute(t_MANIPULATOR& manipulator,
                              const char*    name,
                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

// ACCESSORS
template <typename t_ACCESSOR>
int Void::accessAttributes(t_ACCESSOR& accessor) const
{
    (void)accessor;
    return 0;
}

template <typename t_ACCESSOR>
int Void::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    (void)accessor;
    enum { NOT_FOUND = -1 };

    switch (id) {
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Void::accessAttribute(t_ACCESSOR& accessor,
                          const char* name,
                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

// -------------------
// class ActiveFileSet
// -------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ActiveFileSet::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->dataFile());
    hashAppend(hashAlgorithm, this->journalFile());
    hashAppend(hashAlgorithm, this->qlistFile());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ActiveFileSet::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_dataFile,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_journalFile,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_JOURNAL_FILE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_qlistFile,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ActiveFileSet::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DATA_FILE: {
        return manipulator(&d_dataFile,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE]);
    }
    case ATTRIBUTE_ID_JOURNAL_FILE: {
        return manipulator(&d_journalFile,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_JOURNAL_FILE]);
    }
    case ATTRIBUTE_ID_QLIST_FILE: {
        return manipulator(&d_qlistFile,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ActiveFileSet::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline FileInfo& ActiveFileSet::dataFile()
{
    return d_dataFile;
}

inline FileInfo& ActiveFileSet::journalFile()
{
    return d_journalFile;
}

inline FileInfo& ActiveFileSet::qlistFile()
{
    return d_qlistFile;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ActiveFileSet::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_dataFile,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_journalFile,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_JOURNAL_FILE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_qlistFile,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ActiveFileSet::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DATA_FILE: {
        return accessor(d_dataFile,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DATA_FILE]);
    }
    case ATTRIBUTE_ID_JOURNAL_FILE: {
        return accessor(d_journalFile,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_JOURNAL_FILE]);
    }
    case ATTRIBUTE_ID_QLIST_FILE: {
        return accessor(d_qlistFile,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QLIST_FILE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ActiveFileSet::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const FileInfo& ActiveFileSet::dataFile() const
{
    return d_dataFile;
}

inline const FileInfo& ActiveFileSet::journalFile() const
{
    return d_journalFile;
}

inline const FileInfo& ActiveFileSet::qlistFile() const
{
    return d_qlistFile;
}

// -------------------------
// class BrokerConfigCommand
// -------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void BrokerConfigCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef BrokerConfigCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_DUMP:
        hashAppend(hashAlgorithm, this->dump());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
BrokerConfigCommand::isEqualTo(const BrokerConfigCommand& rhs) const
{
    typedef BrokerConfigCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_DUMP: return this->dump() == rhs.dump();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline BrokerConfigCommand::BrokerConfigCommand()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline BrokerConfigCommand::~BrokerConfigCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int BrokerConfigCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case BrokerConfigCommand::SELECTION_ID_DUMP:
        return manipulator(&d_dump.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DUMP]);
    default:
        BSLS_ASSERT(BrokerConfigCommand::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline Void& BrokerConfigCommand::dump()
{
    BSLS_ASSERT(SELECTION_ID_DUMP == d_selectionId);
    return d_dump.object();
}

// ACCESSORS
inline int BrokerConfigCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int BrokerConfigCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_DUMP:
        return accessor(d_dump.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DUMP]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& BrokerConfigCommand::dump() const
{
    BSLS_ASSERT(SELECTION_ID_DUMP == d_selectionId);
    return d_dump.object();
}

inline bool BrokerConfigCommand::isDumpValue() const
{
    return SELECTION_ID_DUMP == d_selectionId;
}

inline bool BrokerConfigCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------
// class ClearCache
// ----------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClearCache::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ClearCache Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_DOMAIN:
        hashAppend(hashAlgorithm, this->domain());
        break;
    case Class::SELECTION_ID_ALL:
        hashAppend(hashAlgorithm, this->all());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ClearCache::isEqualTo(const ClearCache& rhs) const
{
    typedef ClearCache Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_DOMAIN: return this->domain() == rhs.domain();
        case Class::SELECTION_ID_ALL: return this->all() == rhs.all();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ClearCache::ClearCache(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClearCache::~ClearCache()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ClearCache::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClearCache::SELECTION_ID_DOMAIN:
        return manipulator(&d_domain.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN]);
    case ClearCache::SELECTION_ID_ALL:
        return manipulator(&d_all.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ALL]);
    default:
        BSLS_ASSERT(ClearCache::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline bsl::string& ClearCache::domain()
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN == d_selectionId);
    return d_domain.object();
}

inline Void& ClearCache::all()
{
    BSLS_ASSERT(SELECTION_ID_ALL == d_selectionId);
    return d_all.object();
}

// ACCESSORS
inline int ClearCache::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ClearCache::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_DOMAIN:
        return accessor(d_domain.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN]);
    case SELECTION_ID_ALL:
        return accessor(d_all.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ALL]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const bsl::string& ClearCache::domain() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN == d_selectionId);
    return d_domain.object();
}

inline const Void& ClearCache::all() const
{
    BSLS_ASSERT(SELECTION_ID_ALL == d_selectionId);
    return d_all.object();
}

inline bool ClearCache::isDomainValue() const
{
    return SELECTION_ID_DOMAIN == d_selectionId;
}

inline bool ClearCache::isAllValue() const
{
    return SELECTION_ID_ALL == d_selectionId;
}

inline bool ClearCache::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------
// class ClusterInfo
// -----------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->locality());
    hashAppend(hashAlgorithm, this->name());
    hashAppend(hashAlgorithm, this->nodes());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_locality,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOCALITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_nodes, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LOCALITY: {
        return manipulator(&d_locality,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOCALITY]);
    }
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_NODES: {
        return manipulator(&d_nodes,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline Locality::Value& ClusterInfo::locality()
{
    return d_locality;
}

inline bsl::string& ClusterInfo::name()
{
    return d_name;
}

inline bsl::vector<ClusterNode>& ClusterInfo::nodes()
{
    return d_nodes;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_locality, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOCALITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_nodes, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LOCALITY: {
        return accessor(d_locality,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOCALITY]);
    }
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_NODES: {
        return accessor(d_nodes, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterInfo::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline Locality::Value ClusterInfo::locality() const
{
    return d_locality;
}

inline const bsl::string& ClusterInfo::name() const
{
    return d_name;
}

inline const bsl::vector<ClusterNode>& ClusterInfo::nodes() const
{
    return d_nodes;
}

// ---------------------
// class ClusterNodeInfo
// ---------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterNodeInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->description());
    hashAppend(hashAlgorithm, this->isAvailable());
    hashAppend(hashAlgorithm, this->status());
    hashAppend(hashAlgorithm, this->primaryForPartitionIds());
}

inline bool ClusterNodeInfo::isEqualTo(const ClusterNodeInfo& rhs) const
{
    return this->description() == rhs.description() &&
           this->isAvailable() == rhs.isAvailable() &&
           this->status() == rhs.status() &&
           this->primaryForPartitionIds() == rhs.primaryForPartitionIds();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterNodeInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_description,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isAvailable,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_primaryForPartitionIds,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_FOR_PARTITION_IDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterNodeInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DESCRIPTION: {
        return manipulator(&d_description,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_IS_AVAILABLE: {
        return manipulator(&d_isAvailable,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    case ATTRIBUTE_ID_PRIMARY_FOR_PARTITION_IDS: {
        return manipulator(
            &d_primaryForPartitionIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_FOR_PARTITION_IDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterNodeInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                         const char*    name,
                                         int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClusterNodeInfo::description()
{
    return d_description;
}

inline bdlb::NullableValue<bool>& ClusterNodeInfo::isAvailable()
{
    return d_isAvailable;
}

inline NodeStatus::Value& ClusterNodeInfo::status()
{
    return d_status;
}

inline bsl::vector<int>& ClusterNodeInfo::primaryForPartitionIds()
{
    return d_primaryForPartitionIds;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterNodeInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_description,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isAvailable,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_primaryForPartitionIds,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_FOR_PARTITION_IDS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterNodeInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DESCRIPTION: {
        return accessor(d_description,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_IS_AVAILABLE: {
        return accessor(d_isAvailable,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    case ATTRIBUTE_ID_PRIMARY_FOR_PARTITION_IDS: {
        return accessor(
            d_primaryForPartitionIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_FOR_PARTITION_IDS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterNodeInfo::accessAttribute(t_ACCESSOR& accessor,
                                     const char* name,
                                     int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ClusterNodeInfo::description() const
{
    return d_description;
}

inline const bdlb::NullableValue<bool>& ClusterNodeInfo::isAvailable() const
{
    return d_isAvailable;
}

inline NodeStatus::Value ClusterNodeInfo::status() const
{
    return d_status;
}

inline const bsl::vector<int>& ClusterNodeInfo::primaryForPartitionIds() const
{
    return d_primaryForPartitionIds;
}

// ------------------
// class ClusterQueue
// ------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterQueue::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->uri());
    hashAppend(hashAlgorithm, this->numInFlightContexts());
    hashAppend(hashAlgorithm, this->isAssigned());
    hashAppend(hashAlgorithm, this->isPrimaryAvailable());
    hashAppend(hashAlgorithm, this->id());
    hashAppend(hashAlgorithm, this->subIds());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->primaryNodeDescription());
    hashAppend(hashAlgorithm, this->key());
    hashAppend(hashAlgorithm, this->isCreated());
    hashAppend(hashAlgorithm, this->contexts());
}

inline bool ClusterQueue::isEqualTo(const ClusterQueue& rhs) const
{
    return this->uri() == rhs.uri() &&
           this->numInFlightContexts() == rhs.numInFlightContexts() &&
           this->isAssigned() == rhs.isAssigned() &&
           this->isPrimaryAvailable() == rhs.isPrimaryAvailable() &&
           this->id() == rhs.id() && this->subIds() == rhs.subIds() &&
           this->partitionId() == rhs.partitionId() &&
           this->primaryNodeDescription() == rhs.primaryNodeDescription() &&
           this->key() == rhs.key() && this->isCreated() == rhs.isCreated() &&
           this->contexts() == rhs.contexts();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterQueue::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numInFlightContexts,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_IN_FLIGHT_CONTEXTS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isAssigned,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_ASSIGNED]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_isPrimaryAvailable,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PRIMARY_AVAILABLE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_subIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_IDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_primaryNodeDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isCreated,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_CREATED]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_contexts,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONTEXTS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterQueue::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_NUM_IN_FLIGHT_CONTEXTS: {
        return manipulator(
            &d_numInFlightContexts,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_IN_FLIGHT_CONTEXTS]);
    }
    case ATTRIBUTE_ID_IS_ASSIGNED: {
        return manipulator(&d_isAssigned,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_ASSIGNED]);
    }
    case ATTRIBUTE_ID_IS_PRIMARY_AVAILABLE: {
        return manipulator(
            &d_isPrimaryAvailable,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PRIMARY_AVAILABLE]);
    }
    case ATTRIBUTE_ID_ID: {
        return manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_SUB_IDS: {
        return manipulator(&d_subIds,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_IDS]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_DESCRIPTION: {
        return manipulator(
            &d_primaryNodeDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_KEY: {
        return manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_IS_CREATED: {
        return manipulator(&d_isCreated,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_CREATED]);
    }
    case ATTRIBUTE_ID_CONTEXTS: {
        return manipulator(&d_contexts,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONTEXTS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterQueue::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClusterQueue::uri()
{
    return d_uri;
}

inline unsigned int& ClusterQueue::numInFlightContexts()
{
    return d_numInFlightContexts;
}

inline bool& ClusterQueue::isAssigned()
{
    return d_isAssigned;
}

inline bool& ClusterQueue::isPrimaryAvailable()
{
    return d_isPrimaryAvailable;
}

inline unsigned int& ClusterQueue::id()
{
    return d_id;
}

inline bsl::vector<SubId>& ClusterQueue::subIds()
{
    return d_subIds;
}

inline int& ClusterQueue::partitionId()
{
    return d_partitionId;
}

inline bdlb::NullableValue<bsl::string>& ClusterQueue::primaryNodeDescription()
{
    return d_primaryNodeDescription;
}

inline bsl::string& ClusterQueue::key()
{
    return d_key;
}

inline bool& ClusterQueue::isCreated()
{
    return d_isCreated;
}

inline bsl::vector<Context>& ClusterQueue::contexts()
{
    return d_contexts;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterQueue::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_numInFlightContexts,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_IN_FLIGHT_CONTEXTS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isAssigned,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_ASSIGNED]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isPrimaryAvailable,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PRIMARY_AVAILABLE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_subIds, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_IDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_primaryNodeDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isCreated,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_CREATED]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_contexts, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONTEXTS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterQueue::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_NUM_IN_FLIGHT_CONTEXTS: {
        return accessor(
            d_numInFlightContexts,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_IN_FLIGHT_CONTEXTS]);
    }
    case ATTRIBUTE_ID_IS_ASSIGNED: {
        return accessor(d_isAssigned,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_ASSIGNED]);
    }
    case ATTRIBUTE_ID_IS_PRIMARY_AVAILABLE: {
        return accessor(
            d_isPrimaryAvailable,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PRIMARY_AVAILABLE]);
    }
    case ATTRIBUTE_ID_ID: {
        return accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_SUB_IDS: {
        return accessor(d_subIds,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_IDS]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE_DESCRIPTION: {
        return accessor(
            d_primaryNodeDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_KEY: {
        return accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_IS_CREATED: {
        return accessor(d_isCreated,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_CREATED]);
    }
    case ATTRIBUTE_ID_CONTEXTS: {
        return accessor(d_contexts,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONTEXTS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterQueue::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ClusterQueue::uri() const
{
    return d_uri;
}

inline unsigned int ClusterQueue::numInFlightContexts() const
{
    return d_numInFlightContexts;
}

inline bool ClusterQueue::isAssigned() const
{
    return d_isAssigned;
}

inline bool ClusterQueue::isPrimaryAvailable() const
{
    return d_isPrimaryAvailable;
}

inline unsigned int ClusterQueue::id() const
{
    return d_id;
}

inline const bsl::vector<SubId>& ClusterQueue::subIds() const
{
    return d_subIds;
}

inline int ClusterQueue::partitionId() const
{
    return d_partitionId;
}

inline const bdlb::NullableValue<bsl::string>&
ClusterQueue::primaryNodeDescription() const
{
    return d_primaryNodeDescription;
}

inline const bsl::string& ClusterQueue::key() const
{
    return d_key;
}

inline bool ClusterQueue::isCreated() const
{
    return d_isCreated;
}

inline const bsl::vector<Context>& ClusterQueue::contexts() const
{
    return d_contexts;
}

// -------------------
// class DangerCommand
// -------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DangerCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef DangerCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_SHUTDOWN:
        hashAppend(hashAlgorithm, this->shutdown());
        break;
    case Class::SELECTION_ID_TERMINATE:
        hashAppend(hashAlgorithm, this->terminate());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool DangerCommand::isEqualTo(const DangerCommand& rhs) const
{
    typedef DangerCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_SHUTDOWN:
            return this->shutdown() == rhs.shutdown();
        case Class::SELECTION_ID_TERMINATE:
            return this->terminate() == rhs.terminate();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline DangerCommand::DangerCommand()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline DangerCommand::~DangerCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int DangerCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case DangerCommand::SELECTION_ID_SHUTDOWN:
        return manipulator(&d_shutdown.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SHUTDOWN]);
    case DangerCommand::SELECTION_ID_TERMINATE:
        return manipulator(&d_terminate.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TERMINATE]);
    default:
        BSLS_ASSERT(DangerCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& DangerCommand::shutdown()
{
    BSLS_ASSERT(SELECTION_ID_SHUTDOWN == d_selectionId);
    return d_shutdown.object();
}

inline Void& DangerCommand::terminate()
{
    BSLS_ASSERT(SELECTION_ID_TERMINATE == d_selectionId);
    return d_terminate.object();
}

// ACCESSORS
inline int DangerCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int DangerCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_SHUTDOWN:
        return accessor(d_shutdown.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SHUTDOWN]);
    case SELECTION_ID_TERMINATE:
        return accessor(d_terminate.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TERMINATE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& DangerCommand::shutdown() const
{
    BSLS_ASSERT(SELECTION_ID_SHUTDOWN == d_selectionId);
    return d_shutdown.object();
}

inline const Void& DangerCommand::terminate() const
{
    BSLS_ASSERT(SELECTION_ID_TERMINATE == d_selectionId);
    return d_terminate.object();
}

inline bool DangerCommand::isShutdownValue() const
{
    return SELECTION_ID_SHUTDOWN == d_selectionId;
}

inline bool DangerCommand::isTerminateValue() const
{
    return SELECTION_ID_TERMINATE == d_selectionId;
}

inline bool DangerCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------
// class ElectorInfo
// -----------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ElectorInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->electorState());
    hashAppend(hashAlgorithm, this->leaderNode());
    hashAppend(hashAlgorithm, this->leaderMessageSequence());
    hashAppend(hashAlgorithm, this->leaderStatus());
}

inline bool ElectorInfo::isEqualTo(const ElectorInfo& rhs) const
{
    return this->electorState() == rhs.electorState() &&
           this->leaderNode() == rhs.leaderNode() &&
           this->leaderMessageSequence() == rhs.leaderMessageSequence() &&
           this->leaderStatus() == rhs.leaderStatus();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ElectorInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_electorState,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_STATE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_leaderNode,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_NODE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_leaderMessageSequence,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_leaderStatus,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ElectorInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ELECTOR_STATE: {
        return manipulator(
            &d_electorState,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_STATE]);
    }
    case ATTRIBUTE_ID_LEADER_NODE: {
        return manipulator(&d_leaderNode,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_NODE]);
    }
    case ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE: {
        return manipulator(
            &d_leaderMessageSequence,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    }
    case ATTRIBUTE_ID_LEADER_STATUS: {
        return manipulator(
            &d_leaderStatus,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ElectorInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ElectorState::Value& ElectorInfo::electorState()
{
    return d_electorState;
}

inline bsl::string& ElectorInfo::leaderNode()
{
    return d_leaderNode;
}

inline LeaderMessageSequence& ElectorInfo::leaderMessageSequence()
{
    return d_leaderMessageSequence;
}

inline LeaderStatus::Value& ElectorInfo::leaderStatus()
{
    return d_leaderStatus;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ElectorInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_electorState,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_STATE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_leaderNode,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_NODE]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_leaderMessageSequence,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_leaderStatus,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ElectorInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ELECTOR_STATE: {
        return accessor(d_electorState,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_STATE]);
    }
    case ATTRIBUTE_ID_LEADER_NODE: {
        return accessor(d_leaderNode,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_NODE]);
    }
    case ATTRIBUTE_ID_LEADER_MESSAGE_SEQUENCE: {
        return accessor(
            d_leaderMessageSequence,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_MESSAGE_SEQUENCE]);
    }
    case ATTRIBUTE_ID_LEADER_STATUS: {
        return accessor(d_leaderStatus,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEADER_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ElectorInfo::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline ElectorState::Value ElectorInfo::electorState() const
{
    return d_electorState;
}

inline const bsl::string& ElectorInfo::leaderNode() const
{
    return d_leaderNode;
}

inline const LeaderMessageSequence& ElectorInfo::leaderMessageSequence() const
{
    return d_leaderMessageSequence;
}

inline LeaderStatus::Value ElectorInfo::leaderStatus() const
{
    return d_leaderStatus;
}

// ----------------------
// class GetTunableChoice
// ----------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void GetTunableChoice::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef GetTunableChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ALL:
        hashAppend(hashAlgorithm, this->all());
        break;
    case Class::SELECTION_ID_SELF:
        hashAppend(hashAlgorithm, this->self());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool GetTunableChoice::isEqualTo(const GetTunableChoice& rhs) const
{
    typedef GetTunableChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ALL: return this->all() == rhs.all();
        case Class::SELECTION_ID_SELF: return this->self() == rhs.self();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline GetTunableChoice::GetTunableChoice()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline GetTunableChoice::~GetTunableChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int GetTunableChoice::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case GetTunableChoice::SELECTION_ID_ALL:
        return manipulator(&d_all.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ALL]);
    case GetTunableChoice::SELECTION_ID_SELF:
        return manipulator(&d_self.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SELF]);
    default:
        BSLS_ASSERT(GetTunableChoice::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& GetTunableChoice::all()
{
    BSLS_ASSERT(SELECTION_ID_ALL == d_selectionId);
    return d_all.object();
}

inline Void& GetTunableChoice::self()
{
    BSLS_ASSERT(SELECTION_ID_SELF == d_selectionId);
    return d_self.object();
}

// ACCESSORS
inline int GetTunableChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int GetTunableChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ALL:
        return accessor(d_all.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ALL]);
    case SELECTION_ID_SELF:
        return accessor(d_self.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SELF]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& GetTunableChoice::all() const
{
    BSLS_ASSERT(SELECTION_ID_ALL == d_selectionId);
    return d_all.object();
}

inline const Void& GetTunableChoice::self() const
{
    BSLS_ASSERT(SELECTION_ID_SELF == d_selectionId);
    return d_self.object();
}

inline bool GetTunableChoice::isAllValue() const
{
    return SELECTION_ID_ALL == d_selectionId;
}

inline bool GetTunableChoice::isSelfValue() const
{
    return SELECTION_ID_SELF == d_selectionId;
}

inline bool GetTunableChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------
// class Help
// ----------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Help::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_commands,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMANDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isPlumbing,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PLUMBING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Help::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_COMMANDS: {
        return manipulator(&d_commands,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMANDS]);
    }
    case ATTRIBUTE_ID_IS_PLUMBING: {
        return manipulator(&d_isPlumbing,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PLUMBING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Help::manipulateAttribute(t_MANIPULATOR& manipulator,
                              const char*    name,
                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<CommandSpec>& Help::commands()
{
    return d_commands;
}

inline bool& Help::isPlumbing()
{
    return d_isPlumbing;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Help::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_commands, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMANDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isPlumbing,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PLUMBING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Help::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_COMMANDS: {
        return accessor(d_commands,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMANDS]);
    }
    case ATTRIBUTE_ID_IS_PLUMBING: {
        return accessor(d_isPlumbing,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_PLUMBING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Help::accessAttribute(t_ACCESSOR& accessor,
                          const char* name,
                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<CommandSpec>& Help::commands() const
{
    return d_commands;
}

inline bool Help::isPlumbing() const
{
    return d_isPlumbing;
}

// --------------------------------
// class MessageGroupIdManagerIndex
// --------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int MessageGroupIdManagerIndex::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_leastRecentlyUsedGroupIds,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEAST_RECENTLY_USED_GROUP_IDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numMsgGroupsPerClient,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MSG_GROUPS_PER_CLIENT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int MessageGroupIdManagerIndex::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEAST_RECENTLY_USED_GROUP_IDS: {
        return manipulator(
            &d_leastRecentlyUsedGroupIds,
            ATTRIBUTE_INFO_ARRAY
                [ATTRIBUTE_INDEX_LEAST_RECENTLY_USED_GROUP_IDS]);
    }
    case ATTRIBUTE_ID_NUM_MSG_GROUPS_PER_CLIENT: {
        return manipulator(
            &d_numMsgGroupsPerClient,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MSG_GROUPS_PER_CLIENT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int MessageGroupIdManagerIndex::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                    const char*    name,
                                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<LeastRecentlyUsedGroupId>&
MessageGroupIdManagerIndex::leastRecentlyUsedGroupIds()
{
    return d_leastRecentlyUsedGroupIds;
}

inline bsl::vector<ClientMsgGroupsCount>&
MessageGroupIdManagerIndex::numMsgGroupsPerClient()
{
    return d_numMsgGroupsPerClient;
}

// ACCESSORS
template <typename t_ACCESSOR>
int MessageGroupIdManagerIndex::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_leastRecentlyUsedGroupIds,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LEAST_RECENTLY_USED_GROUP_IDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_numMsgGroupsPerClient,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MSG_GROUPS_PER_CLIENT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int MessageGroupIdManagerIndex::accessAttribute(t_ACCESSOR& accessor,
                                                int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_LEAST_RECENTLY_USED_GROUP_IDS: {
        return accessor(d_leastRecentlyUsedGroupIds,
                        ATTRIBUTE_INFO_ARRAY
                            [ATTRIBUTE_INDEX_LEAST_RECENTLY_USED_GROUP_IDS]);
    }
    case ATTRIBUTE_ID_NUM_MSG_GROUPS_PER_CLIENT: {
        return accessor(
            d_numMsgGroupsPerClient,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MSG_GROUPS_PER_CLIENT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int MessageGroupIdManagerIndex::accessAttribute(t_ACCESSOR& accessor,
                                                const char* name,
                                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<LeastRecentlyUsedGroupId>&
MessageGroupIdManagerIndex::leastRecentlyUsedGroupIds() const
{
    return d_leastRecentlyUsedGroupIds;
}

inline const bsl::vector<ClientMsgGroupsCount>&
MessageGroupIdManagerIndex::numMsgGroupsPerClient() const
{
    return d_numMsgGroupsPerClient;
}

// -------------------
// class PartitionInfo
// -------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PartitionInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->numQueuesMapped());
    hashAppend(hashAlgorithm, this->numActiveQueues());
    hashAppend(hashAlgorithm, this->primaryNode());
    hashAppend(hashAlgorithm, this->primaryLeaseId());
    hashAppend(hashAlgorithm, this->primaryStatus());
}

inline bool PartitionInfo::isEqualTo(const PartitionInfo& rhs) const
{
    return this->numQueuesMapped() == rhs.numQueuesMapped() &&
           this->numActiveQueues() == rhs.numActiveQueues() &&
           this->primaryNode() == rhs.primaryNode() &&
           this->primaryLeaseId() == rhs.primaryLeaseId() &&
           this->primaryStatus() == rhs.primaryStatus();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_numQueuesMapped,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUES_MAPPED]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numActiveQueues,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_ACTIVE_QUEUES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryNode,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryStatus,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NUM_QUEUES_MAPPED: {
        return manipulator(
            &d_numQueuesMapped,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUES_MAPPED]);
    }
    case ATTRIBUTE_ID_NUM_ACTIVE_QUEUES: {
        return manipulator(
            &d_numActiveQueues,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_ACTIVE_QUEUES]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE: {
        return manipulator(&d_primaryNode,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_STATUS: {
        return manipulator(
            &d_primaryStatus,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& PartitionInfo::numQueuesMapped()
{
    return d_numQueuesMapped;
}

inline int& PartitionInfo::numActiveQueues()
{
    return d_numActiveQueues;
}

inline bdlb::NullableValue<bsl::string>& PartitionInfo::primaryNode()
{
    return d_primaryNode;
}

inline unsigned int& PartitionInfo::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline PrimaryStatus::Value& PartitionInfo::primaryStatus()
{
    return d_primaryStatus;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_numQueuesMapped,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUES_MAPPED]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numActiveQueues,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_ACTIVE_QUEUES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryNode,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryStatus,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NUM_QUEUES_MAPPED: {
        return accessor(
            d_numQueuesMapped,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUES_MAPPED]);
    }
    case ATTRIBUTE_ID_NUM_ACTIVE_QUEUES: {
        return accessor(
            d_numActiveQueues,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_ACTIVE_QUEUES]);
    }
    case ATTRIBUTE_ID_PRIMARY_NODE: {
        return accessor(d_primaryNode,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_PRIMARY_STATUS: {
        return accessor(d_primaryStatus,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionInfo::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int PartitionInfo::numQueuesMapped() const
{
    return d_numQueuesMapped;
}

inline int PartitionInfo::numActiveQueues() const
{
    return d_numActiveQueues;
}

inline const bdlb::NullableValue<bsl::string>&
PartitionInfo::primaryNode() const
{
    return d_primaryNode;
}

inline unsigned int PartitionInfo::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline PrimaryStatus::Value PartitionInfo::primaryStatus() const
{
    return d_primaryStatus;
}

// ----------------------
// class PurgeQueueResult
// ----------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void PurgeQueueResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef PurgeQueueResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_QUEUE:
        hashAppend(hashAlgorithm, this->queue());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool PurgeQueueResult::isEqualTo(const PurgeQueueResult& rhs) const
{
    typedef PurgeQueueResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_QUEUE: return this->queue() == rhs.queue();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline PurgeQueueResult::PurgeQueueResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline PurgeQueueResult::~PurgeQueueResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int PurgeQueueResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case PurgeQueueResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case PurgeQueueResult::SELECTION_ID_QUEUE:
        return manipulator(&d_queue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE]);
    default:
        BSLS_ASSERT(PurgeQueueResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Error& PurgeQueueResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline PurgedQueueDetails& PurgeQueueResult::queue()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE == d_selectionId);
    return d_queue.object();
}

// ACCESSORS
inline int PurgeQueueResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int PurgeQueueResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_QUEUE:
        return accessor(d_queue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& PurgeQueueResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const PurgedQueueDetails& PurgeQueueResult::queue() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE == d_selectionId);
    return d_queue.object();
}

inline bool PurgeQueueResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool PurgeQueueResult::isQueueValue() const
{
    return SELECTION_ID_QUEUE == d_selectionId;
}

inline bool PurgeQueueResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ------------------
// class QueueCommand
// ------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef QueueCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_PURGE_APP_ID:
        hashAppend(hashAlgorithm, this->purgeAppId());
        break;
    case Class::SELECTION_ID_INTERNALS:
        hashAppend(hashAlgorithm, this->internals());
        break;
    case Class::SELECTION_ID_MESSAGES:
        hashAppend(hashAlgorithm, this->messages());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool QueueCommand::isEqualTo(const QueueCommand& rhs) const
{
    typedef QueueCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_PURGE_APP_ID:
            return this->purgeAppId() == rhs.purgeAppId();
        case Class::SELECTION_ID_INTERNALS:
            return this->internals() == rhs.internals();
        case Class::SELECTION_ID_MESSAGES:
            return this->messages() == rhs.messages();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline QueueCommand::QueueCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline QueueCommand::~QueueCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case QueueCommand::SELECTION_ID_PURGE_APP_ID:
        return manipulator(&d_purgeAppId.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGE_APP_ID]);
    case QueueCommand::SELECTION_ID_INTERNALS:
        return manipulator(&d_internals.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_INTERNALS]);
    case QueueCommand::SELECTION_ID_MESSAGES:
        return manipulator(&d_messages.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_MESSAGES]);
    default:
        BSLS_ASSERT(QueueCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline bsl::string& QueueCommand::purgeAppId()
{
    BSLS_ASSERT(SELECTION_ID_PURGE_APP_ID == d_selectionId);
    return d_purgeAppId.object();
}

inline Void& QueueCommand::internals()
{
    BSLS_ASSERT(SELECTION_ID_INTERNALS == d_selectionId);
    return d_internals.object();
}

inline ListMessages& QueueCommand::messages()
{
    BSLS_ASSERT(SELECTION_ID_MESSAGES == d_selectionId);
    return d_messages.object();
}

// ACCESSORS
inline int QueueCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int QueueCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_PURGE_APP_ID:
        return accessor(d_purgeAppId.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGE_APP_ID]);
    case SELECTION_ID_INTERNALS:
        return accessor(d_internals.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_INTERNALS]);
    case SELECTION_ID_MESSAGES:
        return accessor(d_messages.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_MESSAGES]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const bsl::string& QueueCommand::purgeAppId() const
{
    BSLS_ASSERT(SELECTION_ID_PURGE_APP_ID == d_selectionId);
    return d_purgeAppId.object();
}

inline const Void& QueueCommand::internals() const
{
    BSLS_ASSERT(SELECTION_ID_INTERNALS == d_selectionId);
    return d_internals.object();
}

inline const ListMessages& QueueCommand::messages() const
{
    BSLS_ASSERT(SELECTION_ID_MESSAGES == d_selectionId);
    return d_messages.object();
}

inline bool QueueCommand::isPurgeAppIdValue() const
{
    return SELECTION_ID_PURGE_APP_ID == d_selectionId;
}

inline bool QueueCommand::isInternalsValue() const
{
    return SELECTION_ID_INTERNALS == d_selectionId;
}

inline bool QueueCommand::isMessagesValue() const
{
    return SELECTION_ID_MESSAGES == d_selectionId;
}

inline bool QueueCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -------------------
// class QueueContents
// -------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueContents::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->messages());
    hashAppend(hashAlgorithm, this->offset());
    hashAppend(hashAlgorithm, this->totalQueueMessages());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueContents::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_messages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_offset, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_totalQueueMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TOTAL_QUEUE_MESSAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueContents::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MESSAGES: {
        return manipulator(&d_messages,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES]);
    }
    case ATTRIBUTE_ID_OFFSET: {
        return manipulator(&d_offset,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    }
    case ATTRIBUTE_ID_TOTAL_QUEUE_MESSAGES: {
        return manipulator(
            &d_totalQueueMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TOTAL_QUEUE_MESSAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueContents::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<Message>& QueueContents::messages()
{
    return d_messages;
}

inline bsls::Types::Int64& QueueContents::offset()
{
    return d_offset;
}

inline bsls::Types::Int64& QueueContents::totalQueueMessages()
{
    return d_totalQueueMessages;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueContents::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_messages, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_offset, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_totalQueueMessages,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TOTAL_QUEUE_MESSAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueContents::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MESSAGES: {
        return accessor(d_messages,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES]);
    }
    case ATTRIBUTE_ID_OFFSET: {
        return accessor(d_offset,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OFFSET]);
    }
    case ATTRIBUTE_ID_TOTAL_QUEUE_MESSAGES: {
        return accessor(
            d_totalQueueMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TOTAL_QUEUE_MESSAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueContents::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<Message>& QueueContents::messages() const
{
    return d_messages;
}

inline bsls::Types::Int64 QueueContents::offset() const
{
    return d_offset;
}

inline bsls::Types::Int64 QueueContents::totalQueueMessages() const
{
    return d_totalQueueMessages;
}

// ------------------
// class QueueStorage
// ------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueStorage::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->numMessages());
    hashAppend(hashAlgorithm, this->numBytes());
    hashAppend(hashAlgorithm, this->virtualStorages());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueStorage::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_numMessages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numBytes,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_virtualStorages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VIRTUAL_STORAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueStorage::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return manipulator(&d_numMessages,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    case ATTRIBUTE_ID_NUM_BYTES: {
        return manipulator(&d_numBytes,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    }
    case ATTRIBUTE_ID_VIRTUAL_STORAGES: {
        return manipulator(
            &d_virtualStorages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VIRTUAL_STORAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueStorage::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& QueueStorage::numMessages()
{
    return d_numMessages;
}

inline unsigned int& QueueStorage::numBytes()
{
    return d_numBytes;
}

inline bsl::vector<VirtualStorage>& QueueStorage::virtualStorages()
{
    return d_virtualStorages;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueStorage::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_numMessages,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_virtualStorages,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VIRTUAL_STORAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueStorage::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return accessor(d_numMessages,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    case ATTRIBUTE_ID_NUM_BYTES: {
        return accessor(d_numBytes,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    }
    case ATTRIBUTE_ID_VIRTUAL_STORAGES: {
        return accessor(
            d_virtualStorages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VIRTUAL_STORAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueStorage::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int QueueStorage::numMessages() const
{
    return d_numMessages;
}

inline unsigned int QueueStorage::numBytes() const
{
    return d_numBytes;
}

inline const bsl::vector<VirtualStorage>& QueueStorage::virtualStorages() const
{
    return d_virtualStorages;
}

// --------------------------
// class ResourceUsageMonitor
// --------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ResourceUsageMonitor::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->state());
    hashAppend(hashAlgorithm, this->messagesState());
    hashAppend(hashAlgorithm, this->numMessages());
    hashAppend(hashAlgorithm, this->messagesLowWatermarkRatio());
    hashAppend(hashAlgorithm, this->messagesHighWatermarkRatio());
    hashAppend(hashAlgorithm, this->messagesCapacity());
    hashAppend(hashAlgorithm, this->bytesState());
    hashAppend(hashAlgorithm, this->numBytes());
    hashAppend(hashAlgorithm, this->bytesLowWatermarkRatio());
    hashAppend(hashAlgorithm, this->bytesHighWatermarkRatio());
    hashAppend(hashAlgorithm, this->bytesCapacity());
}

inline bool
ResourceUsageMonitor::isEqualTo(const ResourceUsageMonitor& rhs) const
{
    return this->state() == rhs.state() &&
           this->messagesState() == rhs.messagesState() &&
           this->numMessages() == rhs.numMessages() &&
           this->messagesLowWatermarkRatio() ==
               rhs.messagesLowWatermarkRatio() &&
           this->messagesHighWatermarkRatio() ==
               rhs.messagesHighWatermarkRatio() &&
           this->messagesCapacity() == rhs.messagesCapacity() &&
           this->bytesState() == rhs.bytesState() &&
           this->numBytes() == rhs.numBytes() &&
           this->bytesLowWatermarkRatio() == rhs.bytesLowWatermarkRatio() &&
           this->bytesHighWatermarkRatio() == rhs.bytesHighWatermarkRatio() &&
           this->bytesCapacity() == rhs.bytesCapacity();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ResourceUsageMonitor::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_messagesState,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_STATE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numMessages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_messagesLowWatermarkRatio,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_LOW_WATERMARK_RATIO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_messagesHighWatermarkRatio,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_HIGH_WATERMARK_RATIO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_messagesCapacity,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_CAPACITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_bytesState,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_STATE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numBytes,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_bytesLowWatermarkRatio,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_LOW_WATERMARK_RATIO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_bytesHighWatermarkRatio,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_HIGH_WATERMARK_RATIO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_bytesCapacity,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_CAPACITY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ResourceUsageMonitor::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATE: {
        return manipulator(&d_state,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    }
    case ATTRIBUTE_ID_MESSAGES_STATE: {
        return manipulator(
            &d_messagesState,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_STATE]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return manipulator(&d_numMessages,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    case ATTRIBUTE_ID_MESSAGES_LOW_WATERMARK_RATIO: {
        return manipulator(&d_messagesLowWatermarkRatio,
                           ATTRIBUTE_INFO_ARRAY
                               [ATTRIBUTE_INDEX_MESSAGES_LOW_WATERMARK_RATIO]);
    }
    case ATTRIBUTE_ID_MESSAGES_HIGH_WATERMARK_RATIO: {
        return manipulator(
            &d_messagesHighWatermarkRatio,
            ATTRIBUTE_INFO_ARRAY
                [ATTRIBUTE_INDEX_MESSAGES_HIGH_WATERMARK_RATIO]);
    }
    case ATTRIBUTE_ID_MESSAGES_CAPACITY: {
        return manipulator(
            &d_messagesCapacity,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_CAPACITY]);
    }
    case ATTRIBUTE_ID_BYTES_STATE: {
        return manipulator(&d_bytesState,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_STATE]);
    }
    case ATTRIBUTE_ID_NUM_BYTES: {
        return manipulator(&d_numBytes,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    }
    case ATTRIBUTE_ID_BYTES_LOW_WATERMARK_RATIO: {
        return manipulator(
            &d_bytesLowWatermarkRatio,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_LOW_WATERMARK_RATIO]);
    }
    case ATTRIBUTE_ID_BYTES_HIGH_WATERMARK_RATIO: {
        return manipulator(
            &d_bytesHighWatermarkRatio,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_HIGH_WATERMARK_RATIO]);
    }
    case ATTRIBUTE_ID_BYTES_CAPACITY: {
        return manipulator(
            &d_bytesCapacity,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_CAPACITY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ResourceUsageMonitor::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline ResourceUsageMonitorState::Value& ResourceUsageMonitor::state()
{
    return d_state;
}

inline ResourceUsageMonitorState::Value& ResourceUsageMonitor::messagesState()
{
    return d_messagesState;
}

inline bsls::Types::Int64& ResourceUsageMonitor::numMessages()
{
    return d_numMessages;
}

inline bsls::Types::Int64& ResourceUsageMonitor::messagesLowWatermarkRatio()
{
    return d_messagesLowWatermarkRatio;
}

inline bsls::Types::Int64& ResourceUsageMonitor::messagesHighWatermarkRatio()
{
    return d_messagesHighWatermarkRatio;
}

inline bsls::Types::Int64& ResourceUsageMonitor::messagesCapacity()
{
    return d_messagesCapacity;
}

inline ResourceUsageMonitorState::Value& ResourceUsageMonitor::bytesState()
{
    return d_bytesState;
}

inline bsls::Types::Int64& ResourceUsageMonitor::numBytes()
{
    return d_numBytes;
}

inline bsls::Types::Int64& ResourceUsageMonitor::bytesLowWatermarkRatio()
{
    return d_bytesLowWatermarkRatio;
}

inline bsls::Types::Int64& ResourceUsageMonitor::bytesHighWatermarkRatio()
{
    return d_bytesHighWatermarkRatio;
}

inline bsls::Types::Int64& ResourceUsageMonitor::bytesCapacity()
{
    return d_bytesCapacity;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ResourceUsageMonitor::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_messagesState,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_STATE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numMessages,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_messagesLowWatermarkRatio,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_LOW_WATERMARK_RATIO]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_messagesHighWatermarkRatio,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_HIGH_WATERMARK_RATIO]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_messagesCapacity,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_CAPACITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_bytesState,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_STATE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_bytesLowWatermarkRatio,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_LOW_WATERMARK_RATIO]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_bytesHighWatermarkRatio,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_HIGH_WATERMARK_RATIO]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_bytesCapacity,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_CAPACITY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ResourceUsageMonitor::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATE: {
        return accessor(d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    }
    case ATTRIBUTE_ID_MESSAGES_STATE: {
        return accessor(d_messagesState,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_STATE]);
    }
    case ATTRIBUTE_ID_NUM_MESSAGES: {
        return accessor(d_numMessages,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_MESSAGES]);
    }
    case ATTRIBUTE_ID_MESSAGES_LOW_WATERMARK_RATIO: {
        return accessor(d_messagesLowWatermarkRatio,
                        ATTRIBUTE_INFO_ARRAY
                            [ATTRIBUTE_INDEX_MESSAGES_LOW_WATERMARK_RATIO]);
    }
    case ATTRIBUTE_ID_MESSAGES_HIGH_WATERMARK_RATIO: {
        return accessor(d_messagesHighWatermarkRatio,
                        ATTRIBUTE_INFO_ARRAY
                            [ATTRIBUTE_INDEX_MESSAGES_HIGH_WATERMARK_RATIO]);
    }
    case ATTRIBUTE_ID_MESSAGES_CAPACITY: {
        return accessor(
            d_messagesCapacity,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MESSAGES_CAPACITY]);
    }
    case ATTRIBUTE_ID_BYTES_STATE: {
        return accessor(d_bytesState,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_STATE]);
    }
    case ATTRIBUTE_ID_NUM_BYTES: {
        return accessor(d_numBytes,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_BYTES]);
    }
    case ATTRIBUTE_ID_BYTES_LOW_WATERMARK_RATIO: {
        return accessor(
            d_bytesLowWatermarkRatio,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_LOW_WATERMARK_RATIO]);
    }
    case ATTRIBUTE_ID_BYTES_HIGH_WATERMARK_RATIO: {
        return accessor(
            d_bytesHighWatermarkRatio,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_HIGH_WATERMARK_RATIO]);
    }
    case ATTRIBUTE_ID_BYTES_CAPACITY: {
        return accessor(d_bytesCapacity,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_BYTES_CAPACITY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ResourceUsageMonitor::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline ResourceUsageMonitorState::Value ResourceUsageMonitor::state() const
{
    return d_state;
}

inline ResourceUsageMonitorState::Value
ResourceUsageMonitor::messagesState() const
{
    return d_messagesState;
}

inline bsls::Types::Int64 ResourceUsageMonitor::numMessages() const
{
    return d_numMessages;
}

inline bsls::Types::Int64
ResourceUsageMonitor::messagesLowWatermarkRatio() const
{
    return d_messagesLowWatermarkRatio;
}

inline bsls::Types::Int64
ResourceUsageMonitor::messagesHighWatermarkRatio() const
{
    return d_messagesHighWatermarkRatio;
}

inline bsls::Types::Int64 ResourceUsageMonitor::messagesCapacity() const
{
    return d_messagesCapacity;
}

inline ResourceUsageMonitorState::Value
ResourceUsageMonitor::bytesState() const
{
    return d_bytesState;
}

inline bsls::Types::Int64 ResourceUsageMonitor::numBytes() const
{
    return d_numBytes;
}

inline bsls::Types::Int64 ResourceUsageMonitor::bytesLowWatermarkRatio() const
{
    return d_bytesLowWatermarkRatio;
}

inline bsls::Types::Int64 ResourceUsageMonitor::bytesHighWatermarkRatio() const
{
    return d_bytesHighWatermarkRatio;
}

inline bsls::Types::Int64 ResourceUsageMonitor::bytesCapacity() const
{
    return d_bytesCapacity;
}

// -----------------------
// class RouteResponseList
// -----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RouteResponseList::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_responses,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RouteResponseList::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_RESPONSES: {
        return manipulator(&d_responses,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RouteResponseList::manipulateAttribute(t_MANIPULATOR& manipulator,
                                           const char*    name,
                                           int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<RouteResponse>& RouteResponseList::responses()
{
    return d_responses;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RouteResponseList::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_responses,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RouteResponseList::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_RESPONSES: {
        return accessor(d_responses,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RouteResponseList::accessAttribute(t_ACCESSOR& accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<RouteResponse>& RouteResponseList::responses() const
{
    return d_responses;
}

// ----------------------
// class SetTunableChoice
// ----------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void SetTunableChoice::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef SetTunableChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ALL:
        hashAppend(hashAlgorithm, this->all());
        break;
    case Class::SELECTION_ID_SELF:
        hashAppend(hashAlgorithm, this->self());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool SetTunableChoice::isEqualTo(const SetTunableChoice& rhs) const
{
    typedef SetTunableChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ALL: return this->all() == rhs.all();
        case Class::SELECTION_ID_SELF: return this->self() == rhs.self();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline SetTunableChoice::SetTunableChoice()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline SetTunableChoice::~SetTunableChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int SetTunableChoice::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case SetTunableChoice::SELECTION_ID_ALL:
        return manipulator(&d_all.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ALL]);
    case SetTunableChoice::SELECTION_ID_SELF:
        return manipulator(&d_self.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SELF]);
    default:
        BSLS_ASSERT(SetTunableChoice::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& SetTunableChoice::all()
{
    BSLS_ASSERT(SELECTION_ID_ALL == d_selectionId);
    return d_all.object();
}

inline Void& SetTunableChoice::self()
{
    BSLS_ASSERT(SELECTION_ID_SELF == d_selectionId);
    return d_self.object();
}

// ACCESSORS
inline int SetTunableChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int SetTunableChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ALL:
        return accessor(d_all.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ALL]);
    case SELECTION_ID_SELF:
        return accessor(d_self.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SELF]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& SetTunableChoice::all() const
{
    BSLS_ASSERT(SELECTION_ID_ALL == d_selectionId);
    return d_all.object();
}

inline const Void& SetTunableChoice::self() const
{
    BSLS_ASSERT(SELECTION_ID_SELF == d_selectionId);
    return d_self.object();
}

inline bool SetTunableChoice::isAllValue() const
{
    return SELECTION_ID_ALL == d_selectionId;
}

inline bool SetTunableChoice::isSelfValue() const
{
    return SELECTION_ID_SELF == d_selectionId;
}

inline bool SetTunableChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class StorageContent
// --------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageContent::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_storages,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StorageContent::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STORAGES: {
        return manipulator(&d_storages,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StorageContent::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<StorageQueueInfo>& StorageContent::storages()
{
    return d_storages;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StorageContent::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_storages, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StorageContent::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STORAGES: {
        return accessor(d_storages,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StorageContent::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<StorageQueueInfo>& StorageContent::storages() const
{
    return d_storages;
}

// --------------------------
// class StorageDomainCommand
// --------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StorageDomainCommand::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef StorageDomainCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_QUEUE_STATUS:
        hashAppend(hashAlgorithm, this->queueStatus());
        break;
    case Class::SELECTION_ID_PURGE:
        hashAppend(hashAlgorithm, this->purge());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
StorageDomainCommand::isEqualTo(const StorageDomainCommand& rhs) const
{
    typedef StorageDomainCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_QUEUE_STATUS:
            return this->queueStatus() == rhs.queueStatus();
        case Class::SELECTION_ID_PURGE: return this->purge() == rhs.purge();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline StorageDomainCommand::StorageDomainCommand()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline StorageDomainCommand::~StorageDomainCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageDomainCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StorageDomainCommand::SELECTION_ID_QUEUE_STATUS:
        return manipulator(&d_queueStatus.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_STATUS]);
    case StorageDomainCommand::SELECTION_ID_PURGE:
        return manipulator(&d_purge.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGE]);
    default:
        BSLS_ASSERT(StorageDomainCommand::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline Void& StorageDomainCommand::queueStatus()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_STATUS == d_selectionId);
    return d_queueStatus.object();
}

inline Void& StorageDomainCommand::purge()
{
    BSLS_ASSERT(SELECTION_ID_PURGE == d_selectionId);
    return d_purge.object();
}

// ACCESSORS
inline int StorageDomainCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int StorageDomainCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_QUEUE_STATUS:
        return accessor(d_queueStatus.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_STATUS]);
    case SELECTION_ID_PURGE:
        return accessor(d_purge.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& StorageDomainCommand::queueStatus() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_STATUS == d_selectionId);
    return d_queueStatus.object();
}

inline const Void& StorageDomainCommand::purge() const
{
    BSLS_ASSERT(SELECTION_ID_PURGE == d_selectionId);
    return d_purge.object();
}

inline bool StorageDomainCommand::isQueueStatusValue() const
{
    return SELECTION_ID_QUEUE_STATUS == d_selectionId;
}

inline bool StorageDomainCommand::isPurgeValue() const
{
    return SELECTION_ID_PURGE == d_selectionId;
}

inline bool StorageDomainCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------------------
// class StoragePartitionCommand
// -----------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StoragePartitionCommand::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef StoragePartitionCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ENABLE:
        hashAppend(hashAlgorithm, this->enable());
        break;
    case Class::SELECTION_ID_DISABLE:
        hashAppend(hashAlgorithm, this->disable());
        break;
    case Class::SELECTION_ID_SUMMARY:
        hashAppend(hashAlgorithm, this->summary());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
StoragePartitionCommand::isEqualTo(const StoragePartitionCommand& rhs) const
{
    typedef StoragePartitionCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ENABLE: return this->enable() == rhs.enable();
        case Class::SELECTION_ID_DISABLE:
            return this->disable() == rhs.disable();
        case Class::SELECTION_ID_SUMMARY:
            return this->summary() == rhs.summary();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline StoragePartitionCommand::StoragePartitionCommand()
: d_selectionId(SELECTION_ID_UNDEFINED)
{
}

inline StoragePartitionCommand::~StoragePartitionCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int StoragePartitionCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StoragePartitionCommand::SELECTION_ID_ENABLE:
        return manipulator(&d_enable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ENABLE]);
    case StoragePartitionCommand::SELECTION_ID_DISABLE:
        return manipulator(&d_disable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DISABLE]);
    case StoragePartitionCommand::SELECTION_ID_SUMMARY:
        return manipulator(&d_summary.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUMMARY]);
    default:
        BSLS_ASSERT(StoragePartitionCommand::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline Void& StoragePartitionCommand::enable()
{
    BSLS_ASSERT(SELECTION_ID_ENABLE == d_selectionId);
    return d_enable.object();
}

inline Void& StoragePartitionCommand::disable()
{
    BSLS_ASSERT(SELECTION_ID_DISABLE == d_selectionId);
    return d_disable.object();
}

inline Void& StoragePartitionCommand::summary()
{
    BSLS_ASSERT(SELECTION_ID_SUMMARY == d_selectionId);
    return d_summary.object();
}

// ACCESSORS
inline int StoragePartitionCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int StoragePartitionCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ENABLE:
        return accessor(d_enable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ENABLE]);
    case SELECTION_ID_DISABLE:
        return accessor(d_disable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DISABLE]);
    case SELECTION_ID_SUMMARY:
        return accessor(d_summary.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUMMARY]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& StoragePartitionCommand::enable() const
{
    BSLS_ASSERT(SELECTION_ID_ENABLE == d_selectionId);
    return d_enable.object();
}

inline const Void& StoragePartitionCommand::disable() const
{
    BSLS_ASSERT(SELECTION_ID_DISABLE == d_selectionId);
    return d_disable.object();
}

inline const Void& StoragePartitionCommand::summary() const
{
    BSLS_ASSERT(SELECTION_ID_SUMMARY == d_selectionId);
    return d_summary.object();
}

inline bool StoragePartitionCommand::isEnableValue() const
{
    return SELECTION_ID_ENABLE == d_selectionId;
}

inline bool StoragePartitionCommand::isDisableValue() const
{
    return SELECTION_ID_DISABLE == d_selectionId;
}

inline bool StoragePartitionCommand::isSummaryValue() const
{
    return SELECTION_ID_SUMMARY == d_selectionId;
}

inline bool StoragePartitionCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ------------------
// class StorageQueue
// ------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageQueue::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_canonicalUri,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CANONICAL_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StorageQueue::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CANONICAL_URI: {
        return manipulator(
            &d_canonicalUri,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CANONICAL_URI]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StorageQueue::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StorageQueue::canonicalUri()
{
    return d_canonicalUri;
}

inline StorageQueueCommand& StorageQueue::command()
{
    return d_command;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StorageQueue::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_canonicalUri,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CANONICAL_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StorageQueue::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CANONICAL_URI: {
        return accessor(d_canonicalUri,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CANONICAL_URI]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StorageQueue::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StorageQueue::canonicalUri() const
{
    return d_canonicalUri;
}

inline const StorageQueueCommand& StorageQueue::command() const
{
    return d_command;
}

// ------------------
// class Subscription
// ------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void Subscription::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->downstreamSubscriptionId());
    hashAppend(hashAlgorithm, this->consumer());
    hashAppend(hashAlgorithm, this->subscriber());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Subscription::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_downstreamSubscriptionId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOWNSTREAM_SUBSCRIPTION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumer,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_subscriber,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Subscription::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DOWNSTREAM_SUBSCRIPTION_ID: {
        return manipulator(
            &d_downstreamSubscriptionId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOWNSTREAM_SUBSCRIPTION_ID]);
    }
    case ATTRIBUTE_ID_CONSUMER: {
        return manipulator(&d_consumer,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER]);
    }
    case ATTRIBUTE_ID_SUBSCRIBER: {
        return manipulator(&d_subscriber,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Subscription::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& Subscription::downstreamSubscriptionId()
{
    return d_downstreamSubscriptionId;
}

inline ConsumerInfo& Subscription::consumer()
{
    return d_consumer;
}

inline Subscriber& Subscription::subscriber()
{
    return d_subscriber;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Subscription::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_downstreamSubscriptionId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOWNSTREAM_SUBSCRIPTION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumer, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_subscriber,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIBER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Subscription::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DOWNSTREAM_SUBSCRIPTION_ID: {
        return accessor(
            d_downstreamSubscriptionId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOWNSTREAM_SUBSCRIPTION_ID]);
    }
    case ATTRIBUTE_ID_CONSUMER: {
        return accessor(d_consumer,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER]);
    }
    case ATTRIBUTE_ID_SUBSCRIBER: {
        return accessor(d_subscriber,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIBER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Subscription::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int Subscription::downstreamSubscriptionId() const
{
    return d_downstreamSubscriptionId;
}

inline const ConsumerInfo& Subscription::consumer() const
{
    return d_consumer;
}

inline const Subscriber& Subscription::subscriber() const
{
    return d_subscriber;
}

// -----------
// class Value
// -----------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void Value::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef Value Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_THE_NULL:
        hashAppend(hashAlgorithm, this->theNull());
        break;
    case Class::SELECTION_ID_THE_BOOL:
        hashAppend(hashAlgorithm, this->theBool());
        break;
    case Class::SELECTION_ID_THE_INTEGER:
        hashAppend(hashAlgorithm, this->theInteger());
        break;
    case Class::SELECTION_ID_THE_DOUBLE:
        hashAppend(hashAlgorithm, this->theDouble());
        break;
    case Class::SELECTION_ID_THE_DATE:
        hashAppend(hashAlgorithm, this->theDate());
        break;
    case Class::SELECTION_ID_THE_TIME:
        hashAppend(hashAlgorithm, this->theTime());
        break;
    case Class::SELECTION_ID_THE_DATETIME:
        hashAppend(hashAlgorithm, this->theDatetime());
        break;
    case Class::SELECTION_ID_THE_STRING:
        hashAppend(hashAlgorithm, this->theString());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool Value::isEqualTo(const Value& rhs) const
{
    typedef Value Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_THE_NULL:
            return this->theNull() == rhs.theNull();
        case Class::SELECTION_ID_THE_BOOL:
            return this->theBool() == rhs.theBool();
        case Class::SELECTION_ID_THE_INTEGER:
            return this->theInteger() == rhs.theInteger();
        case Class::SELECTION_ID_THE_DOUBLE:
            return this->theDouble() == rhs.theDouble();
        case Class::SELECTION_ID_THE_DATE:
            return this->theDate() == rhs.theDate();
        case Class::SELECTION_ID_THE_TIME:
            return this->theTime() == rhs.theTime();
        case Class::SELECTION_ID_THE_DATETIME:
            return this->theDatetime() == rhs.theDatetime();
        case Class::SELECTION_ID_THE_STRING:
            return this->theString() == rhs.theString();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline Value::Value(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline Value::~Value()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int Value::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case Value::SELECTION_ID_THE_NULL:
        return manipulator(&d_theNull.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_NULL]);
    case Value::SELECTION_ID_THE_BOOL:
        return manipulator(&d_theBool.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_BOOL]);
    case Value::SELECTION_ID_THE_INTEGER:
        return manipulator(&d_theInteger.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_INTEGER]);
    case Value::SELECTION_ID_THE_DOUBLE:
        return manipulator(&d_theDouble.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_DOUBLE]);
    case Value::SELECTION_ID_THE_DATE:
        return manipulator(&d_theDate.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_DATE]);
    case Value::SELECTION_ID_THE_TIME:
        return manipulator(&d_theTime.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_TIME]);
    case Value::SELECTION_ID_THE_DATETIME:
        return manipulator(&d_theDatetime.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_DATETIME]);
    case Value::SELECTION_ID_THE_STRING:
        return manipulator(&d_theString.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_STRING]);
    default:
        BSLS_ASSERT(Value::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& Value::theNull()
{
    BSLS_ASSERT(SELECTION_ID_THE_NULL == d_selectionId);
    return d_theNull.object();
}

inline bool& Value::theBool()
{
    BSLS_ASSERT(SELECTION_ID_THE_BOOL == d_selectionId);
    return d_theBool.object();
}

inline bsls::Types::Int64& Value::theInteger()
{
    BSLS_ASSERT(SELECTION_ID_THE_INTEGER == d_selectionId);
    return d_theInteger.object();
}

inline double& Value::theDouble()
{
    BSLS_ASSERT(SELECTION_ID_THE_DOUBLE == d_selectionId);
    return d_theDouble.object();
}

inline bdlt::DateTz& Value::theDate()
{
    BSLS_ASSERT(SELECTION_ID_THE_DATE == d_selectionId);
    return d_theDate.object();
}

inline bdlt::TimeTz& Value::theTime()
{
    BSLS_ASSERT(SELECTION_ID_THE_TIME == d_selectionId);
    return d_theTime.object();
}

inline bdlt::DatetimeTz& Value::theDatetime()
{
    BSLS_ASSERT(SELECTION_ID_THE_DATETIME == d_selectionId);
    return d_theDatetime.object();
}

inline bsl::string& Value::theString()
{
    BSLS_ASSERT(SELECTION_ID_THE_STRING == d_selectionId);
    return d_theString.object();
}

// ACCESSORS
inline int Value::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int Value::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_THE_NULL:
        return accessor(d_theNull.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_NULL]);
    case SELECTION_ID_THE_BOOL:
        return accessor(d_theBool.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_BOOL]);
    case SELECTION_ID_THE_INTEGER:
        return accessor(d_theInteger.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_INTEGER]);
    case SELECTION_ID_THE_DOUBLE:
        return accessor(d_theDouble.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_DOUBLE]);
    case SELECTION_ID_THE_DATE:
        return accessor(d_theDate.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_DATE]);
    case SELECTION_ID_THE_TIME:
        return accessor(d_theTime.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_TIME]);
    case SELECTION_ID_THE_DATETIME:
        return accessor(d_theDatetime.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_DATETIME]);
    case SELECTION_ID_THE_STRING:
        return accessor(d_theString.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_THE_STRING]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& Value::theNull() const
{
    BSLS_ASSERT(SELECTION_ID_THE_NULL == d_selectionId);
    return d_theNull.object();
}

inline const bool& Value::theBool() const
{
    BSLS_ASSERT(SELECTION_ID_THE_BOOL == d_selectionId);
    return d_theBool.object();
}

inline const bsls::Types::Int64& Value::theInteger() const
{
    BSLS_ASSERT(SELECTION_ID_THE_INTEGER == d_selectionId);
    return d_theInteger.object();
}

inline const double& Value::theDouble() const
{
    BSLS_ASSERT(SELECTION_ID_THE_DOUBLE == d_selectionId);
    return d_theDouble.object();
}

inline const bdlt::DateTz& Value::theDate() const
{
    BSLS_ASSERT(SELECTION_ID_THE_DATE == d_selectionId);
    return d_theDate.object();
}

inline const bdlt::TimeTz& Value::theTime() const
{
    BSLS_ASSERT(SELECTION_ID_THE_TIME == d_selectionId);
    return d_theTime.object();
}

inline const bdlt::DatetimeTz& Value::theDatetime() const
{
    BSLS_ASSERT(SELECTION_ID_THE_DATETIME == d_selectionId);
    return d_theDatetime.object();
}

inline const bsl::string& Value::theString() const
{
    BSLS_ASSERT(SELECTION_ID_THE_STRING == d_selectionId);
    return d_theString.object();
}

inline bool Value::isTheNullValue() const
{
    return SELECTION_ID_THE_NULL == d_selectionId;
}

inline bool Value::isTheBoolValue() const
{
    return SELECTION_ID_THE_BOOL == d_selectionId;
}

inline bool Value::isTheIntegerValue() const
{
    return SELECTION_ID_THE_INTEGER == d_selectionId;
}

inline bool Value::isTheDoubleValue() const
{
    return SELECTION_ID_THE_DOUBLE == d_selectionId;
}

inline bool Value::isTheDateValue() const
{
    return SELECTION_ID_THE_DATE == d_selectionId;
}

inline bool Value::isTheTimeValue() const
{
    return SELECTION_ID_THE_TIME == d_selectionId;
}

inline bool Value::isTheDatetimeValue() const
{
    return SELECTION_ID_THE_DATETIME == d_selectionId;
}

inline bool Value::isTheStringValue() const
{
    return SELECTION_ID_THE_STRING == d_selectionId;
}

inline bool Value::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------
// class ClusterList
// -----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterList::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clusters,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterList::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTERS: {
        return manipulator(&d_clusters,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterList::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<ClusterInfo>& ClusterList::clusters()
{
    return d_clusters;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterList::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clusters, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterList::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTERS: {
        return accessor(d_clusters,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterList::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<ClusterInfo>& ClusterList::clusters() const
{
    return d_clusters;
}

// ------------------------
// class ClusterQueueHelper
// ------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterQueueHelper::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->clusterName());
    hashAppend(hashAlgorithm, this->locality());
    hashAppend(hashAlgorithm, this->numQueues());
    hashAppend(hashAlgorithm, this->numQueueKeys());
    hashAppend(hashAlgorithm, this->numPendingReopenQueueRequests());
    hashAppend(hashAlgorithm, this->domains());
    hashAppend(hashAlgorithm, this->queues());
}

inline bool ClusterQueueHelper::isEqualTo(const ClusterQueueHelper& rhs) const
{
    return this->clusterName() == rhs.clusterName() &&
           this->locality() == rhs.locality() &&
           this->numQueues() == rhs.numQueues() &&
           this->numQueueKeys() == rhs.numQueueKeys() &&
           this->numPendingReopenQueueRequests() ==
               rhs.numPendingReopenQueueRequests() &&
           this->domains() == rhs.domains() && this->queues() == rhs.queues();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterQueueHelper::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_locality,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOCALITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numQueues,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numQueueKeys,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUE_KEYS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numPendingReopenQueueRequests,
                      ATTRIBUTE_INFO_ARRAY
                          [ATTRIBUTE_INDEX_NUM_PENDING_REOPEN_QUEUE_REQUESTS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_domains,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAINS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterQueueHelper::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_LOCALITY: {
        return manipulator(&d_locality,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOCALITY]);
    }
    case ATTRIBUTE_ID_NUM_QUEUES: {
        return manipulator(&d_numQueues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUES]);
    }
    case ATTRIBUTE_ID_NUM_QUEUE_KEYS: {
        return manipulator(
            &d_numQueueKeys,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUE_KEYS]);
    }
    case ATTRIBUTE_ID_NUM_PENDING_REOPEN_QUEUE_REQUESTS: {
        return manipulator(
            &d_numPendingReopenQueueRequests,
            ATTRIBUTE_INFO_ARRAY
                [ATTRIBUTE_INDEX_NUM_PENDING_REOPEN_QUEUE_REQUESTS]);
    }
    case ATTRIBUTE_ID_DOMAINS: {
        return manipulator(&d_domains,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAINS]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterQueueHelper::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClusterQueueHelper::clusterName()
{
    return d_clusterName;
}

inline Locality::Value& ClusterQueueHelper::locality()
{
    return d_locality;
}

inline unsigned int& ClusterQueueHelper::numQueues()
{
    return d_numQueues;
}

inline unsigned int& ClusterQueueHelper::numQueueKeys()
{
    return d_numQueueKeys;
}

inline unsigned int& ClusterQueueHelper::numPendingReopenQueueRequests()
{
    return d_numPendingReopenQueueRequests;
}

inline bsl::vector<ClusterDomain>& ClusterQueueHelper::domains()
{
    return d_domains;
}

inline bsl::vector<ClusterQueue>& ClusterQueueHelper::queues()
{
    return d_queues;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterQueueHelper::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_locality, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOCALITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numQueues,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numQueueKeys,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUE_KEYS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numPendingReopenQueueRequests,
                   ATTRIBUTE_INFO_ARRAY
                       [ATTRIBUTE_INDEX_NUM_PENDING_REOPEN_QUEUE_REQUESTS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_domains, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAINS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterQueueHelper::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_LOCALITY: {
        return accessor(d_locality,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_LOCALITY]);
    }
    case ATTRIBUTE_ID_NUM_QUEUES: {
        return accessor(d_numQueues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUES]);
    }
    case ATTRIBUTE_ID_NUM_QUEUE_KEYS: {
        return accessor(d_numQueueKeys,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_QUEUE_KEYS]);
    }
    case ATTRIBUTE_ID_NUM_PENDING_REOPEN_QUEUE_REQUESTS: {
        return accessor(
            d_numPendingReopenQueueRequests,
            ATTRIBUTE_INFO_ARRAY
                [ATTRIBUTE_INDEX_NUM_PENDING_REOPEN_QUEUE_REQUESTS]);
    }
    case ATTRIBUTE_ID_DOMAINS: {
        return accessor(d_domains,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DOMAINS]);
    }
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterQueueHelper::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ClusterQueueHelper::clusterName() const
{
    return d_clusterName;
}

inline Locality::Value ClusterQueueHelper::locality() const
{
    return d_locality;
}

inline unsigned int ClusterQueueHelper::numQueues() const
{
    return d_numQueues;
}

inline unsigned int ClusterQueueHelper::numQueueKeys() const
{
    return d_numQueueKeys;
}

inline unsigned int ClusterQueueHelper::numPendingReopenQueueRequests() const
{
    return d_numPendingReopenQueueRequests;
}

inline const bsl::vector<ClusterDomain>& ClusterQueueHelper::domains() const
{
    return d_domains;
}

inline const bsl::vector<ClusterQueue>& ClusterQueueHelper::queues() const
{
    return d_queues;
}

// ---------------------------
// class ConfigProviderCommand
// ---------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ConfigProviderCommand::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ConfigProviderCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_CLEAR_CACHE:
        hashAppend(hashAlgorithm, this->clearCache());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
ConfigProviderCommand::isEqualTo(const ConfigProviderCommand& rhs) const
{
    typedef ConfigProviderCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_CLEAR_CACHE:
            return this->clearCache() == rhs.clearCache();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ConfigProviderCommand::ConfigProviderCommand(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ConfigProviderCommand::~ConfigProviderCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ConfigProviderCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ConfigProviderCommand::SELECTION_ID_CLEAR_CACHE:
        return manipulator(&d_clearCache.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLEAR_CACHE]);
    default:
        BSLS_ASSERT(ConfigProviderCommand::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ClearCache& ConfigProviderCommand::clearCache()
{
    BSLS_ASSERT(SELECTION_ID_CLEAR_CACHE == d_selectionId);
    return d_clearCache.object();
}

// ACCESSORS
inline int ConfigProviderCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ConfigProviderCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_CLEAR_CACHE:
        return accessor(d_clearCache.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLEAR_CACHE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ClearCache& ConfigProviderCommand::clearCache() const
{
    BSLS_ASSERT(SELECTION_ID_CLEAR_CACHE == d_selectionId);
    return d_clearCache.object();
}

inline bool ConfigProviderCommand::isClearCacheValue() const
{
    return SELECTION_ID_CLEAR_CACHE == d_selectionId;
}

inline bool ConfigProviderCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------
// class DomainInfo
// ----------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DomainInfo::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->name());
    hashAppend(hashAlgorithm, this->configJson());
    hashAppend(hashAlgorithm, this->clusterName());
    hashAppend(hashAlgorithm, this->capacityMeter());
    hashAppend(hashAlgorithm, this->queueUris());
    hashAppend(hashAlgorithm, this->storageContent());
}

inline bool DomainInfo::isEqualTo(const DomainInfo& rhs) const
{
    return this->name() == rhs.name() &&
           this->configJson() == rhs.configJson() &&
           this->clusterName() == rhs.clusterName() &&
           this->capacityMeter() == rhs.capacityMeter() &&
           this->queueUris() == rhs.queueUris() &&
           this->storageContent() == rhs.storageContent();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int DomainInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_configJson,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONFIG_JSON]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_clusterName,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    BSLS_ASSERT(d_capacityMeter);
    ret = manipulator(d_capacityMeter,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CAPACITY_METER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queueUris,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URIS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_storageContent,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_CONTENT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int DomainInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_CONFIG_JSON: {
        return manipulator(&d_configJson,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONFIG_JSON]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return manipulator(&d_clusterName,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CAPACITY_METER: {
        BSLS_ASSERT(d_capacityMeter);
        return manipulator(
            d_capacityMeter,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CAPACITY_METER]);
    }
    case ATTRIBUTE_ID_QUEUE_URIS: {
        return manipulator(&d_queueUris,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URIS]);
    }
    case ATTRIBUTE_ID_STORAGE_CONTENT: {
        return manipulator(
            &d_storageContent,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_CONTENT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int DomainInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& DomainInfo::name()
{
    return d_name;
}

inline bsl::string& DomainInfo::configJson()
{
    return d_configJson;
}

inline bsl::string& DomainInfo::clusterName()
{
    return d_clusterName;
}

inline CapacityMeter& DomainInfo::capacityMeter()
{
    BSLS_ASSERT(d_capacityMeter);
    return *d_capacityMeter;
}

inline bsl::vector<bsl::string>& DomainInfo::queueUris()
{
    return d_queueUris;
}

inline StorageContent& DomainInfo::storageContent()
{
    return d_storageContent;
}

// ACCESSORS
template <typename t_ACCESSOR>
int DomainInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_configJson,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONFIG_JSON]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_clusterName,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    if (ret) {
        return ret;
    }

    BSLS_ASSERT(d_capacityMeter);
    ret = accessor(*d_capacityMeter,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CAPACITY_METER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queueUris,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URIS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_storageContent,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_CONTENT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int DomainInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_CONFIG_JSON: {
        return accessor(d_configJson,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONFIG_JSON]);
    }
    case ATTRIBUTE_ID_CLUSTER_NAME: {
        return accessor(d_clusterName,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_NAME]);
    }
    case ATTRIBUTE_ID_CAPACITY_METER: {
        BSLS_ASSERT(d_capacityMeter);
        return accessor(*d_capacityMeter,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CAPACITY_METER]);
    }
    case ATTRIBUTE_ID_QUEUE_URIS: {
        return accessor(d_queueUris,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_URIS]);
    }
    case ATTRIBUTE_ID_STORAGE_CONTENT: {
        return accessor(d_storageContent,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_CONTENT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int DomainInfo::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& DomainInfo::name() const
{
    return d_name;
}

inline const bsl::string& DomainInfo::configJson() const
{
    return d_configJson;
}

inline const bsl::string& DomainInfo::clusterName() const
{
    return d_clusterName;
}

inline const CapacityMeter& DomainInfo::capacityMeter() const
{
    BSLS_ASSERT(d_capacityMeter);
    return *d_capacityMeter;
}

inline const bsl::vector<bsl::string>& DomainInfo::queueUris() const
{
    return d_queueUris;
}

inline const StorageContent& DomainInfo::storageContent() const
{
    return d_storageContent;
}

// -----------------
// class DomainQueue
// -----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int DomainQueue::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int DomainQueue::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int DomainQueue::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& DomainQueue::name()
{
    return d_name;
}

inline QueueCommand& DomainQueue::command()
{
    return d_command;
}

// ACCESSORS
template <typename t_ACCESSOR>
int DomainQueue::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int DomainQueue::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int DomainQueue::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& DomainQueue::name() const
{
    return d_name;
}

inline const QueueCommand& DomainQueue::command() const
{
    return d_command;
}

// ---------------------------
// class DomainResolverCommand
// ---------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DomainResolverCommand::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef DomainResolverCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_CLEAR_CACHE:
        hashAppend(hashAlgorithm, this->clearCache());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
DomainResolverCommand::isEqualTo(const DomainResolverCommand& rhs) const
{
    typedef DomainResolverCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_CLEAR_CACHE:
            return this->clearCache() == rhs.clearCache();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline DomainResolverCommand::DomainResolverCommand(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline DomainResolverCommand::~DomainResolverCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int DomainResolverCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case DomainResolverCommand::SELECTION_ID_CLEAR_CACHE:
        return manipulator(&d_clearCache.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLEAR_CACHE]);
    default:
        BSLS_ASSERT(DomainResolverCommand::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ClearCache& DomainResolverCommand::clearCache()
{
    BSLS_ASSERT(SELECTION_ID_CLEAR_CACHE == d_selectionId);
    return d_clearCache.object();
}

// ACCESSORS
inline int DomainResolverCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int DomainResolverCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_CLEAR_CACHE:
        return accessor(d_clearCache.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLEAR_CACHE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ClearCache& DomainResolverCommand::clearCache() const
{
    BSLS_ASSERT(SELECTION_ID_CLEAR_CACHE == d_selectionId);
    return d_clearCache.object();
}

inline bool DomainResolverCommand::isClearCacheValue() const
{
    return SELECTION_ID_CLEAR_CACHE == d_selectionId;
}

inline bool DomainResolverCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------------
// class FileStoreSummary
// ----------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void FileStoreSummary::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->primaryNodeDescription());
    hashAppend(hashAlgorithm, this->primaryLeaseId());
    hashAppend(hashAlgorithm, this->sequenceNum());
    hashAppend(hashAlgorithm, this->isAvailable());
    hashAppend(hashAlgorithm, this->fileSets());
    hashAppend(hashAlgorithm, this->activeFileSet());
    hashAppend(hashAlgorithm, this->totalMappedBytes());
    hashAppend(hashAlgorithm, this->numOutstandingRecords());
    hashAppend(hashAlgorithm, this->numUnreceiptedMessages());
    hashAppend(hashAlgorithm, this->naglePacketCount());
    hashAppend(hashAlgorithm, this->storageContent());
}

inline bool FileStoreSummary::isEqualTo(const FileStoreSummary& rhs) const
{
    return this->primaryNodeDescription() == rhs.primaryNodeDescription() &&
           this->primaryLeaseId() == rhs.primaryLeaseId() &&
           this->sequenceNum() == rhs.sequenceNum() &&
           this->isAvailable() == rhs.isAvailable() &&
           this->fileSets() == rhs.fileSets() &&
           this->activeFileSet() == rhs.activeFileSet() &&
           this->totalMappedBytes() == rhs.totalMappedBytes() &&
           this->numOutstandingRecords() == rhs.numOutstandingRecords() &&
           this->numUnreceiptedMessages() == rhs.numUnreceiptedMessages() &&
           this->naglePacketCount() == rhs.naglePacketCount() &&
           this->storageContent() == rhs.storageContent();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FileStoreSummary::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_primaryNodeDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_primaryLeaseId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_sequenceNum,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isAvailable,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_fileSets,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FILE_SETS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_activeFileSet,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ACTIVE_FILE_SET]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_totalMappedBytes,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TOTAL_MAPPED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numOutstandingRecords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_OUTSTANDING_RECORDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numUnreceiptedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UNRECEIPTED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_naglePacketCount,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAGLE_PACKET_COUNT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_storageContent,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_CONTENT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int FileStoreSummary::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_NODE_DESCRIPTION: {
        return manipulator(
            &d_primaryNodeDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return manipulator(
            &d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return manipulator(&d_sequenceNum,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_IS_AVAILABLE: {
        return manipulator(&d_isAvailable,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    }
    case ATTRIBUTE_ID_FILE_SETS: {
        return manipulator(&d_fileSets,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FILE_SETS]);
    }
    case ATTRIBUTE_ID_ACTIVE_FILE_SET: {
        return manipulator(
            &d_activeFileSet,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ACTIVE_FILE_SET]);
    }
    case ATTRIBUTE_ID_TOTAL_MAPPED_BYTES: {
        return manipulator(
            &d_totalMappedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TOTAL_MAPPED_BYTES]);
    }
    case ATTRIBUTE_ID_NUM_OUTSTANDING_RECORDS: {
        return manipulator(
            &d_numOutstandingRecords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_OUTSTANDING_RECORDS]);
    }
    case ATTRIBUTE_ID_NUM_UNRECEIPTED_MESSAGES: {
        return manipulator(
            &d_numUnreceiptedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UNRECEIPTED_MESSAGES]);
    }
    case ATTRIBUTE_ID_NAGLE_PACKET_COUNT: {
        return manipulator(
            &d_naglePacketCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAGLE_PACKET_COUNT]);
    }
    case ATTRIBUTE_ID_STORAGE_CONTENT: {
        return manipulator(
            &d_storageContent,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_CONTENT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FileStoreSummary::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& FileStoreSummary::primaryNodeDescription()
{
    return d_primaryNodeDescription;
}

inline unsigned int& FileStoreSummary::primaryLeaseId()
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64& FileStoreSummary::sequenceNum()
{
    return d_sequenceNum;
}

inline bool& FileStoreSummary::isAvailable()
{
    return d_isAvailable;
}

inline bsl::vector<FileSet>& FileStoreSummary::fileSets()
{
    return d_fileSets;
}

inline ActiveFileSet& FileStoreSummary::activeFileSet()
{
    return d_activeFileSet;
}

inline bsls::Types::Uint64& FileStoreSummary::totalMappedBytes()
{
    return d_totalMappedBytes;
}

inline unsigned int& FileStoreSummary::numOutstandingRecords()
{
    return d_numOutstandingRecords;
}

inline unsigned int& FileStoreSummary::numUnreceiptedMessages()
{
    return d_numUnreceiptedMessages;
}

inline unsigned int& FileStoreSummary::naglePacketCount()
{
    return d_naglePacketCount;
}

inline StorageContent& FileStoreSummary::storageContent()
{
    return d_storageContent;
}

// ACCESSORS
template <typename t_ACCESSOR>
int FileStoreSummary::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_primaryNodeDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_primaryLeaseId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_sequenceNum,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isAvailable,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_fileSets,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FILE_SETS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_activeFileSet,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ACTIVE_FILE_SET]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_totalMappedBytes,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TOTAL_MAPPED_BYTES]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_numOutstandingRecords,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_OUTSTANDING_RECORDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_numUnreceiptedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UNRECEIPTED_MESSAGES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_naglePacketCount,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAGLE_PACKET_COUNT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_storageContent,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_CONTENT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int FileStoreSummary::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIMARY_NODE_DESCRIPTION: {
        return accessor(
            d_primaryNodeDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_NODE_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_PRIMARY_LEASE_ID: {
        return accessor(
            d_primaryLeaseId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIMARY_LEASE_ID]);
    }
    case ATTRIBUTE_ID_SEQUENCE_NUM: {
        return accessor(d_sequenceNum,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SEQUENCE_NUM]);
    }
    case ATTRIBUTE_ID_IS_AVAILABLE: {
        return accessor(d_isAvailable,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AVAILABLE]);
    }
    case ATTRIBUTE_ID_FILE_SETS: {
        return accessor(d_fileSets,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FILE_SETS]);
    }
    case ATTRIBUTE_ID_ACTIVE_FILE_SET: {
        return accessor(d_activeFileSet,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ACTIVE_FILE_SET]);
    }
    case ATTRIBUTE_ID_TOTAL_MAPPED_BYTES: {
        return accessor(
            d_totalMappedBytes,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TOTAL_MAPPED_BYTES]);
    }
    case ATTRIBUTE_ID_NUM_OUTSTANDING_RECORDS: {
        return accessor(
            d_numOutstandingRecords,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_OUTSTANDING_RECORDS]);
    }
    case ATTRIBUTE_ID_NUM_UNRECEIPTED_MESSAGES: {
        return accessor(
            d_numUnreceiptedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UNRECEIPTED_MESSAGES]);
    }
    case ATTRIBUTE_ID_NAGLE_PACKET_COUNT: {
        return accessor(
            d_naglePacketCount,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAGLE_PACKET_COUNT]);
    }
    case ATTRIBUTE_ID_STORAGE_CONTENT: {
        return accessor(d_storageContent,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE_CONTENT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FileStoreSummary::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& FileStoreSummary::primaryNodeDescription() const
{
    return d_primaryNodeDescription;
}

inline unsigned int FileStoreSummary::primaryLeaseId() const
{
    return d_primaryLeaseId;
}

inline bsls::Types::Uint64 FileStoreSummary::sequenceNum() const
{
    return d_sequenceNum;
}

inline bool FileStoreSummary::isAvailable() const
{
    return d_isAvailable;
}

inline const bsl::vector<FileSet>& FileStoreSummary::fileSets() const
{
    return d_fileSets;
}

inline const ActiveFileSet& FileStoreSummary::activeFileSet() const
{
    return d_activeFileSet;
}

inline bsls::Types::Uint64 FileStoreSummary::totalMappedBytes() const
{
    return d_totalMappedBytes;
}

inline unsigned int FileStoreSummary::numOutstandingRecords() const
{
    return d_numOutstandingRecords;
}

inline unsigned int FileStoreSummary::numUnreceiptedMessages() const
{
    return d_numUnreceiptedMessages;
}

inline unsigned int FileStoreSummary::naglePacketCount() const
{
    return d_naglePacketCount;
}

inline const StorageContent& FileStoreSummary::storageContent() const
{
    return d_storageContent;
}

// ----------------
// class GetTunable
// ----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int GetTunable::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int GetTunable::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int GetTunable::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& GetTunable::name()
{
    return d_name;
}

inline GetTunableChoice& GetTunable::choice()
{
    return d_choice;
}

// ACCESSORS
template <typename t_ACCESSOR>
int GetTunable::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int GetTunable::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int GetTunable::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& GetTunable::name() const
{
    return d_name;
}

inline const GetTunableChoice& GetTunable::choice() const
{
    return d_choice;
}

// --------------------------
// class MessageGroupIdHelper
// --------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void MessageGroupIdHelper::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->timeoutNanoseconds());
    hashAppend(hashAlgorithm, this->maxMsgGroupIds());
    hashAppend(hashAlgorithm, this->isRebalanceOn());
    hashAppend(hashAlgorithm, this->status());
}

inline bool
MessageGroupIdHelper::isEqualTo(const MessageGroupIdHelper& rhs) const
{
    return this->timeoutNanoseconds() == rhs.timeoutNanoseconds() &&
           this->maxMsgGroupIds() == rhs.maxMsgGroupIds() &&
           this->isRebalanceOn() == rhs.isRebalanceOn() &&
           this->status() == rhs.status();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int MessageGroupIdHelper::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_timeoutNanoseconds,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TIMEOUT_NANOSECONDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_maxMsgGroupIds,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_MSG_GROUP_IDS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isRebalanceOn,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_REBALANCE_ON]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int MessageGroupIdHelper::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TIMEOUT_NANOSECONDS: {
        return manipulator(
            &d_timeoutNanoseconds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TIMEOUT_NANOSECONDS]);
    }
    case ATTRIBUTE_ID_MAX_MSG_GROUP_IDS: {
        return manipulator(
            &d_maxMsgGroupIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_MSG_GROUP_IDS]);
    }
    case ATTRIBUTE_ID_IS_REBALANCE_ON: {
        return manipulator(
            &d_isRebalanceOn,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_REBALANCE_ON]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int MessageGroupIdHelper::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Int64& MessageGroupIdHelper::timeoutNanoseconds()
{
    return d_timeoutNanoseconds;
}

inline int& MessageGroupIdHelper::maxMsgGroupIds()
{
    return d_maxMsgGroupIds;
}

inline bool& MessageGroupIdHelper::isRebalanceOn()
{
    return d_isRebalanceOn;
}

inline MessageGroupIdManagerIndex& MessageGroupIdHelper::status()
{
    return d_status;
}

// ACCESSORS
template <typename t_ACCESSOR>
int MessageGroupIdHelper::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_timeoutNanoseconds,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TIMEOUT_NANOSECONDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_maxMsgGroupIds,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_MSG_GROUP_IDS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isRebalanceOn,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_REBALANCE_ON]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int MessageGroupIdHelper::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TIMEOUT_NANOSECONDS: {
        return accessor(
            d_timeoutNanoseconds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TIMEOUT_NANOSECONDS]);
    }
    case ATTRIBUTE_ID_MAX_MSG_GROUP_IDS: {
        return accessor(
            d_maxMsgGroupIds,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_MSG_GROUP_IDS]);
    }
    case ATTRIBUTE_ID_IS_REBALANCE_ON: {
        return accessor(d_isRebalanceOn,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_REBALANCE_ON]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int MessageGroupIdHelper::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Int64 MessageGroupIdHelper::timeoutNanoseconds() const
{
    return d_timeoutNanoseconds;
}

inline int MessageGroupIdHelper::maxMsgGroupIds() const
{
    return d_maxMsgGroupIds;
}

inline bool MessageGroupIdHelper::isRebalanceOn() const
{
    return d_isRebalanceOn;
}

inline const MessageGroupIdManagerIndex& MessageGroupIdHelper::status() const
{
    return d_status;
}

// ------------------
// class NodeStatuses
// ------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int NodeStatuses::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_nodes, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int NodeStatuses::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NODES: {
        return manipulator(&d_nodes,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int NodeStatuses::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<ClusterNodeInfo>& NodeStatuses::nodes()
{
    return d_nodes;
}

// ACCESSORS
template <typename t_ACCESSOR>
int NodeStatuses::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_nodes, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int NodeStatuses::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NODES: {
        return accessor(d_nodes, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int NodeStatuses::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<ClusterNodeInfo>& NodeStatuses::nodes() const
{
    return d_nodes;
}

// --------------------
// class PartitionsInfo
// --------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PartitionsInfo::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitions,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PartitionsInfo::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITIONS: {
        return manipulator(&d_partitions,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PartitionsInfo::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<PartitionInfo>& PartitionsInfo::partitions()
{
    return d_partitions;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PartitionsInfo::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitions,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PartitionsInfo::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITIONS: {
        return accessor(d_partitions,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PartitionsInfo::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<PartitionInfo>& PartitionsInfo::partitions() const
{
    return d_partitions;
}

// -------------------
// class PriorityGroup
// -------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PriorityGroup::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_highestSubscriptions,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HIGHEST_SUBSCRIPTIONS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PriorityGroup::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ID: {
        return manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_HIGHEST_SUBSCRIPTIONS: {
        return manipulator(
            &d_highestSubscriptions,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HIGHEST_SUBSCRIPTIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PriorityGroup::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& PriorityGroup::id()
{
    return d_id;
}

inline bsl::vector<Subscription>& PriorityGroup::highestSubscriptions()
{
    return d_highestSubscriptions;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PriorityGroup::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_highestSubscriptions,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HIGHEST_SUBSCRIPTIONS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PriorityGroup::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ID: {
        return accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_HIGHEST_SUBSCRIPTIONS: {
        return accessor(
            d_highestSubscriptions,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HIGHEST_SUBSCRIPTIONS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PriorityGroup::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int PriorityGroup::id() const
{
    return d_id;
}

inline const bsl::vector<Subscription>&
PriorityGroup::highestSubscriptions() const
{
    return d_highestSubscriptions;
}

// ------------------
// class PurgedQueues
// ------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int PurgedQueues::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int PurgedQueues::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUES: {
        return manipulator(&d_queues,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int PurgedQueues::manipulateAttribute(t_MANIPULATOR& manipulator,
                                      const char*    name,
                                      int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<PurgeQueueResult>& PurgedQueues::queues()
{
    return d_queues;
}

// ACCESSORS
template <typename t_ACCESSOR>
int PurgedQueues::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queues, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int PurgedQueues::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUES: {
        return accessor(d_queues,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int PurgedQueues::accessAttribute(t_ACCESSOR& accessor,
                                  const char* name,
                                  int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<PurgeQueueResult>& PurgedQueues::queues() const
{
    return d_queues;
}

// --------------------------
// class QueueHandleSubStream
// --------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueHandleSubStream::hashAppendImpl(
    t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->subId());
    hashAppend(hashAlgorithm, this->appId());
    hashAppend(hashAlgorithm, this->parametersJson());
    hashAppend(hashAlgorithm, this->unconfirmedMonitors());
    hashAppend(hashAlgorithm, this->numUnconfirmedMessages());
}

inline bool
QueueHandleSubStream::isEqualTo(const QueueHandleSubStream& rhs) const
{
    return this->subId() == rhs.subId() && this->appId() == rhs.appId() &&
           this->parametersJson() == rhs.parametersJson() &&
           this->unconfirmedMonitors() == rhs.unconfirmedMonitors() &&
           this->numUnconfirmedMessages() == rhs.numUnconfirmedMessages();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueHandleSubStream::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_parametersJson,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_unconfirmedMonitors,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UNCONFIRMED_MONITORS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueHandleSubStream::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID: {
        return manipulator(&d_subId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_PARAMETERS_JSON: {
        return manipulator(
            &d_parametersJson,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARAMETERS_JSON]);
    }
    case ATTRIBUTE_ID_UNCONFIRMED_MONITORS: {
        return manipulator(
            &d_unconfirmedMonitors,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UNCONFIRMED_MONITORS]);
    }
    case ATTRIBUTE_ID_NUM_UNCONFIRMED_MESSAGES: {
        return manipulator(
            &d_numUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UNCONFIRMED_MESSAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueHandleSubStream::manipulateAttribute(t_MANIPULATOR& manipulator,
                                              const char*    name,
                                              int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& QueueHandleSubStream::subId()
{
    return d_subId;
}

inline bdlb::NullableValue<bsl::string>& QueueHandleSubStream::appId()
{
    return d_appId;
}

inline bsl::string& QueueHandleSubStream::parametersJson()
{
    return d_parametersJson;
}

inline bsl::vector<ResourceUsageMonitor>&
QueueHandleSubStream::unconfirmedMonitors()
{
    return d_unconfirmedMonitors;
}

inline bdlb::NullableValue<bsls::Types::Int64>&
QueueHandleSubStream::numUnconfirmedMessages()
{
    return d_numUnconfirmedMessages;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueHandleSubStream::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_parametersJson,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_unconfirmedMonitors,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UNCONFIRMED_MONITORS]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_numUnconfirmedMessages,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UNCONFIRMED_MESSAGES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueHandleSubStream::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUB_ID: {
        return accessor(d_subId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_ID]);
    }
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_PARAMETERS_JSON: {
        return accessor(d_parametersJson,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARAMETERS_JSON]);
    }
    case ATTRIBUTE_ID_UNCONFIRMED_MONITORS: {
        return accessor(
            d_unconfirmedMonitors,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UNCONFIRMED_MONITORS]);
    }
    case ATTRIBUTE_ID_NUM_UNCONFIRMED_MESSAGES: {
        return accessor(
            d_numUnconfirmedMessages,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UNCONFIRMED_MESSAGES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueHandleSubStream::accessAttribute(t_ACCESSOR& accessor,
                                          const char* name,
                                          int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int QueueHandleSubStream::subId() const
{
    return d_subId;
}

inline const bdlb::NullableValue<bsl::string>&
QueueHandleSubStream::appId() const
{
    return d_appId;
}

inline const bsl::string& QueueHandleSubStream::parametersJson() const
{
    return d_parametersJson;
}

inline const bsl::vector<ResourceUsageMonitor>&
QueueHandleSubStream::unconfirmedMonitors() const
{
    return d_unconfirmedMonitors;
}

inline const bdlb::NullableValue<bsls::Types::Int64>&
QueueHandleSubStream::numUnconfirmedMessages() const
{
    return d_numUnconfirmedMessages;
}

// -------------------
// class QueueStatuses
// -------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueStatuses::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queueStatuses,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_STATUSES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueStatuses::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_STATUSES: {
        return manipulator(
            &d_queueStatuses,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_STATUSES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueStatuses::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<StorageContent>& QueueStatuses::queueStatuses()
{
    return d_queueStatuses;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueStatuses::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queueStatuses,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_STATUSES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueStatuses::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_STATUSES: {
        return accessor(d_queueStatuses,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_STATUSES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueStatuses::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<StorageContent>& QueueStatuses::queueStatuses() const
{
    return d_queueStatuses;
}

// ----------------
// class SetTunable
// ----------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void SetTunable::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->name());
    hashAppend(hashAlgorithm, this->value());
    hashAppend(hashAlgorithm, this->choice());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int SetTunable::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_value, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VALUE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int SetTunable::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_VALUE: {
        return manipulator(&d_value,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VALUE]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int SetTunable::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& SetTunable::name()
{
    return d_name;
}

inline Value& SetTunable::value()
{
    return d_value;
}

inline SetTunableChoice& SetTunable::choice()
{
    return d_choice;
}

// ACCESSORS
template <typename t_ACCESSOR>
int SetTunable::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_value, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VALUE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int SetTunable::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_VALUE: {
        return accessor(d_value, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VALUE]);
    }
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int SetTunable::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& SetTunable::name() const
{
    return d_name;
}

inline const Value& SetTunable::value() const
{
    return d_value;
}

inline const SetTunableChoice& SetTunable::choice() const
{
    return d_choice;
}

// -------------------
// class StorageDomain
// -------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageDomain::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StorageDomain::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StorageDomain::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& StorageDomain::name()
{
    return d_name;
}

inline StorageDomainCommand& StorageDomain::command()
{
    return d_command;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StorageDomain::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StorageDomain::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StorageDomain::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& StorageDomain::name() const
{
    return d_name;
}

inline const StorageDomainCommand& StorageDomain::command() const
{
    return d_command;
}

// ----------------------
// class StoragePartition
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int StoragePartition::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int StoragePartition::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int StoragePartition::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& StoragePartition::partitionId()
{
    return d_partitionId;
}

inline StoragePartitionCommand& StoragePartition::command()
{
    return d_command;
}

// ACCESSORS
template <typename t_ACCESSOR>
int StoragePartition::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int StoragePartition::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int StoragePartition::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int StoragePartition::partitionId() const
{
    return d_partitionId;
}

inline const StoragePartitionCommand& StoragePartition::command() const
{
    return d_command;
}

// -------------
// class Tunable
// -------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void Tunable::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->name());
    hashAppend(hashAlgorithm, this->value());
    hashAppend(hashAlgorithm, this->description());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Tunable::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_value, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VALUE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_description,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Tunable::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_VALUE: {
        return manipulator(&d_value,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VALUE]);
    }
    case ATTRIBUTE_ID_DESCRIPTION: {
        return manipulator(&d_description,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Tunable::manipulateAttribute(t_MANIPULATOR& manipulator,
                                 const char*    name,
                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& Tunable::name()
{
    return d_name;
}

inline Value& Tunable::value()
{
    return d_value;
}

inline bsl::string& Tunable::description()
{
    return d_description;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Tunable::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_value, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VALUE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_description,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Tunable::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_VALUE: {
        return accessor(d_value, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_VALUE]);
    }
    case ATTRIBUTE_ID_DESCRIPTION: {
        return accessor(d_description,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Tunable::accessAttribute(t_ACCESSOR& accessor,
                             const char* name,
                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& Tunable::name() const
{
    return d_name;
}

inline const Value& Tunable::value() const
{
    return d_value;
}

inline const bsl::string& Tunable::description() const
{
    return d_description;
}

// -------------------------
// class TunableConfirmation
// -------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void TunableConfirmation::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->name());
    hashAppend(hashAlgorithm, this->oldValue());
    hashAppend(hashAlgorithm, this->newValue());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int TunableConfirmation::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_oldValue,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OLD_VALUE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_newValue,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NEW_VALUE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int TunableConfirmation::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_OLD_VALUE: {
        return manipulator(&d_oldValue,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OLD_VALUE]);
    }
    case ATTRIBUTE_ID_NEW_VALUE: {
        return manipulator(&d_newValue,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NEW_VALUE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int TunableConfirmation::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& TunableConfirmation::name()
{
    return d_name;
}

inline Value& TunableConfirmation::oldValue()
{
    return d_oldValue;
}

inline Value& TunableConfirmation::newValue()
{
    return d_newValue;
}

// ACCESSORS
template <typename t_ACCESSOR>
int TunableConfirmation::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_oldValue,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OLD_VALUE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_newValue,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NEW_VALUE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int TunableConfirmation::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_OLD_VALUE: {
        return accessor(d_oldValue,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_OLD_VALUE]);
    }
    case ATTRIBUTE_ID_NEW_VALUE: {
        return accessor(d_newValue,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NEW_VALUE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int TunableConfirmation::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& TunableConfirmation::name() const
{
    return d_name;
}

inline const Value& TunableConfirmation::oldValue() const
{
    return d_oldValue;
}

inline const Value& TunableConfirmation::newValue() const
{
    return d_newValue;
}

// --------------------------------
// class ClusterDomainQueueStatuses
// --------------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterDomainQueueStatuses::manipulateAttributes(
    t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_statuses,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUSES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterDomainQueueStatuses::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                    int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATUSES: {
        return manipulator(&d_statuses,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUSES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterDomainQueueStatuses::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                    const char*    name,
                                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bdlb::NullableValue<QueueStatuses>&
ClusterDomainQueueStatuses::statuses()
{
    return d_statuses;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterDomainQueueStatuses::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_statuses, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUSES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterDomainQueueStatuses::accessAttribute(t_ACCESSOR& accessor,
                                                int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATUSES: {
        return accessor(d_statuses,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUSES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterDomainQueueStatuses::accessAttribute(t_ACCESSOR& accessor,
                                                const char* name,
                                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bdlb::NullableValue<QueueStatuses>&
ClusterDomainQueueStatuses::statuses() const
{
    return d_statuses;
}

// ------------------------
// class ClusterProxyStatus
// ------------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterProxyStatus::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->description());
    hashAppend(hashAlgorithm, this->activeNodeDescription());
    hashAppend(hashAlgorithm, this->isHealthy());
    hashAppend(hashAlgorithm, this->nodeStatuses());
    hashAppend(hashAlgorithm, this->queuesInfo());
}

inline bool ClusterProxyStatus::isEqualTo(const ClusterProxyStatus& rhs) const
{
    return this->description() == rhs.description() &&
           this->activeNodeDescription() == rhs.activeNodeDescription() &&
           this->isHealthy() == rhs.isHealthy() &&
           this->nodeStatuses() == rhs.nodeStatuses() &&
           this->queuesInfo() == rhs.queuesInfo();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterProxyStatus::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_description,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_activeNodeDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ACTIVE_NODE_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isHealthy,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_HEALTHY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_nodeStatuses,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_STATUSES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queuesInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES_INFO]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterProxyStatus::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DESCRIPTION: {
        return manipulator(&d_description,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_ACTIVE_NODE_DESCRIPTION: {
        return manipulator(
            &d_activeNodeDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ACTIVE_NODE_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_IS_HEALTHY: {
        return manipulator(&d_isHealthy,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_HEALTHY]);
    }
    case ATTRIBUTE_ID_NODE_STATUSES: {
        return manipulator(
            &d_nodeStatuses,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_STATUSES]);
    }
    case ATTRIBUTE_ID_QUEUES_INFO: {
        return manipulator(&d_queuesInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES_INFO]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterProxyStatus::manipulateAttribute(t_MANIPULATOR& manipulator,
                                            const char*    name,
                                            int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClusterProxyStatus::description()
{
    return d_description;
}

inline bdlb::NullableValue<bsl::string>&
ClusterProxyStatus::activeNodeDescription()
{
    return d_activeNodeDescription;
}

inline bool& ClusterProxyStatus::isHealthy()
{
    return d_isHealthy;
}

inline NodeStatuses& ClusterProxyStatus::nodeStatuses()
{
    return d_nodeStatuses;
}

inline StorageContent& ClusterProxyStatus::queuesInfo()
{
    return d_queuesInfo;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterProxyStatus::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_description,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_activeNodeDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ACTIVE_NODE_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isHealthy,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_HEALTHY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_nodeStatuses,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_STATUSES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queuesInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES_INFO]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterProxyStatus::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_DESCRIPTION: {
        return accessor(d_description,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_ACTIVE_NODE_DESCRIPTION: {
        return accessor(
            d_activeNodeDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ACTIVE_NODE_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_IS_HEALTHY: {
        return accessor(d_isHealthy,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_HEALTHY]);
    }
    case ATTRIBUTE_ID_NODE_STATUSES: {
        return accessor(d_nodeStatuses,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_STATUSES]);
    }
    case ATTRIBUTE_ID_QUEUES_INFO: {
        return accessor(d_queuesInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES_INFO]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterProxyStatus::accessAttribute(t_ACCESSOR& accessor,
                                        const char* name,
                                        int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ClusterProxyStatus::description() const
{
    return d_description;
}

inline const bdlb::NullableValue<bsl::string>&
ClusterProxyStatus::activeNodeDescription() const
{
    return d_activeNodeDescription;
}

inline bool ClusterProxyStatus::isHealthy() const
{
    return d_isHealthy;
}

inline const NodeStatuses& ClusterProxyStatus::nodeStatuses() const
{
    return d_nodeStatuses;
}

inline const StorageContent& ClusterProxyStatus::queuesInfo() const
{
    return d_queuesInfo;
}

// -------------------
// class DomainCommand
// -------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DomainCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef DomainCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_PURGE:
        hashAppend(hashAlgorithm, this->purge());
        break;
    case Class::SELECTION_ID_INFO:
        hashAppend(hashAlgorithm, this->info());
        break;
    case Class::SELECTION_ID_QUEUE:
        hashAppend(hashAlgorithm, this->queue());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool DomainCommand::isEqualTo(const DomainCommand& rhs) const
{
    typedef DomainCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_PURGE: return this->purge() == rhs.purge();
        case Class::SELECTION_ID_INFO: return this->info() == rhs.info();
        case Class::SELECTION_ID_QUEUE: return this->queue() == rhs.queue();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline DomainCommand::DomainCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline DomainCommand::~DomainCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int DomainCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case DomainCommand::SELECTION_ID_PURGE:
        return manipulator(&d_purge.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGE]);
    case DomainCommand::SELECTION_ID_INFO:
        return manipulator(&d_info.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_INFO]);
    case DomainCommand::SELECTION_ID_QUEUE:
        return manipulator(&d_queue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE]);
    default:
        BSLS_ASSERT(DomainCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& DomainCommand::purge()
{
    BSLS_ASSERT(SELECTION_ID_PURGE == d_selectionId);
    return d_purge.object();
}

inline Void& DomainCommand::info()
{
    BSLS_ASSERT(SELECTION_ID_INFO == d_selectionId);
    return d_info.object();
}

inline DomainQueue& DomainCommand::queue()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE == d_selectionId);
    return d_queue.object();
}

// ACCESSORS
inline int DomainCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int DomainCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_PURGE:
        return accessor(d_purge.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGE]);
    case SELECTION_ID_INFO:
        return accessor(d_info.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_INFO]);
    case SELECTION_ID_QUEUE:
        return accessor(d_queue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& DomainCommand::purge() const
{
    BSLS_ASSERT(SELECTION_ID_PURGE == d_selectionId);
    return d_purge.object();
}

inline const Void& DomainCommand::info() const
{
    BSLS_ASSERT(SELECTION_ID_INFO == d_selectionId);
    return d_info.object();
}

inline const DomainQueue& DomainCommand::queue() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE == d_selectionId);
    return d_queue.object();
}

inline bool DomainCommand::isPurgeValue() const
{
    return SELECTION_ID_PURGE == d_selectionId;
}

inline bool DomainCommand::isInfoValue() const
{
    return SELECTION_ID_INFO == d_selectionId;
}

inline bool DomainCommand::isQueueValue() const
{
    return SELECTION_ID_QUEUE == d_selectionId;
}

inline bool DomainCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class ElectorCommand
// --------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ElectorCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ElectorCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_SET_TUNABLE:
        hashAppend(hashAlgorithm, this->setTunable());
        break;
    case Class::SELECTION_ID_GET_TUNABLE:
        hashAppend(hashAlgorithm, this->getTunable());
        break;
    case Class::SELECTION_ID_LIST_TUNABLES:
        hashAppend(hashAlgorithm, this->listTunables());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ElectorCommand::isEqualTo(const ElectorCommand& rhs) const
{
    typedef ElectorCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_SET_TUNABLE:
            return this->setTunable() == rhs.setTunable();
        case Class::SELECTION_ID_GET_TUNABLE:
            return this->getTunable() == rhs.getTunable();
        case Class::SELECTION_ID_LIST_TUNABLES:
            return this->listTunables() == rhs.listTunables();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ElectorCommand::ElectorCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ElectorCommand::~ElectorCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ElectorCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ElectorCommand::SELECTION_ID_SET_TUNABLE:
        return manipulator(&d_setTunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SET_TUNABLE]);
    case ElectorCommand::SELECTION_ID_GET_TUNABLE:
        return manipulator(&d_getTunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_GET_TUNABLE]);
    case ElectorCommand::SELECTION_ID_LIST_TUNABLES:
        return manipulator(
            &d_listTunables.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LIST_TUNABLES]);
    default:
        BSLS_ASSERT(ElectorCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline SetTunable& ElectorCommand::setTunable()
{
    BSLS_ASSERT(SELECTION_ID_SET_TUNABLE == d_selectionId);
    return d_setTunable.object();
}

inline GetTunable& ElectorCommand::getTunable()
{
    BSLS_ASSERT(SELECTION_ID_GET_TUNABLE == d_selectionId);
    return d_getTunable.object();
}

inline Void& ElectorCommand::listTunables()
{
    BSLS_ASSERT(SELECTION_ID_LIST_TUNABLES == d_selectionId);
    return d_listTunables.object();
}

// ACCESSORS
inline int ElectorCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ElectorCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_SET_TUNABLE:
        return accessor(d_setTunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SET_TUNABLE]);
    case SELECTION_ID_GET_TUNABLE:
        return accessor(d_getTunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_GET_TUNABLE]);
    case SELECTION_ID_LIST_TUNABLES:
        return accessor(d_listTunables.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LIST_TUNABLES]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const SetTunable& ElectorCommand::setTunable() const
{
    BSLS_ASSERT(SELECTION_ID_SET_TUNABLE == d_selectionId);
    return d_setTunable.object();
}

inline const GetTunable& ElectorCommand::getTunable() const
{
    BSLS_ASSERT(SELECTION_ID_GET_TUNABLE == d_selectionId);
    return d_getTunable.object();
}

inline const Void& ElectorCommand::listTunables() const
{
    BSLS_ASSERT(SELECTION_ID_LIST_TUNABLES == d_selectionId);
    return d_listTunables.object();
}

inline bool ElectorCommand::isSetTunableValue() const
{
    return SELECTION_ID_SET_TUNABLE == d_selectionId;
}

inline bool ElectorCommand::isGetTunableValue() const
{
    return SELECTION_ID_GET_TUNABLE == d_selectionId;
}

inline bool ElectorCommand::isListTunablesValue() const
{
    return SELECTION_ID_LIST_TUNABLES == d_selectionId;
}

inline bool ElectorCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ---------------
// class FileStore
// ---------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void FileStore::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->state());
    hashAppend(hashAlgorithm, this->summary());
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FileStore::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_summary,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUMMARY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int FileStore::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STATE: {
        return manipulator(&d_state,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    }
    case ATTRIBUTE_ID_SUMMARY: {
        return manipulator(&d_summary,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUMMARY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FileStore::manipulateAttribute(t_MANIPULATOR& manipulator,
                                   const char*    name,
                                   int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& FileStore::partitionId()
{
    return d_partitionId;
}

inline FileStoreState::Value& FileStore::state()
{
    return d_state;
}

inline FileStoreSummary& FileStore::summary()
{
    return d_summary;
}

// ACCESSORS
template <typename t_ACCESSOR>
int FileStore::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_summary, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUMMARY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int FileStore::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STATE: {
        return accessor(d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    }
    case ATTRIBUTE_ID_SUMMARY: {
        return accessor(d_summary,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUMMARY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FileStore::accessAttribute(t_ACCESSOR& accessor,
                               const char* name,
                               int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int FileStore::partitionId() const
{
    return d_partitionId;
}

inline FileStoreState::Value FileStore::state() const
{
    return d_state;
}

inline const FileStoreSummary& FileStore::summary() const
{
    return d_summary;
}

// -----------------
// class QueueHandle
// -----------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueHandle::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->clientDescription());
    hashAppend(hashAlgorithm, this->parametersJson());
    hashAppend(hashAlgorithm, this->isClientClusterMember());
    hashAppend(hashAlgorithm, this->subStreams());
}

inline bool QueueHandle::isEqualTo(const QueueHandle& rhs) const
{
    return this->clientDescription() == rhs.clientDescription() &&
           this->parametersJson() == rhs.parametersJson() &&
           this->isClientClusterMember() == rhs.isClientClusterMember() &&
           this->subStreams() == rhs.subStreams();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueHandle::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_clientDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_parametersJson,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_isClientClusterMember,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_CLIENT_CLUSTER_MEMBER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_subStreams,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_STREAMS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueHandle::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_DESCRIPTION: {
        return manipulator(
            &d_clientDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_PARAMETERS_JSON: {
        return manipulator(
            &d_parametersJson,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARAMETERS_JSON]);
    }
    case ATTRIBUTE_ID_IS_CLIENT_CLUSTER_MEMBER: {
        return manipulator(
            &d_isClientClusterMember,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_CLIENT_CLUSTER_MEMBER]);
    }
    case ATTRIBUTE_ID_SUB_STREAMS: {
        return manipulator(&d_subStreams,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_STREAMS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueHandle::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueHandle::clientDescription()
{
    return d_clientDescription;
}

inline bsl::string& QueueHandle::parametersJson()
{
    return d_parametersJson;
}

inline bool& QueueHandle::isClientClusterMember()
{
    return d_isClientClusterMember;
}

inline bsl::vector<QueueHandleSubStream>& QueueHandle::subStreams()
{
    return d_subStreams;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueHandle::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_clientDescription,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_parametersJson,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_isClientClusterMember,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_CLIENT_CLUSTER_MEMBER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_subStreams,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_STREAMS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueHandle::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLIENT_DESCRIPTION: {
        return accessor(
            d_clientDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLIENT_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_PARAMETERS_JSON: {
        return accessor(d_parametersJson,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARAMETERS_JSON]);
    }
    case ATTRIBUTE_ID_IS_CLIENT_CLUSTER_MEMBER: {
        return accessor(
            d_isClientClusterMember,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_CLIENT_CLUSTER_MEMBER]);
    }
    case ATTRIBUTE_ID_SUB_STREAMS: {
        return accessor(d_subStreams,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_STREAMS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueHandle::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueHandle::clientDescription() const
{
    return d_clientDescription;
}

inline const bsl::string& QueueHandle::parametersJson() const
{
    return d_parametersJson;
}

inline bool QueueHandle::isClientClusterMember() const
{
    return d_isClientClusterMember;
}

inline const bsl::vector<QueueHandleSubStream>& QueueHandle::subStreams() const
{
    return d_subStreams;
}

// ------------------------
// class ReplicationCommand
// ------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ReplicationCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ReplicationCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_SET_TUNABLE:
        hashAppend(hashAlgorithm, this->setTunable());
        break;
    case Class::SELECTION_ID_GET_TUNABLE:
        hashAppend(hashAlgorithm, this->getTunable());
        break;
    case Class::SELECTION_ID_LIST_TUNABLES:
        hashAppend(hashAlgorithm, this->listTunables());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ReplicationCommand::isEqualTo(const ReplicationCommand& rhs) const
{
    typedef ReplicationCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_SET_TUNABLE:
            return this->setTunable() == rhs.setTunable();
        case Class::SELECTION_ID_GET_TUNABLE:
            return this->getTunable() == rhs.getTunable();
        case Class::SELECTION_ID_LIST_TUNABLES:
            return this->listTunables() == rhs.listTunables();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ReplicationCommand::ReplicationCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ReplicationCommand::~ReplicationCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ReplicationCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ReplicationCommand::SELECTION_ID_SET_TUNABLE:
        return manipulator(&d_setTunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SET_TUNABLE]);
    case ReplicationCommand::SELECTION_ID_GET_TUNABLE:
        return manipulator(&d_getTunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_GET_TUNABLE]);
    case ReplicationCommand::SELECTION_ID_LIST_TUNABLES:
        return manipulator(
            &d_listTunables.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LIST_TUNABLES]);
    default:
        BSLS_ASSERT(ReplicationCommand::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline SetTunable& ReplicationCommand::setTunable()
{
    BSLS_ASSERT(SELECTION_ID_SET_TUNABLE == d_selectionId);
    return d_setTunable.object();
}

inline GetTunable& ReplicationCommand::getTunable()
{
    BSLS_ASSERT(SELECTION_ID_GET_TUNABLE == d_selectionId);
    return d_getTunable.object();
}

inline Void& ReplicationCommand::listTunables()
{
    BSLS_ASSERT(SELECTION_ID_LIST_TUNABLES == d_selectionId);
    return d_listTunables.object();
}

// ACCESSORS
inline int ReplicationCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ReplicationCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_SET_TUNABLE:
        return accessor(d_setTunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SET_TUNABLE]);
    case SELECTION_ID_GET_TUNABLE:
        return accessor(d_getTunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_GET_TUNABLE]);
    case SELECTION_ID_LIST_TUNABLES:
        return accessor(d_listTunables.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LIST_TUNABLES]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const SetTunable& ReplicationCommand::setTunable() const
{
    BSLS_ASSERT(SELECTION_ID_SET_TUNABLE == d_selectionId);
    return d_setTunable.object();
}

inline const GetTunable& ReplicationCommand::getTunable() const
{
    BSLS_ASSERT(SELECTION_ID_GET_TUNABLE == d_selectionId);
    return d_getTunable.object();
}

inline const Void& ReplicationCommand::listTunables() const
{
    BSLS_ASSERT(SELECTION_ID_LIST_TUNABLES == d_selectionId);
    return d_listTunables.object();
}

inline bool ReplicationCommand::isSetTunableValue() const
{
    return SELECTION_ID_SET_TUNABLE == d_selectionId;
}

inline bool ReplicationCommand::isGetTunableValue() const
{
    return SELECTION_ID_GET_TUNABLE == d_selectionId;
}

inline bool ReplicationCommand::isListTunablesValue() const
{
    return SELECTION_ID_LIST_TUNABLES == d_selectionId;
}

inline bool ReplicationCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------
// class StatCommand
// -----------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StatCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef StatCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_SHOW:
        hashAppend(hashAlgorithm, this->show());
        break;
    case Class::SELECTION_ID_SET_TUNABLE:
        hashAppend(hashAlgorithm, this->setTunable());
        break;
    case Class::SELECTION_ID_GET_TUNABLE:
        hashAppend(hashAlgorithm, this->getTunable());
        break;
    case Class::SELECTION_ID_LIST_TUNABLES:
        hashAppend(hashAlgorithm, this->listTunables());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool StatCommand::isEqualTo(const StatCommand& rhs) const
{
    typedef StatCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_SHOW: return this->show() == rhs.show();
        case Class::SELECTION_ID_SET_TUNABLE:
            return this->setTunable() == rhs.setTunable();
        case Class::SELECTION_ID_GET_TUNABLE:
            return this->getTunable() == rhs.getTunable();
        case Class::SELECTION_ID_LIST_TUNABLES:
            return this->listTunables() == rhs.listTunables();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline StatCommand::StatCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline StatCommand::~StatCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int StatCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StatCommand::SELECTION_ID_SHOW:
        return manipulator(&d_show.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SHOW]);
    case StatCommand::SELECTION_ID_SET_TUNABLE:
        return manipulator(&d_setTunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SET_TUNABLE]);
    case StatCommand::SELECTION_ID_GET_TUNABLE:
        return manipulator(&d_getTunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_GET_TUNABLE]);
    case StatCommand::SELECTION_ID_LIST_TUNABLES:
        return manipulator(
            &d_listTunables.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_LIST_TUNABLES]);
    default:
        BSLS_ASSERT(StatCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& StatCommand::show()
{
    BSLS_ASSERT(SELECTION_ID_SHOW == d_selectionId);
    return d_show.object();
}

inline SetTunable& StatCommand::setTunable()
{
    BSLS_ASSERT(SELECTION_ID_SET_TUNABLE == d_selectionId);
    return d_setTunable.object();
}

inline bsl::string& StatCommand::getTunable()
{
    BSLS_ASSERT(SELECTION_ID_GET_TUNABLE == d_selectionId);
    return d_getTunable.object();
}

inline Void& StatCommand::listTunables()
{
    BSLS_ASSERT(SELECTION_ID_LIST_TUNABLES == d_selectionId);
    return d_listTunables.object();
}

// ACCESSORS
inline int StatCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int StatCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_SHOW:
        return accessor(d_show.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SHOW]);
    case SELECTION_ID_SET_TUNABLE:
        return accessor(d_setTunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SET_TUNABLE]);
    case SELECTION_ID_GET_TUNABLE:
        return accessor(d_getTunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_GET_TUNABLE]);
    case SELECTION_ID_LIST_TUNABLES:
        return accessor(d_listTunables.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LIST_TUNABLES]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& StatCommand::show() const
{
    BSLS_ASSERT(SELECTION_ID_SHOW == d_selectionId);
    return d_show.object();
}

inline const SetTunable& StatCommand::setTunable() const
{
    BSLS_ASSERT(SELECTION_ID_SET_TUNABLE == d_selectionId);
    return d_setTunable.object();
}

inline const bsl::string& StatCommand::getTunable() const
{
    BSLS_ASSERT(SELECTION_ID_GET_TUNABLE == d_selectionId);
    return d_getTunable.object();
}

inline const Void& StatCommand::listTunables() const
{
    BSLS_ASSERT(SELECTION_ID_LIST_TUNABLES == d_selectionId);
    return d_listTunables.object();
}

inline bool StatCommand::isShowValue() const
{
    return SELECTION_ID_SHOW == d_selectionId;
}

inline bool StatCommand::isSetTunableValue() const
{
    return SELECTION_ID_SET_TUNABLE == d_selectionId;
}

inline bool StatCommand::isGetTunableValue() const
{
    return SELECTION_ID_GET_TUNABLE == d_selectionId;
}

inline bool StatCommand::isListTunablesValue() const
{
    return SELECTION_ID_LIST_TUNABLES == d_selectionId;
}

inline bool StatCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------------
// class SubscriptionGroup
// -----------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void SubscriptionGroup::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->id());
    hashAppend(hashAlgorithm, this->expression());
    hashAppend(hashAlgorithm, this->upstreamSubQueueId());
    hashAppend(hashAlgorithm, this->priorityGroup());
}

inline bool SubscriptionGroup::isEqualTo(const SubscriptionGroup& rhs) const
{
    return this->id() == rhs.id() && this->expression() == rhs.expression() &&
           this->upstreamSubQueueId() == rhs.upstreamSubQueueId() &&
           this->priorityGroup() == rhs.priorityGroup();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int SubscriptionGroup::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_expression,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_upstreamSubQueueId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPSTREAM_SUB_QUEUE_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_priorityGroup,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIORITY_GROUP]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int SubscriptionGroup::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ID: {
        return manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_EXPRESSION: {
        return manipulator(&d_expression,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    }
    case ATTRIBUTE_ID_UPSTREAM_SUB_QUEUE_ID: {
        return manipulator(
            &d_upstreamSubQueueId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPSTREAM_SUB_QUEUE_ID]);
    }
    case ATTRIBUTE_ID_PRIORITY_GROUP: {
        return manipulator(
            &d_priorityGroup,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIORITY_GROUP]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int SubscriptionGroup::manipulateAttribute(t_MANIPULATOR& manipulator,
                                           const char*    name,
                                           int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& SubscriptionGroup::id()
{
    return d_id;
}

inline bsl::string& SubscriptionGroup::expression()
{
    return d_expression;
}

inline unsigned int& SubscriptionGroup::upstreamSubQueueId()
{
    return d_upstreamSubQueueId;
}

inline bdlb::NullableValue<PriorityGroup>& SubscriptionGroup::priorityGroup()
{
    return d_priorityGroup;
}

// ACCESSORS
template <typename t_ACCESSOR>
int SubscriptionGroup::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_expression,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_upstreamSubQueueId,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPSTREAM_SUB_QUEUE_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_priorityGroup,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIORITY_GROUP]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int SubscriptionGroup::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_ID: {
        return accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_EXPRESSION: {
        return accessor(d_expression,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    }
    case ATTRIBUTE_ID_UPSTREAM_SUB_QUEUE_ID: {
        return accessor(
            d_upstreamSubQueueId,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_UPSTREAM_SUB_QUEUE_ID]);
    }
    case ATTRIBUTE_ID_PRIORITY_GROUP: {
        return accessor(d_priorityGroup,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIORITY_GROUP]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int SubscriptionGroup::accessAttribute(t_ACCESSOR& accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int SubscriptionGroup::id() const
{
    return d_id;
}

inline const bsl::string& SubscriptionGroup::expression() const
{
    return d_expression;
}

inline unsigned int SubscriptionGroup::upstreamSubQueueId() const
{
    return d_upstreamSubQueueId;
}

inline const bdlb::NullableValue<PriorityGroup>&
SubscriptionGroup::priorityGroup() const
{
    return d_priorityGroup;
}

// --------------
// class Tunables
// --------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Tunables::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_tunables,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TUNABLES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Tunables::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TUNABLES: {
        return manipulator(&d_tunables,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TUNABLES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Tunables::manipulateAttribute(t_MANIPULATOR& manipulator,
                                  const char*    name,
                                  int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<Tunable>& Tunables::tunables()
{
    return d_tunables;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Tunables::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_tunables, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TUNABLES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Tunables::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_TUNABLES: {
        return accessor(d_tunables,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_TUNABLES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Tunables::accessAttribute(t_ACCESSOR& accessor,
                              const char* name,
                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<Tunable>& Tunables::tunables() const
{
    return d_tunables;
}

// -------------------------
// class ClusterStateCommand
// -------------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterStateCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ClusterStateCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ELECTOR:
        hashAppend(hashAlgorithm, this->elector());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool
ClusterStateCommand::isEqualTo(const ClusterStateCommand& rhs) const
{
    typedef ClusterStateCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ELECTOR:
            return this->elector() == rhs.elector();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ClusterStateCommand::ClusterStateCommand(
    bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClusterStateCommand::~ClusterStateCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterStateCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClusterStateCommand::SELECTION_ID_ELECTOR:
        return manipulator(&d_elector.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR]);
    default:
        BSLS_ASSERT(ClusterStateCommand::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline ElectorCommand& ClusterStateCommand::elector()
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR == d_selectionId);
    return d_elector.object();
}

// ACCESSORS
inline int ClusterStateCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ClusterStateCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ELECTOR:
        return accessor(d_elector.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const ElectorCommand& ClusterStateCommand::elector() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR == d_selectionId);
    return d_elector.object();
}

inline bool ClusterStateCommand::isElectorValue() const
{
    return SELECTION_ID_ELECTOR == d_selectionId;
}

inline bool ClusterStateCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ---------------------------
// class ClusterStorageSummary
// ---------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterStorageSummary::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_clusterFileStoreLocation,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_FILE_STORE_LOCATION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_fileStores,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FILE_STORES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterStorageSummary::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_FILE_STORE_LOCATION: {
        return manipulator(
            &d_clusterFileStoreLocation,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_FILE_STORE_LOCATION]);
    }
    case ATTRIBUTE_ID_FILE_STORES: {
        return manipulator(&d_fileStores,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FILE_STORES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterStorageSummary::manipulateAttribute(t_MANIPULATOR& manipulator,
                                               const char*    name,
                                               int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClusterStorageSummary::clusterFileStoreLocation()
{
    return d_clusterFileStoreLocation;
}

inline bsl::vector<FileStore>& ClusterStorageSummary::fileStores()
{
    return d_fileStores;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterStorageSummary::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(
        d_clusterFileStoreLocation,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_FILE_STORE_LOCATION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_fileStores,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FILE_STORES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterStorageSummary::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CLUSTER_FILE_STORE_LOCATION: {
        return accessor(
            d_clusterFileStoreLocation,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_FILE_STORE_LOCATION]);
    }
    case ATTRIBUTE_ID_FILE_STORES: {
        return accessor(d_fileStores,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_FILE_STORES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterStorageSummary::accessAttribute(t_ACCESSOR& accessor,
                                           const char* name,
                                           int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string&
ClusterStorageSummary::clusterFileStoreLocation() const
{
    return d_clusterFileStoreLocation;
}

inline const bsl::vector<FileStore>& ClusterStorageSummary::fileStores() const
{
    return d_fileStores;
}

// ------------
// class Domain
// ------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Domain::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Domain::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Domain::manipulateAttribute(t_MANIPULATOR& manipulator,
                                const char*    name,
                                int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& Domain::name()
{
    return d_name;
}

inline DomainCommand& Domain::command()
{
    return d_command;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Domain::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Domain::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Domain::accessAttribute(t_ACCESSOR& accessor,
                            const char* name,
                            int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& Domain::name() const
{
    return d_name;
}

inline const DomainCommand& Domain::command() const
{
    return d_command;
}

// -------------------
// class ElectorResult
// -------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ElectorResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ElectorResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_TUNABLE:
        hashAppend(hashAlgorithm, this->tunable());
        break;
    case Class::SELECTION_ID_TUNABLES:
        hashAppend(hashAlgorithm, this->tunables());
        break;
    case Class::SELECTION_ID_TUNABLE_CONFIRMATION:
        hashAppend(hashAlgorithm, this->tunableConfirmation());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ElectorResult::isEqualTo(const ElectorResult& rhs) const
{
    typedef ElectorResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_TUNABLE:
            return this->tunable() == rhs.tunable();
        case Class::SELECTION_ID_TUNABLES:
            return this->tunables() == rhs.tunables();
        case Class::SELECTION_ID_TUNABLE_CONFIRMATION:
            return this->tunableConfirmation() == rhs.tunableConfirmation();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ElectorResult::ElectorResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ElectorResult::~ElectorResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ElectorResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ElectorResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case ElectorResult::SELECTION_ID_TUNABLE:
        return manipulator(&d_tunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE]);
    case ElectorResult::SELECTION_ID_TUNABLES:
        return manipulator(&d_tunables.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLES]);
    case ElectorResult::SELECTION_ID_TUNABLE_CONFIRMATION:
        return manipulator(
            &d_tunableConfirmation.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE_CONFIRMATION]);
    default:
        BSLS_ASSERT(ElectorResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Error& ElectorResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline Tunable& ElectorResult::tunable()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE == d_selectionId);
    return d_tunable.object();
}

inline Tunables& ElectorResult::tunables()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLES == d_selectionId);
    return d_tunables.object();
}

inline TunableConfirmation& ElectorResult::tunableConfirmation()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId);
    return d_tunableConfirmation.object();
}

// ACCESSORS
inline int ElectorResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ElectorResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_TUNABLE:
        return accessor(d_tunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE]);
    case SELECTION_ID_TUNABLES:
        return accessor(d_tunables.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLES]);
    case SELECTION_ID_TUNABLE_CONFIRMATION:
        return accessor(
            d_tunableConfirmation.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE_CONFIRMATION]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& ElectorResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const Tunable& ElectorResult::tunable() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE == d_selectionId);
    return d_tunable.object();
}

inline const Tunables& ElectorResult::tunables() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLES == d_selectionId);
    return d_tunables.object();
}

inline const TunableConfirmation& ElectorResult::tunableConfirmation() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId);
    return d_tunableConfirmation.object();
}

inline bool ElectorResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool ElectorResult::isTunableValue() const
{
    return SELECTION_ID_TUNABLE == d_selectionId;
}

inline bool ElectorResult::isTunablesValue() const
{
    return SELECTION_ID_TUNABLES == d_selectionId;
}

inline bool ElectorResult::isTunableConfirmationValue() const
{
    return SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId;
}

inline bool ElectorResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------
// class QueueState
// ----------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueState::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->uri());
    hashAppend(hashAlgorithm, this->handleParametersJson());
    hashAppend(hashAlgorithm, this->streamParametersJson());
    hashAppend(hashAlgorithm, this->id());
    hashAppend(hashAlgorithm, this->key());
    hashAppend(hashAlgorithm, this->partitionId());
    hashAppend(hashAlgorithm, this->storage());
    hashAppend(hashAlgorithm, this->capacityMeter());
    hashAppend(hashAlgorithm, this->handles());
}

inline bool QueueState::isEqualTo(const QueueState& rhs) const
{
    return this->uri() == rhs.uri() &&
           this->handleParametersJson() == rhs.handleParametersJson() &&
           this->streamParametersJson() == rhs.streamParametersJson() &&
           this->id() == rhs.id() && this->key() == rhs.key() &&
           this->partitionId() == rhs.partitionId() &&
           this->storage() == rhs.storage() &&
           this->capacityMeter() == rhs.capacityMeter() &&
           this->handles() == rhs.handles();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueState::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_handleParametersJson,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_streamParametersJson,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionId,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_storage,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_capacityMeter,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CAPACITY_METER]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_handles,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueState::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return manipulator(&d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_HANDLE_PARAMETERS_JSON: {
        return manipulator(
            &d_handleParametersJson,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS_JSON]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS_JSON: {
        return manipulator(
            &d_streamParametersJson,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS_JSON]);
    }
    case ATTRIBUTE_ID_ID: {
        return manipulator(&d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_KEY: {
        return manipulator(&d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return manipulator(&d_partitionId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STORAGE: {
        return manipulator(&d_storage,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE]);
    }
    case ATTRIBUTE_ID_CAPACITY_METER: {
        return manipulator(
            &d_capacityMeter,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CAPACITY_METER]);
    }
    case ATTRIBUTE_ID_HANDLES: {
        return manipulator(&d_handles,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueState::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& QueueState::uri()
{
    return d_uri;
}

inline bsl::string& QueueState::handleParametersJson()
{
    return d_handleParametersJson;
}

inline bsl::string& QueueState::streamParametersJson()
{
    return d_streamParametersJson;
}

inline unsigned int& QueueState::id()
{
    return d_id;
}

inline bsl::string& QueueState::key()
{
    return d_key;
}

inline int& QueueState::partitionId()
{
    return d_partitionId;
}

inline bdlb::NullableValue<QueueStorage>& QueueState::storage()
{
    return d_storage;
}

inline bdlb::NullableValue<CapacityMeter>& QueueState::capacityMeter()
{
    return d_capacityMeter;
}

inline bsl::vector<QueueHandle>& QueueState::handles()
{
    return d_handles;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueState::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_handleParametersJson,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_streamParametersJson,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS_JSON]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionId,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_storage, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_capacityMeter,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CAPACITY_METER]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_handles, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueState::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_URI: {
        return accessor(d_uri, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_URI]);
    }
    case ATTRIBUTE_ID_HANDLE_PARAMETERS_JSON: {
        return accessor(
            d_handleParametersJson,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLE_PARAMETERS_JSON]);
    }
    case ATTRIBUTE_ID_STREAM_PARAMETERS_JSON: {
        return accessor(
            d_streamParametersJson,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAM_PARAMETERS_JSON]);
    }
    case ATTRIBUTE_ID_ID: {
        return accessor(d_id, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ID]);
    }
    case ATTRIBUTE_ID_KEY: {
        return accessor(d_key, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_KEY]);
    }
    case ATTRIBUTE_ID_PARTITION_ID: {
        return accessor(d_partitionId,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITION_ID]);
    }
    case ATTRIBUTE_ID_STORAGE: {
        return accessor(d_storage,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STORAGE]);
    }
    case ATTRIBUTE_ID_CAPACITY_METER: {
        return accessor(d_capacityMeter,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CAPACITY_METER]);
    }
    case ATTRIBUTE_ID_HANDLES: {
        return accessor(d_handles,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_HANDLES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueState::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& QueueState::uri() const
{
    return d_uri;
}

inline const bsl::string& QueueState::handleParametersJson() const
{
    return d_handleParametersJson;
}

inline const bsl::string& QueueState::streamParametersJson() const
{
    return d_streamParametersJson;
}

inline unsigned int QueueState::id() const
{
    return d_id;
}

inline const bsl::string& QueueState::key() const
{
    return d_key;
}

inline int QueueState::partitionId() const
{
    return d_partitionId;
}

inline const bdlb::NullableValue<QueueStorage>& QueueState::storage() const
{
    return d_storage;
}

inline const bdlb::NullableValue<CapacityMeter>&
QueueState::capacityMeter() const
{
    return d_capacityMeter;
}

inline const bsl::vector<QueueHandle>& QueueState::handles() const
{
    return d_handles;
}

// -----------------------
// class ReplicationResult
// -----------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ReplicationResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ReplicationResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_TUNABLE:
        hashAppend(hashAlgorithm, this->tunable());
        break;
    case Class::SELECTION_ID_TUNABLES:
        hashAppend(hashAlgorithm, this->tunables());
        break;
    case Class::SELECTION_ID_TUNABLE_CONFIRMATION:
        hashAppend(hashAlgorithm, this->tunableConfirmation());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ReplicationResult::isEqualTo(const ReplicationResult& rhs) const
{
    typedef ReplicationResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_TUNABLE:
            return this->tunable() == rhs.tunable();
        case Class::SELECTION_ID_TUNABLES:
            return this->tunables() == rhs.tunables();
        case Class::SELECTION_ID_TUNABLE_CONFIRMATION:
            return this->tunableConfirmation() == rhs.tunableConfirmation();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ReplicationResult::ReplicationResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ReplicationResult::~ReplicationResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ReplicationResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ReplicationResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case ReplicationResult::SELECTION_ID_TUNABLE:
        return manipulator(&d_tunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE]);
    case ReplicationResult::SELECTION_ID_TUNABLES:
        return manipulator(&d_tunables.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLES]);
    case ReplicationResult::SELECTION_ID_TUNABLE_CONFIRMATION:
        return manipulator(
            &d_tunableConfirmation.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE_CONFIRMATION]);
    default:
        BSLS_ASSERT(ReplicationResult::SELECTION_ID_UNDEFINED ==
                    d_selectionId);
        return -1;
    }
}

inline Error& ReplicationResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline Tunable& ReplicationResult::tunable()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE == d_selectionId);
    return d_tunable.object();
}

inline Tunables& ReplicationResult::tunables()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLES == d_selectionId);
    return d_tunables.object();
}

inline TunableConfirmation& ReplicationResult::tunableConfirmation()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId);
    return d_tunableConfirmation.object();
}

// ACCESSORS
inline int ReplicationResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ReplicationResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_TUNABLE:
        return accessor(d_tunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE]);
    case SELECTION_ID_TUNABLES:
        return accessor(d_tunables.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLES]);
    case SELECTION_ID_TUNABLE_CONFIRMATION:
        return accessor(
            d_tunableConfirmation.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE_CONFIRMATION]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& ReplicationResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const Tunable& ReplicationResult::tunable() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE == d_selectionId);
    return d_tunable.object();
}

inline const Tunables& ReplicationResult::tunables() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLES == d_selectionId);
    return d_tunables.object();
}

inline const TunableConfirmation&
ReplicationResult::tunableConfirmation() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId);
    return d_tunableConfirmation.object();
}

inline bool ReplicationResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool ReplicationResult::isTunableValue() const
{
    return SELECTION_ID_TUNABLE == d_selectionId;
}

inline bool ReplicationResult::isTunablesValue() const
{
    return SELECTION_ID_TUNABLES == d_selectionId;
}

inline bool ReplicationResult::isTunableConfirmationValue() const
{
    return SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId;
}

inline bool ReplicationResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class RouterConsumer
// --------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void RouterConsumer::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->priority());
    hashAppend(hashAlgorithm, this->queueHandle());
    hashAppend(hashAlgorithm, this->count());
    hashAppend(hashAlgorithm, this->expression());
}

inline bool RouterConsumer::isEqualTo(const RouterConsumer& rhs) const
{
    return this->priority() == rhs.priority() &&
           this->queueHandle() == rhs.queueHandle() &&
           this->count() == rhs.count() &&
           this->expression() == rhs.expression();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RouterConsumer::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_priority,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queueHandle,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_HANDLE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_count, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COUNT]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_expression,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RouterConsumer::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIORITY: {
        return manipulator(&d_priority,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIORITY]);
    }
    case ATTRIBUTE_ID_QUEUE_HANDLE: {
        return manipulator(&d_queueHandle,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_HANDLE]);
    }
    case ATTRIBUTE_ID_COUNT: {
        return manipulator(&d_count,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COUNT]);
    }
    case ATTRIBUTE_ID_EXPRESSION: {
        return manipulator(&d_expression,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RouterConsumer::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline int& RouterConsumer::priority()
{
    return d_priority;
}

inline QueueHandle& RouterConsumer::queueHandle()
{
    return d_queueHandle;
}

inline unsigned int& RouterConsumer::count()
{
    return d_count;
}

inline bsl::string& RouterConsumer::expression()
{
    return d_expression;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RouterConsumer::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_priority, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIORITY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queueHandle,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_HANDLE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_count, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COUNT]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_expression,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RouterConsumer::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_PRIORITY: {
        return accessor(d_priority,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PRIORITY]);
    }
    case ATTRIBUTE_ID_QUEUE_HANDLE: {
        return accessor(d_queueHandle,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_HANDLE]);
    }
    case ATTRIBUTE_ID_COUNT: {
        return accessor(d_count, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COUNT]);
    }
    case ATTRIBUTE_ID_EXPRESSION: {
        return accessor(d_expression,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_EXPRESSION]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RouterConsumer::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline int RouterConsumer::priority() const
{
    return d_priority;
}

inline const QueueHandle& RouterConsumer::queueHandle() const
{
    return d_queueHandle;
}

inline unsigned int RouterConsumer::count() const
{
    return d_count;
}

inline const bsl::string& RouterConsumer::expression() const
{
    return d_expression;
}

// -------------
// class Routing
// -------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Routing::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(
        &d_subscriptionGroups,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTION_GROUPS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Routing::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUBSCRIPTION_GROUPS: {
        return manipulator(
            &d_subscriptionGroups,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTION_GROUPS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Routing::manipulateAttribute(t_MANIPULATOR& manipulator,
                                 const char*    name,
                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<SubscriptionGroup>& Routing::subscriptionGroups()
{
    return d_subscriptionGroups;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Routing::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_subscriptionGroups,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTION_GROUPS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Routing::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SUBSCRIPTION_GROUPS: {
        return accessor(
            d_subscriptionGroups,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUBSCRIPTION_GROUPS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Routing::accessAttribute(t_ACCESSOR& accessor,
                             const char* name,
                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<SubscriptionGroup>&
Routing::subscriptionGroups() const
{
    return d_subscriptionGroups;
}

// ----------------
// class StatResult
// ----------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StatResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef StatResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_STATS:
        hashAppend(hashAlgorithm, this->stats());
        break;
    case Class::SELECTION_ID_TUNABLE:
        hashAppend(hashAlgorithm, this->tunable());
        break;
    case Class::SELECTION_ID_TUNABLES:
        hashAppend(hashAlgorithm, this->tunables());
        break;
    case Class::SELECTION_ID_TUNABLE_CONFIRMATION:
        hashAppend(hashAlgorithm, this->tunableConfirmation());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool StatResult::isEqualTo(const StatResult& rhs) const
{
    typedef StatResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_STATS: return this->stats() == rhs.stats();
        case Class::SELECTION_ID_TUNABLE:
            return this->tunable() == rhs.tunable();
        case Class::SELECTION_ID_TUNABLES:
            return this->tunables() == rhs.tunables();
        case Class::SELECTION_ID_TUNABLE_CONFIRMATION:
            return this->tunableConfirmation() == rhs.tunableConfirmation();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline StatResult::StatResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline StatResult::~StatResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int StatResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StatResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case StatResult::SELECTION_ID_STATS:
        return manipulator(&d_stats.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STATS]);
    case StatResult::SELECTION_ID_TUNABLE:
        return manipulator(&d_tunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE]);
    case StatResult::SELECTION_ID_TUNABLES:
        return manipulator(&d_tunables.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLES]);
    case StatResult::SELECTION_ID_TUNABLE_CONFIRMATION:
        return manipulator(
            &d_tunableConfirmation.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE_CONFIRMATION]);
    default:
        BSLS_ASSERT(StatResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Error& StatResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline bsl::string& StatResult::stats()
{
    BSLS_ASSERT(SELECTION_ID_STATS == d_selectionId);
    return d_stats.object();
}

inline Tunable& StatResult::tunable()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE == d_selectionId);
    return d_tunable.object();
}

inline Tunables& StatResult::tunables()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLES == d_selectionId);
    return d_tunables.object();
}

inline TunableConfirmation& StatResult::tunableConfirmation()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId);
    return d_tunableConfirmation.object();
}

// ACCESSORS
inline int StatResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int StatResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_STATS:
        return accessor(d_stats.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STATS]);
    case SELECTION_ID_TUNABLE:
        return accessor(d_tunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE]);
    case SELECTION_ID_TUNABLES:
        return accessor(d_tunables.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLES]);
    case SELECTION_ID_TUNABLE_CONFIRMATION:
        return accessor(
            d_tunableConfirmation.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE_CONFIRMATION]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& StatResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const bsl::string& StatResult::stats() const
{
    BSLS_ASSERT(SELECTION_ID_STATS == d_selectionId);
    return d_stats.object();
}

inline const Tunable& StatResult::tunable() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE == d_selectionId);
    return d_tunable.object();
}

inline const Tunables& StatResult::tunables() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLES == d_selectionId);
    return d_tunables.object();
}

inline const TunableConfirmation& StatResult::tunableConfirmation() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId);
    return d_tunableConfirmation.object();
}

inline bool StatResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool StatResult::isStatsValue() const
{
    return SELECTION_ID_STATS == d_selectionId;
}

inline bool StatResult::isTunableValue() const
{
    return SELECTION_ID_TUNABLE == d_selectionId;
}

inline bool StatResult::isTunablesValue() const
{
    return SELECTION_ID_TUNABLES == d_selectionId;
}

inline bool StatResult::isTunableConfirmationValue() const
{
    return SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId;
}

inline bool StatResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class StorageCommand
// --------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StorageCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef StorageCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_SUMMARY:
        hashAppend(hashAlgorithm, this->summary());
        break;
    case Class::SELECTION_ID_PARTITION:
        hashAppend(hashAlgorithm, this->partition());
        break;
    case Class::SELECTION_ID_DOMAIN:
        hashAppend(hashAlgorithm, this->domain());
        break;
    case Class::SELECTION_ID_QUEUE:
        hashAppend(hashAlgorithm, this->queue());
        break;
    case Class::SELECTION_ID_REPLICATION:
        hashAppend(hashAlgorithm, this->replication());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool StorageCommand::isEqualTo(const StorageCommand& rhs) const
{
    typedef StorageCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_SUMMARY:
            return this->summary() == rhs.summary();
        case Class::SELECTION_ID_PARTITION:
            return this->partition() == rhs.partition();
        case Class::SELECTION_ID_DOMAIN: return this->domain() == rhs.domain();
        case Class::SELECTION_ID_QUEUE: return this->queue() == rhs.queue();
        case Class::SELECTION_ID_REPLICATION:
            return this->replication() == rhs.replication();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline StorageCommand::StorageCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline StorageCommand::~StorageCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StorageCommand::SELECTION_ID_SUMMARY:
        return manipulator(&d_summary.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUMMARY]);
    case StorageCommand::SELECTION_ID_PARTITION:
        return manipulator(&d_partition.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION]);
    case StorageCommand::SELECTION_ID_DOMAIN:
        return manipulator(&d_domain.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN]);
    case StorageCommand::SELECTION_ID_QUEUE:
        return manipulator(&d_queue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE]);
    case StorageCommand::SELECTION_ID_REPLICATION:
        return manipulator(&d_replication.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICATION]);
    default:
        BSLS_ASSERT(StorageCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& StorageCommand::summary()
{
    BSLS_ASSERT(SELECTION_ID_SUMMARY == d_selectionId);
    return d_summary.object();
}

inline StoragePartition& StorageCommand::partition()
{
    BSLS_ASSERT(SELECTION_ID_PARTITION == d_selectionId);
    return d_partition.object();
}

inline StorageDomain& StorageCommand::domain()
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN == d_selectionId);
    return d_domain.object();
}

inline StorageQueue& StorageCommand::queue()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE == d_selectionId);
    return d_queue.object();
}

inline ReplicationCommand& StorageCommand::replication()
{
    BSLS_ASSERT(SELECTION_ID_REPLICATION == d_selectionId);
    return d_replication.object();
}

// ACCESSORS
inline int StorageCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int StorageCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_SUMMARY:
        return accessor(d_summary.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUMMARY]);
    case SELECTION_ID_PARTITION:
        return accessor(d_partition.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITION]);
    case SELECTION_ID_DOMAIN:
        return accessor(d_domain.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN]);
    case SELECTION_ID_QUEUE:
        return accessor(d_queue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE]);
    case SELECTION_ID_REPLICATION:
        return accessor(d_replication.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICATION]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& StorageCommand::summary() const
{
    BSLS_ASSERT(SELECTION_ID_SUMMARY == d_selectionId);
    return d_summary.object();
}

inline const StoragePartition& StorageCommand::partition() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITION == d_selectionId);
    return d_partition.object();
}

inline const StorageDomain& StorageCommand::domain() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN == d_selectionId);
    return d_domain.object();
}

inline const StorageQueue& StorageCommand::queue() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE == d_selectionId);
    return d_queue.object();
}

inline const ReplicationCommand& StorageCommand::replication() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICATION == d_selectionId);
    return d_replication.object();
}

inline bool StorageCommand::isSummaryValue() const
{
    return SELECTION_ID_SUMMARY == d_selectionId;
}

inline bool StorageCommand::isPartitionValue() const
{
    return SELECTION_ID_PARTITION == d_selectionId;
}

inline bool StorageCommand::isDomainValue() const
{
    return SELECTION_ID_DOMAIN == d_selectionId;
}

inline bool StorageCommand::isQueueValue() const
{
    return SELECTION_ID_QUEUE == d_selectionId;
}

inline bool StorageCommand::isReplicationValue() const
{
    return SELECTION_ID_REPLICATION == d_selectionId;
}

inline bool StorageCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class ClusterCommand
// --------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ClusterCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_STATUS:
        hashAppend(hashAlgorithm, this->status());
        break;
    case Class::SELECTION_ID_QUEUE_HELPER:
        hashAppend(hashAlgorithm, this->queueHelper());
        break;
    case Class::SELECTION_ID_FORCE_GC_QUEUES:
        hashAppend(hashAlgorithm, this->forceGcQueues());
        break;
    case Class::SELECTION_ID_STORAGE:
        hashAppend(hashAlgorithm, this->storage());
        break;
    case Class::SELECTION_ID_STATE:
        hashAppend(hashAlgorithm, this->state());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ClusterCommand::isEqualTo(const ClusterCommand& rhs) const
{
    typedef ClusterCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_STATUS: return this->status() == rhs.status();
        case Class::SELECTION_ID_QUEUE_HELPER:
            return this->queueHelper() == rhs.queueHelper();
        case Class::SELECTION_ID_FORCE_GC_QUEUES:
            return this->forceGcQueues() == rhs.forceGcQueues();
        case Class::SELECTION_ID_STORAGE:
            return this->storage() == rhs.storage();
        case Class::SELECTION_ID_STATE: return this->state() == rhs.state();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ClusterCommand::ClusterCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClusterCommand::~ClusterCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClusterCommand::SELECTION_ID_STATUS:
        return manipulator(&d_status.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STATUS]);
    case ClusterCommand::SELECTION_ID_QUEUE_HELPER:
        return manipulator(&d_queueHelper.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_HELPER]);
    case ClusterCommand::SELECTION_ID_FORCE_GC_QUEUES:
        return manipulator(
            &d_forceGcQueues.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_FORCE_GC_QUEUES]);
    case ClusterCommand::SELECTION_ID_STORAGE:
        return manipulator(&d_storage.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE]);
    case ClusterCommand::SELECTION_ID_STATE:
        return manipulator(&d_state.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STATE]);
    default:
        BSLS_ASSERT(ClusterCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& ClusterCommand::status()
{
    BSLS_ASSERT(SELECTION_ID_STATUS == d_selectionId);
    return d_status.object();
}

inline Void& ClusterCommand::queueHelper()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_HELPER == d_selectionId);
    return d_queueHelper.object();
}

inline Void& ClusterCommand::forceGcQueues()
{
    BSLS_ASSERT(SELECTION_ID_FORCE_GC_QUEUES == d_selectionId);
    return d_forceGcQueues.object();
}

inline StorageCommand& ClusterCommand::storage()
{
    BSLS_ASSERT(SELECTION_ID_STORAGE == d_selectionId);
    return d_storage.object();
}

inline ClusterStateCommand& ClusterCommand::state()
{
    BSLS_ASSERT(SELECTION_ID_STATE == d_selectionId);
    return d_state.object();
}

// ACCESSORS
inline int ClusterCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ClusterCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_STATUS:
        return accessor(d_status.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STATUS]);
    case SELECTION_ID_QUEUE_HELPER:
        return accessor(d_queueHelper.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_HELPER]);
    case SELECTION_ID_FORCE_GC_QUEUES:
        return accessor(d_forceGcQueues.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_FORCE_GC_QUEUES]);
    case SELECTION_ID_STORAGE:
        return accessor(d_storage.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE]);
    case SELECTION_ID_STATE:
        return accessor(d_state.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STATE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& ClusterCommand::status() const
{
    BSLS_ASSERT(SELECTION_ID_STATUS == d_selectionId);
    return d_status.object();
}

inline const Void& ClusterCommand::queueHelper() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_HELPER == d_selectionId);
    return d_queueHelper.object();
}

inline const Void& ClusterCommand::forceGcQueues() const
{
    BSLS_ASSERT(SELECTION_ID_FORCE_GC_QUEUES == d_selectionId);
    return d_forceGcQueues.object();
}

inline const StorageCommand& ClusterCommand::storage() const
{
    BSLS_ASSERT(SELECTION_ID_STORAGE == d_selectionId);
    return d_storage.object();
}

inline const ClusterStateCommand& ClusterCommand::state() const
{
    BSLS_ASSERT(SELECTION_ID_STATE == d_selectionId);
    return d_state.object();
}

inline bool ClusterCommand::isStatusValue() const
{
    return SELECTION_ID_STATUS == d_selectionId;
}

inline bool ClusterCommand::isQueueHelperValue() const
{
    return SELECTION_ID_QUEUE_HELPER == d_selectionId;
}

inline bool ClusterCommand::isForceGcQueuesValue() const
{
    return SELECTION_ID_FORCE_GC_QUEUES == d_selectionId;
}

inline bool ClusterCommand::isStorageValue() const
{
    return SELECTION_ID_STORAGE == d_selectionId;
}

inline bool ClusterCommand::isStateValue() const
{
    return SELECTION_ID_STATE == d_selectionId;
}

inline bool ClusterCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -------------------
// class ClusterStatus
// -------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterStatus::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->name());
    hashAppend(hashAlgorithm, this->description());
    hashAppend(hashAlgorithm, this->selfNodeDescription());
    hashAppend(hashAlgorithm, this->isHealthy());
    hashAppend(hashAlgorithm, this->nodeStatuses());
    hashAppend(hashAlgorithm, this->electorInfo());
    hashAppend(hashAlgorithm, this->partitionsInfo());
    hashAppend(hashAlgorithm, this->queuesInfo());
    hashAppend(hashAlgorithm, this->clusterStorageSummary());
}

inline bool ClusterStatus::isEqualTo(const ClusterStatus& rhs) const
{
    return this->name() == rhs.name() &&
           this->description() == rhs.description() &&
           this->selfNodeDescription() == rhs.selfNodeDescription() &&
           this->isHealthy() == rhs.isHealthy() &&
           this->nodeStatuses() == rhs.nodeStatuses() &&
           this->electorInfo() == rhs.electorInfo() &&
           this->partitionsInfo() == rhs.partitionsInfo() &&
           this->queuesInfo() == rhs.queuesInfo() &&
           this->clusterStorageSummary() == rhs.clusterStorageSummary();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterStatus::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_description,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_selfNodeDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SELF_NODE_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_isHealthy,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_HEALTHY]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_nodeStatuses,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_STATUSES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_electorInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_INFO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_partitionsInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS_INFO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queuesInfo,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES_INFO]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_clusterStorageSummary,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STORAGE_SUMMARY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ClusterStatus::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_DESCRIPTION: {
        return manipulator(&d_description,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_SELF_NODE_DESCRIPTION: {
        return manipulator(
            &d_selfNodeDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SELF_NODE_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_IS_HEALTHY: {
        return manipulator(&d_isHealthy,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_HEALTHY]);
    }
    case ATTRIBUTE_ID_NODE_STATUSES: {
        return manipulator(
            &d_nodeStatuses,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_STATUSES]);
    }
    case ATTRIBUTE_ID_ELECTOR_INFO: {
        return manipulator(&d_electorInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_INFO]);
    }
    case ATTRIBUTE_ID_PARTITIONS_INFO: {
        return manipulator(
            &d_partitionsInfo,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS_INFO]);
    }
    case ATTRIBUTE_ID_QUEUES_INFO: {
        return manipulator(&d_queuesInfo,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES_INFO]);
    }
    case ATTRIBUTE_ID_CLUSTER_STORAGE_SUMMARY: {
        return manipulator(
            &d_clusterStorageSummary,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STORAGE_SUMMARY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ClusterStatus::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ClusterStatus::name()
{
    return d_name;
}

inline bsl::string& ClusterStatus::description()
{
    return d_description;
}

inline bsl::string& ClusterStatus::selfNodeDescription()
{
    return d_selfNodeDescription;
}

inline bool& ClusterStatus::isHealthy()
{
    return d_isHealthy;
}

inline NodeStatuses& ClusterStatus::nodeStatuses()
{
    return d_nodeStatuses;
}

inline ElectorInfo& ClusterStatus::electorInfo()
{
    return d_electorInfo;
}

inline PartitionsInfo& ClusterStatus::partitionsInfo()
{
    return d_partitionsInfo;
}

inline StorageContent& ClusterStatus::queuesInfo()
{
    return d_queuesInfo;
}

inline ClusterStorageSummary& ClusterStatus::clusterStorageSummary()
{
    return d_clusterStorageSummary;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ClusterStatus::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_description,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_selfNodeDescription,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SELF_NODE_DESCRIPTION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isHealthy,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_HEALTHY]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_nodeStatuses,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_STATUSES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_electorInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_INFO]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_partitionsInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS_INFO]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queuesInfo,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES_INFO]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_clusterStorageSummary,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STORAGE_SUMMARY]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ClusterStatus::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_DESCRIPTION: {
        return accessor(d_description,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_SELF_NODE_DESCRIPTION: {
        return accessor(
            d_selfNodeDescription,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SELF_NODE_DESCRIPTION]);
    }
    case ATTRIBUTE_ID_IS_HEALTHY: {
        return accessor(d_isHealthy,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_HEALTHY]);
    }
    case ATTRIBUTE_ID_NODE_STATUSES: {
        return accessor(d_nodeStatuses,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NODE_STATUSES]);
    }
    case ATTRIBUTE_ID_ELECTOR_INFO: {
        return accessor(d_electorInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ELECTOR_INFO]);
    }
    case ATTRIBUTE_ID_PARTITIONS_INFO: {
        return accessor(d_partitionsInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_PARTITIONS_INFO]);
    }
    case ATTRIBUTE_ID_QUEUES_INFO: {
        return accessor(d_queuesInfo,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUES_INFO]);
    }
    case ATTRIBUTE_ID_CLUSTER_STORAGE_SUMMARY: {
        return accessor(
            d_clusterStorageSummary,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CLUSTER_STORAGE_SUMMARY]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ClusterStatus::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ClusterStatus::name() const
{
    return d_name;
}

inline const bsl::string& ClusterStatus::description() const
{
    return d_description;
}

inline const bsl::string& ClusterStatus::selfNodeDescription() const
{
    return d_selfNodeDescription;
}

inline bool ClusterStatus::isHealthy() const
{
    return d_isHealthy;
}

inline const NodeStatuses& ClusterStatus::nodeStatuses() const
{
    return d_nodeStatuses;
}

inline const ElectorInfo& ClusterStatus::electorInfo() const
{
    return d_electorInfo;
}

inline const PartitionsInfo& ClusterStatus::partitionsInfo() const
{
    return d_partitionsInfo;
}

inline const StorageContent& ClusterStatus::queuesInfo() const
{
    return d_queuesInfo;
}

inline const ClusterStorageSummary&
ClusterStatus::clusterStorageSummary() const
{
    return d_clusterStorageSummary;
}

// --------------------
// class DomainsCommand
// --------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DomainsCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef DomainsCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_DOMAIN:
        hashAppend(hashAlgorithm, this->domain());
        break;
    case Class::SELECTION_ID_RESOLVER:
        hashAppend(hashAlgorithm, this->resolver());
        break;
    case Class::SELECTION_ID_RECONFIGURE:
        hashAppend(hashAlgorithm, this->reconfigure());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool DomainsCommand::isEqualTo(const DomainsCommand& rhs) const
{
    typedef DomainsCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_DOMAIN: return this->domain() == rhs.domain();
        case Class::SELECTION_ID_RESOLVER:
            return this->resolver() == rhs.resolver();
        case Class::SELECTION_ID_RECONFIGURE:
            return this->reconfigure() == rhs.reconfigure();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline DomainsCommand::DomainsCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline DomainsCommand::~DomainsCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int DomainsCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case DomainsCommand::SELECTION_ID_DOMAIN:
        return manipulator(&d_domain.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN]);
    case DomainsCommand::SELECTION_ID_RESOLVER:
        return manipulator(&d_resolver.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_RESOLVER]);
    case DomainsCommand::SELECTION_ID_RECONFIGURE:
        return manipulator(&d_reconfigure.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_RECONFIGURE]);
    default:
        BSLS_ASSERT(DomainsCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Domain& DomainsCommand::domain()
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN == d_selectionId);
    return d_domain.object();
}

inline DomainResolverCommand& DomainsCommand::resolver()
{
    BSLS_ASSERT(SELECTION_ID_RESOLVER == d_selectionId);
    return d_resolver.object();
}

inline DomainReconfigure& DomainsCommand::reconfigure()
{
    BSLS_ASSERT(SELECTION_ID_RECONFIGURE == d_selectionId);
    return d_reconfigure.object();
}

// ACCESSORS
inline int DomainsCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int DomainsCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_DOMAIN:
        return accessor(d_domain.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN]);
    case SELECTION_ID_RESOLVER:
        return accessor(d_resolver.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_RESOLVER]);
    case SELECTION_ID_RECONFIGURE:
        return accessor(d_reconfigure.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_RECONFIGURE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Domain& DomainsCommand::domain() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN == d_selectionId);
    return d_domain.object();
}

inline const DomainResolverCommand& DomainsCommand::resolver() const
{
    BSLS_ASSERT(SELECTION_ID_RESOLVER == d_selectionId);
    return d_resolver.object();
}

inline const DomainReconfigure& DomainsCommand::reconfigure() const
{
    BSLS_ASSERT(SELECTION_ID_RECONFIGURE == d_selectionId);
    return d_reconfigure.object();
}

inline bool DomainsCommand::isDomainValue() const
{
    return SELECTION_ID_DOMAIN == d_selectionId;
}

inline bool DomainsCommand::isResolverValue() const
{
    return SELECTION_ID_RESOLVER == d_selectionId;
}

inline bool DomainsCommand::isReconfigureValue() const
{
    return SELECTION_ID_RECONFIGURE == d_selectionId;
}

inline bool DomainsCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------------
// class RoundRobinRouter
// ----------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RoundRobinRouter::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_consumers,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RoundRobinRouter::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CONSUMERS: {
        return manipulator(&d_consumers,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RoundRobinRouter::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<RouterConsumer>& RoundRobinRouter::consumers()
{
    return d_consumers;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RoundRobinRouter::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_consumers,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RoundRobinRouter::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CONSUMERS: {
        return accessor(d_consumers,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMERS]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RoundRobinRouter::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<RouterConsumer>& RoundRobinRouter::consumers() const
{
    return d_consumers;
}

// -------------------
// class StorageResult
// -------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void StorageResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef StorageResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_SUCCESS:
        hashAppend(hashAlgorithm, this->success());
        break;
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_STORAGE_CONTENT:
        hashAppend(hashAlgorithm, this->storageContent());
        break;
    case Class::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        hashAppend(hashAlgorithm, this->clusterStorageSummary());
        break;
    case Class::SELECTION_ID_REPLICATION_RESULT:
        hashAppend(hashAlgorithm, this->replicationResult());
        break;
    case Class::SELECTION_ID_PURGED_QUEUES:
        hashAppend(hashAlgorithm, this->purgedQueues());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool StorageResult::isEqualTo(const StorageResult& rhs) const
{
    typedef StorageResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_SUCCESS:
            return this->success() == rhs.success();
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_STORAGE_CONTENT:
            return this->storageContent() == rhs.storageContent();
        case Class::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
            return this->clusterStorageSummary() ==
                   rhs.clusterStorageSummary();
        case Class::SELECTION_ID_REPLICATION_RESULT:
            return this->replicationResult() == rhs.replicationResult();
        case Class::SELECTION_ID_PURGED_QUEUES:
            return this->purgedQueues() == rhs.purgedQueues();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline StorageResult::StorageResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline StorageResult::~StorageResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int StorageResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case StorageResult::SELECTION_ID_SUCCESS:
        return manipulator(&d_success.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case StorageResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case StorageResult::SELECTION_ID_STORAGE_CONTENT:
        return manipulator(
            &d_storageContent.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_CONTENT]);
    case StorageResult::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        return manipulator(
            &d_clusterStorageSummary.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY]);
    case StorageResult::SELECTION_ID_REPLICATION_RESULT:
        return manipulator(
            &d_replicationResult.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICATION_RESULT]);
    case StorageResult::SELECTION_ID_PURGED_QUEUES:
        return manipulator(
            &d_purgedQueues.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGED_QUEUES]);
    default:
        BSLS_ASSERT(StorageResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& StorageResult::success()
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline Error& StorageResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline StorageContent& StorageResult::storageContent()
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_CONTENT == d_selectionId);
    return d_storageContent.object();
}

inline ClusterStorageSummary& StorageResult::clusterStorageSummary()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId);
    return d_clusterStorageSummary.object();
}

inline ReplicationResult& StorageResult::replicationResult()
{
    BSLS_ASSERT(SELECTION_ID_REPLICATION_RESULT == d_selectionId);
    return d_replicationResult.object();
}

inline PurgedQueues& StorageResult::purgedQueues()
{
    BSLS_ASSERT(SELECTION_ID_PURGED_QUEUES == d_selectionId);
    return d_purgedQueues.object();
}

// ACCESSORS
inline int StorageResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int StorageResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_SUCCESS:
        return accessor(d_success.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_STORAGE_CONTENT:
        return accessor(d_storageContent.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_CONTENT]);
    case SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        return accessor(
            d_clusterStorageSummary.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY]);
    case SELECTION_ID_REPLICATION_RESULT:
        return accessor(
            d_replicationResult.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_REPLICATION_RESULT]);
    case SELECTION_ID_PURGED_QUEUES:
        return accessor(d_purgedQueues.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGED_QUEUES]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& StorageResult::success() const
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline const Error& StorageResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const StorageContent& StorageResult::storageContent() const
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_CONTENT == d_selectionId);
    return d_storageContent.object();
}

inline const ClusterStorageSummary&
StorageResult::clusterStorageSummary() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId);
    return d_clusterStorageSummary.object();
}

inline const ReplicationResult& StorageResult::replicationResult() const
{
    BSLS_ASSERT(SELECTION_ID_REPLICATION_RESULT == d_selectionId);
    return d_replicationResult.object();
}

inline const PurgedQueues& StorageResult::purgedQueues() const
{
    BSLS_ASSERT(SELECTION_ID_PURGED_QUEUES == d_selectionId);
    return d_purgedQueues.object();
}

inline bool StorageResult::isSuccessValue() const
{
    return SELECTION_ID_SUCCESS == d_selectionId;
}

inline bool StorageResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool StorageResult::isStorageContentValue() const
{
    return SELECTION_ID_STORAGE_CONTENT == d_selectionId;
}

inline bool StorageResult::isClusterStorageSummaryValue() const
{
    return SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId;
}

inline bool StorageResult::isReplicationResultValue() const
{
    return SELECTION_ID_REPLICATION_RESULT == d_selectionId;
}

inline bool StorageResult::isPurgedQueuesValue() const
{
    return SELECTION_ID_PURGED_QUEUES == d_selectionId;
}

inline bool StorageResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------
// class AppState
// --------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void AppState::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->appId());
    hashAppend(hashAlgorithm, this->numConsumers());
    hashAppend(hashAlgorithm, this->redeliveryListLength());
    hashAppend(hashAlgorithm, this->roundRobinRouter());
}

inline bool AppState::isEqualTo(const AppState& rhs) const
{
    return this->appId() == rhs.appId() &&
           this->numConsumers() == rhs.numConsumers() &&
           this->redeliveryListLength() == rhs.redeliveryListLength() &&
           this->roundRobinRouter() == rhs.roundRobinRouter();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int AppState::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_numConsumers,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_CONSUMERS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_redeliveryListLength,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REDELIVERY_LIST_LENGTH]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_roundRobinRouter,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUND_ROBIN_ROUTER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int AppState::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_NUM_CONSUMERS: {
        return manipulator(
            &d_numConsumers,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_CONSUMERS]);
    }
    case ATTRIBUTE_ID_REDELIVERY_LIST_LENGTH: {
        return manipulator(
            &d_redeliveryListLength,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REDELIVERY_LIST_LENGTH]);
    }
    case ATTRIBUTE_ID_ROUND_ROBIN_ROUTER: {
        return manipulator(
            &d_roundRobinRouter,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUND_ROBIN_ROUTER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int AppState::manipulateAttribute(t_MANIPULATOR& manipulator,
                                  const char*    name,
                                  int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& AppState::appId()
{
    return d_appId;
}

inline unsigned int& AppState::numConsumers()
{
    return d_numConsumers;
}

inline bsls::Types::Int64& AppState::redeliveryListLength()
{
    return d_redeliveryListLength;
}

inline RoundRobinRouter& AppState::roundRobinRouter()
{
    return d_roundRobinRouter;
}

// ACCESSORS
template <typename t_ACCESSOR>
int AppState::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numConsumers,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_CONSUMERS]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_redeliveryListLength,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REDELIVERY_LIST_LENGTH]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_roundRobinRouter,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUND_ROBIN_ROUTER]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int AppState::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_NUM_CONSUMERS: {
        return accessor(d_numConsumers,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_CONSUMERS]);
    }
    case ATTRIBUTE_ID_REDELIVERY_LIST_LENGTH: {
        return accessor(
            d_redeliveryListLength,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_REDELIVERY_LIST_LENGTH]);
    }
    case ATTRIBUTE_ID_ROUND_ROBIN_ROUTER: {
        return accessor(
            d_roundRobinRouter,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUND_ROBIN_ROUTER]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int AppState::accessAttribute(t_ACCESSOR& accessor,
                              const char* name,
                              int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& AppState::appId() const
{
    return d_appId;
}

inline unsigned int AppState::numConsumers() const
{
    return d_numConsumers;
}

inline bsls::Types::Int64 AppState::redeliveryListLength() const
{
    return d_redeliveryListLength;
}

inline const RoundRobinRouter& AppState::roundRobinRouter() const
{
    return d_roundRobinRouter;
}

// -------------
// class Cluster
// -------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Cluster::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_command,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Cluster::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return manipulator(&d_name,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return manipulator(&d_command,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Cluster::manipulateAttribute(t_MANIPULATOR& manipulator,
                                 const char*    name,
                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& Cluster::name()
{
    return d_name;
}

inline ClusterCommand& Cluster::command()
{
    return d_command;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Cluster::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_command, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Cluster::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NAME: {
        return accessor(d_name, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NAME]);
    }
    case ATTRIBUTE_ID_COMMAND: {
        return accessor(d_command,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_COMMAND]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Cluster::accessAttribute(t_ACCESSOR& accessor,
                             const char* name,
                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& Cluster::name() const
{
    return d_name;
}

inline const ClusterCommand& Cluster::command() const
{
    return d_command;
}

// -------------------
// class ClusterResult
// -------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClusterResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ClusterResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_SUCCESS:
        hashAppend(hashAlgorithm, this->success());
        break;
    case Class::SELECTION_ID_ELECTOR_RESULT:
        hashAppend(hashAlgorithm, this->electorResult());
        break;
    case Class::SELECTION_ID_STORAGE_RESULT:
        hashAppend(hashAlgorithm, this->storageResult());
        break;
    case Class::SELECTION_ID_CLUSTER_QUEUE_HELPER:
        hashAppend(hashAlgorithm, this->clusterQueueHelper());
        break;
    case Class::SELECTION_ID_CLUSTER_STATUS:
        hashAppend(hashAlgorithm, this->clusterStatus());
        break;
    case Class::SELECTION_ID_CLUSTER_PROXY_STATUS:
        hashAppend(hashAlgorithm, this->clusterProxyStatus());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ClusterResult::isEqualTo(const ClusterResult& rhs) const
{
    typedef ClusterResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_SUCCESS:
            return this->success() == rhs.success();
        case Class::SELECTION_ID_ELECTOR_RESULT:
            return this->electorResult() == rhs.electorResult();
        case Class::SELECTION_ID_STORAGE_RESULT:
            return this->storageResult() == rhs.storageResult();
        case Class::SELECTION_ID_CLUSTER_QUEUE_HELPER:
            return this->clusterQueueHelper() == rhs.clusterQueueHelper();
        case Class::SELECTION_ID_CLUSTER_STATUS:
            return this->clusterStatus() == rhs.clusterStatus();
        case Class::SELECTION_ID_CLUSTER_PROXY_STATUS:
            return this->clusterProxyStatus() == rhs.clusterProxyStatus();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ClusterResult::ClusterResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClusterResult::~ClusterResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ClusterResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClusterResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case ClusterResult::SELECTION_ID_SUCCESS:
        return manipulator(&d_success.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case ClusterResult::SELECTION_ID_ELECTOR_RESULT:
        return manipulator(
            &d_electorResult.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR_RESULT]);
    case ClusterResult::SELECTION_ID_STORAGE_RESULT:
        return manipulator(
            &d_storageResult.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_RESULT]);
    case ClusterResult::SELECTION_ID_CLUSTER_QUEUE_HELPER:
        return manipulator(
            &d_clusterQueueHelper.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_QUEUE_HELPER]);
    case ClusterResult::SELECTION_ID_CLUSTER_STATUS:
        return manipulator(
            &d_clusterStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STATUS]);
    case ClusterResult::SELECTION_ID_CLUSTER_PROXY_STATUS:
        return manipulator(
            &d_clusterProxyStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_PROXY_STATUS]);
    default:
        BSLS_ASSERT(ClusterResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Error& ClusterResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline Void& ClusterResult::success()
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline ElectorResult& ClusterResult::electorResult()
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR_RESULT == d_selectionId);
    return d_electorResult.object();
}

inline StorageResult& ClusterResult::storageResult()
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_RESULT == d_selectionId);
    return d_storageResult.object();
}

inline ClusterQueueHelper& ClusterResult::clusterQueueHelper()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId);
    return d_clusterQueueHelper.object();
}

inline ClusterStatus& ClusterResult::clusterStatus()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STATUS == d_selectionId);
    return d_clusterStatus.object();
}

inline ClusterProxyStatus& ClusterResult::clusterProxyStatus()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_PROXY_STATUS == d_selectionId);
    return d_clusterProxyStatus.object();
}

// ACCESSORS
inline int ClusterResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ClusterResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_SUCCESS:
        return accessor(d_success.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case SELECTION_ID_ELECTOR_RESULT:
        return accessor(d_electorResult.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR_RESULT]);
    case SELECTION_ID_STORAGE_RESULT:
        return accessor(d_storageResult.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_RESULT]);
    case SELECTION_ID_CLUSTER_QUEUE_HELPER:
        return accessor(
            d_clusterQueueHelper.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_QUEUE_HELPER]);
    case SELECTION_ID_CLUSTER_STATUS:
        return accessor(d_clusterStatus.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STATUS]);
    case SELECTION_ID_CLUSTER_PROXY_STATUS:
        return accessor(
            d_clusterProxyStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_PROXY_STATUS]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& ClusterResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const Void& ClusterResult::success() const
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline const ElectorResult& ClusterResult::electorResult() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR_RESULT == d_selectionId);
    return d_electorResult.object();
}

inline const StorageResult& ClusterResult::storageResult() const
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_RESULT == d_selectionId);
    return d_storageResult.object();
}

inline const ClusterQueueHelper& ClusterResult::clusterQueueHelper() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId);
    return d_clusterQueueHelper.object();
}

inline const ClusterStatus& ClusterResult::clusterStatus() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STATUS == d_selectionId);
    return d_clusterStatus.object();
}

inline const ClusterProxyStatus& ClusterResult::clusterProxyStatus() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_PROXY_STATUS == d_selectionId);
    return d_clusterProxyStatus.object();
}

inline bool ClusterResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool ClusterResult::isSuccessValue() const
{
    return SELECTION_ID_SUCCESS == d_selectionId;
}

inline bool ClusterResult::isElectorResultValue() const
{
    return SELECTION_ID_ELECTOR_RESULT == d_selectionId;
}

inline bool ClusterResult::isStorageResultValue() const
{
    return SELECTION_ID_STORAGE_RESULT == d_selectionId;
}

inline bool ClusterResult::isClusterQueueHelperValue() const
{
    return SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId;
}

inline bool ClusterResult::isClusterStatusValue() const
{
    return SELECTION_ID_CLUSTER_STATUS == d_selectionId;
}

inline bool ClusterResult::isClusterProxyStatusValue() const
{
    return SELECTION_ID_CLUSTER_PROXY_STATUS == d_selectionId;
}

inline bool ClusterResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ---------------------
// class ClustersCommand
// ---------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClustersCommand::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ClustersCommand Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_LIST:
        hashAppend(hashAlgorithm, this->list());
        break;
    case Class::SELECTION_ID_ADD_REVERSE_PROXY:
        hashAppend(hashAlgorithm, this->addReverseProxy());
        break;
    case Class::SELECTION_ID_CLUSTER:
        hashAppend(hashAlgorithm, this->cluster());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ClustersCommand::isEqualTo(const ClustersCommand& rhs) const
{
    typedef ClustersCommand Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_LIST: return this->list() == rhs.list();
        case Class::SELECTION_ID_ADD_REVERSE_PROXY:
            return this->addReverseProxy() == rhs.addReverseProxy();
        case Class::SELECTION_ID_CLUSTER:
            return this->cluster() == rhs.cluster();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ClustersCommand::ClustersCommand(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClustersCommand::~ClustersCommand()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ClustersCommand::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClustersCommand::SELECTION_ID_LIST:
        return manipulator(&d_list.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_LIST]);
    case ClustersCommand::SELECTION_ID_ADD_REVERSE_PROXY:
        return manipulator(
            &d_addReverseProxy.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ADD_REVERSE_PROXY]);
    case ClustersCommand::SELECTION_ID_CLUSTER:
        return manipulator(&d_cluster.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER]);
    default:
        BSLS_ASSERT(ClustersCommand::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& ClustersCommand::list()
{
    BSLS_ASSERT(SELECTION_ID_LIST == d_selectionId);
    return d_list.object();
}

inline AddReverseProxy& ClustersCommand::addReverseProxy()
{
    BSLS_ASSERT(SELECTION_ID_ADD_REVERSE_PROXY == d_selectionId);
    return d_addReverseProxy.object();
}

inline Cluster& ClustersCommand::cluster()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER == d_selectionId);
    return d_cluster.object();
}

// ACCESSORS
inline int ClustersCommand::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ClustersCommand::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_LIST:
        return accessor(d_list.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LIST]);
    case SELECTION_ID_ADD_REVERSE_PROXY:
        return accessor(
            d_addReverseProxy.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_ADD_REVERSE_PROXY]);
    case SELECTION_ID_CLUSTER:
        return accessor(d_cluster.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& ClustersCommand::list() const
{
    BSLS_ASSERT(SELECTION_ID_LIST == d_selectionId);
    return d_list.object();
}

inline const AddReverseProxy& ClustersCommand::addReverseProxy() const
{
    BSLS_ASSERT(SELECTION_ID_ADD_REVERSE_PROXY == d_selectionId);
    return d_addReverseProxy.object();
}

inline const Cluster& ClustersCommand::cluster() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER == d_selectionId);
    return d_cluster.object();
}

inline bool ClustersCommand::isListValue() const
{
    return SELECTION_ID_LIST == d_selectionId;
}

inline bool ClustersCommand::isAddReverseProxyValue() const
{
    return SELECTION_ID_ADD_REVERSE_PROXY == d_selectionId;
}

inline bool ClustersCommand::isClusterValue() const
{
    return SELECTION_ID_CLUSTER == d_selectionId;
}

inline bool ClustersCommand::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class ClustersResult
// --------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ClustersResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef ClustersResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_SUCCESS:
        hashAppend(hashAlgorithm, this->success());
        break;
    case Class::SELECTION_ID_CLUSTER_LIST:
        hashAppend(hashAlgorithm, this->clusterList());
        break;
    case Class::SELECTION_ID_CLUSTER_RESULT:
        hashAppend(hashAlgorithm, this->clusterResult());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool ClustersResult::isEqualTo(const ClustersResult& rhs) const
{
    typedef ClustersResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_SUCCESS:
            return this->success() == rhs.success();
        case Class::SELECTION_ID_CLUSTER_LIST:
            return this->clusterList() == rhs.clusterList();
        case Class::SELECTION_ID_CLUSTER_RESULT:
            return this->clusterResult() == rhs.clusterResult();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline ClustersResult::ClustersResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline ClustersResult::~ClustersResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int ClustersResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case ClustersResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case ClustersResult::SELECTION_ID_SUCCESS:
        return manipulator(&d_success.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case ClustersResult::SELECTION_ID_CLUSTER_LIST:
        return manipulator(&d_clusterList.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_LIST]);
    case ClustersResult::SELECTION_ID_CLUSTER_RESULT:
        return manipulator(
            &d_clusterResult.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_RESULT]);
    default:
        BSLS_ASSERT(ClustersResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Error& ClustersResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline Void& ClustersResult::success()
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline ClusterList& ClustersResult::clusterList()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_LIST == d_selectionId);
    return d_clusterList.object();
}

inline ClusterResult& ClustersResult::clusterResult()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_RESULT == d_selectionId);
    return d_clusterResult.object();
}

// ACCESSORS
inline int ClustersResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int ClustersResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_SUCCESS:
        return accessor(d_success.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case SELECTION_ID_CLUSTER_LIST:
        return accessor(d_clusterList.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_LIST]);
    case SELECTION_ID_CLUSTER_RESULT:
        return accessor(d_clusterResult.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_RESULT]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& ClustersResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const Void& ClustersResult::success() const
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline const ClusterList& ClustersResult::clusterList() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_LIST == d_selectionId);
    return d_clusterList.object();
}

inline const ClusterResult& ClustersResult::clusterResult() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_RESULT == d_selectionId);
    return d_clusterResult.object();
}

inline bool ClustersResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool ClustersResult::isSuccessValue() const
{
    return SELECTION_ID_SUCCESS == d_selectionId;
}

inline bool ClustersResult::isClusterListValue() const
{
    return SELECTION_ID_CLUSTER_LIST == d_selectionId;
}

inline bool ClustersResult::isClusterResultValue() const
{
    return SELECTION_ID_CLUSTER_RESULT == d_selectionId;
}

inline bool ClustersResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -------------------
// class ConsumerState
// -------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void ConsumerState::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->appId());
    hashAppend(hashAlgorithm, this->status());
    hashAppend(hashAlgorithm, this->isAtEndOfStorage());
    hashAppend(hashAlgorithm, this->appState());
}

inline bool ConsumerState::isEqualTo(const ConsumerState& rhs) const
{
    return this->appId() == rhs.appId() && this->status() == rhs.status() &&
           this->isAtEndOfStorage() == rhs.isAtEndOfStorage() &&
           this->appState() == rhs.appState();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int ConsumerState::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_isAtEndOfStorage,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AT_END_OF_STORAGE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appState,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_STATE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int ConsumerState::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return manipulator(&d_appId,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return manipulator(&d_status,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    case ATTRIBUTE_ID_IS_AT_END_OF_STORAGE: {
        return manipulator(
            &d_isAtEndOfStorage,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AT_END_OF_STORAGE]);
    }
    case ATTRIBUTE_ID_APP_STATE: {
        return manipulator(&d_appState,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_STATE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int ConsumerState::manipulateAttribute(t_MANIPULATOR& manipulator,
                                       const char*    name,
                                       int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& ConsumerState::appId()
{
    return d_appId;
}

inline ConsumerStatus::Value& ConsumerState::status()
{
    return d_status;
}

inline bdlb::NullableValue<bool>& ConsumerState::isAtEndOfStorage()
{
    return d_isAtEndOfStorage;
}

inline AppState& ConsumerState::appState()
{
    return d_appState;
}

// ACCESSORS
template <typename t_ACCESSOR>
int ConsumerState::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_status, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isAtEndOfStorage,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AT_END_OF_STORAGE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appState,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_STATE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int ConsumerState::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_APP_ID: {
        return accessor(d_appId, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_ID]);
    }
    case ATTRIBUTE_ID_STATUS: {
        return accessor(d_status,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATUS]);
    }
    case ATTRIBUTE_ID_IS_AT_END_OF_STORAGE: {
        return accessor(
            d_isAtEndOfStorage,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_IS_AT_END_OF_STORAGE]);
    }
    case ATTRIBUTE_ID_APP_STATE: {
        return accessor(d_appState,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_STATE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int ConsumerState::accessAttribute(t_ACCESSOR& accessor,
                                   const char* name,
                                   int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& ConsumerState::appId() const
{
    return d_appId;
}

inline ConsumerStatus::Value ConsumerState::status() const
{
    return d_status;
}

inline const bdlb::NullableValue<bool>& ConsumerState::isAtEndOfStorage() const
{
    return d_isAtEndOfStorage;
}

inline const AppState& ConsumerState::appState() const
{
    return d_appState;
}

// ----------------------
// class RelayQueueEngine
// ----------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void RelayQueueEngine::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->numSubstreams());
    hashAppend(hashAlgorithm, this->subStreams());
    hashAppend(hashAlgorithm, this->appStates());
    hashAppend(hashAlgorithm, this->routing());
}

inline bool RelayQueueEngine::isEqualTo(const RelayQueueEngine& rhs) const
{
    return this->numSubstreams() == rhs.numSubstreams() &&
           this->subStreams() == rhs.subStreams() &&
           this->appStates() == rhs.appStates() &&
           this->routing() == rhs.routing();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RelayQueueEngine::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_numSubstreams,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_SUBSTREAMS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_subStreams,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_STREAMS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_appStates,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_STATES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_routing,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RelayQueueEngine::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NUM_SUBSTREAMS: {
        return manipulator(
            &d_numSubstreams,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_SUBSTREAMS]);
    }
    case ATTRIBUTE_ID_SUB_STREAMS: {
        return manipulator(&d_subStreams,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_STREAMS]);
    }
    case ATTRIBUTE_ID_APP_STATES: {
        return manipulator(&d_appStates,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_STATES]);
    }
    case ATTRIBUTE_ID_ROUTING: {
        return manipulator(&d_routing,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RelayQueueEngine::manipulateAttribute(t_MANIPULATOR& manipulator,
                                          const char*    name,
                                          int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& RelayQueueEngine::numSubstreams()
{
    return d_numSubstreams;
}

inline bsl::vector<RelayQueueEngineSubStream>& RelayQueueEngine::subStreams()
{
    return d_subStreams;
}

inline bsl::vector<AppState>& RelayQueueEngine::appStates()
{
    return d_appStates;
}

inline Routing& RelayQueueEngine::routing()
{
    return d_routing;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RelayQueueEngine::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_numSubstreams,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_SUBSTREAMS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_subStreams,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_STREAMS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_appStates,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_STATES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_routing, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RelayQueueEngine::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NUM_SUBSTREAMS: {
        return accessor(d_numSubstreams,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_SUBSTREAMS]);
    }
    case ATTRIBUTE_ID_SUB_STREAMS: {
        return accessor(d_subStreams,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SUB_STREAMS]);
    }
    case ATTRIBUTE_ID_APP_STATES: {
        return accessor(d_appStates,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_APP_STATES]);
    }
    case ATTRIBUTE_ID_ROUTING: {
        return accessor(d_routing,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RelayQueueEngine::accessAttribute(t_ACCESSOR& accessor,
                                      const char* name,
                                      int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int RelayQueueEngine::numSubstreams() const
{
    return d_numSubstreams;
}

inline const bsl::vector<RelayQueueEngineSubStream>&
RelayQueueEngine::subStreams() const
{
    return d_subStreams;
}

inline const bsl::vector<AppState>& RelayQueueEngine::appStates() const
{
    return d_appStates;
}

inline const Routing& RelayQueueEngine::routing() const
{
    return d_routing;
}

// -------------------
// class CommandChoice
// -------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void CommandChoice::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef CommandChoice Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_HELP:
        hashAppend(hashAlgorithm, this->help());
        break;
    case Class::SELECTION_ID_DOMAINS:
        hashAppend(hashAlgorithm, this->domains());
        break;
    case Class::SELECTION_ID_CONFIG_PROVIDER:
        hashAppend(hashAlgorithm, this->configProvider());
        break;
    case Class::SELECTION_ID_STAT:
        hashAppend(hashAlgorithm, this->stat());
        break;
    case Class::SELECTION_ID_CLUSTERS:
        hashAppend(hashAlgorithm, this->clusters());
        break;
    case Class::SELECTION_ID_DANGER:
        hashAppend(hashAlgorithm, this->danger());
        break;
    case Class::SELECTION_ID_BROKER_CONFIG:
        hashAppend(hashAlgorithm, this->brokerConfig());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool CommandChoice::isEqualTo(const CommandChoice& rhs) const
{
    typedef CommandChoice Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_HELP: return this->help() == rhs.help();
        case Class::SELECTION_ID_DOMAINS:
            return this->domains() == rhs.domains();
        case Class::SELECTION_ID_CONFIG_PROVIDER:
            return this->configProvider() == rhs.configProvider();
        case Class::SELECTION_ID_STAT: return this->stat() == rhs.stat();
        case Class::SELECTION_ID_CLUSTERS:
            return this->clusters() == rhs.clusters();
        case Class::SELECTION_ID_DANGER: return this->danger() == rhs.danger();
        case Class::SELECTION_ID_BROKER_CONFIG:
            return this->brokerConfig() == rhs.brokerConfig();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline CommandChoice::CommandChoice(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline CommandChoice::~CommandChoice()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int CommandChoice::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case CommandChoice::SELECTION_ID_HELP:
        return manipulator(&d_help.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_HELP]);
    case CommandChoice::SELECTION_ID_DOMAINS:
        return manipulator(&d_domains.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAINS]);
    case CommandChoice::SELECTION_ID_CONFIG_PROVIDER:
        return manipulator(
            &d_configProvider.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIG_PROVIDER]);
    case CommandChoice::SELECTION_ID_STAT:
        return manipulator(&d_stat.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STAT]);
    case CommandChoice::SELECTION_ID_CLUSTERS:
        return manipulator(&d_clusters.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTERS]);
    case CommandChoice::SELECTION_ID_DANGER:
        return manipulator(&d_danger.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DANGER]);
    case CommandChoice::SELECTION_ID_BROKER_CONFIG:
        return manipulator(
            &d_brokerConfig.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_CONFIG]);
    default:
        BSLS_ASSERT(CommandChoice::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline HelpCommand& CommandChoice::help()
{
    BSLS_ASSERT(SELECTION_ID_HELP == d_selectionId);
    return d_help.object();
}

inline DomainsCommand& CommandChoice::domains()
{
    BSLS_ASSERT(SELECTION_ID_DOMAINS == d_selectionId);
    return d_domains.object();
}

inline ConfigProviderCommand& CommandChoice::configProvider()
{
    BSLS_ASSERT(SELECTION_ID_CONFIG_PROVIDER == d_selectionId);
    return d_configProvider.object();
}

inline StatCommand& CommandChoice::stat()
{
    BSLS_ASSERT(SELECTION_ID_STAT == d_selectionId);
    return d_stat.object();
}

inline ClustersCommand& CommandChoice::clusters()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTERS == d_selectionId);
    return d_clusters.object();
}

inline DangerCommand& CommandChoice::danger()
{
    BSLS_ASSERT(SELECTION_ID_DANGER == d_selectionId);
    return d_danger.object();
}

inline BrokerConfigCommand& CommandChoice::brokerConfig()
{
    BSLS_ASSERT(SELECTION_ID_BROKER_CONFIG == d_selectionId);
    return d_brokerConfig.object();
}

// ACCESSORS
inline int CommandChoice::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int CommandChoice::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_HELP:
        return accessor(d_help.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_HELP]);
    case SELECTION_ID_DOMAINS:
        return accessor(d_domains.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAINS]);
    case SELECTION_ID_CONFIG_PROVIDER:
        return accessor(d_configProvider.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CONFIG_PROVIDER]);
    case SELECTION_ID_STAT:
        return accessor(d_stat.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STAT]);
    case SELECTION_ID_CLUSTERS:
        return accessor(d_clusters.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTERS]);
    case SELECTION_ID_DANGER:
        return accessor(d_danger.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DANGER]);
    case SELECTION_ID_BROKER_CONFIG:
        return accessor(d_brokerConfig.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_CONFIG]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const HelpCommand& CommandChoice::help() const
{
    BSLS_ASSERT(SELECTION_ID_HELP == d_selectionId);
    return d_help.object();
}

inline const DomainsCommand& CommandChoice::domains() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAINS == d_selectionId);
    return d_domains.object();
}

inline const ConfigProviderCommand& CommandChoice::configProvider() const
{
    BSLS_ASSERT(SELECTION_ID_CONFIG_PROVIDER == d_selectionId);
    return d_configProvider.object();
}

inline const StatCommand& CommandChoice::stat() const
{
    BSLS_ASSERT(SELECTION_ID_STAT == d_selectionId);
    return d_stat.object();
}

inline const ClustersCommand& CommandChoice::clusters() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTERS == d_selectionId);
    return d_clusters.object();
}

inline const DangerCommand& CommandChoice::danger() const
{
    BSLS_ASSERT(SELECTION_ID_DANGER == d_selectionId);
    return d_danger.object();
}

inline const BrokerConfigCommand& CommandChoice::brokerConfig() const
{
    BSLS_ASSERT(SELECTION_ID_BROKER_CONFIG == d_selectionId);
    return d_brokerConfig.object();
}

inline bool CommandChoice::isHelpValue() const
{
    return SELECTION_ID_HELP == d_selectionId;
}

inline bool CommandChoice::isDomainsValue() const
{
    return SELECTION_ID_DOMAINS == d_selectionId;
}

inline bool CommandChoice::isConfigProviderValue() const
{
    return SELECTION_ID_CONFIG_PROVIDER == d_selectionId;
}

inline bool CommandChoice::isStatValue() const
{
    return SELECTION_ID_STAT == d_selectionId;
}

inline bool CommandChoice::isClustersValue() const
{
    return SELECTION_ID_CLUSTERS == d_selectionId;
}

inline bool CommandChoice::isDangerValue() const
{
    return SELECTION_ID_DANGER == d_selectionId;
}

inline bool CommandChoice::isBrokerConfigValue() const
{
    return SELECTION_ID_BROKER_CONFIG == d_selectionId;
}

inline bool CommandChoice::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------------
// class FanoutQueueEngine
// -----------------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void FanoutQueueEngine::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->maxConsumers());
    hashAppend(hashAlgorithm, this->mode());
    hashAppend(hashAlgorithm, this->consumerStates());
    hashAppend(hashAlgorithm, this->routing());
}

inline bool FanoutQueueEngine::isEqualTo(const FanoutQueueEngine& rhs) const
{
    return this->maxConsumers() == rhs.maxConsumers() &&
           this->mode() == rhs.mode() &&
           this->consumerStates() == rhs.consumerStates() &&
           this->routing() == rhs.routing();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int FanoutQueueEngine::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_maxConsumers,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_CONSUMERS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_mode, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MODE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_consumerStates,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_STATES]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_routing,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int FanoutQueueEngine::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MAX_CONSUMERS: {
        return manipulator(
            &d_maxConsumers,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_CONSUMERS]);
    }
    case ATTRIBUTE_ID_MODE: {
        return manipulator(&d_mode,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MODE]);
    }
    case ATTRIBUTE_ID_CONSUMER_STATES: {
        return manipulator(
            &d_consumerStates,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_STATES]);
    }
    case ATTRIBUTE_ID_ROUTING: {
        return manipulator(&d_routing,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int FanoutQueueEngine::manipulateAttribute(t_MANIPULATOR& manipulator,
                                           const char*    name,
                                           int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline unsigned int& FanoutQueueEngine::maxConsumers()
{
    return d_maxConsumers;
}

inline bsl::string& FanoutQueueEngine::mode()
{
    return d_mode;
}

inline bsl::vector<ConsumerState>& FanoutQueueEngine::consumerStates()
{
    return d_consumerStates;
}

inline Routing& FanoutQueueEngine::routing()
{
    return d_routing;
}

// ACCESSORS
template <typename t_ACCESSOR>
int FanoutQueueEngine::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_maxConsumers,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_CONSUMERS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_mode, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MODE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_consumerStates,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_STATES]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_routing, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int FanoutQueueEngine::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_MAX_CONSUMERS: {
        return accessor(d_maxConsumers,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MAX_CONSUMERS]);
    }
    case ATTRIBUTE_ID_MODE: {
        return accessor(d_mode, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_MODE]);
    }
    case ATTRIBUTE_ID_CONSUMER_STATES: {
        return accessor(d_consumerStates,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CONSUMER_STATES]);
    }
    case ATTRIBUTE_ID_ROUTING: {
        return accessor(d_routing,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ROUTING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int FanoutQueueEngine::accessAttribute(t_ACCESSOR& accessor,
                                       const char* name,
                                       int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline unsigned int FanoutQueueEngine::maxConsumers() const
{
    return d_maxConsumers;
}

inline const bsl::string& FanoutQueueEngine::mode() const
{
    return d_mode;
}

inline const bsl::vector<ConsumerState>&
FanoutQueueEngine::consumerStates() const
{
    return d_consumerStates;
}

inline const Routing& FanoutQueueEngine::routing() const
{
    return d_routing;
}

// -------------
// class Command
// -------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int Command::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_encoding,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ENCODING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int Command::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return manipulator(&d_choice,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    case ATTRIBUTE_ID_ENCODING: {
        return manipulator(&d_encoding,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ENCODING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int Command::manipulateAttribute(t_MANIPULATOR& manipulator,
                                 const char*    name,
                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline CommandChoice& Command::choice()
{
    return d_choice;
}

inline EncodingFormat::Value& Command::encoding()
{
    return d_encoding;
}

// ACCESSORS
template <typename t_ACCESSOR>
int Command::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_choice, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_encoding, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ENCODING]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int Command::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_CHOICE: {
        return accessor(d_choice,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_CHOICE]);
    }
    case ATTRIBUTE_ID_ENCODING: {
        return accessor(d_encoding,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_ENCODING]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int Command::accessAttribute(t_ACCESSOR& accessor,
                             const char* name,
                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const CommandChoice& Command::choice() const
{
    return d_choice;
}

inline EncodingFormat::Value Command::encoding() const
{
    return d_encoding;
}

// -----------------
// class QueueEngine
// -----------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueEngine::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef QueueEngine Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_FANOUT:
        hashAppend(hashAlgorithm, this->fanout());
        break;
    case Class::SELECTION_ID_RELAY:
        hashAppend(hashAlgorithm, this->relay());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool QueueEngine::isEqualTo(const QueueEngine& rhs) const
{
    typedef QueueEngine Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_FANOUT: return this->fanout() == rhs.fanout();
        case Class::SELECTION_ID_RELAY: return this->relay() == rhs.relay();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline QueueEngine::QueueEngine(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline QueueEngine::~QueueEngine()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueEngine::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case QueueEngine::SELECTION_ID_FANOUT:
        return manipulator(&d_fanout.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_FANOUT]);
    case QueueEngine::SELECTION_ID_RELAY:
        return manipulator(&d_relay.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_RELAY]);
    default:
        BSLS_ASSERT(QueueEngine::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline FanoutQueueEngine& QueueEngine::fanout()
{
    BSLS_ASSERT(SELECTION_ID_FANOUT == d_selectionId);
    return d_fanout.object();
}

inline RelayQueueEngine& QueueEngine::relay()
{
    BSLS_ASSERT(SELECTION_ID_RELAY == d_selectionId);
    return d_relay.object();
}

// ACCESSORS
inline int QueueEngine::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int QueueEngine::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_FANOUT:
        return accessor(d_fanout.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_FANOUT]);
    case SELECTION_ID_RELAY:
        return accessor(d_relay.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_RELAY]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const FanoutQueueEngine& QueueEngine::fanout() const
{
    BSLS_ASSERT(SELECTION_ID_FANOUT == d_selectionId);
    return d_fanout.object();
}

inline const RelayQueueEngine& QueueEngine::relay() const
{
    BSLS_ASSERT(SELECTION_ID_RELAY == d_selectionId);
    return d_relay.object();
}

inline bool QueueEngine::isFanoutValue() const
{
    return SELECTION_ID_FANOUT == d_selectionId;
}

inline bool QueueEngine::isRelayValue() const
{
    return SELECTION_ID_RELAY == d_selectionId;
}

inline bool QueueEngine::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ----------------
// class LocalQueue
// ----------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int LocalQueue::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_queueEngine,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_ENGINE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int LocalQueue::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_ENGINE: {
        return manipulator(&d_queueEngine,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_ENGINE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int LocalQueue::manipulateAttribute(t_MANIPULATOR& manipulator,
                                    const char*    name,
                                    int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline QueueEngine& LocalQueue::queueEngine()
{
    return d_queueEngine;
}

// ACCESSORS
template <typename t_ACCESSOR>
int LocalQueue::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_queueEngine,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_ENGINE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int LocalQueue::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_QUEUE_ENGINE: {
        return accessor(d_queueEngine,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_ENGINE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int LocalQueue::accessAttribute(t_ACCESSOR& accessor,
                                const char* name,
                                int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const QueueEngine& LocalQueue::queueEngine() const
{
    return d_queueEngine;
}

// -----------------
// class RemoteQueue
// -----------------

// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void RemoteQueue::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->numPendingPuts());
    hashAppend(hashAlgorithm, this->numPendingConfirms());
    hashAppend(hashAlgorithm, this->isPushExpirationTimerScheduled());
    hashAppend(hashAlgorithm, this->numUpstreamGeneration());
    hashAppend(hashAlgorithm, this->streams());
    hashAppend(hashAlgorithm, this->queueEngine());
}

inline bool RemoteQueue::isEqualTo(const RemoteQueue& rhs) const
{
    return this->numPendingPuts() == rhs.numPendingPuts() &&
           this->numPendingConfirms() == rhs.numPendingConfirms() &&
           this->isPushExpirationTimerScheduled() ==
               rhs.isPushExpirationTimerScheduled() &&
           this->numUpstreamGeneration() == rhs.numUpstreamGeneration() &&
           this->streams() == rhs.streams() &&
           this->queueEngine() == rhs.queueEngine();
}

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RemoteQueue::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_numPendingPuts,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_PENDING_PUTS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numPendingConfirms,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_PENDING_CONFIRMS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_isPushExpirationTimerScheduled,
        ATTRIBUTE_INFO_ARRAY
            [ATTRIBUTE_INDEX_IS_PUSH_EXPIRATION_TIMER_SCHEDULED]);
    if (ret) {
        return ret;
    }

    ret = manipulator(
        &d_numUpstreamGeneration,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UPSTREAM_GENERATION]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_streams,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAMS]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queueEngine,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_ENGINE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RemoteQueue::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NUM_PENDING_PUTS: {
        return manipulator(
            &d_numPendingPuts,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_PENDING_PUTS]);
    }
    case ATTRIBUTE_ID_NUM_PENDING_CONFIRMS: {
        return manipulator(
            &d_numPendingConfirms,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_PENDING_CONFIRMS]);
    }
    case ATTRIBUTE_ID_IS_PUSH_EXPIRATION_TIMER_SCHEDULED: {
        return manipulator(
            &d_isPushExpirationTimerScheduled,
            ATTRIBUTE_INFO_ARRAY
                [ATTRIBUTE_INDEX_IS_PUSH_EXPIRATION_TIMER_SCHEDULED]);
    }
    case ATTRIBUTE_ID_NUM_UPSTREAM_GENERATION: {
        return manipulator(
            &d_numUpstreamGeneration,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UPSTREAM_GENERATION]);
    }
    case ATTRIBUTE_ID_STREAMS: {
        return manipulator(&d_streams,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAMS]);
    }
    case ATTRIBUTE_ID_QUEUE_ENGINE: {
        return manipulator(&d_queueEngine,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_ENGINE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RemoteQueue::manipulateAttribute(t_MANIPULATOR& manipulator,
                                     const char*    name,
                                     int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsls::Types::Int64& RemoteQueue::numPendingPuts()
{
    return d_numPendingPuts;
}

inline bsls::Types::Int64& RemoteQueue::numPendingConfirms()
{
    return d_numPendingConfirms;
}

inline bool& RemoteQueue::isPushExpirationTimerScheduled()
{
    return d_isPushExpirationTimerScheduled;
}

inline unsigned int& RemoteQueue::numUpstreamGeneration()
{
    return d_numUpstreamGeneration;
}

inline bsl::vector<RemoteStreamInfo>& RemoteQueue::streams()
{
    return d_streams;
}

inline QueueEngine& RemoteQueue::queueEngine()
{
    return d_queueEngine;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RemoteQueue::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_numPendingPuts,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_PENDING_PUTS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_numPendingConfirms,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_PENDING_CONFIRMS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_isPushExpirationTimerScheduled,
                   ATTRIBUTE_INFO_ARRAY
                       [ATTRIBUTE_INDEX_IS_PUSH_EXPIRATION_TIMER_SCHEDULED]);
    if (ret) {
        return ret;
    }

    ret = accessor(
        d_numUpstreamGeneration,
        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UPSTREAM_GENERATION]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_streams, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAMS]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queueEngine,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_ENGINE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RemoteQueue::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_NUM_PENDING_PUTS: {
        return accessor(
            d_numPendingPuts,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_PENDING_PUTS]);
    }
    case ATTRIBUTE_ID_NUM_PENDING_CONFIRMS: {
        return accessor(
            d_numPendingConfirms,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_PENDING_CONFIRMS]);
    }
    case ATTRIBUTE_ID_IS_PUSH_EXPIRATION_TIMER_SCHEDULED: {
        return accessor(
            d_isPushExpirationTimerScheduled,
            ATTRIBUTE_INFO_ARRAY
                [ATTRIBUTE_INDEX_IS_PUSH_EXPIRATION_TIMER_SCHEDULED]);
    }
    case ATTRIBUTE_ID_NUM_UPSTREAM_GENERATION: {
        return accessor(
            d_numUpstreamGeneration,
            ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_NUM_UPSTREAM_GENERATION]);
    }
    case ATTRIBUTE_ID_STREAMS: {
        return accessor(d_streams,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STREAMS]);
    }
    case ATTRIBUTE_ID_QUEUE_ENGINE: {
        return accessor(d_queueEngine,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE_ENGINE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RemoteQueue::accessAttribute(t_ACCESSOR& accessor,
                                 const char* name,
                                 int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline bsls::Types::Int64 RemoteQueue::numPendingPuts() const
{
    return d_numPendingPuts;
}

inline bsls::Types::Int64 RemoteQueue::numPendingConfirms() const
{
    return d_numPendingConfirms;
}

inline bool RemoteQueue::isPushExpirationTimerScheduled() const
{
    return d_isPushExpirationTimerScheduled;
}

inline unsigned int RemoteQueue::numUpstreamGeneration() const
{
    return d_numUpstreamGeneration;
}

inline const bsl::vector<RemoteStreamInfo>& RemoteQueue::streams() const
{
    return d_streams;
}

inline const QueueEngine& RemoteQueue::queueEngine() const
{
    return d_queueEngine;
}

// -----------
// class Queue
// -----------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void Queue::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef Queue Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_LOCAL_QUEUE:
        hashAppend(hashAlgorithm, this->localQueue());
        break;
    case Class::SELECTION_ID_REMOTE_QUEUE:
        hashAppend(hashAlgorithm, this->remoteQueue());
        break;
    case Class::SELECTION_ID_UNINITIALIZED_QUEUE:
        hashAppend(hashAlgorithm, this->uninitializedQueue());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool Queue::isEqualTo(const Queue& rhs) const
{
    typedef Queue Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_LOCAL_QUEUE:
            return this->localQueue() == rhs.localQueue();
        case Class::SELECTION_ID_REMOTE_QUEUE:
            return this->remoteQueue() == rhs.remoteQueue();
        case Class::SELECTION_ID_UNINITIALIZED_QUEUE:
            return this->uninitializedQueue() == rhs.uninitializedQueue();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline Queue::Queue(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline Queue::~Queue()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int Queue::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case Queue::SELECTION_ID_LOCAL_QUEUE:
        return manipulator(&d_localQueue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_LOCAL_QUEUE]);
    case Queue::SELECTION_ID_REMOTE_QUEUE:
        return manipulator(&d_remoteQueue.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_REMOTE_QUEUE]);
    case Queue::SELECTION_ID_UNINITIALIZED_QUEUE:
        return manipulator(
            &d_uninitializedQueue.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_UNINITIALIZED_QUEUE]);
    default:
        BSLS_ASSERT(Queue::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline LocalQueue& Queue::localQueue()
{
    BSLS_ASSERT(SELECTION_ID_LOCAL_QUEUE == d_selectionId);
    return d_localQueue.object();
}

inline RemoteQueue& Queue::remoteQueue()
{
    BSLS_ASSERT(SELECTION_ID_REMOTE_QUEUE == d_selectionId);
    return d_remoteQueue.object();
}

inline UninitializedQueue& Queue::uninitializedQueue()
{
    BSLS_ASSERT(SELECTION_ID_UNINITIALIZED_QUEUE == d_selectionId);
    return d_uninitializedQueue.object();
}

// ACCESSORS
inline int Queue::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int Queue::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_LOCAL_QUEUE:
        return accessor(d_localQueue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_LOCAL_QUEUE]);
    case SELECTION_ID_REMOTE_QUEUE:
        return accessor(d_remoteQueue.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_REMOTE_QUEUE]);
    case SELECTION_ID_UNINITIALIZED_QUEUE:
        return accessor(
            d_uninitializedQueue.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_UNINITIALIZED_QUEUE]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const LocalQueue& Queue::localQueue() const
{
    BSLS_ASSERT(SELECTION_ID_LOCAL_QUEUE == d_selectionId);
    return d_localQueue.object();
}

inline const RemoteQueue& Queue::remoteQueue() const
{
    BSLS_ASSERT(SELECTION_ID_REMOTE_QUEUE == d_selectionId);
    return d_remoteQueue.object();
}

inline const UninitializedQueue& Queue::uninitializedQueue() const
{
    BSLS_ASSERT(SELECTION_ID_UNINITIALIZED_QUEUE == d_selectionId);
    return d_uninitializedQueue.object();
}

inline bool Queue::isLocalQueueValue() const
{
    return SELECTION_ID_LOCAL_QUEUE == d_selectionId;
}

inline bool Queue::isRemoteQueueValue() const
{
    return SELECTION_ID_REMOTE_QUEUE == d_selectionId;
}

inline bool Queue::isUninitializedQueueValue() const
{
    return SELECTION_ID_UNINITIALIZED_QUEUE == d_selectionId;
}

inline bool Queue::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// --------------------
// class QueueInternals
// --------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueInternals::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_queue, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int QueueInternals::manipulateAttribute(t_MANIPULATOR& manipulator, int id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATE: {
        return manipulator(&d_state,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    }
    case ATTRIBUTE_ID_QUEUE: {
        return manipulator(&d_queue,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int QueueInternals::manipulateAttribute(t_MANIPULATOR& manipulator,
                                        const char*    name,
                                        int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline QueueState& QueueInternals::state()
{
    return d_state;
}

inline Queue& QueueInternals::queue()
{
    return d_queue;
}

// ACCESSORS
template <typename t_ACCESSOR>
int QueueInternals::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_queue, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int QueueInternals::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_STATE: {
        return accessor(d_state, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_STATE]);
    }
    case ATTRIBUTE_ID_QUEUE: {
        return accessor(d_queue, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_QUEUE]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int QueueInternals::accessAttribute(t_ACCESSOR& accessor,
                                    const char* name,
                                    int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const QueueState& QueueInternals::state() const
{
    return d_state;
}

inline const Queue& QueueInternals::queue() const
{
    return d_queue;
}

// -----------------
// class QueueResult
// -----------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void QueueResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef QueueResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_PURGED_QUEUES:
        hashAppend(hashAlgorithm, this->purgedQueues());
        break;
    case Class::SELECTION_ID_QUEUE_CONTENTS:
        hashAppend(hashAlgorithm, this->queueContents());
        break;
    case Class::SELECTION_ID_QUEUE_INTERNALS:
        hashAppend(hashAlgorithm, this->queueInternals());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool QueueResult::isEqualTo(const QueueResult& rhs) const
{
    typedef QueueResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_PURGED_QUEUES:
            return this->purgedQueues() == rhs.purgedQueues();
        case Class::SELECTION_ID_QUEUE_CONTENTS:
            return this->queueContents() == rhs.queueContents();
        case Class::SELECTION_ID_QUEUE_INTERNALS:
            return this->queueInternals() == rhs.queueInternals();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline QueueResult::QueueResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline QueueResult::~QueueResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int QueueResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case QueueResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case QueueResult::SELECTION_ID_PURGED_QUEUES:
        return manipulator(
            &d_purgedQueues.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGED_QUEUES]);
    case QueueResult::SELECTION_ID_QUEUE_CONTENTS:
        return manipulator(
            &d_queueContents.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_CONTENTS]);
    case QueueResult::SELECTION_ID_QUEUE_INTERNALS:
        return manipulator(
            &d_queueInternals.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_INTERNALS]);
    default:
        BSLS_ASSERT(QueueResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Error& QueueResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline PurgedQueues& QueueResult::purgedQueues()
{
    BSLS_ASSERT(SELECTION_ID_PURGED_QUEUES == d_selectionId);
    return d_purgedQueues.object();
}

inline QueueContents& QueueResult::queueContents()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_CONTENTS == d_selectionId);
    return d_queueContents.object();
}

inline QueueInternals& QueueResult::queueInternals()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_INTERNALS == d_selectionId);
    return d_queueInternals.object();
}

// ACCESSORS
inline int QueueResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int QueueResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_PURGED_QUEUES:
        return accessor(d_purgedQueues.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGED_QUEUES]);
    case SELECTION_ID_QUEUE_CONTENTS:
        return accessor(d_queueContents.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_CONTENTS]);
    case SELECTION_ID_QUEUE_INTERNALS:
        return accessor(d_queueInternals.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_INTERNALS]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& QueueResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const PurgedQueues& QueueResult::purgedQueues() const
{
    BSLS_ASSERT(SELECTION_ID_PURGED_QUEUES == d_selectionId);
    return d_purgedQueues.object();
}

inline const QueueContents& QueueResult::queueContents() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_CONTENTS == d_selectionId);
    return d_queueContents.object();
}

inline const QueueInternals& QueueResult::queueInternals() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_INTERNALS == d_selectionId);
    return d_queueInternals.object();
}

inline bool QueueResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool QueueResult::isPurgedQueuesValue() const
{
    return SELECTION_ID_PURGED_QUEUES == d_selectionId;
}

inline bool QueueResult::isQueueContentsValue() const
{
    return SELECTION_ID_QUEUE_CONTENTS == d_selectionId;
}

inline bool QueueResult::isQueueInternalsValue() const
{
    return SELECTION_ID_QUEUE_INTERNALS == d_selectionId;
}

inline bool QueueResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ------------
// class Result
// ------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void Result::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef Result Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_SUCCESS:
        hashAppend(hashAlgorithm, this->success());
        break;
    case Class::SELECTION_ID_VALUE:
        hashAppend(hashAlgorithm, this->value());
        break;
    case Class::SELECTION_ID_TUNABLE:
        hashAppend(hashAlgorithm, this->tunable());
        break;
    case Class::SELECTION_ID_TUNABLES:
        hashAppend(hashAlgorithm, this->tunables());
        break;
    case Class::SELECTION_ID_TUNABLE_CONFIRMATION:
        hashAppend(hashAlgorithm, this->tunableConfirmation());
        break;
    case Class::SELECTION_ID_HELP:
        hashAppend(hashAlgorithm, this->help());
        break;
    case Class::SELECTION_ID_DOMAIN_INFO:
        hashAppend(hashAlgorithm, this->domainInfo());
        break;
    case Class::SELECTION_ID_PURGED_QUEUES:
        hashAppend(hashAlgorithm, this->purgedQueues());
        break;
    case Class::SELECTION_ID_QUEUE_INTERNALS:
        hashAppend(hashAlgorithm, this->queueInternals());
        break;
    case Class::SELECTION_ID_MESSAGE_GROUP_ID_HELPER:
        hashAppend(hashAlgorithm, this->messageGroupIdHelper());
        break;
    case Class::SELECTION_ID_QUEUE_CONTENTS:
        hashAppend(hashAlgorithm, this->queueContents());
        break;
    case Class::SELECTION_ID_MESSAGE:
        hashAppend(hashAlgorithm, this->message());
        break;
    case Class::SELECTION_ID_STATS:
        hashAppend(hashAlgorithm, this->stats());
        break;
    case Class::SELECTION_ID_CLUSTER_LIST:
        hashAppend(hashAlgorithm, this->clusterList());
        break;
    case Class::SELECTION_ID_CLUSTER_STATUS:
        hashAppend(hashAlgorithm, this->clusterStatus());
        break;
    case Class::SELECTION_ID_CLUSTER_PROXY_STATUS:
        hashAppend(hashAlgorithm, this->clusterProxyStatus());
        break;
    case Class::SELECTION_ID_NODE_STATUSES:
        hashAppend(hashAlgorithm, this->nodeStatuses());
        break;
    case Class::SELECTION_ID_ELECTOR_INFO:
        hashAppend(hashAlgorithm, this->electorInfo());
        break;
    case Class::SELECTION_ID_PARTITIONS_INFO:
        hashAppend(hashAlgorithm, this->partitionsInfo());
        break;
    case Class::SELECTION_ID_CLUSTER_QUEUE_HELPER:
        hashAppend(hashAlgorithm, this->clusterQueueHelper());
        break;
    case Class::SELECTION_ID_STORAGE_CONTENT:
        hashAppend(hashAlgorithm, this->storageContent());
        break;
    case Class::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        hashAppend(hashAlgorithm, this->clusterStorageSummary());
        break;
    case Class::SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES:
        hashAppend(hashAlgorithm, this->clusterDomainQueueStatuses());
        break;
    case Class::SELECTION_ID_BROKER_CONFIG:
        hashAppend(hashAlgorithm, this->brokerConfig());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool Result::isEqualTo(const Result& rhs) const
{
    typedef Result Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_SUCCESS:
            return this->success() == rhs.success();
        case Class::SELECTION_ID_VALUE: return this->value() == rhs.value();
        case Class::SELECTION_ID_TUNABLE:
            return this->tunable() == rhs.tunable();
        case Class::SELECTION_ID_TUNABLES:
            return this->tunables() == rhs.tunables();
        case Class::SELECTION_ID_TUNABLE_CONFIRMATION:
            return this->tunableConfirmation() == rhs.tunableConfirmation();
        case Class::SELECTION_ID_HELP: return this->help() == rhs.help();
        case Class::SELECTION_ID_DOMAIN_INFO:
            return this->domainInfo() == rhs.domainInfo();
        case Class::SELECTION_ID_PURGED_QUEUES:
            return this->purgedQueues() == rhs.purgedQueues();
        case Class::SELECTION_ID_QUEUE_INTERNALS:
            return this->queueInternals() == rhs.queueInternals();
        case Class::SELECTION_ID_MESSAGE_GROUP_ID_HELPER:
            return this->messageGroupIdHelper() == rhs.messageGroupIdHelper();
        case Class::SELECTION_ID_QUEUE_CONTENTS:
            return this->queueContents() == rhs.queueContents();
        case Class::SELECTION_ID_MESSAGE:
            return this->message() == rhs.message();
        case Class::SELECTION_ID_STATS: return this->stats() == rhs.stats();
        case Class::SELECTION_ID_CLUSTER_LIST:
            return this->clusterList() == rhs.clusterList();
        case Class::SELECTION_ID_CLUSTER_STATUS:
            return this->clusterStatus() == rhs.clusterStatus();
        case Class::SELECTION_ID_CLUSTER_PROXY_STATUS:
            return this->clusterProxyStatus() == rhs.clusterProxyStatus();
        case Class::SELECTION_ID_NODE_STATUSES:
            return this->nodeStatuses() == rhs.nodeStatuses();
        case Class::SELECTION_ID_ELECTOR_INFO:
            return this->electorInfo() == rhs.electorInfo();
        case Class::SELECTION_ID_PARTITIONS_INFO:
            return this->partitionsInfo() == rhs.partitionsInfo();
        case Class::SELECTION_ID_CLUSTER_QUEUE_HELPER:
            return this->clusterQueueHelper() == rhs.clusterQueueHelper();
        case Class::SELECTION_ID_STORAGE_CONTENT:
            return this->storageContent() == rhs.storageContent();
        case Class::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
            return this->clusterStorageSummary() ==
                   rhs.clusterStorageSummary();
        case Class::SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES:
            return this->clusterDomainQueueStatuses() ==
                   rhs.clusterDomainQueueStatuses();
        case Class::SELECTION_ID_BROKER_CONFIG:
            return this->brokerConfig() == rhs.brokerConfig();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline Result::Result(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline Result::~Result()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int Result::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case Result::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case Result::SELECTION_ID_SUCCESS:
        return manipulator(&d_success.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case Result::SELECTION_ID_VALUE:
        return manipulator(&d_value.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_VALUE]);
    case Result::SELECTION_ID_TUNABLE:
        return manipulator(&d_tunable.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE]);
    case Result::SELECTION_ID_TUNABLES:
        return manipulator(&d_tunables.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLES]);
    case Result::SELECTION_ID_TUNABLE_CONFIRMATION:
        return manipulator(
            &d_tunableConfirmation.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE_CONFIRMATION]);
    case Result::SELECTION_ID_HELP:
        return manipulator(&d_help.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_HELP]);
    case Result::SELECTION_ID_DOMAIN_INFO:
        return manipulator(&d_domainInfo.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN_INFO]);
    case Result::SELECTION_ID_PURGED_QUEUES:
        return manipulator(
            &d_purgedQueues.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGED_QUEUES]);
    case Result::SELECTION_ID_QUEUE_INTERNALS:
        return manipulator(
            &d_queueInternals.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_INTERNALS]);
    case Result::SELECTION_ID_MESSAGE_GROUP_ID_HELPER:
        return manipulator(
            &d_messageGroupIdHelper.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_MESSAGE_GROUP_ID_HELPER]);
    case Result::SELECTION_ID_QUEUE_CONTENTS:
        return manipulator(
            &d_queueContents.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_CONTENTS]);
    case Result::SELECTION_ID_MESSAGE:
        return manipulator(&d_message.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_MESSAGE]);
    case Result::SELECTION_ID_STATS:
        return manipulator(&d_stats.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STATS]);
    case Result::SELECTION_ID_CLUSTER_LIST:
        return manipulator(&d_clusterList.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_LIST]);
    case Result::SELECTION_ID_CLUSTER_STATUS:
        return manipulator(
            &d_clusterStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STATUS]);
    case Result::SELECTION_ID_CLUSTER_PROXY_STATUS:
        return manipulator(
            &d_clusterProxyStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_PROXY_STATUS]);
    case Result::SELECTION_ID_NODE_STATUSES:
        return manipulator(
            &d_nodeStatuses.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_NODE_STATUSES]);
    case Result::SELECTION_ID_ELECTOR_INFO:
        return manipulator(&d_electorInfo.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR_INFO]);
    case Result::SELECTION_ID_PARTITIONS_INFO:
        return manipulator(
            &d_partitionsInfo.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITIONS_INFO]);
    case Result::SELECTION_ID_CLUSTER_QUEUE_HELPER:
        return manipulator(
            &d_clusterQueueHelper.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_QUEUE_HELPER]);
    case Result::SELECTION_ID_STORAGE_CONTENT:
        return manipulator(
            &d_storageContent.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_CONTENT]);
    case Result::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        return manipulator(
            &d_clusterStorageSummary.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY]);
    case Result::SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES:
        return manipulator(
            &d_clusterDomainQueueStatuses.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_CLUSTER_DOMAIN_QUEUE_STATUSES]);
    case Result::SELECTION_ID_BROKER_CONFIG:
        return manipulator(
            &d_brokerConfig.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_CONFIG]);
    default:
        BSLS_ASSERT(Result::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Error& Result::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline Void& Result::success()
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline Value& Result::value()
{
    BSLS_ASSERT(SELECTION_ID_VALUE == d_selectionId);
    return d_value.object();
}

inline Tunable& Result::tunable()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE == d_selectionId);
    return d_tunable.object();
}

inline Tunables& Result::tunables()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLES == d_selectionId);
    return d_tunables.object();
}

inline TunableConfirmation& Result::tunableConfirmation()
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId);
    return d_tunableConfirmation.object();
}

inline Help& Result::help()
{
    BSLS_ASSERT(SELECTION_ID_HELP == d_selectionId);
    return d_help.object();
}

inline DomainInfo& Result::domainInfo()
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN_INFO == d_selectionId);
    return d_domainInfo.object();
}

inline PurgedQueues& Result::purgedQueues()
{
    BSLS_ASSERT(SELECTION_ID_PURGED_QUEUES == d_selectionId);
    return d_purgedQueues.object();
}

inline QueueInternals& Result::queueInternals()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_INTERNALS == d_selectionId);
    return d_queueInternals.object();
}

inline MessageGroupIdHelper& Result::messageGroupIdHelper()
{
    BSLS_ASSERT(SELECTION_ID_MESSAGE_GROUP_ID_HELPER == d_selectionId);
    return d_messageGroupIdHelper.object();
}

inline QueueContents& Result::queueContents()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_CONTENTS == d_selectionId);
    return d_queueContents.object();
}

inline Message& Result::message()
{
    BSLS_ASSERT(SELECTION_ID_MESSAGE == d_selectionId);
    return d_message.object();
}

inline bsl::string& Result::stats()
{
    BSLS_ASSERT(SELECTION_ID_STATS == d_selectionId);
    return d_stats.object();
}

inline ClusterList& Result::clusterList()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_LIST == d_selectionId);
    return d_clusterList.object();
}

inline ClusterStatus& Result::clusterStatus()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STATUS == d_selectionId);
    return d_clusterStatus.object();
}

inline ClusterProxyStatus& Result::clusterProxyStatus()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_PROXY_STATUS == d_selectionId);
    return d_clusterProxyStatus.object();
}

inline NodeStatuses& Result::nodeStatuses()
{
    BSLS_ASSERT(SELECTION_ID_NODE_STATUSES == d_selectionId);
    return d_nodeStatuses.object();
}

inline ElectorInfo& Result::electorInfo()
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR_INFO == d_selectionId);
    return d_electorInfo.object();
}

inline PartitionsInfo& Result::partitionsInfo()
{
    BSLS_ASSERT(SELECTION_ID_PARTITIONS_INFO == d_selectionId);
    return d_partitionsInfo.object();
}

inline ClusterQueueHelper& Result::clusterQueueHelper()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId);
    return d_clusterQueueHelper.object();
}

inline StorageContent& Result::storageContent()
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_CONTENT == d_selectionId);
    return d_storageContent.object();
}

inline ClusterStorageSummary& Result::clusterStorageSummary()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId);
    return d_clusterStorageSummary.object();
}

inline ClusterDomainQueueStatuses& Result::clusterDomainQueueStatuses()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES == d_selectionId);
    return d_clusterDomainQueueStatuses.object();
}

inline BrokerConfig& Result::brokerConfig()
{
    BSLS_ASSERT(SELECTION_ID_BROKER_CONFIG == d_selectionId);
    return d_brokerConfig.object();
}

// ACCESSORS
inline int Result::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int Result::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_SUCCESS:
        return accessor(d_success.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case SELECTION_ID_VALUE:
        return accessor(d_value.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_VALUE]);
    case SELECTION_ID_TUNABLE:
        return accessor(d_tunable.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE]);
    case SELECTION_ID_TUNABLES:
        return accessor(d_tunables.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLES]);
    case SELECTION_ID_TUNABLE_CONFIRMATION:
        return accessor(
            d_tunableConfirmation.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_TUNABLE_CONFIRMATION]);
    case SELECTION_ID_HELP:
        return accessor(d_help.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_HELP]);
    case SELECTION_ID_DOMAIN_INFO:
        return accessor(d_domainInfo.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN_INFO]);
    case SELECTION_ID_PURGED_QUEUES:
        return accessor(d_purgedQueues.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGED_QUEUES]);
    case SELECTION_ID_QUEUE_INTERNALS:
        return accessor(d_queueInternals.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_INTERNALS]);
    case SELECTION_ID_MESSAGE_GROUP_ID_HELPER:
        return accessor(
            d_messageGroupIdHelper.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_MESSAGE_GROUP_ID_HELPER]);
    case SELECTION_ID_QUEUE_CONTENTS:
        return accessor(d_queueContents.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_CONTENTS]);
    case SELECTION_ID_MESSAGE:
        return accessor(d_message.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_MESSAGE]);
    case SELECTION_ID_STATS:
        return accessor(d_stats.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STATS]);
    case SELECTION_ID_CLUSTER_LIST:
        return accessor(d_clusterList.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_LIST]);
    case SELECTION_ID_CLUSTER_STATUS:
        return accessor(d_clusterStatus.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STATUS]);
    case SELECTION_ID_CLUSTER_PROXY_STATUS:
        return accessor(
            d_clusterProxyStatus.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_PROXY_STATUS]);
    case SELECTION_ID_NODE_STATUSES:
        return accessor(d_nodeStatuses.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_NODE_STATUSES]);
    case SELECTION_ID_ELECTOR_INFO:
        return accessor(d_electorInfo.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ELECTOR_INFO]);
    case SELECTION_ID_PARTITIONS_INFO:
        return accessor(d_partitionsInfo.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PARTITIONS_INFO]);
    case SELECTION_ID_CLUSTER_QUEUE_HELPER:
        return accessor(
            d_clusterQueueHelper.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_QUEUE_HELPER]);
    case SELECTION_ID_STORAGE_CONTENT:
        return accessor(d_storageContent.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STORAGE_CONTENT]);
    case SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        return accessor(
            d_clusterStorageSummary.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY]);
    case SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES:
        return accessor(d_clusterDomainQueueStatuses.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_CLUSTER_DOMAIN_QUEUE_STATUSES]);
    case SELECTION_ID_BROKER_CONFIG:
        return accessor(d_brokerConfig.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_CONFIG]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& Result::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const Void& Result::success() const
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline const Value& Result::value() const
{
    BSLS_ASSERT(SELECTION_ID_VALUE == d_selectionId);
    return d_value.object();
}

inline const Tunable& Result::tunable() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE == d_selectionId);
    return d_tunable.object();
}

inline const Tunables& Result::tunables() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLES == d_selectionId);
    return d_tunables.object();
}

inline const TunableConfirmation& Result::tunableConfirmation() const
{
    BSLS_ASSERT(SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId);
    return d_tunableConfirmation.object();
}

inline const Help& Result::help() const
{
    BSLS_ASSERT(SELECTION_ID_HELP == d_selectionId);
    return d_help.object();
}

inline const DomainInfo& Result::domainInfo() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN_INFO == d_selectionId);
    return d_domainInfo.object();
}

inline const PurgedQueues& Result::purgedQueues() const
{
    BSLS_ASSERT(SELECTION_ID_PURGED_QUEUES == d_selectionId);
    return d_purgedQueues.object();
}

inline const QueueInternals& Result::queueInternals() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_INTERNALS == d_selectionId);
    return d_queueInternals.object();
}

inline const MessageGroupIdHelper& Result::messageGroupIdHelper() const
{
    BSLS_ASSERT(SELECTION_ID_MESSAGE_GROUP_ID_HELPER == d_selectionId);
    return d_messageGroupIdHelper.object();
}

inline const QueueContents& Result::queueContents() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_CONTENTS == d_selectionId);
    return d_queueContents.object();
}

inline const Message& Result::message() const
{
    BSLS_ASSERT(SELECTION_ID_MESSAGE == d_selectionId);
    return d_message.object();
}

inline const bsl::string& Result::stats() const
{
    BSLS_ASSERT(SELECTION_ID_STATS == d_selectionId);
    return d_stats.object();
}

inline const ClusterList& Result::clusterList() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_LIST == d_selectionId);
    return d_clusterList.object();
}

inline const ClusterStatus& Result::clusterStatus() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STATUS == d_selectionId);
    return d_clusterStatus.object();
}

inline const ClusterProxyStatus& Result::clusterProxyStatus() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_PROXY_STATUS == d_selectionId);
    return d_clusterProxyStatus.object();
}

inline const NodeStatuses& Result::nodeStatuses() const
{
    BSLS_ASSERT(SELECTION_ID_NODE_STATUSES == d_selectionId);
    return d_nodeStatuses.object();
}

inline const ElectorInfo& Result::electorInfo() const
{
    BSLS_ASSERT(SELECTION_ID_ELECTOR_INFO == d_selectionId);
    return d_electorInfo.object();
}

inline const PartitionsInfo& Result::partitionsInfo() const
{
    BSLS_ASSERT(SELECTION_ID_PARTITIONS_INFO == d_selectionId);
    return d_partitionsInfo.object();
}

inline const ClusterQueueHelper& Result::clusterQueueHelper() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId);
    return d_clusterQueueHelper.object();
}

inline const StorageContent& Result::storageContent() const
{
    BSLS_ASSERT(SELECTION_ID_STORAGE_CONTENT == d_selectionId);
    return d_storageContent.object();
}

inline const ClusterStorageSummary& Result::clusterStorageSummary() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId);
    return d_clusterStorageSummary.object();
}

inline const ClusterDomainQueueStatuses&
Result::clusterDomainQueueStatuses() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES == d_selectionId);
    return d_clusterDomainQueueStatuses.object();
}

inline const BrokerConfig& Result::brokerConfig() const
{
    BSLS_ASSERT(SELECTION_ID_BROKER_CONFIG == d_selectionId);
    return d_brokerConfig.object();
}

inline bool Result::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool Result::isSuccessValue() const
{
    return SELECTION_ID_SUCCESS == d_selectionId;
}

inline bool Result::isValueValue() const
{
    return SELECTION_ID_VALUE == d_selectionId;
}

inline bool Result::isTunableValue() const
{
    return SELECTION_ID_TUNABLE == d_selectionId;
}

inline bool Result::isTunablesValue() const
{
    return SELECTION_ID_TUNABLES == d_selectionId;
}

inline bool Result::isTunableConfirmationValue() const
{
    return SELECTION_ID_TUNABLE_CONFIRMATION == d_selectionId;
}

inline bool Result::isHelpValue() const
{
    return SELECTION_ID_HELP == d_selectionId;
}

inline bool Result::isDomainInfoValue() const
{
    return SELECTION_ID_DOMAIN_INFO == d_selectionId;
}

inline bool Result::isPurgedQueuesValue() const
{
    return SELECTION_ID_PURGED_QUEUES == d_selectionId;
}

inline bool Result::isQueueInternalsValue() const
{
    return SELECTION_ID_QUEUE_INTERNALS == d_selectionId;
}

inline bool Result::isMessageGroupIdHelperValue() const
{
    return SELECTION_ID_MESSAGE_GROUP_ID_HELPER == d_selectionId;
}

inline bool Result::isQueueContentsValue() const
{
    return SELECTION_ID_QUEUE_CONTENTS == d_selectionId;
}

inline bool Result::isMessageValue() const
{
    return SELECTION_ID_MESSAGE == d_selectionId;
}

inline bool Result::isStatsValue() const
{
    return SELECTION_ID_STATS == d_selectionId;
}

inline bool Result::isClusterListValue() const
{
    return SELECTION_ID_CLUSTER_LIST == d_selectionId;
}

inline bool Result::isClusterStatusValue() const
{
    return SELECTION_ID_CLUSTER_STATUS == d_selectionId;
}

inline bool Result::isClusterProxyStatusValue() const
{
    return SELECTION_ID_CLUSTER_PROXY_STATUS == d_selectionId;
}

inline bool Result::isNodeStatusesValue() const
{
    return SELECTION_ID_NODE_STATUSES == d_selectionId;
}

inline bool Result::isElectorInfoValue() const
{
    return SELECTION_ID_ELECTOR_INFO == d_selectionId;
}

inline bool Result::isPartitionsInfoValue() const
{
    return SELECTION_ID_PARTITIONS_INFO == d_selectionId;
}

inline bool Result::isClusterQueueHelperValue() const
{
    return SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId;
}

inline bool Result::isStorageContentValue() const
{
    return SELECTION_ID_STORAGE_CONTENT == d_selectionId;
}

inline bool Result::isClusterStorageSummaryValue() const
{
    return SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId;
}

inline bool Result::isClusterDomainQueueStatusesValue() const
{
    return SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES == d_selectionId;
}

inline bool Result::isBrokerConfigValue() const
{
    return SELECTION_ID_BROKER_CONFIG == d_selectionId;
}

inline bool Result::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// ------------------
// class DomainResult
// ------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DomainResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef DomainResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_SUCCESS:
        hashAppend(hashAlgorithm, this->success());
        break;
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_DOMAIN_INFO:
        hashAppend(hashAlgorithm, this->domainInfo());
        break;
    case Class::SELECTION_ID_PURGED_QUEUES:
        hashAppend(hashAlgorithm, this->purgedQueues());
        break;
    case Class::SELECTION_ID_QUEUE_RESULT:
        hashAppend(hashAlgorithm, this->queueResult());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool DomainResult::isEqualTo(const DomainResult& rhs) const
{
    typedef DomainResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_SUCCESS:
            return this->success() == rhs.success();
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_DOMAIN_INFO:
            return this->domainInfo() == rhs.domainInfo();
        case Class::SELECTION_ID_PURGED_QUEUES:
            return this->purgedQueues() == rhs.purgedQueues();
        case Class::SELECTION_ID_QUEUE_RESULT:
            return this->queueResult() == rhs.queueResult();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline DomainResult::DomainResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline DomainResult::~DomainResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int DomainResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case DomainResult::SELECTION_ID_SUCCESS:
        return manipulator(&d_success.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case DomainResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case DomainResult::SELECTION_ID_DOMAIN_INFO:
        return manipulator(&d_domainInfo.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN_INFO]);
    case DomainResult::SELECTION_ID_PURGED_QUEUES:
        return manipulator(
            &d_purgedQueues.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGED_QUEUES]);
    case DomainResult::SELECTION_ID_QUEUE_RESULT:
        return manipulator(&d_queueResult.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_RESULT]);
    default:
        BSLS_ASSERT(DomainResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& DomainResult::success()
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline Error& DomainResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline DomainInfo& DomainResult::domainInfo()
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN_INFO == d_selectionId);
    return d_domainInfo.object();
}

inline PurgedQueues& DomainResult::purgedQueues()
{
    BSLS_ASSERT(SELECTION_ID_PURGED_QUEUES == d_selectionId);
    return d_purgedQueues.object();
}

inline QueueResult& DomainResult::queueResult()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_RESULT == d_selectionId);
    return d_queueResult.object();
}

// ACCESSORS
inline int DomainResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int DomainResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_SUCCESS:
        return accessor(d_success.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_DOMAIN_INFO:
        return accessor(d_domainInfo.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN_INFO]);
    case SELECTION_ID_PURGED_QUEUES:
        return accessor(d_purgedQueues.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_PURGED_QUEUES]);
    case SELECTION_ID_QUEUE_RESULT:
        return accessor(d_queueResult.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_RESULT]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& DomainResult::success() const
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline const Error& DomainResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const DomainInfo& DomainResult::domainInfo() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN_INFO == d_selectionId);
    return d_domainInfo.object();
}

inline const PurgedQueues& DomainResult::purgedQueues() const
{
    BSLS_ASSERT(SELECTION_ID_PURGED_QUEUES == d_selectionId);
    return d_purgedQueues.object();
}

inline const QueueResult& DomainResult::queueResult() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_RESULT == d_selectionId);
    return d_queueResult.object();
}

inline bool DomainResult::isSuccessValue() const
{
    return SELECTION_ID_SUCCESS == d_selectionId;
}

inline bool DomainResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool DomainResult::isDomainInfoValue() const
{
    return SELECTION_ID_DOMAIN_INFO == d_selectionId;
}

inline bool DomainResult::isPurgedQueuesValue() const
{
    return SELECTION_ID_PURGED_QUEUES == d_selectionId;
}

inline bool DomainResult::isQueueResultValue() const
{
    return SELECTION_ID_QUEUE_RESULT == d_selectionId;
}

inline bool DomainResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -------------------------
// class RouteResponseResult
// -------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RouteResponseResult::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_source, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SOURCE]);
    if (ret) {
        return ret;
    }

    ret = manipulator(&d_result, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RouteResponseResult::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SOURCE: {
        return manipulator(&d_source,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SOURCE]);
    }
    case ATTRIBUTE_ID_RESULT: {
        return manipulator(&d_result,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RouteResponseResult::manipulateAttribute(t_MANIPULATOR& manipulator,
                                             const char*    name,
                                             int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::string& RouteResponseResult::source()
{
    return d_source;
}

inline Result& RouteResponseResult::result()
{
    return d_result;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RouteResponseResult::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_source, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SOURCE]);
    if (ret) {
        return ret;
    }

    ret = accessor(d_result, ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RouteResponseResult::accessAttribute(t_ACCESSOR& accessor, int id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_SOURCE: {
        return accessor(d_source,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_SOURCE]);
    }
    case ATTRIBUTE_ID_RESULT: {
        return accessor(d_result,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESULT]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RouteResponseResult::accessAttribute(t_ACCESSOR& accessor,
                                         const char* name,
                                         int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::string& RouteResponseResult::source() const
{
    return d_source;
}

inline const Result& RouteResponseResult::result() const
{
    return d_result;
}

// -------------------
// class DomainsResult
// -------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void DomainsResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef DomainsResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_SUCCESS:
        hashAppend(hashAlgorithm, this->success());
        break;
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_DOMAIN_RESULT:
        hashAppend(hashAlgorithm, this->domainResult());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool DomainsResult::isEqualTo(const DomainsResult& rhs) const
{
    typedef DomainsResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_SUCCESS:
            return this->success() == rhs.success();
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_DOMAIN_RESULT:
            return this->domainResult() == rhs.domainResult();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline DomainsResult::DomainsResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline DomainsResult::~DomainsResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int DomainsResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case DomainsResult::SELECTION_ID_SUCCESS:
        return manipulator(&d_success.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case DomainsResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case DomainsResult::SELECTION_ID_DOMAIN_RESULT:
        return manipulator(
            &d_domainResult.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN_RESULT]);
    default:
        BSLS_ASSERT(DomainsResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Void& DomainsResult::success()
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline Error& DomainsResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline DomainResult& DomainsResult::domainResult()
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN_RESULT == d_selectionId);
    return d_domainResult.object();
}

// ACCESSORS
inline int DomainsResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int DomainsResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_SUCCESS:
        return accessor(d_success.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_DOMAIN_RESULT:
        return accessor(d_domainResult.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAIN_RESULT]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Void& DomainsResult::success() const
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline const Error& DomainsResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const DomainResult& DomainsResult::domainResult() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAIN_RESULT == d_selectionId);
    return d_domainResult.object();
}

inline bool DomainsResult::isSuccessValue() const
{
    return SELECTION_ID_SUCCESS == d_selectionId;
}

inline bool DomainsResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool DomainsResult::isDomainResultValue() const
{
    return SELECTION_ID_DOMAIN_RESULT == d_selectionId;
}

inline bool DomainsResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}

// -----------------------------
// class RouteResponseResultList
// -----------------------------

// CLASS METHODS
// MANIPULATORS
template <typename t_MANIPULATOR>
int RouteResponseResultList::manipulateAttributes(t_MANIPULATOR& manipulator)
{
    int ret;

    ret = manipulator(&d_responses,
                      ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_MANIPULATOR>
int RouteResponseResultList::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 int            id)
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_RESPONSES: {
        return manipulator(&d_responses,
                           ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_MANIPULATOR>
int RouteResponseResultList::manipulateAttribute(t_MANIPULATOR& manipulator,
                                                 const char*    name,
                                                 int            nameLength)
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return manipulateAttribute(manipulator, attributeInfo->d_id);
}

inline bsl::vector<RouteResponseResult>& RouteResponseResultList::responses()
{
    return d_responses;
}

// ACCESSORS
template <typename t_ACCESSOR>
int RouteResponseResultList::accessAttributes(t_ACCESSOR& accessor) const
{
    int ret;

    ret = accessor(d_responses,
                   ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSES]);
    if (ret) {
        return ret;
    }

    return 0;
}

template <typename t_ACCESSOR>
int RouteResponseResultList::accessAttribute(t_ACCESSOR& accessor,
                                             int         id) const
{
    enum { NOT_FOUND = -1 };

    switch (id) {
    case ATTRIBUTE_ID_RESPONSES: {
        return accessor(d_responses,
                        ATTRIBUTE_INFO_ARRAY[ATTRIBUTE_INDEX_RESPONSES]);
    }
    default: return NOT_FOUND;
    }
}

template <typename t_ACCESSOR>
int RouteResponseResultList::accessAttribute(t_ACCESSOR& accessor,
                                             const char* name,
                                             int         nameLength) const
{
    enum { NOT_FOUND = -1 };

    const bdlat_AttributeInfo* attributeInfo = lookupAttributeInfo(name,
                                                                   nameLength);
    if (0 == attributeInfo) {
        return NOT_FOUND;
    }

    return accessAttribute(accessor, attributeInfo->d_id);
}

inline const bsl::vector<RouteResponseResult>&
RouteResponseResultList::responses() const
{
    return d_responses;
}

// --------------------
// class InternalResult
// --------------------

// CLASS METHODS
// PRIVATE ACCESSORS
template <typename t_HASH_ALGORITHM>
void InternalResult::hashAppendImpl(t_HASH_ALGORITHM& hashAlgorithm) const
{
    typedef InternalResult Class;
    using bslh::hashAppend;
    hashAppend(hashAlgorithm, this->selectionId());
    switch (this->selectionId()) {
    case Class::SELECTION_ID_ERROR:
        hashAppend(hashAlgorithm, this->error());
        break;
    case Class::SELECTION_ID_SUCCESS:
        hashAppend(hashAlgorithm, this->success());
        break;
    case Class::SELECTION_ID_DOMAINS_RESULT:
        hashAppend(hashAlgorithm, this->domainsResult());
        break;
    case Class::SELECTION_ID_CLUSTERS_RESULT:
        hashAppend(hashAlgorithm, this->clustersResult());
        break;
    case Class::SELECTION_ID_HELP:
        hashAppend(hashAlgorithm, this->help());
        break;
    case Class::SELECTION_ID_QUEUE_INTERNALS:
        hashAppend(hashAlgorithm, this->queueInternals());
        break;
    case Class::SELECTION_ID_STAT_RESULT:
        hashAppend(hashAlgorithm, this->statResult());
        break;
    case Class::SELECTION_ID_CLUSTER_LIST:
        hashAppend(hashAlgorithm, this->clusterList());
        break;
    case Class::SELECTION_ID_CLUSTER_QUEUE_HELPER:
        hashAppend(hashAlgorithm, this->clusterQueueHelper());
        break;
    case Class::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        hashAppend(hashAlgorithm, this->clusterStorageSummary());
        break;
    case Class::SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES:
        hashAppend(hashAlgorithm, this->clusterDomainQueueStatuses());
        break;
    case Class::SELECTION_ID_BROKER_CONFIG:
        hashAppend(hashAlgorithm, this->brokerConfig());
        break;
    default: BSLS_ASSERT(this->selectionId() == Class::SELECTION_ID_UNDEFINED);
    }
}

inline bool InternalResult::isEqualTo(const InternalResult& rhs) const
{
    typedef InternalResult Class;
    if (this->selectionId() == rhs.selectionId()) {
        switch (rhs.selectionId()) {
        case Class::SELECTION_ID_ERROR: return this->error() == rhs.error();
        case Class::SELECTION_ID_SUCCESS:
            return this->success() == rhs.success();
        case Class::SELECTION_ID_DOMAINS_RESULT:
            return this->domainsResult() == rhs.domainsResult();
        case Class::SELECTION_ID_CLUSTERS_RESULT:
            return this->clustersResult() == rhs.clustersResult();
        case Class::SELECTION_ID_HELP: return this->help() == rhs.help();
        case Class::SELECTION_ID_QUEUE_INTERNALS:
            return this->queueInternals() == rhs.queueInternals();
        case Class::SELECTION_ID_STAT_RESULT:
            return this->statResult() == rhs.statResult();
        case Class::SELECTION_ID_CLUSTER_LIST:
            return this->clusterList() == rhs.clusterList();
        case Class::SELECTION_ID_CLUSTER_QUEUE_HELPER:
            return this->clusterQueueHelper() == rhs.clusterQueueHelper();
        case Class::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
            return this->clusterStorageSummary() ==
                   rhs.clusterStorageSummary();
        case Class::SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES:
            return this->clusterDomainQueueStatuses() ==
                   rhs.clusterDomainQueueStatuses();
        case Class::SELECTION_ID_BROKER_CONFIG:
            return this->brokerConfig() == rhs.brokerConfig();
        default:
            BSLS_ASSERT(Class::SELECTION_ID_UNDEFINED == rhs.selectionId());
            return true;
        }
    }
    else {
        return false;
    }
}

// CREATORS
inline InternalResult::InternalResult(bslma::Allocator* basicAllocator)
: d_selectionId(SELECTION_ID_UNDEFINED)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

inline InternalResult::~InternalResult()
{
    reset();
}

// MANIPULATORS
template <typename t_MANIPULATOR>
int InternalResult::manipulateSelection(t_MANIPULATOR& manipulator)
{
    switch (d_selectionId) {
    case InternalResult::SELECTION_ID_ERROR:
        return manipulator(&d_error.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case InternalResult::SELECTION_ID_SUCCESS:
        return manipulator(&d_success.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case InternalResult::SELECTION_ID_DOMAINS_RESULT:
        return manipulator(
            &d_domainsResult.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAINS_RESULT]);
    case InternalResult::SELECTION_ID_CLUSTERS_RESULT:
        return manipulator(
            &d_clustersResult.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTERS_RESULT]);
    case InternalResult::SELECTION_ID_HELP:
        return manipulator(&d_help.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_HELP]);
    case InternalResult::SELECTION_ID_QUEUE_INTERNALS:
        return manipulator(
            &d_queueInternals.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_INTERNALS]);
    case InternalResult::SELECTION_ID_STAT_RESULT:
        return manipulator(&d_statResult.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_STAT_RESULT]);
    case InternalResult::SELECTION_ID_CLUSTER_LIST:
        return manipulator(&d_clusterList.object(),
                           SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_LIST]);
    case InternalResult::SELECTION_ID_CLUSTER_QUEUE_HELPER:
        return manipulator(
            &d_clusterQueueHelper.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_QUEUE_HELPER]);
    case InternalResult::SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        return manipulator(
            &d_clusterStorageSummary.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY]);
    case InternalResult::SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES:
        return manipulator(
            &d_clusterDomainQueueStatuses.object(),
            SELECTION_INFO_ARRAY
                [SELECTION_INDEX_CLUSTER_DOMAIN_QUEUE_STATUSES]);
    case InternalResult::SELECTION_ID_BROKER_CONFIG:
        return manipulator(
            &d_brokerConfig.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_CONFIG]);
    default:
        BSLS_ASSERT(InternalResult::SELECTION_ID_UNDEFINED == d_selectionId);
        return -1;
    }
}

inline Error& InternalResult::error()
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline Void& InternalResult::success()
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline DomainsResult& InternalResult::domainsResult()
{
    BSLS_ASSERT(SELECTION_ID_DOMAINS_RESULT == d_selectionId);
    return d_domainsResult.object();
}

inline ClustersResult& InternalResult::clustersResult()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTERS_RESULT == d_selectionId);
    return d_clustersResult.object();
}

inline Help& InternalResult::help()
{
    BSLS_ASSERT(SELECTION_ID_HELP == d_selectionId);
    return d_help.object();
}

inline QueueInternals& InternalResult::queueInternals()
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_INTERNALS == d_selectionId);
    return d_queueInternals.object();
}

inline StatResult& InternalResult::statResult()
{
    BSLS_ASSERT(SELECTION_ID_STAT_RESULT == d_selectionId);
    return d_statResult.object();
}

inline ClusterList& InternalResult::clusterList()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_LIST == d_selectionId);
    return d_clusterList.object();
}

inline ClusterQueueHelper& InternalResult::clusterQueueHelper()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId);
    return d_clusterQueueHelper.object();
}

inline ClusterStorageSummary& InternalResult::clusterStorageSummary()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId);
    return d_clusterStorageSummary.object();
}

inline ClusterDomainQueueStatuses& InternalResult::clusterDomainQueueStatuses()
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES == d_selectionId);
    return d_clusterDomainQueueStatuses.object();
}

inline BrokerConfig& InternalResult::brokerConfig()
{
    BSLS_ASSERT(SELECTION_ID_BROKER_CONFIG == d_selectionId);
    return d_brokerConfig.object();
}

// ACCESSORS
inline int InternalResult::selectionId() const
{
    return d_selectionId;
}

template <typename t_ACCESSOR>
int InternalResult::accessSelection(t_ACCESSOR& accessor) const
{
    switch (d_selectionId) {
    case SELECTION_ID_ERROR:
        return accessor(d_error.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_ERROR]);
    case SELECTION_ID_SUCCESS:
        return accessor(d_success.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_SUCCESS]);
    case SELECTION_ID_DOMAINS_RESULT:
        return accessor(d_domainsResult.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_DOMAINS_RESULT]);
    case SELECTION_ID_CLUSTERS_RESULT:
        return accessor(d_clustersResult.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTERS_RESULT]);
    case SELECTION_ID_HELP:
        return accessor(d_help.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_HELP]);
    case SELECTION_ID_QUEUE_INTERNALS:
        return accessor(d_queueInternals.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_QUEUE_INTERNALS]);
    case SELECTION_ID_STAT_RESULT:
        return accessor(d_statResult.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_STAT_RESULT]);
    case SELECTION_ID_CLUSTER_LIST:
        return accessor(d_clusterList.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_LIST]);
    case SELECTION_ID_CLUSTER_QUEUE_HELPER:
        return accessor(
            d_clusterQueueHelper.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_QUEUE_HELPER]);
    case SELECTION_ID_CLUSTER_STORAGE_SUMMARY:
        return accessor(
            d_clusterStorageSummary.object(),
            SELECTION_INFO_ARRAY[SELECTION_INDEX_CLUSTER_STORAGE_SUMMARY]);
    case SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES:
        return accessor(d_clusterDomainQueueStatuses.object(),
                        SELECTION_INFO_ARRAY
                            [SELECTION_INDEX_CLUSTER_DOMAIN_QUEUE_STATUSES]);
    case SELECTION_ID_BROKER_CONFIG:
        return accessor(d_brokerConfig.object(),
                        SELECTION_INFO_ARRAY[SELECTION_INDEX_BROKER_CONFIG]);
    default: BSLS_ASSERT(SELECTION_ID_UNDEFINED == d_selectionId); return -1;
    }
}

inline const Error& InternalResult::error() const
{
    BSLS_ASSERT(SELECTION_ID_ERROR == d_selectionId);
    return d_error.object();
}

inline const Void& InternalResult::success() const
{
    BSLS_ASSERT(SELECTION_ID_SUCCESS == d_selectionId);
    return d_success.object();
}

inline const DomainsResult& InternalResult::domainsResult() const
{
    BSLS_ASSERT(SELECTION_ID_DOMAINS_RESULT == d_selectionId);
    return d_domainsResult.object();
}

inline const ClustersResult& InternalResult::clustersResult() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTERS_RESULT == d_selectionId);
    return d_clustersResult.object();
}

inline const Help& InternalResult::help() const
{
    BSLS_ASSERT(SELECTION_ID_HELP == d_selectionId);
    return d_help.object();
}

inline const QueueInternals& InternalResult::queueInternals() const
{
    BSLS_ASSERT(SELECTION_ID_QUEUE_INTERNALS == d_selectionId);
    return d_queueInternals.object();
}

inline const StatResult& InternalResult::statResult() const
{
    BSLS_ASSERT(SELECTION_ID_STAT_RESULT == d_selectionId);
    return d_statResult.object();
}

inline const ClusterList& InternalResult::clusterList() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_LIST == d_selectionId);
    return d_clusterList.object();
}

inline const ClusterQueueHelper& InternalResult::clusterQueueHelper() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId);
    return d_clusterQueueHelper.object();
}

inline const ClusterStorageSummary&
InternalResult::clusterStorageSummary() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId);
    return d_clusterStorageSummary.object();
}

inline const ClusterDomainQueueStatuses&
InternalResult::clusterDomainQueueStatuses() const
{
    BSLS_ASSERT(SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES == d_selectionId);
    return d_clusterDomainQueueStatuses.object();
}

inline const BrokerConfig& InternalResult::brokerConfig() const
{
    BSLS_ASSERT(SELECTION_ID_BROKER_CONFIG == d_selectionId);
    return d_brokerConfig.object();
}

inline bool InternalResult::isErrorValue() const
{
    return SELECTION_ID_ERROR == d_selectionId;
}

inline bool InternalResult::isSuccessValue() const
{
    return SELECTION_ID_SUCCESS == d_selectionId;
}

inline bool InternalResult::isDomainsResultValue() const
{
    return SELECTION_ID_DOMAINS_RESULT == d_selectionId;
}

inline bool InternalResult::isClustersResultValue() const
{
    return SELECTION_ID_CLUSTERS_RESULT == d_selectionId;
}

inline bool InternalResult::isHelpValue() const
{
    return SELECTION_ID_HELP == d_selectionId;
}

inline bool InternalResult::isQueueInternalsValue() const
{
    return SELECTION_ID_QUEUE_INTERNALS == d_selectionId;
}

inline bool InternalResult::isStatResultValue() const
{
    return SELECTION_ID_STAT_RESULT == d_selectionId;
}

inline bool InternalResult::isClusterListValue() const
{
    return SELECTION_ID_CLUSTER_LIST == d_selectionId;
}

inline bool InternalResult::isClusterQueueHelperValue() const
{
    return SELECTION_ID_CLUSTER_QUEUE_HELPER == d_selectionId;
}

inline bool InternalResult::isClusterStorageSummaryValue() const
{
    return SELECTION_ID_CLUSTER_STORAGE_SUMMARY == d_selectionId;
}

inline bool InternalResult::isClusterDomainQueueStatusesValue() const
{
    return SELECTION_ID_CLUSTER_DOMAIN_QUEUE_STATUSES == d_selectionId;
}

inline bool InternalResult::isBrokerConfigValue() const
{
    return SELECTION_ID_BROKER_CONFIG == d_selectionId;
}

inline bool InternalResult::isUndefinedValue() const
{
    return SELECTION_ID_UNDEFINED == d_selectionId;
}
}  // close package namespace

// FREE FUNCTIONS

}  // close enterprise namespace
#endif

// GENERATED BY @BLP_BAS_CODEGEN_VERSION@
// USING bas_codegen.pl -m msg --noAggregateConversion --noExternalization
// --noIdent --package mqbcmd --msgComponent messages mqbcmd.xsd
// ----------------------------------------------------------------------------
// NOTICE:
//      Copyright 2024 Bloomberg Finance L.P. All rights reserved.
//      Property of Bloomberg Finance L.P. (BFLP)
//      This software is made available solely pursuant to the
//      terms of a BFLP license agreement which governs its use.
// ------------------------------- END-OF-FILE --------------------------------
