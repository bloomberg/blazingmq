<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libbmq: bmqa/bmqa_mocksession.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libbmq<span id="projectnumber">&#160;a535b5b38de28bc389919a54306e1952792d02cd</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('bmqa__mocksession_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">bmqa_mocksession.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provide a mock session, implementing <a class="el" href="classBloombergLP_1_1bmqa_1_1AbstractSession.html">bmqa::AbstractSession</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="bmqa__abstractsession_8h_source.html">bmqa_abstractsession.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__closequeuestatus_8h_source.html">bmqa_closequeuestatus.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__configurequeuestatus_8h_source.html">bmqa_configurequeuestatus.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__messageeventbuilder_8h_source.html">bmqa_messageeventbuilder.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__openqueuestatus_8h_source.html">bmqa_openqueuestatus.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__queueid_8h_source.html">bmqa_queueid.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__session_8h_source.html">bmqa_session.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqt__queueoptions_8h_source.html">bmqt_queueoptions.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqt__sessionoptions_8h_source.html">bmqt_sessionoptions.h</a>&gt;</code><br />
<code>#include &lt;ball_log.h&gt;</code><br />
<code>#include &lt;bdlb_variant.h&gt;</code><br />
<code>#include &lt;bdlbb_blob.h&gt;</code><br />
<code>#include &lt;bdlbb_pooledblobbufferfactory.h&gt;</code><br />
<code>#include &lt;bdlcc_sharedobjectpool.h&gt;</code><br />
<code>#include &lt;bsl_cstddef.h&gt;</code><br />
<code>#include &lt;bsl_deque.h&gt;</code><br />
<code>#include &lt;bsl_functional.h&gt;</code><br />
<code>#include &lt;bsl_memory.h&gt;</code><br />
<code>#include &lt;bsl_string.h&gt;</code><br />
<code>#include &lt;bsl_unordered_map.h&gt;</code><br />
<code>#include &lt;bsl_unordered_set.h&gt;</code><br />
<code>#include &lt;bsl_vector.h&gt;</code><br />
<code>#include &lt;bslma_allocator.h&gt;</code><br />
<code>#include &lt;bslma_managedptr.h&gt;</code><br />
<code>#include &lt;bslma_usesbslmaallocator.h&gt;</code><br />
<code>#include &lt;bslmf_nestedtraitdeclaration.h&gt;</code><br />
<code>#include &lt;bslmt_mutex.h&gt;</code><br />
<code>#include &lt;bsls_alignedbuffer.h&gt;</code><br />
<code>#include &lt;bsls_assert.h&gt;</code><br />
<code>#include &lt;bsls_timeinterval.h&gt;</code><br />
<code>#include &lt;bsls_types.h&gt;</code><br />
</div>
<p><a href="bmqa__mocksession_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBloombergLP_1_1bmqa_1_1MockSessionUtil.html">BloombergLP::bmqa::MockSessionUtil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility methods to create <code>bmqa</code> events.  <a href="structBloombergLP_1_1bmqa_1_1MockSessionUtil.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBloombergLP_1_1bmqa_1_1MockSessionUtil_1_1AckParams.html">BloombergLP::bmqa::MockSessionUtil::AckParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing parameters for an ack message.  <a href="structBloombergLP_1_1bmqa_1_1MockSessionUtil_1_1AckParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBloombergLP_1_1bmqa_1_1MockSessionUtil_1_1PushMessageParams.html">BloombergLP::bmqa::MockSessionUtil::PushMessageParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing parameters for a push message.  <a href="structBloombergLP_1_1bmqa_1_1MockSessionUtil_1_1PushMessageParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">BloombergLP::bmqa::MockSession</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mechanism to mock a <code><a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html" title="A session with a BlazingMQ broker.">bmqa::Session</a></code>  <a href="classBloombergLP_1_1bmqa_1_1MockSession.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceBloombergLP" id="r_namespaceBloombergLP"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBloombergLP.html">BloombergLP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceBloombergLP_1_1bmqst" id="r_namespaceBloombergLP_1_1bmqst"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBloombergLP_1_1bmqst.html">BloombergLP::bmqst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceBloombergLP_1_1bmqa" id="r_namespaceBloombergLP_1_1bmqa"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBloombergLP_1_1bmqa.html">BloombergLP::bmqa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abe2652fa6d696e03dec9bf44e4e731c9" id="r_abe2652fa6d696e03dec9bf44e4e731c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(OBJ,  CALL)&#160;&#160;&#160;    (((OBJ).expect_##CALL).fromLocation(__FILE__, __LINE__))</td></tr>
<tr class="separator:abe2652fa6d696e03dec9bf44e4e731c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This component provides a mechanism implementing the <a class="el" href="classBloombergLP_1_1bmqa_1_1AbstractSession.html">bmqa::AbstractSession</a> protocol, for mocking a <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> and can be used to write a test for an application that uses BMQ. The <a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a> provides all the methods that <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> provides, with added methods to specify return codes and emitted events and expected calls. This can be used to test BlazingMQ application code without a connection to the broker. <a class="el" href="structBloombergLP_1_1bmqa_1_1MockSessionUtil.html">bmqa::MockSessionUtil</a> is a utility namespace providing useful methods to build <a class="el" href="classBloombergLP_1_1bmqa_1_1Event.html">bmqa::Event</a> objects that are typically only emitted from the broker.</p>
<p>The following documentation elucidates the API that this component provides and some simple use cases to get you started.</p>
<h1><a class="anchor" id="bmqa_mocksession_disclaimer"></a>
Disclaimer</h1>
<dl class="section warning"><dt>Warning</dt><dd>THIS COMPONENT SHOULD ONLY BE USED IN TEST DRIVERS. IT WILL NOT WORK WITH PRODUCTION CODE.</dd></dl>
<h1><a class="anchor" id="bmqa_mocksession_usable"></a>
Usable Components</h1>
<ul>
<li><b>BMQA_EXPECT_CALL</b>: Macro to specify an expected call to a <a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a> object. This macro is used to specify which is the next expected call on the <a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a>. If an incorrect call is invoked or incorrect parameters are used, an assert will be invoked.</li>
<li><b>returning</b>: Specify a return value for the expected call. This is the value that will be returned when the method on <a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a> is invoked.</li>
<li><b>emitting</b>: Specify an event to be <code>emitted</code> when the expected call is invoked. The events specified are enqueued to the internal event queue and are delivered to the application when <code>emitEvent</code> is invoked.</li>
</ul>
<h1><a class="anchor" id="bmqa_mocksession_helper"></a>
Static Helper Methods</h1>
<ul>
<li><b>createAckEvent</b>: Create an acknowledgment message event for messages posted to BMQ.</li>
<li><b>createPushEvent</b>: Create a push message event for messages to be consumed from BMQ.</li>
<li><b>createOpenQueueStatus</b>: Create an openQueue result (relating to an async open queue operation)</li>
<li><b>createConfigureQueueStatus</b>: Create a configureQueue result (relating to an async configure queue operation)</li>
<li><b>createCloseQueueStatus</b>: Create a closeQueue result (relating to an async close queue operation)</li>
<li><b>createSessionEvent</b>: Create a specified type of session event except for events related to open, close and configure queue.</li>
</ul>
<p>The static event builder specified above are typically built inside the broker but are now available to be built in the SDK. The expected use of such events is to build them and specify them to either the <a class="el" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a> macro in the <code>emitting</code> parameter, or enqueued to the <a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a> directly through the <code>enqueueEvent</code> method. They can then be emitted by invoking the <code>emitEvent</code> method, which in turn would be processed through the application-provided <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">bmqa::SessionEventHandler</a>.</p>
<h1><a class="anchor" id="bmqa_mocksession_additional"></a>
Additional Note</h1>
<p><a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a> does not check if methods have been invoked in the correct order. The user is responsible for ensuring that the methods are invoked and events enqueued in the correct order.</p>
<p>The following methods do not emit events:</p>
<ul>
<li><code>getQueueId</code></li>
<li><code>loadMessageEventBuilder</code></li>
<li><code>loadConfirmEventBuilder</code></li>
<li><code>loadMessageProperties</code></li>
<li><code>confirmMessage</code></li>
<li><code>confirmMessages</code></li>
</ul>
<p>Calls to the following methods do not require an expect:</p>
<ul>
<li><code>getQueueId</code></li>
<li><code>loadMessageEventBuilder</code></li>
<li><code>loadConfirmEventBuilder</code></li>
<li><code>loadMessageProperties</code></li>
</ul>
<h1><a class="anchor" id="bmqa_mocksession_creating"></a>
Creating a mock session in asynchronous mode</h1>
<p>The <a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a> is created in asynchronous mode when a <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">bmqa::SessionEventHandler</a> is provided to it. If it is not provided a handler, the <a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a> is started in synchronous mode, requiring the application to call <code>nextEvent</code> to access enqueued events. A sample handler could look like this:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyEventHandler : <span class="keyword">public</span> bmqa::SessionEventHandler {</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// DATA</span></div>
<div class="line">    bsl::deque&lt;bmqa::SessionEvent&gt;    d_sessionEventsQueue;</div>
<div class="line">    bsl::deque&lt;bmqa::MessageEvents&gt;   d_messageEventsQueue;</div>
<div class="line">    bsl::deque&lt;bmqa::OpenQueueStatus&gt; d_openQueueResultsQueue;</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// MANIPULATORS</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onSessionEvent(<span class="keyword">const</span> bmqa::SessionEvent&amp; event)</div>
<div class="line">    {</div>
<div class="line">        bsl::cout &lt;&lt; <span class="stringliteral">&quot;Received session event &quot;</span> &lt;&lt; <span class="keyword">event</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        <span class="comment">// some business logic, typically a switch case on</span></div>
<div class="line">        <span class="comment">// &#39;bmqt::SessionEventType&#39;</span></div>
<div class="line">        d_sessionEventsQueue.push_back(event);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onMessageEvent(<span class="keyword">const</span> bmqa::MessageEvent&amp; event)</div>
<div class="line">    {</div>
<div class="line">        bsl::cout &lt;&lt; <span class="stringliteral">&quot;Received message event &quot;</span> &lt;&lt; <span class="keyword">event</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        <span class="comment">// some business logic, typically a switch case on</span></div>
<div class="line">        <span class="comment">// &#39;bmqt::MessageEventType&#39;</span></div>
<div class="line">        d_messageEventsQueue.push_back(event);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> onOpenQueueStatus(<span class="keyword">const</span> bmqa::OpenQueueStatus&amp; result)</div>
<div class="line">    {</div>
<div class="line">        bsl::cout &lt;&lt; <span class="stringliteral">&quot;Received open queue result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">        <span class="comment">// Some business logic</span></div>
<div class="line">        d_openQueueResultsQueue.push_back(result);</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    bmqa::SessionEvent popSessionEvent()</div>
<div class="line">    {</div>
<div class="line">        BSLS_ASSERT(d_sessionEventsQueue.size() &gt; 0);</div>
<div class="line">        bmqa::SessionEvent ret(d_receivedSessionEvents.front());</div>
<div class="line">        d_receivedSessionEvents.pop_front();</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    bmqa::MessageEvent popMessageEvent()</div>
<div class="line">    {</div>
<div class="line">        BSLS_ASSERT(d_messageEventsSize.size() &gt; 0);</div>
<div class="line">        bmqa::MessageEvent ret(d_receivedMessageEvents.front());</div>
<div class="line">        d_receivedMessageEvents.erase(d_receivedMessageEvents.begin());</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    bmqa::OpenQueueStatus popOpenQueueStatus()</div>
<div class="line">    {</div>
<div class="line">        BSLS_ASSERT(d_openQueueResultsQueue.size() &gt; 0);</div>
<div class="line">        bmqa::OpenQueueStatus ret(d_openQueueResultsQueue.front());</div>
<div class="line">        d_openQueueResultsQueue.erase(d_openQueueResultsQueue.begin());</div>
<div class="line">        <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="bmqa_mocksession_usage"></a>
Usage</h1>
<p>This section illustrates intended use of this component.</p>
<h2><a class="anchor" id="bmqa_mocksession_ex1"></a>
Example 1</h2>
<p>The folowing example shows a simple producer in asynchronous mode, which will start the session, open a queue, post a message to the queue, generate an ack for that message and finally stop the session (skipping over close queue because it is analogous to opening a queue). In theory, you can use <code>emitting</code> on the <a class="el" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a> macro and <code>enqueueEvent</code> interchangeably, but in practice it is important to note that events from the broker are generated asynchronously, which means that they are not emitted as you call the method. You can control emission of events, however, by delaying the call to <code>emitEvent</code>.</p>
<dl class="section note"><dt>Note</dt><dd>As with <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a>, calling <code>nextEvent</code> is meaningless in asynchronous mode.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> unitTest()</div>
<div class="line">{</div>
<div class="line">    bslma::Allocator* allocator = bmqtst::TestHelperUtil::allocator();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create an event handler</span></div>
<div class="line">    EventHandler eventHandler(allocator);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The following static initializer method calls all the appropriate</span></div>
<div class="line">    <span class="comment">// static initializers of the underlying components needed for the</span></div>
<div class="line">    <span class="comment">// &#39;MockSession&#39;.  The constructor of &#39;MockSession&#39; will call it in</span></div>
<div class="line">    <span class="comment">// any case but if events need to be built outside the scope of the</span></div>
<div class="line">    <span class="comment">// creation of &#39;MockSession&#39; you will need to explicitly invoke this</span></div>
<div class="line">    <span class="comment">// static initializer method.</span></div>
<div class="line">    bmqa::MockSession::initialize(allocator);</div>
<div class="line"> </div>
<div class="line">    bslma::ManagedPtr&lt;bmqa::SessionEventHandler&gt; handlerMp;</div>
<div class="line">    handlerMp.load(&amp;eventHandler, 0, bslma::ManagedPtrUtil::noOpDeleter);</div>
<div class="line"> </div>
<div class="line">    bmqa::MockSession mockSession(handlerMp,</div>
<div class="line">                                  bmqt::SessionOptions(allocator),</div>
<div class="line">                                  allocator);</div>
<div class="line"> </div>
<div class="line">    bmqa::QueueId       queueId(bmqt::CorrelationId(1), allocator);</div>
<div class="line">    bmqt::CorrelationId corrId(1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Expect a call to start and the call emits an &#39;e_CONNECTED&#39; event.</span></div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession, startAsync())</div>
<div class="line">        .returning(0)</div>
<div class="line">        .emitting(bmqa::MockSessionUtil::createSessionEvent(</div>
<div class="line">                      bmqt::SessionEventType::e_CONNECTED,</div>
<div class="line">                      0,   <span class="comment">// statusCode</span></div>
<div class="line">                      <span class="stringliteral">&quot;&quot;</span>,  <span class="comment">// errorDescription</span></div>
<div class="line">                      allocator));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Make a call to startAsync and emit the event that is enqueued from</span></div>
<div class="line">    <span class="comment">// that call.</span></div>
<div class="line">    BMQTST_ASSERT_EQ(mockSession.startAsync(), 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Emit our enqueued event.  This fully sets up the session which is</span></div>
<div class="line">    <span class="comment">// now ready to use.  Typically you would have some business logic on</span></div>
<div class="line">    <span class="comment">// &#39;e_CONNECTED&#39; that makes your application ready to use.</span></div>
<div class="line">    BMQTST_ASSERT_EQ(mockSession.emitEvent(), <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Our event handler internally just stores the event emitted, so pop</span></div>
<div class="line">    <span class="comment">// it out and examine.</span></div>
<div class="line">    bmqa::SessionEvent startEvent(eventHandler.popSessionEvent());</div>
<div class="line"> </div>
<div class="line">    BMQTST_ASSERT_EQ(startEvent.type(),</div>
<div class="line">    bmqt::SessionEventType::e_CONNECTED);</div>
<div class="line">    BMQTST_ASSERT_EQ(startEvent.status Code(), 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the uri to your queue as you would in your application.</span></div>
<div class="line">    <span class="keyword">const</span> bmqt::Uri uri(<span class="stringliteral">&quot;bmq://my.domain/queue&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialize the queue flags for a producer with acks enabled</span></div>
<div class="line">    bsls::Types::Uint64 flags = 0;</div>
<div class="line">    bmqt::QueueFlagsUtil::setWriter(&amp;flags);</div>
<div class="line">    bmqt::QueueFlagsUtil::setAck(&amp;flags);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We use the macro to expect a call to &#39;openQueueAsync&#39;, binding the</span></div>
<div class="line">    <span class="comment">// &#39;uri&#39; and &#39;queueId&#39; objects as well as the &#39;flags&#39; that we created.</span></div>
<div class="line">    bmqa::MockSession::OpenQueueCallback openQueueCallback =</div>
<div class="line">        bdlf::BindUtil::bind(&amp;EventHandler::onOpenQueueStatus,</div>
<div class="line">                             &amp;eventHandler,</div>
<div class="line">                             bdlf::PlaceHolders::_1); <span class="comment">// result</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession,</div>
<div class="line">                     openQueueAsync(uri1,</div>
<div class="line">                                    flags,</div>
<div class="line">                                    openQueueCallback));</div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession,</div>
<div class="line">                     openQueueAsync(uri, flags, openQueueCallback));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now that we have set our expectations we can try to open the queue.</span></div>
<div class="line">    mockSession.openQueueAsync(uri1, flags, openQueueCallback);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since the application may not have direct access to the queue, we</span></div>
<div class="line">    <span class="comment">// need to get the &#39;queueId&#39; from the session.  We can then bind this</span></div>
<div class="line">    <span class="comment">// retrieved &#39;queueId&#39; to the &#39;e_QUEUE_OPEN_RESULT&#39; session event and</span></div>
<div class="line">    <span class="comment">// enqueue it to the &#39;MockSession&#39;.</span></div>
<div class="line">    <span class="comment">// Note: You can only get the &#39;queueId&#39; after &#39;openQueue&#39; or</span></div>
<div class="line">    <span class="comment">//       &#39;openQueueAsync&#39; has been invoked on the session.</span></div>
<div class="line">    bmqa::QueueId         queueId1(corrId1);</div>
<div class="line">    bmqa::OpenQueueStatus openQueueResult =</div>
<div class="line">        bmqa::MockSessionUtil::createOpenQueueStatus(</div>
<div class="line">                    queueId1,</div>
<div class="line">                    bmqt::OpenQueueResult::e_TIMEOUT,  <span class="comment">// statusCode</span></div>
<div class="line">                    <span class="stringliteral">&quot;Local Timeout&quot;</span>,                   <span class="comment">// errorDescription</span></div>
<div class="line">                    allocator);</div>
<div class="line">    mockSession.enqueueEvent(openQueueResult);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We just enqueued a &#39;bmqa::OpenQueueStatus&#39; to be emitted.  We can</span></div>
<div class="line">    <span class="comment">// emit it using &#39;emitEvent&#39;.</span></div>
<div class="line">    BMQTST_ASSERT_EQ(mockSession.emitEvent(), <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">//  Pop out this event from the handler and examine it.</span></div>
<div class="line">    bmqa::OpenQueueStatus result = eventHandler.popOpenQueueStatus();</div>
<div class="line">    BMQTST_ASSERT_EQ(result, openQueueResult);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// On emission of &#39;bmqa::OpenQueueStatus&#39;, the queue is fully open and</span></div>
<div class="line">    <span class="comment">// we can now post to it.</span></div>
<div class="line">    bmqa::MessageEventBuilder builder;</div>
<div class="line">    mockSession.loadMessageEventBuilder(&amp;builder);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession, post(builder.messageEvent()))</div>
<div class="line">        .returning(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use the builder to build a message event and pack it for the queue</span></div>
<div class="line">    <span class="comment">// that has been opened.  If you try to pack the message for an</span></div>
<div class="line">    <span class="comment">// invalid or closed queue, packing the message will fail. This has</span></div>
<div class="line">    <span class="comment">// been elided for brevity.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now that the event has been built we can &#39;post&#39; it to BMQ.</span></div>
<div class="line">    BMQTST_ASSERT_EQ(mockSession.post(builder.messageEvent()), 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Simply creating a blob buffer factory on the stack to be used by</span></div>
<div class="line">    <span class="comment">// &#39;createAckEvent&#39;.  Typically you would have one for the component.</span></div>
<div class="line">    bdlbb::PooledBlobBufferFactory bufferFactory(4 * 1024, allocator);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The method &#39;createAckEvent&#39; takes a vector of &#39;AckParams&#39; to</span></div>
<div class="line">    <span class="comment">// specify multiple acks per event, but here we are only acknowledging</span></div>
<div class="line">    <span class="comment">// 1 message.  Specify a positive ack with &#39;e_SUCCESS&#39; here but you</span></div>
<div class="line">    <span class="comment">// can specify any from &#39;bmqt::AckResult::Enum&#39;.</span></div>
<div class="line">    bsl::vector&lt;bmqa::MockSessionUtil::AckParams&gt; acks(allocator);</div>
<div class="line">    acks.emplace_back(bmqt::AckResult::e_SUCCESS,</div>
<div class="line">                      bmqt::CorrelationId(1),</div>
<div class="line">                      bmqt::MessageGUID(), <span class="comment">// Real GUID needed if you want</span></div>
<div class="line">                                           <span class="comment">// to record ack messages.</span></div>
<div class="line">                      bmqa::QueueId(1));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Enqueuing ack event to be emitted.  We use the helper function</span></div>
<div class="line">    <span class="comment">// &#39;createAckEvent&#39; to generate this event.</span></div>
<div class="line">    mockSession.enqueueEvent(bmqa::MockSessionUtil::createAckEvent(</div>
<div class="line">                                                          acks,</div>
<div class="line">                                                          &amp;bufferFactory,</div>
<div class="line">                                                          allocator));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Emit the enqueued ack event.</span></div>
<div class="line">    BMQTST_ASSERT_EQ(mockSession.emitEvent(), <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// As we did earlier, pop it out and examine.</span></div>
<div class="line">    bmqa::MessageEvent ackEvent(eventHandler.popMessageEvent());</div>
<div class="line">    BMQTST_ASSERT_EQ(ackEvent.type(), bmqt::MessageEventType::e_ACK);</div>
<div class="line">    bmqa::MessageIterator mIter = ackEvent.messageIterator();</div>
<div class="line">    mIter.nextMessage();</div>
<div class="line">    BMQTST_ASSERT_EQ(mIter.message().ackStatus(),</div>
<div class="line">    bmqt::AckResult::e_SUCCESS);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This is a simple test.  After posting our message and receiving the</span></div>
<div class="line">    <span class="comment">// ack, we are now shutting down our application.  Therefore we expect</span></div>
<div class="line">    <span class="comment">// a &#39;stopAsync&#39; call.</span></div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession, stopAsync());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now make a call to &#39;stopAsync&#39; to stop our session.</span></div>
<div class="line">    mockSession.stopAsync();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Here we are enqueuing an &#39;e_DISCONNECTED&#39; event as you would</span></div>
<div class="line">    <span class="comment">// receive from the broker on a successful shutdown.</span></div>
<div class="line">    mockSession.enqueueEvent(bmqa::MockSessionUtil::createSessionEvent(</div>
<div class="line">                                   bmqt::SessionEventType::e_DISCONNECTED,</div>
<div class="line">                                   0,   <span class="comment">// statusCode</span></div>
<div class="line">                                   <span class="stringliteral">&quot;&quot;</span>,  <span class="comment">// errorDescription</span></div>
<div class="line">                                   d_allocator_p));</div>
<div class="line">    BMQTST_ASSERT_EQ(mockSession.emitEvent(), <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Our event handler internally just stores the event emitted, so pop</span></div>
<div class="line">    <span class="comment">// it out and examine.</span></div>
<div class="line">    bmqa::SessionEvent stopEvent(eventHandler.popSessionEvent());</div>
<div class="line">    BMQTST_ASSERT_EQ(stopEvent.type(),</div>
<div class="line">    bmqt::SessionEventType::e_DISCONNECTED);</div>
<div class="line">    BMQTST_ASSERT_EQ(stopEvent.statusCode(), 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The corresponding pendant operation of the &#39;initialize&#39; which would</span></div>
<div class="line">    <span class="comment">// need to be called only if &#39;initialize&#39; was explicitly called.</span></div>
<div class="line">    <span class="comment">// bmqa::MockSession::shutdown();</span></div>
<div class="line">}</div>
<div class="ttc" id="abmqa__mocksession_8h_html_abe2652fa6d696e03dec9bf44e4e731c9"><div class="ttname"><a href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a></div><div class="ttdeci">#define BMQA_EXPECT_CALL(OBJ, CALL)</div><div class="ttdef"><b>Definition</b> bmqa_mocksession.h:608</div></div>
</div><!-- fragment --><h2><a class="anchor" id="bmqa_mocksession_ex2"></a>
Example 2</h2>
<p>The folowing example shows a consumer in synchronous mode, which will start the session, generate a push message (simulating the broker), confirm the message and then stop the session. Additionally, this test case also sets all expectations up front before running the code, as this is the alternate way of writing your test driver.</p>
<dl class="section note"><dt>Note</dt><dd>Using <code>enqueue</code> or <code>emitEvent</code> on <a class="el" href="classBloombergLP_1_1bmqa_1_1MockSession.html">bmqa::MockSession</a> or <code>emitting</code> on the <a class="el" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a> macro in synchronous mode is meaningless.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> unitTest()</div>
<div class="line">{</div>
<div class="line">    bslma::Allocator* allocator = bmqtst::TestHelperUtil::allocator();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// MockSession created without an eventHandler.</span></div>
<div class="line">    bmqa::MockSession mockSession(bmqt::SessionOptions(allocator),</div>
<div class="line">                                  allocator);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The following static initializer method calls all the appropriate</span></div>
<div class="line">    <span class="comment">// static initializers of the underlying components needed for the</span></div>
<div class="line">    <span class="comment">// &#39;MockSession&#39;.  The constructor of &#39;MockSession&#39; will call it in</span></div>
<div class="line">    <span class="comment">// any case but if events need to be built outside the scope of the</span></div>
<div class="line">    <span class="comment">// creation of &#39;MockSession&#39; you will need to explicitly invoke this</span></div>
<div class="line">    <span class="comment">// static initializer method.</span></div>
<div class="line">    <span class="comment">// bmqa::MockSession::initialize(allocator);</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create simple queueIds and corrIds</span></div>
<div class="line">    bmqa::QueueId       queueId(1);</div>
<div class="line">    bmqt::CorrelationId corrId(1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the uri to your queue as you would in your application.</span></div>
<div class="line">    bmqt::Uri uri(<span class="stringliteral">&quot;bmq://my.domain/queue&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Expecting that &#39;startAsync&#39; will be called on the MockSession.</span></div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession, startAsync())</div>
<div class="line">        .returning(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Simply creating a blob buffer factory on the stack to be used by</span></div>
<div class="line">    <span class="comment">// &#39;createAckEvent&#39;.  Typically you would have one for the component.</span></div>
<div class="line">    bdlbb::PooledBlobBufferFactory bufferFactory(4 * 1024, allocator);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We then expect that &#39;nextEvent&#39; will be called to return the</span></div>
<div class="line">    <span class="comment">// &#39;e_CONNECTED&#39; event from the broker</span></div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession, nextEvent(bsls::TimeInterval()))</div>
<div class="line">        .returning(bmqa::MockSessionUtil::createSessionEvent(</div>
<div class="line">                       bmqt::SessionEventType::e_CONNECTED,</div>
<div class="line">                       bmqt::CorrelationId::autoValue(),</div>
<div class="line">                       0,   <span class="comment">// errorCode</span></div>
<div class="line">                       <span class="stringliteral">&quot;&quot;</span>,  <span class="comment">// errorDescription</span></div>
<div class="line">                       allocator));</div>
<div class="line">        <span class="comment">// Note that we use an &#39;autoValue&#39; for correlationId because it&#39;s</span></div>
<div class="line">        <span class="comment">// irrelevant for a &#39;CONNECTED&#39; event.</span></div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Initialize the queue flags for a consumer</span></div>
<div class="line">     bsls::Types::Uint64 flags = 0;</div>
<div class="line">     bmqt::QueueFlagsUtil::setReader(&amp;flags);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// We use the macro to expect a call to &#39;openQueueSync&#39;, binding the</span></div>
<div class="line">    <span class="comment">// &#39;uri&#39; and &#39;queueId&#39; objects as well as the flags that we created.</span></div>
<div class="line">    <span class="comment">// Note that the &#39;queueId&#39; object will be modified as &#39;openQueueSync&#39;</span></div>
<div class="line">    <span class="comment">// takes it as an output parameter.</span></div>
<div class="line">    bmqa::OpenQueueStatus expectedResult =</div>
<div class="line">        bmqa::MockSessionUtil::createOpenQueueStatus(</div>
<div class="line">                     queueId,</div>
<div class="line">                     bmqt::OpenQueueResult::e_SUCCESS,  <span class="comment">// statusCode</span></div>
<div class="line">                     <span class="stringliteral">&quot;&quot;</span>,                                <span class="comment">// errorDescription</span></div>
<div class="line">                     allocator);</div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession, openQueueSync(&amp;queueId, uri, flags))</div>
<div class="line">        .returning(expectedResult);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Build our incoming message event.</span></div>
<div class="line">    bsl::vector&lt;bmqa::MockSessionUtil::PushMessageParams&gt; pushMsgs(</div>
<div class="line">                                                                allocator);</div>
<div class="line">    bdlbb::Blob payload(&amp;bufferFactory, allocator);</div>
<div class="line">    bdlbb::BlobUtil::append(&amp;payload, <span class="stringliteral">&quot;hello&quot;</span>, 6);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>        guidHex[] = <span class="stringliteral">&quot;00000000000000000000000000000001&quot;</span>;</div>
<div class="line">    bmqt::MessageGUID guid;</div>
<div class="line">    guid.fromHex(guidHex);</div>
<div class="line"> </div>
<div class="line">    bmqa::MessageProperties properties;</div>
<div class="line">    mockSession.loadMessageProperties(&amp;properties);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// For each message that we are supposed to receive from the broker,</span></div>
<div class="line">    <span class="comment">// we need to specify the payload, the queueId, a guid (the hex is</span></div>
<div class="line">    <span class="comment">// random but unique within your test driver) and properties which</span></div>
<div class="line">    <span class="comment">// could be empty.</span></div>
<div class="line">    pushMsgs.emplace_back(payload, queueId, guid, properties);</div>
<div class="line">    bmqa::Event pushMsgEvent = bmqa::MockSessionUtil::createPushEvent(</div>
<div class="line">                                                            pushMsgs,</div>
<div class="line">                                                            &amp;bufferFactory,</div>
<div class="line">                                                            allocator);</div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession, nextEvent(bsls::TimeInterval()))</div>
<div class="line">        .returning(pushMsgEvent);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Next we expect a call to &#39;confirmMessages&#39;, to confirm the 1 message</span></div>
<div class="line">    <span class="comment">// that we received from the broker.</span></div>
<div class="line">    bmqa::ConfirmEventBuilder confirmBuilder;</div>
<div class="line">    mockSession.loadConfirmEventBuilder(&amp;confirmBuilder);</div>
<div class="line">    <a class="code hl_define" href="bmqa__mocksession_8h.html#abe2652fa6d696e03dec9bf44e4e731c9">BMQA_EXPECT_CALL</a>(mockSession, confirmMessages(&amp;confirmBuilder))</div>
<div class="line">        .returning(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Expectations have been set up.  Now we run the code.</span></div>
<div class="line">    <span class="comment">// &#39;startAsync&#39; is the first call.  We expect it to return 0 and we</span></div>
<div class="line">    <span class="comment">// expect &#39;nextEvent&#39; to return the &#39;e_CONNECTED&#39; session event.</span></div>
<div class="line">    <span class="keywordtype">int</span> rc = mockSession.startAsync();</div>
<div class="line">    BMQTST_ASSERT_EQ(rc, 0);</div>
<div class="line">    bmqa::SessionEvent startEvent = mockSession.nextEvent(</div>
<div class="line">                                                      bsls::TimeInterval())</div>
<div class="line">        .sessionEvent();</div>
<div class="line">    BMQTST_ASSERT_EQ(startEvent.type(),</div>
<div class="line">    bmqt::SessionEventType::e_CONNECTED);</div>
<div class="line">    BMQTST_ASSERT_EQ(startEvent.statusCode(),       0);</div>
<div class="line">    BMQTST_ASSERT_EQ(startEvent.errorDescription(), <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Next we expect a call to &#39;openQueue&#39; to open the queue.</span></div>
<div class="line">    bmqa::OpenQueueStatus result = mockSession.openQueueSync(&amp;queueId,</div>
<div class="line">                                                             uri,</div>
<div class="line">                                                             flags);</div>
<div class="line">    BMQTST_ASSERT_EQ(result, expectedResult);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now our call to &#39;nextEvent&#39; will generate a push message from the</span></div>
<div class="line">    <span class="comment">// broker, which we will then go on to confirm.</span></div>
<div class="line">    bmqa::MessageEvent pushMsgEvt(mockSession.nextEvent(</div>
<div class="line">                                                      bsls::TimeInterval())</div>
<div class="line">                                                          .messageEvent());</div>
<div class="line">    BMQTST_ASSERT_EQ(pushMsgEvt.type(), bmqt::MessageEventType::e_PUSH);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Now that we have received a push message which has yet to be</span></div>
<div class="line">    <span class="comment">// confirmed, we can confirm that 1 unconfirmed message exists.</span></div>
<div class="line">    BMQTST_ASSERT_EQ(mockSession.unconfirmedMessages(), 1U);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Since there is only 1 message in our message event, we dont have to</span></div>
<div class="line">    <span class="comment">// iterate over the event but in reality you will want to iterate over</span></div>
<div class="line">    <span class="comment">// each message and add it to the confirm builder.</span></div>
<div class="line">    bmqa::MessageIterator mIter = pushMsgEvt.messageIterator();</div>
<div class="line">    mIter.nextMessage();</div>
<div class="line">    confirmBuilder.addMessageConfirmation(mIter.message());</div>
<div class="line">    BMQTST_ASSERT_EQ(confirmBuilder.messageCount(), 1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Confirm the messages using the builder that has been populated.</span></div>
<div class="line">    rc = mockSession.confirmMessages(&amp;confirmBuilder);</div>
<div class="line">    BMQTST_ASSERT_EQ(rc, 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Voila! We now have no unconfirmed messages.</span></div>
<div class="line">    BMQTST_ASSERT_EQ(mockSession.unconfirmedMessages(), 0u);</div>
<div class="line">    <span class="comment">// &#39;stop&#39; has been elided for brevity and is analogous to &#39;start&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The corresponding pendant operation of the &#39;initialize&#39; which would</span></div>
<div class="line">    <span class="comment">// need to be called only if &#39;initialize&#39; was explicitly called.</span></div>
<div class="line">    <span class="comment">// bmqa::MockSession::shutdown();</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="bmqa_mocksession_thread"></a>
Thread Safety</h2>
<p>THREAD SAFE. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="abe2652fa6d696e03dec9bf44e4e731c9" name="abe2652fa6d696e03dec9bf44e4e731c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2652fa6d696e03dec9bf44e4e731c9">&#9670;&#160;</a></span>BMQA_EXPECT_CALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BMQA_EXPECT_CALL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OBJ, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">CALL&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    (((OBJ).expect_##CALL).fromLocation(__FILE__, __LINE__))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_e8cd90b45eb8e499a7a689fb69672d2e.html">bmqa</a></li><li class="navelem"><a class="el" href="bmqa__mocksession_8h.html">bmqa_mocksession.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
