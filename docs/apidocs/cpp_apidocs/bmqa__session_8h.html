<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libbmq: bmqa/bmqa_session.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libbmq<span id="projectnumber">&#160;01593f8a8599f58efc95de5b027890b065f55d55</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('bmqa__session_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle"><div class="title">bmqa_session.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provide access to the BlazingMQ broker.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="bmqa__abstractsession_8h_source.html">bmqa_abstractsession.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__closequeuestatus_8h_source.html">bmqa_closequeuestatus.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__configurequeuestatus_8h_source.html">bmqa_configurequeuestatus.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__confirmeventbuilder_8h_source.html">bmqa_confirmeventbuilder.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__messageeventbuilder_8h_source.html">bmqa_messageeventbuilder.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqa__openqueuestatus_8h_source.html">bmqa_openqueuestatus.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqt__queueoptions_8h_source.html">bmqt_queueoptions.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqt__sessionoptions_8h_source.html">bmqt_sessionoptions.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="bmqt__uri_8h_source.html">bmqt_uri.h</a>&gt;</code><br />
<code>#include &lt;ball_log.h&gt;</code><br />
<code>#include &lt;bsl_memory.h&gt;</code><br />
<code>#include &lt;bsl_string.h&gt;</code><br />
<code>#include &lt;bslma_allocator.h&gt;</code><br />
<code>#include &lt;bslma_managedptr.h&gt;</code><br />
<code>#include &lt;bslma_usesbslmaallocator.h&gt;</code><br />
<code>#include &lt;bslmf_nestedtraitdeclaration.h&gt;</code><br />
<code>#include &lt;bsls_keyword.h&gt;</code><br />
<code>#include &lt;bsls_timeinterval.h&gt;</code><br />
<code>#include &lt;bsls_types.h&gt;</code><br />
</div>
<p><a href="bmqa__session_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">BloombergLP::bmqa::SessionEventHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">BloombergLP::bmqa::Session</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A session with a BlazingMQ broker.  <a href="classBloombergLP_1_1bmqa_1_1Session.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceBloombergLP" id="r_namespaceBloombergLP"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBloombergLP.html">BloombergLP</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceBloombergLP_1_1bmqa" id="r_namespaceBloombergLP_1_1bmqa"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceBloombergLP_1_1bmqa.html">BloombergLP::bmqa</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This component provides a mechanism, <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a>, that provides access to a message queue broker and an interface, <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">bmqa::SessionEventHandler</a> for asynchronous notification of events. The broker manages named, persistent queues of messages. This broker allows a client to open queues, post messages to them, or retrieve messages from them. All of these operations take place within the context of the session opened by the client application.</p>
<p>Messages received from a broker are communicated to the application by the session associated with that broker in the form of events (see <a class="el" href="bmqa__event_8h.html">bmqa_event.h</a>). Events can be of two different types: (1) Messages and message status events (<a class="el" href="classBloombergLP_1_1bmqa_1_1MessageEvent.html">bmqa::MessageEvent</a>), or (2) Session or queue status events (<a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEvent.html">bmqa::SessionEvent</a>).</p>
<p>A <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> can dispatch events to the application in either a synchronous or asynchronous mode. In synchronous mode, the application must call the <code>nextEvent</code> method in order to obtain events from the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a>. In asynchronous mode, the application must supply a concrete <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">bmqa::SessionEventHandler</a> object at construction time. The concrete <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">bmqa::SessionEventHandler</a> provided by the application must implement the <code>onSessionEvent</code> and <code>onMessageEvent</code> methods, which will be called by the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> every time a session event or a message event is received. Note that by default, a session created in asynchronous mode creates only one internal thread to dispatch events, but a different value for number of threads can be specified in <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>.</p>
<p>A <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> is created either in synchronous or in asynchronous mode, and it will remain in that mode until destruction. Allowing a mix between synchronous or asynchronous would make the SDK complicated. The only exceptions are the "start" and "open" operations that must be available in synchronous or asynchronous version for the convenience of the programmer.</p>
<p>By default a <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> connects to the local broker, which in turn may connect to a remote cluster based on configuration.</p>
<p>After a <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> is started, the application has to open one or several queues in read and/or write mode.</p>
<h1><a class="anchor" id="bmqa_session_disclaimer"></a>
Disclaimer</h1>
<p>A <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> object is a heavy object representing the negotiated TCP session with the broker, and the entire associated state (opened queues, statistics, ...). Therefore, sessions should be always reused if possible, preferably with only <em>one</em> session per lifetime of a component/library/task. Note that at the time of this writing multiplexing of different logical sessions over the same physical connection is not supported, so in certain circumstances reuse of the same session across the whole of a single application will not be possible. For example, if an application uses two unrelated libraries both of which use BlazingMQ under the hood, they won't be able to share a session as it stands. An example of an extreme inefficiency and an abuse of resources is to create a session ad-hoc every time a message needs to be posted by the same component.</p>
<h1><a class="anchor" id="bmqa_session_thread"></a>
Thread-safety</h1>
<p>This session object is <em>thread</em> <em>enabled</em>, meaning that two threads can safely call any methods on the <em>same</em> <em>instance</em> without external synchronization.</p>
<h1><a class="anchor" id="bmqa_session_connecting"></a>
Connecting to the Broker</h1>
<p>A <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> establishes a communication with a broker service using TCP/IP. Each <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> object must be constructed with a <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> object, which provides the necessary information to connect to the broker. In particular, the <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> object must specify the IP address and port needed to connect to the broker. The <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> object may also provide extra parameters for tuning the TCP connection behavior (see <a class="el" href="bmqt__sessionoptions_8h.html">bmqt_sessionoptions.h</a> for details).</p>
<p>Note that in most cases the user does not need to explicitly construct a <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> object: the default constructor for <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> creates an instance that will connect to the broker service on the local machine using the standard port.</p>
<p>Some options can also be provided using environment variables.</p>
<ul>
<li><b>BMQ_BROKER_URI</b>: Corresponds to <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html#aafdced0acc315ea53c517ac036dfdeb2">bmqt::SessionOptions::brokerUri</a>. If this environment variable is set, its value will override the one specified in the <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html">bmqt::SessionOptions</a>.</li>
</ul>
<p>A <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> object is created in an unconnected state. The <code>start</code> or <code>startAsync</code> method must be called to connect to the broker. Note that <code>start</code> method is blocking, and returns either after connection to broker has been established (success), or after specified timeout (failure). <code>startAsync</code> method, as the name suggests, connects to the broker asynchronously (i.e., it returns immediately), and the result of the operation is notified via <a class="el" href="structBloombergLP_1_1bmqt_1_1SessionEventType.html#ae92327d931cc88d7adb05afdbc5f0431ab032e5f36bc849b00f60956eac7bdd66">bmqt::SessionEventType::e_CONNECTED</a> session event.</p>
<p>When the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> is no longer needed, the application should call the <code>stop</code> (blocking) or <code>stopAsync</code> (non-blocking) method to shut down the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> and disconnect from the broker. Note that destroying a Session automatically stops it. The session can be restarted with a call to <code>start</code> or <code>startAsync</code> once it has been fully stopped.</p>
<h1><a class="anchor" id="bmqa_session_reconnection"></a>
Connection loss and reconnection</h1>
<p>If the connection between the application and the broker is lost, the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> will automatically try to reconnect periodically. The <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> will also notify the application of the event of losing the connection via <a class="el" href="structBloombergLP_1_1bmqt_1_1SessionEventType.html#ae92327d931cc88d7adb05afdbc5f0431adbf91f3702e845361e624172adb4f06a">bmqt::SessionEventType::e_CONNECTION_LOST</a> session event.</p>
<p>Once the connection has been re-established with the broker (as a result of one of the periodic reconnection attempts), the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> will notify the application via <a class="el" href="structBloombergLP_1_1bmqt_1_1SessionEventType.html#ae92327d931cc88d7adb05afdbc5f0431a67435ef5b55121b337a426e9ca673916">bmqt::SessionEventType::e_RECONNECTED</a> session event. After the connection re-establishment, the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> will attempt to reopen the queues that were in <code>OPEN</code> state prior to connection loss. The <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> will notify the application of the result of reopen operation via <a class="el" href="structBloombergLP_1_1bmqt_1_1SessionEventType.html#ae92327d931cc88d7adb05afdbc5f0431aea4047c152e039f9ae21a13cd11ba234">bmqt::SessionEventType::e_QUEUE_REOPEN_RESULT</a> for each queue. Note that a reopen operation on a queue may fail (due to broker issue, machine issue, etc), so the application must keep track on these session events, and stop posting on a queue that failed to reopen.</p>
<p>After all reopen operations are complete and application has been notified with all <a class="el" href="structBloombergLP_1_1bmqt_1_1SessionEventType.html#ae92327d931cc88d7adb05afdbc5f0431aea4047c152e039f9ae21a13cd11ba234">bmqt::SessionEventType::e_QUEUE_REOPEN_RESULT</a> events, the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> delivers a <a class="el" href="structBloombergLP_1_1bmqt_1_1SessionEventType.html#ae92327d931cc88d7adb05afdbc5f0431a0c09a95ce1895790390ab2e7689928b2">bmqt::SessionEventType::e_STATE_RESTORED</a> session event to the application.</p>
<h2><a class="anchor" id="bmqa_session_ex1"></a>
Example 1</h2>
<p>The following example illustrates how to create a <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> in synchronous mode, start it, and stop it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> runSession()</div>
<div class="line">{</div>
<div class="line">    bmqt::SessionOptions options;</div>
<div class="line">    options.setBrokerUri(<span class="stringliteral">&quot;tcp://localhost:30114&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    bmqa::Session session(options);</div>
<div class="line">    <span class="keywordtype">int</span> res = session.start();</div>
<div class="line">    <span class="keywordflow">if</span> (0 != res) {</div>
<div class="line">        bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to start session (&quot;</span> &lt;&lt; res &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div>
<div class="line">                  &lt;&lt; bsl::endl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    bsl::cout &lt;&lt; <span class="stringliteral">&quot;Session started.&quot;</span> &lt;&lt; bsl::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Open queue in READ or WRITE or READ/WRITE mode, and receive or</span></div>
<div class="line">    <span class="comment">// post messages, etc.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    session.stop();</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example can be simplified because the constructor for <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> uses a default <a class="el" href="classBloombergLP_1_1bmqt_1_1SessionOptions.html">bmqt::SessionOptions</a> object that will connect to the local broker service. The example may be rewritten as follow:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> runSession()</div>
<div class="line">{</div>
<div class="line">    bmqa::Session session;     <span class="comment">// using default &#39;SessionOptions&#39;</span></div>
<div class="line">    <span class="keywordtype">int</span> res = session.start();</div>
<div class="line">    <span class="keywordflow">if</span> (0 != res) {</div>
<div class="line">        bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to start session (&quot;</span> &lt;&lt; res &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div>
<div class="line">                  &lt;&lt; bsl::endl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">    bsl::cout &lt;&lt; <span class="stringliteral">&quot;Session started.&quot;</span> &lt;&lt; bsl::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Open queue in READ or WRITE or READ/WRITE mode, and receive or</span></div>
<div class="line">    <span class="comment">// post messages, etc.</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    session.stop();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="bmqa_session_synchronous"></a>
Processing session events - synchronous mode</h1>
<p>If the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> is created in synchronous mode, the application needs to call the <code>nextEvent</code> method on a regular basis in order to receive events. This method takes an optional wait timeout as a parameter, and it will return the next available <a class="el" href="classBloombergLP_1_1bmqa_1_1Event.html">bmqa::Event</a> from the session's internal event queue or it will block the calling thread execution until new <a class="el" href="classBloombergLP_1_1bmqa_1_1Event.html">bmqa::Event</a> arrives or until the specified timeout expires. It is safe to call the <code>nextEvent</code> method from different threads simultaneously: the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> class provides proper synchronization logic to protect the internal event queue from corruption in this scenario.</p>
<h2><a class="anchor" id="bmqa_session_ex2"></a>
Example 2</h2>
<p>The following example demonstrates how to write a function that queries and processes events synchronously. In this example the switch form checks the type of the <a class="el" href="classBloombergLP_1_1bmqa_1_1Event.html">bmqa::Event</a> and performs the necessary actions.</p>
<p>We first define two functions to process <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEvent.html">bmqa::SessionEvent</a> and <a class="el" href="classBloombergLP_1_1bmqa_1_1MessageEvent.html">bmqa::MessageEvent</a>. These functions return <code>true</code> if we should keep processing events and <code>false</code> otherwise (i.e., no more events are expected from the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a>).</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> processSessionEvent(<span class="keyword">const</span> bmqa::SessionEvent&amp; event)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">switch</span> (event.type()) {</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> bmqt::SessionEventType::e_CONNECTED:</div>
<div class="line">        <span class="comment">// The connection to the broker is established (as a result</span></div>
<div class="line">        <span class="comment">// of a call to the &#39;start&#39; method).</span></div>
<div class="line">        openQueues();</div>
<div class="line">        startPostingToQueues();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> bmqt::SessionEventType::e_DISCONNECTED:</div>
<div class="line">        <span class="comment">// The connection to the broker is terminated (as a result</span></div>
<div class="line">        <span class="comment">// of a call to the &#39;stop&#39; method).</span></div>
<div class="line">        result = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> bmqt::SessionEventType::e_CONNECTION_LOST:</div>
<div class="line">        <span class="comment">// The connection to the broker dropped. Stop posting to the queue.</span></div>
<div class="line">        stopPostingToQueues();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> bmqt::SessionEventType::e_STATE_RESTORED:</div>
<div class="line">        <span class="comment">// The connection to the broker has been restored (i.e., all queues</span></div>
<div class="line">        <span class="comment">// have been re-opened. Resume posting to the queue.</span></div>
<div class="line">        resumePostingToQueues();</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> bmqt::SessionEventType::e_CONNECTION_TIMEOUT:</div>
<div class="line">        <span class="comment">// The connection to the broker has timed out.</span></div>
<div class="line">        result = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> bmqt::SessionEventType::e_ERROR:</div>
<div class="line">        <span class="comment">// Internal error</span></div>
<div class="line">        bsl::cout &lt;&lt; <span class="stringliteral">&quot;Unexpected session error: &quot;</span></div>
<div class="line">                  &lt;&lt; <span class="keyword">event</span>.errorDescription() &lt;&lt; bsl::endl;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// end switch</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> processMessageEvent(<span class="keyword">const</span> bmqa::MessageEvent&amp; event)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> result = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">switch</span> (event.type()) {</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> bmqt::MessageEventType::e_PUSH: {</div>
<div class="line">        <span class="comment">// Received a &#39;PUSH&#39; event from the broker.</span></div>
<div class="line">        bmqa::MessageIterator msgIter = <span class="keyword">event</span>.messageIterator();</div>
<div class="line">        <span class="keywordflow">while</span> (msgIter.nextMessage()) {</div>
<div class="line">            <span class="keyword">const</span> bmqa::Message&amp; msg = msgIter.message();</div>
<div class="line">            <span class="comment">// Process &#39;PUSH&#39; msg here (omitted for brevity)</span></div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> bmqt::MessageEventType::e_ACK: {</div>
<div class="line">        <span class="comment">// Received an &#39;ACK&#39; event from the broker.</span></div>
<div class="line">        bmqa::MessageIterator msgIter = <span class="keyword">event</span>.messageIterator();</div>
<div class="line">        <span class="keywordflow">while</span> (msgIter.nextMessage()) {</div>
<div class="line">            <span class="keyword">const</span> bmqa::Message&amp; msg = msgIter.message();</div>
<div class="line">            <span class="comment">// Process &#39;ACK&#39; msg here (omitted for brevity)</span></div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">    } <span class="comment">// end switch</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we define a function that handles events synchronously using the <code>processSessionEvent</code> and <code>processMessageEvent</code> functions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handleEventsSynchronously(bmqa::Session *startedSession)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> more = <span class="keyword">true</span>;</div>
<div class="line">    <span class="keywordflow">while</span> (more) {</div>
<div class="line">        bmqa::Event <span class="keyword">event</span> =</div>
<div class="line">                startedSession-&gt;nextEvent(bsls::TimeInterval(2.0));</div>
<div class="line">        <span class="keywordflow">if</span> (event.isSessionEvent()) {</div>
<div class="line">            more = processSessionEvent(event.sessionEvent());</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">            more = processMessageEvent(event.messageEvent());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="bmqa_session_asynchronous"></a>
Processing session events - asynchronous mode</h1>
<p>If application wishes to use <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> in asynchronous mode, it must pass a managed pointer to an event handler implementing the <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">bmqa::SessionEventHandler</a>. In this case, when <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> is started, a thread pool owned by the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> is also started for processing events asynchronously. The <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> will call event handler's <code>onSessionEvent</code> or <code>onMessageEvent</code> method every time a session event or a message event is available.</p>
<p>Note that after the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> is associated with some event handler, this association cannot be changed or canceled. The event handler will be used for processing events until the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> object is destroyed.</p>
<h2><a class="anchor" id="bmqa_session_ex3"></a>
Example 3</h2>
<p>The following example demonstrates how to implement an event handler and how to make the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> use an instance of this event handler for processing events.</p>
<p>First, we define a concrete implementation of <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">bmqa::SessionEventHandler</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler: <span class="keyword">public</span> bmqa::SessionEventHandler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyHandler() { }</div>
<div class="line">    <span class="keyword">virtual</span> ~MyHandler() { }</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onSessionEvent(<span class="keyword">const</span> bmqa::SessionEvent&amp; event);</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onMessageEvent(<span class="keyword">const</span> bmqa::MessageEvent&amp; event);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyHandler::onSessionEvent(<span class="keyword">const</span> bmqa::SessionEvent&amp; event)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// The implementation is similar to our &#39;processSessionEvent&#39; function</span></div>
<div class="line">    <span class="comment">// defined in the previous example.</span></div>
<div class="line">    processSessionEvent(event);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyHandler::onMessageEvent(<span class="keyword">const</span> bmqa::MessageEvent&amp; event)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// The implementation is similar to our &#39;processMessageEvent&#39; function</span></div>
<div class="line">    <span class="comment">// defined in the previous example.</span></div>
<div class="line">    processMessageEvent(event);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Next, we define a function that creates a <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> using our implementation of <a class="el" href="classBloombergLP_1_1bmqa_1_1SessionEventHandler.html">bmqa::SessionEventHandler</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> runAsyncSession()</div>
<div class="line">{</div>
<div class="line">    bslma::ManagedPtr&lt;SessionEventHandler&gt; handlerMp(<span class="keyword">new</span> MyHandler());</div>
<div class="line"> </div>
<div class="line">    bmqa::Session session(handlerMp);   <span class="comment">// using default &#39;SessionOptions&#39;</span></div>
<div class="line">    <span class="keywordtype">int</span> res = session.start();</div>
<div class="line">    <span class="keywordflow">if</span> (0 != res) {</div>
<div class="line">        bsl::cout &lt;&lt; <span class="stringliteral">&quot;Failed to start session (&quot;</span> &lt;&lt; res &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div>
<div class="line">                  &lt;&lt; bsl::endl;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    session.stop();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="bmqa_session_opening"></a>
Opening queues</h1>
<p>Once the <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> has been created and started, the application can use it to open queues for producing and/or consuming messages. A queue is associated with a domain. Domain metadata must be deployed in the BlazingMQ infrastructure prior to opening queues under that domain, because opening a queue actually loads the metadata deployed for the associated domain.</p>
<p>The metadata associated with a domain defines various parameters like maximum queue size and capacity, persistent policy, routing policy, etc.</p>
<p>Queue are identified by URIs (Unified Resource Identifiers) that must follow the BlazingMQ syntax, manipulated as <a class="el" href="classBloombergLP_1_1bmqt_1_1Uri.html">bmqt::Uri</a> objects. A queue URI is typically formatted as follows:</p>
<div class="fragment"><div class="line">bmq:<span class="comment">//my.domain/my.queue</span></div>
</div><!-- fragment --><p>Note that domain names are unique in BlazingMQ infrastructure, which makes a fully qualified queue URI unique too.</p>
<p>Queues in BlazingMQ infrastructure are created by applications on demand. Broke creates a queue when it receives an open-queue request from an application for a queue that does not exist currently.</p>
<p>Application can open a queue by calling <code>openQueue</code> or <code>openQueueAsync</code> method on a started session. Application must pass appropriate flags to indicate if it wants to post messages to queue, consume messages from the queue, or both.</p>
<p>Note that <code>openQueue</code> is a blocking method, and returns after specified queue has been successfully opened (success) or after specified timeout has expired (failure). <code>openQueueAsync</code> method, as the name suggests, is non blocking, and the result of the operation is notified via <a class="el" href="structBloombergLP_1_1bmqt_1_1SessionEventType.html#ae92327d931cc88d7adb05afdbc5f0431a15f23358d9963553de9192220bd84bf4">bmqt::SessionEventType::e_QUEUE_OPEN_RESULT</a> session event.</p>
<h2><a class="anchor" id="bmqa_session_ex4"></a>
Example 4</h2>
<p>The following example demonstrates how to open a queue for posting messages. The code first opens the queue with appropriate flags, and then uses <a class="el" href="classBloombergLP_1_1bmqa_1_1MessageEventBuilder.html">bmqa::MessageEventBuilder</a> to build a message event and post to the queue.</p>
<div class="fragment"><div class="line"><span class="comment">// Session creation and startup logic elided for brevity</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *queueUri = <span class="stringliteral">&quot;bmq://my.domain/my.queue&quot;</span>;</div>
<div class="line">bmqa::QueueId myQueueId(1);       <span class="comment">// ID for the queue</span></div>
<div class="line"><span class="keywordtype">int</span> rc = session.openQueue(</div>
<div class="line">                    &amp;myQueueId,</div>
<div class="line">                    queueUri,</div>
<div class="line">                    bmqt::QueueFlags::e_WRITE | bmqt::QueueFlags::e_ACK,</div>
<div class="line">                    bsls::TimeInterval(30, 0));</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (rc != 0) {</div>
<div class="line">    bsl::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to open queue, rc: &quot;</span></div>
<div class="line">              &lt;&lt; bmqt::OpenQueueResult::Enum(rc)</div>
<div class="line">              &lt;&lt; bsl::endl;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that apart from <code>WRITE</code> flag, <code>ACK</code> flag has been passed to <code>openQueue</code> method above. This indicates that application is interested in receiving <code>ACK</code> notification for each message it posts to the queue, irrespective of whether or not the message was successfully received by the broker and posted to the queue.</p>
<p>Once the queue has been successfully opened for writing, messages can be posted to the queue for consumption by interested applications. We will use <a class="el" href="classBloombergLP_1_1bmqa_1_1MessageEventBuilder.html">bmqa::MessageEventBuilder</a> to build a message event.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a message event builder</span></div>
<div class="line">bmqa::MessageEventBuilder builder;</div>
<div class="line">session.loadMessageEventBuilder(&amp;builder);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create and post a message event containing 1 message</span></div>
<div class="line">bmqa::Message&amp; msg = builder.startMessage();</div>
<div class="line"> </div>
<div class="line">msg.setCorrelationId(myCorrelationId);</div>
<div class="line">msg.setDataRef(&amp;myPayload);  <span class="comment">// where &#39;myPayload&#39; is of type &#39;bdlbb::Blob&#39;</span></div>
<div class="line">rc = builder.packMessage(myQueueId);</div>
<div class="line"><span class="keywordflow">if</span> (rc != 0) {</div>
<div class="line">    bsl::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to pack message, rc: &quot;</span></div>
<div class="line">              &lt;&lt; bmqt::EventBuilderResult::Enum(rc)</div>
<div class="line">              &lt;&lt; bsl::endl;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Post message event</span></div>
<div class="line">rc = session.post(builder.messageEvent());</div>
<div class="line"><span class="keywordflow">if</span> (rc != 0) {</div>
<div class="line">    bsl::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to post message event to the queue, rc: &quot;</span></div>
<div class="line">              &lt;&lt; bmqt::PostResult::Enum(rc)</div>
<div class="line">              &lt;&lt; bsl::endl;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... post more messages</span></div>
</div><!-- fragment --><h1><a class="anchor" id="bmqa_session_closing"></a>
Closing queues</h1>
<p>After an application no longer needs to produce or consume messages from a queue, it can be closed by <code>closeQueue</code> or <code>closeQueueAsync</code> method. Note that closing a queue closes an application's "view" on the queue, and may not lead to queue deletion in the broker. A <a class="el" href="classBloombergLP_1_1bmqa_1_1Session.html">bmqa::Session</a> does not expose any method to explicitly delete a queue.</p>
<p>Note that <code>closeQueue</code> is a blocking method and returns after the specified queue has been successfully closed (success) or after specified timeout has expired (failure). <code>closeQueueAsync</code>, as the name suggests, is a non-blocking method, and result of the operation is notified via <a class="el" href="structBloombergLP_1_1bmqt_1_1SessionEventType.html#ae92327d931cc88d7adb05afdbc5f0431aac9fc5fd896b676703ba5e4989fa4f6f">bmqt::SessionEventType::e_QUEUE_CLOSE_RESULT</a> session event.</p>
<p>There are 3 flavors which behave differently with regard to thread blocking and callback execution:</p>
<table class="doxtable">
<tr>
<th></th><th>openQueue, configureQueue, closeQueue (deprecated Sync) </th><th>openQueueSync, configureQueueSync, closeQueueSync (Synchronous) </th><th>openQueueAsync, configureQueueAsync, closeQueueAsync (Asynchronous)  </th></tr>
<tr>
<td>event handler </td><td>unblocks in internal thread </td><td>unblocks in event handler thread (*) </td><td>executes callback in event handler thread  </td></tr>
<tr>
<td>nextEvent </td><td>unblocks in internal thread </td><td>unblocks in internal thread </td><td>executes callback in nextEvent thread  </td></tr>
</table>
<p>(*) - guarantees unblocking after all previously enqueued events have been emitted to the eventHandler, allowing the user to have proper serialization of events for the given queue (for example no more PUSH messages will be delivered through the eventHandler for the queue after <code>configureQueueSync(maxUnconfirmed = 0)</code> returns). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_e8cd90b45eb8e499a7a689fb69672d2e.html">bmqa</a></li><li class="navelem"><a class="el" href="bmqa__session_8h.html">bmqa_session.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
